<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xxxxx.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="同步互斥和通信的区别 同步是指多个线程之间存在的一种松散的协作关系，一个线程的执行与否依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。例如生产消费者模型中，消费者需要等待生产者释放信号的条件后才会有动作 互斥是指某个共享资源在某一时刻只能有一个线程对他进行读写，而其他想要获取它的线程只能休眠。线程互斥可以看做特殊的同步 什么是系统调用 系统调用是操作">
<meta property="og:type" content="article">
<meta property="og:title" content="面经2">
<meta property="og:url" content="http://xxxxx.com/posts/11838/index.html">
<meta property="og:site_name" content="Ruowang&#39;s blogs">
<meta property="og:description" content="同步互斥和通信的区别 同步是指多个线程之间存在的一种松散的协作关系，一个线程的执行与否依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。例如生产消费者模型中，消费者需要等待生产者释放信号的条件后才会有动作 互斥是指某个共享资源在某一时刻只能有一个线程对他进行读写，而其他想要获取它的线程只能休眠。线程互斥可以看做特殊的同步 什么是系统调用 系统调用是操作">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210617224928.png">
<meta property="article:published_time" content="2021-05-11T02:11:25.000Z">
<meta property="article:modified_time" content="2021-08-30T12:25:12.201Z">
<meta property="article:author" content="常若望">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210617224928.png">

<link rel="canonical" href="http://xxxxx.com/posts/11838/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>面经2 | Ruowang's blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ruowang's blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">去更远的地方，见更亮的光</p>
      <a>
        <img class="custom-logo-image" src="/images/icon.png" alt="Ruowang's blogs">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xxxxx.com/posts/11838/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="常若望">
      <meta itemprop="description" content="可乐">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ruowang's blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面经2
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-11 10:11:25" itemprop="dateCreated datePublished" datetime="2021-05-11T10:11:25+08:00">2021-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-30 20:25:12" itemprop="dateModified" datetime="2021-08-30T20:25:12+08:00">2021-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <span id="more"></span>
<h3 id="同步互斥和通信的区别">同步互斥和通信的区别</h3>
<p>同步是指多个线程之间存在的一种松散的协作关系，一个线程的执行与否依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。例如生产消费者模型中，消费者需要等待生产者释放信号的条件后才会有动作</p>
<p>互斥是指某个共享资源在某一时刻只能有一个线程对他进行读写，而其他想要获取它的线程只能休眠。线程互斥可以看做特殊的同步</p>
<h3 id="什么是系统调用">什么是系统调用</h3>
<p>系统调用是操作系统提供给用户的一组接口，用户程序工作在用户态只能受限的访问系统的资源。通过系统调用用户可以主动从用户态转到内核态，进而获得更高的权限，访问操作系统更多的资源。write fork 等都是系统调用</p>
<p>用户态切换到内核态的3种方式</p>
<p>系统调用 异常（例如缺页异常） 外部中断</p>
<p>从出发方式看，可以在认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一样的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断处理机制基本上是一样的，用户态切换到内核态的步骤主要包括：</p>
<ol type="1">
<li>从当前进程的描述符中提取其内核栈的ss0及esp0信息。</li>
<li>使用ss0和esp0指向的内核栈 ； 将当前进程的cs,eip （CS+EIP = PC），eflags，ss(栈段地址), esp（栈顶指针）信息保存起来，这个过程也完成了由用户栈找到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。</li>
<li>将先前由中断向量检索得到的中断处理程序的 cs，eip 信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。</li>
</ol>
<p>软件调用 system_call 函数 触发 80H 中断，然后通过80H的中断向量找到系统调用的处理函数，在该函数中根据不同的系统调用号 找到内核中对应的函数去处理，系统调用号是不同调用函数独有的，用户空间通过CPU寄存器暂存调用号。处理完毕后返回值通过 CPU 寄存器暂存。</p>
<h3 id="互斥锁机制以及互斥锁和读写锁的区别">互斥锁机制，以及互斥锁和读写锁的区别</h3>
<p>互斥锁： 用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。</p>
<p>读写锁：分为读锁 和 写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒，优先唤醒写锁。适用于读取数据的频率远远大于写数据的频率的场合。</p>
<p>互斥锁和读写锁的区别：</p>
<ul>
<li>互斥锁 只允许一个进程访问 资源，不区分读写，因此不能多个线程同时读。</li>
<li>读写锁区分读 和 写，而互斥锁不区分</li>
</ul>
<h3 id="linux的四种锁机制">Linux的四种锁机制</h3>
<p>读写锁：</p>
<p>互斥锁：</p>
<p>自旋锁：spinlock 在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样<strong>节省了线程从睡眠状态到被唤醒期间的消耗</strong>，<strong>在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。</strong></p>
<p>RCU锁：在加上写锁后，所有的读操作都被阻塞了，RCU锁就是解决这个问题的。它支持在写的时候同时高并发读，只有多个同时写的线程需要加自旋锁，但是这个也是很高效的。本质是当线程要对临界资源修改时，创建数据副本，对副本修改，修改完毕后，等待所有的读线程退出临界区后（宽松区）才会将原始的数据指针指向修改后的数据副本。这个指针的修改过程是 原子的，不会发生线程调度和中断，同时只能有一个线程访问并修改数据指针的指向。</p>
<h3 id="说一说进程状态转换图动态就绪静态就绪动态阻塞静态阻塞">说一说进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞</h3>
<ol type="1">
<li>创建状态：进程正在被创建</li>
<li>就绪状态：进程被加入到就绪队列，等到CPU调度运行</li>
<li>运行状态：进程获得时间片，正在CPU中运行，可以和就绪态相互转换</li>
<li>阻塞状态：进程因为等待某种 IO/系统 资源设备而被阻塞 而暂时不能运行，当获取资源后 会 转换为就绪态等待再次被调度</li>
<li>终止状态：进程运行结束</li>
</ol>
<p>早期内存小，资源紧张，I/O设备访问速度慢，可能会出现很多进程都处于阻塞状态等待I/O，这时候可以通过交换技术把阻塞的进程换到外存，腾出内存空间。从而出现了进程的<strong>挂起状态</strong>：<strong>进程被交换到外存，进程状态就成为了挂起状态</strong>。而同进程中解决内存占用过大的问题是通过虚拟内存技术解决。</p>
<ol type="1">
<li>动态就绪：进程在内存，只要CPU调度就可以运行</li>
<li>静态就绪：进程在外存，处于就绪状态，换入到内存然后CPU给调度就可以运行</li>
<li>活动阻塞：进程在内存，但是由于某种原因被阻塞了</li>
<li>静止阻塞：进程在外存，同时被某种原因阻塞了</li>
</ol>
<p>新的转换过程：</p>
<ol type="1">
<li>内存不够时：活动就绪 -&gt; 静止就绪，调到外存</li>
<li>内存不够时：活动阻塞 -&gt; 静止阻塞，调到外存</li>
<li>内存不够 且 时间片用完：运行态 -&gt; 静止就绪，调到外存</li>
</ol>
<h3 id="a-a-new-a-a-i-10在内核中的内存分配上发生了什么">A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么</h3>
<p>可以首先介绍一下内存的模型 各个段的作用</p>
<ol type="1">
<li>A *a 是一个局部指针变量，在栈区，开辟 4/8字节的空间分配给指针</li>
<li>new A 是动态内存分配，在堆区分配，大小为类A的大小</li>
<li>将指针 a 的内存区域填入栈中类A申请到的地址的地址。即指针指向 new 分配的地址</li>
<li>a-&gt;i：先找到指针a的地址 0x000m，通过a的值 0x000n和i在类a中偏移offset，得到a-&gt;i的地址0x000n + offset，进行*(0x000n + offset) = 10的赋值操作，即内存0x000n + offset的值是10</li>
</ol>
<h3 id="给你一个类里面有staticvirtual之类的来说一说这个类的内存分布">给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布</h3>
<p>static修饰成员变量…. 在全局数据区分配内存；static修饰成员函数…..在代码区</p>
<p>如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。对于含有虚函数的对象，在首地址处有个虚函数表指针，指针指向了该类的虚函数表，虚函数表是个数组一样的表里面每一项存放的是该类的虚函数地址（虚函数指针），虚函数表存放在 代码段中的只读数据区，虚函数表中的函数指针指向的是代码段中的虚函数。</p>
<h3 id="软链接和硬链接区别">软链接和硬链接区别</h3>
<p>链接除了解决了文件共享的问题，还可以隐藏文件的原本路劲，节省空间，提高安全性等。硬链接相当于一个 inode 有不同的文件名，删除源文件，文件实际不会从系统上删除，引用依然有效。软链接相当于创建了一个新的文件，新的 inode 只不过存储的是指向的文件的路径，使用 ln -s 创建，删除源文件，软连接就失效了。</p>
<h3 id="什么是大端小端以及如何判断大端小端">什么是大端小端以及如何判断大端小端</h3>
<p>大端是低字节存在高地址，小端是低字节存在低地址。联合体变量总是从低地址往高地址存储，所以使用联合体判断</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Test t;</span><br><span class="line">    t.i = <span class="number">0</span>;</span><br><span class="line">    t.i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (t.a == <span class="number">1</span>);  <span class="comment">// 如果 a == 1 说明int的低地址存放的是 低字节 是小端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态变量什么时候初始化">静态变量什么时候初始化</h3>
<p>对于C语言，不存在类的构造问题，静态变量存放在 全局数据区，在编译时就可以初始化；而 c++ 的静态对象存在构造问题，全局静态对象在 main函数执行之前初始化，局部静态对象在第一次使用的时候初始化。</p>
<h3 id="用户态和内核态区别">用户态和内核态区别</h3>
<p>是操作系统的两种运行级别，二者权限不同。用户态的权限级别最低，运行在用户态的程序不能直接访问操作系统的数据结构，只能通过系统调用，异常（例如缺页异常），中断从用户态转向内核态。</p>
<h3 id="两个进程访问临界区资源会不会出现都获得自旋锁的情况">两个进程访问临界区资源，会不会出现都获得自旋锁的情况？</h3>
<p>???</p>
<p>单核cpu，并且开了抢占可以造成这种情况。</p>
<h3 id="windows消息机制知道吗请说一说">windows消息机制知道吗，请说一说</h3>
<p>当用户有操作(鼠标，键盘等)时，系统会将这些时间转化为消息。每个打开的进程系统都为其维护了一个消息队列，系统会将这些消息放到进程的消息队列中，而应用程序会循环从消息队列中取出来消息，完成对应的操作。</p>
<h3 id="c的锁你知道几种">C++的锁你知道几种?</h3>
<p>锁包括互斥锁，自旋锁和读写锁, RCU锁</p>
<h3 id="说一说你用到的锁">说一说你用到的锁</h3>
<p>生产者消费者问题利用互斥锁和条件变量可以很容易解决，条件变量这里起到了替代信号量的作用</p>
<h3 id="内存溢出和内存泄漏">内存溢出和内存泄漏</h3>
<p>内存溢出：指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误</p>
<ul>
<li>内存中加载的数据量过于庞大，如一次从数据库取出过多数据</li>
<li>集合类中有对对象的引用，使用完后未清空，使得不能回收</li>
<li>代码中存在死循环或循环产生过多重复的对象实体</li>
<li>启动参数内存值设定的过小</li>
<li>使用的第三方软件中的BUG</li>
</ul>
<p>内存泄漏：内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。</p>
<ul>
<li>堆内存泄漏：</li>
<li>系统内存泄漏：</li>
<li>虚函数：</li>
</ul>
<h3 id="你都使用什么线程模型">你都使用什么线程模型</h3>
<p>OPEN MP</p>
<p><strong>Future模型</strong>：Future是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。在 c++ 中 使用 pakage_task 类 对可执行对象封装后 可以返回一个 future 对象，通过future 对象可以异步的获取 可执行对象在其他线程中执行后返回的结果。在线程池的实现中，就是通过 package_task 对函数和参数进行统一封装后返回future对象，用于异步获取任务的执行结果。</p>
<p><strong>fork&amp;join模型</strong>：该模型就是 递归的将一个大任务拆解为小任务。然后由单独的线程分别执行小任务，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果。在图像分块多线程中采用了fork join 的思路，最大线程数预先根据cpu核心数设置，如果输入图像大于1000 就分四个线程分别处理。让后汇总结果进入下一步。</p>
<p><strong>actor模型</strong>：actor模型属于一种基于<strong>消息传递机制并行任务处理思想</strong>，它以消息的形式来进行线程间数据传输，<strong>避免了全局变量的使用，进而避免了数据同步错误的隐患</strong>。actor在接受到消息之后可以自己进行处理，也可以继续传递（分发）给其它actor进行处理。在使用actor模型的时候需要使用第三方Akka提供的框架。</p>
<p><strong>生产者消费者模型</strong>：生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题。（线程池就是采用了这个模型，生产者为用户，用户通过GUI线程像 任务队列中放置 地标，多个消费者从 任务队列中取任务完成）</p>
<p><strong>master-worker模型</strong>：master-worker模型类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker子线程，然后由子线程处理任务。如需返回结果，则worker处理结束之后把处理结果返回给master。</p>
<h3 id="说一下微内核与宏内核">说一下微内核与宏内核</h3>
<p>宏内核：除了最基本的进程、线程管理、内存管理外，将文件系统，驱动，网络协议等等都集成在内核里面，例如linux内核。</p>
<ul>
<li>优点：效率高。</li>
<li>缺点：稳定性差，开发过程中的bug经常会导致整个系统挂掉。</li>
</ul>
<p>微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的。</p>
<ul>
<li>优点：稳定，驱动等的错误只会导致相应进程死掉，不会导致整个系统都崩溃</li>
<li>缺点：效率低。典型代表QNX，QNX的文件系统是跑在用户态的进程，称为resmgr的东西，是订阅发布机制，文件系统的错误只会导致这个守护进程挂掉。不过数据吞吐量就比较不乐观了。</li>
</ul>
<h3 id="说一下僵尸进程">说一下僵尸进程</h3>
<ul>
<li><p>正常进程：父进程和子进程是异步的，就是父进程在创建子进程后，子进程什么时候结束，运行到什么状态，父进程是不知道的。Unix中，子进程退出后，除了会释放子进程占用的系统资源，但是会保留子进程的进程号，退出状态，运行时间等这种基本信息。父进程可以通过 waitpid() 系统调用来获得这个信息，调用子进程信息才会完全从内核中删除。</p></li>
<li><p>孤儿进程：就是父进程提前退出，子进程会被init初始进程托管，并在子进程退出后由它代为处理最后的信息。</p></li>
<li><p>僵尸进程：就是子进程退出后，父进程未调用 waitpid 系统调用 获取 子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，占用着进程号。</p>
<ul>
<li>因为系统的进程号是有限的，用完后就无法创建新的进程。</li>
<li>僵尸进程是每个进程必经的阶段</li>
<li>可以同过 ps 命令查看 进程，状态为 Z 的就是僵尸进程，可以通过 kill 命令清楚</li>
<li>子进程在 退出的时候可以向父进程发送信号，告诉它及时处理，或者 fork 两次让他变成孤儿进程由init 进程接管</li>
</ul></li>
</ul>
<p>守护进程(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。</p>
<h3 id="请问gdb调试用过吗什么是条件断点">请问GDB调试用过吗，什么是条件断点</h3>
<h3 id="种io模型">5种IO模型</h3>
<ol type="1">
<li>阻塞式I/O：如果当前进程获取不到I/O时间，就进入休眠状态，会阻塞当前线程的其他任务，但是并不会增加cpu的负担</li>
<li>非阻塞式：类似于轮询，隔段时间检查一下时间是否就绪，中途可以区处理别的事物。但是反复轮询会降低cpu效率</li>
<li>多路复用：多路复用和阻塞式类似，也会阻塞当前线程，但是在一个线程中可以管理多个IO事件，原理就是统一管理一批文件描述符，当其中某一个有响应后就处理。</li>
<li>信号驱动：应用程序使用套接口进行信号驱动I/O，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据</li>
<li>异步式：信号驱动I/O是由内核通知应用程序何时启动一个I/O操作，而异步I/O模型是由内核通知应用程序I/O操作何时完成</li>
</ol>
<h3 id="如何设计server使得能够接收多个客户端的请求">如何设计server，使得能够接收多个客户端的请求</h3>
<p>多线程，线程池，io复用</p>
<h3 id="死循环来连接时新建线程的方法效率有点低怎么改进">死循环+来连接时新建线程的方法效率有点低，怎么改进？</h3>
<p>提前创建好一个线程池，用生产者消费者模型，创建一个任务队列，队列作为临界资源，有了新连接，就挂在到任务队列上，队列为空所有线程睡眠。改进死循环：使用select epoll这样的技术</p>
<h3 id="怎么实现线程池">怎么实现线程池</h3>
<ol type="1">
<li>设置一个生产者消费者队列，作为临界资源</li>
<li>初始化n个线程，并让其运行起来，加锁去队列取任务运行</li>
<li>当任务队列为空的时候，所有线程阻塞</li>
<li>当生产者队列来了一个任务后，先对队列加锁，把任务挂在到队列上，然后使用条件变量去通知阻塞中的一个线程</li>
</ol>
<h3 id="内存池">内存池</h3>
<p>内存池是指程序预先从操作系统<strong>申请一块足够大内存</strong>，此后，当程序中需要申请内存的时候，不是直接向操作系统申请，而是直接从内存池中获取；同理，当程序释放内存的时候，并不真正将内存返回给操作系统，而是返回内存池。当程序退出(或者特定时间)时，内存池才将之前申请的内存真正释放。</p>
<h3 id="动态链接库与静态链接库的区别">动态链接库与静态链接库的区别</h3>
<p>如果可执行文件使用静态库编译，那么编译的时候会将静态库中的可执行代码编译进可执行文件中，而动态库是在程序运行时才加载的。</p>
<p>因此区别是：</p>
<ol type="1">
<li>使用静态库编出的可执行文件更大，但是运行执行效率更高。而动态库需要运行时加载所以慢一点</li>
<li>动态库是系统中所有进程共享的，如果两个程序使用了相同的动态库，那么只需加载进内存中一次，而使用静态库编译的文件则在每个程序中都有一份实现，因此动态库更节省内存</li>
<li>动态库方便后续维护，如果需要更新功能，更换动态库即可不用重新编译可执行文件，而静态库不行</li>
<li>静态库中不能再包含其他动态或静态库，而动态库可以</li>
</ol>
<h3 id="c语言函数调用的原理">C语言函数调用的原理</h3>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210617224928.png" alt="image-20210617224928241" style="zoom: 50%;" /></p>
<p>函数调用流程如下：</p>
<ol type="1">
<li>首先要将当前PC设置为下调用函数的下一条指令，便于调用完毕后返回。同时将PC设置为子函数地址</li>
<li>还要将调用者栈帧的 栈底 bp 指针压入栈中, 并将 sp 指针赋给 bp ， 即当前栈顶为子函数的栈底</li>
<li>将调用函数的入口参数 从右到左 依次入栈</li>
<li>通过PC跳转执行，最后返回值 可以通过eax保存，具体的返回值保存方法
<ul>
<li>返回值类型的，如果所用内存较大 eax 寄存器无法直接保存下，那就预先在栈上开辟一个空间，然后将变量的地址作为第一个隐含的函数入口参数传入函数中；否则直接用 eax cpu寄存器作为媒介返回。</li>
</ul></li>
</ol>
<h3 id="分页和分段存储管理有何区别">分页和分段存储管理有何区别</h3>
<ol type="1">
<li>页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率。段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。</li>
<li>页的大小固定且由系统决定；而段的长度却不固定，决定于用户所编写的程序。</li>
<li>分页的地址空间是一维的，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。</li>
</ol>
<h3 id="多重继承虚函数怎么实现">多重继承虚函数怎么实现</h3>
<p>如果继承自多个类，并且每个类都有虚函数，那么实例化后的对象 就有N个虚表指针；如果虚表中最后一个是 星号 代表还有下一个虚表，否则无。</p>
<h3 id="c原子类型如何实现">C++原子类型如何实现</h3>
<ol type="1">
<li>单核系统中 简单的关中断 屏蔽任务调度即可</li>
<li>在多核系统中 不仅如此还存在多个核的缓存不一致性的问题 ，还需要结合CAS实现 原子操作。CAS一般有硬件指令级的支持，原理就是，首先从内存中读取要修改的变量，将他和期望值比较，如果和期望值不同，那么就说明它被修改了就什么都不做返回false，如果相同，则对变量修改并返回true。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如我要执行 i++  首先是  从内存中读取 i 发现他等于 0 然后在cpu缓存中执行+1为1后要把它写回内存，这时候 CAS 作用就来了，如果回写的时候，我先读一遍发现 i 不是 0 而是 其他值，说明在我执行i+1过程中有其他人修改了内存值，因此此时 返回false 不能将自己cpu中缓存的1写给i；</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_and_swap</span> <span class="params">(<span class="keyword">int</span>*accum, <span class="keyword">int</span>*dest, intnewval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( *accum == *dest ) &#123;</span><br><span class="line">      *dest = newval;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进程调度算法详解">进程调度算法详解</h3>
<h3 id="多个线程轮流打印1-100">多个线程轮流打印1-100</h3>
<p>思路</p>
<ol type="1">
<li>通过一个变量来控制线程同步的逻辑</li>
<li>如果</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="keyword">int</span> ready = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintString_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(ready != <span class="number">0</span>)</span><br><span class="line">            cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        ready = <span class="number">1</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintString_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(ready != <span class="number">1</span>)</span><br><span class="line">            cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        ready = <span class="number">2</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintString_3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(ready != <span class="number">2</span>)</span><br><span class="line">            cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;C&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        ready = <span class="number">0</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread  <span class="title">t1</span><span class="params">(PrintString_1)</span></span>;</span><br><span class="line">    <span class="function">std::thread  <span class="title">t2</span><span class="params">(PrintString_2)</span></span>;</span><br><span class="line">    <span class="function">std::thread  <span class="title">t3</span><span class="params">(PrintString_3)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="inline-和-define区别">inline 和 define区别</h3>
<p>define 是预处理阶处理的，只是简单的替换，并没有入口参数类型检查啥的。而Inline 在编译阶段将代码段直接擦插入到每个调用它的地方，但是并不是函数调用的形式，因此效率比较高且安全可靠 是一种空间换时间的手段。</p>
<h3 id="两个线程对一个int-a-1-的变量同时进行-a-操作一万次那么最后a的值是多少呢">两个线程对一个int a = 1 的变量同时进行 a++ 操作一万次，那么最后a的值是多少呢</h3>
<p>10000 - 20000 之间 考虑多线程冲突</p>
<h3 id="什么是闭包-lambda表达式">什么是闭包 lambda表达式</h3>
<p>c++11 中 匿名函数 可以实现闭包，但是概念上 闭包是指 包含函数指针和上下文数据环境的一个结构体，相当于捕获的上下文数据+函数地址。如果一个函数没有捕捉自由变量那么其实就可以实现为一个函数指针，如果捕获了自由变量，他就是一个闭包，当他脱离当前的环境，依然可以正常执行。c98中没有匿名函数，但是可以通过仿函数来模拟闭包。</p>
<p>因此匿名函数返回的就是一个匿名的闭包实例，他是个右值，可以通过捕获的方式封装当前作用域的变量或者他们的引用。</p>
<h3 id="c11-vector库中有什么改进">C++11 vector库中有什么改进</h3>
<p>有了移动拷贝构造函数 避免了很多不必要的对象内存赋值</p>
<h3 id="模板类和泛型编程">模板类和泛型编程</h3>
<p>C++这种语言不像python javascript这种动态语言一样，一个函数可以传入任何类型的参数。C++的模板弥补了这个缺点，在定义函数或者类时可以将参数类型设置为模板，当调用的时候编译器再根据调用的类型去实例化对应的参数类型。优点是更灵活，大大减少代码量。缺点是 模板的定义和声明必须放在同一个文件中 这点和c++常规的定义声明分开编写的原则不同。</p>
<h3 id="磁盘io的原理">磁盘IO的原理</h3>
<p>操作系统使用DMA直接将数据从 磁盘 拷贝到 页缓存中，或者将数据写回磁盘，这个过程不需要处理。但是将应用程序地址空间和内核空间之间的拷贝需要 CPU 开销。</p>
<h3 id="序执行-内存屏障-voliate">序执行 内存屏障 voliate</h3>
<h3 id="linux的字符集">Linux的字符集</h3>
<h3 id="读写锁的实现原理">读写锁的实现原理</h3>
<h3 id="c死锁检测">C++死锁检测</h3>
<h3 id="操作系统的内存映射是如何实现的-共享内存如何实现的">操作系统的内存映射是如何实现的 （共享内存如何实现的）</h3>
<h3 id="共享内存能放什么样的数据结构是用什么数据结构实现的">共享内存能放什么样的数据结构，是用什么数据结构实现的</h3>
<h3 id="进程在操作系统的存在方式">进程在操作系统的存在方式</h3>
<h3 id="epoll原理和类似的中间件之间的区别selectpoll">epoll原理和类似的中间件之间的区别（select，poll）</h3>
<h3 id="消息队列内核是如何实现的">消息队列内核是如何实现的</h3>
<h3 id="信号量linux是如何实现的如何进行进程的通信">信号量Linux是如何实现的，如何进行进程的通信</h3>
<h3 id="信号了解吗进程的信号通信底层是如何实现的">信号了解吗，进程的信号通信底层是如何实现的</h3>
<h3 id="讲讲io模型">讲讲I/O模型</h3>
<h3 id="pv操作如何实现的">PV操作如何实现的</h3>
<h3 id="什么是中断">什么是中断</h3>
<h3 id="liunx下如何shell下查看cpu内存资源使用情况用什么命令">liunx下如何shell下查看cpu内存资源使用情况用什么命令</h3>
<h4 id="介绍一下io多路复用">介绍一下<strong>IO</strong>多路复用</h4>
<h3 id="缓存的管理方式lrulfu">缓存的管理方式（LRU，LFU）</h3>
<h4 id="将一个文件从内存中写入磁盘设计一种数据结构来加速这个过程">将一个文件从内存中写入磁盘，设计一种数据结构来加速这个过程</h4>
<p>（应该是LSM树）</p>
<h3 id="负载均衡算法">负载均衡算法</h3>
<h3 id="cpu流水线">CPU流水线</h3>
<h3 id="缓存一致性协议">缓存一致性协议</h3>
<h3 id="程序中通过地址读取一个变量的过程">程序中通过地址读取一个变量的过程</h3>
<p>（虚拟地址到物理地址，MMU，CR3，转换的细节，这里问了一个我不懂的名词，说是MMU获取页目录地址的过程）</p>
<h3 id="进程优先级和cpu的任务调度策略优先级反转">进程优先级和CPU的任务调度策略（优先级反转）</h3>
<h3 id="高并发下同时操作任务队列">高并发下同时操作任务队列</h3>
<h2 id="linux">Linux</h2>
<p>Linux命令 awk，strace，gdb调试相关</p>
<p>Linux常用命令</p>
<p>Linux与Windows最大的区别</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/12158/" rel="prev" title="面经1">
      <i class="fa fa-chevron-left"></i> 面经1
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/34204/" rel="next" title="Socket">
      Socket <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 
      src="//music.163.com/outchain/player?type=0&id=885457449&auto=0&height=66">
    </iframe>

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E5%92%8C%E9%80%9A%E4%BF%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">同步互斥和通信的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">什么是系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">互斥锁机制，以及互斥锁和读写锁的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%94%81%E6%9C%BA%E5%88%B6"><span class="nav-number">4.</span> <span class="nav-text">Linux的四种锁机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE%E5%8A%A8%E6%80%81%E5%B0%B1%E7%BB%AA%E9%9D%99%E6%80%81%E5%B0%B1%E7%BB%AA%E5%8A%A8%E6%80%81%E9%98%BB%E5%A1%9E%E9%9D%99%E6%80%81%E9%98%BB%E5%A1%9E"><span class="nav-number">5.</span> <span class="nav-text">说一说进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-a-new-a-a-i-10%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8A%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">6.</span> <span class="nav-text">A* a &#x3D; new A; a-&gt;i &#x3D; 10;在内核中的内存分配上发生了什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%99%E4%BD%A0%E4%B8%80%E4%B8%AA%E7%B1%BB%E9%87%8C%E9%9D%A2%E6%9C%89staticvirtual%E4%B9%8B%E7%B1%BB%E7%9A%84%E6%9D%A5%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%BF%99%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83"><span class="nav-number">7.</span> <span class="nav-text">给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%8C%BA%E5%88%AB"><span class="nav-number">8.</span> <span class="nav-text">软链接和硬链接区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF"><span class="nav-number">9.</span> <span class="nav-text">什么是大端小端以及如何判断大端小端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">10.</span> <span class="nav-text">静态变量什么时候初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E5%8C%BA%E5%88%AB"><span class="nav-number">11.</span> <span class="nav-text">用户态和内核态区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E8%BF%9B%E7%A8%8B%E8%AE%BF%E9%97%AE%E4%B8%B4%E7%95%8C%E5%8C%BA%E8%B5%84%E6%BA%90%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%87%BA%E7%8E%B0%E9%83%BD%E8%8E%B7%E5%BE%97%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">12.</span> <span class="nav-text">两个进程访问临界区资源，会不会出现都获得自旋锁的情况？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#windows%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E7%9F%A5%E9%81%93%E5%90%97%E8%AF%B7%E8%AF%B4%E4%B8%80%E8%AF%B4"><span class="nav-number">13.</span> <span class="nav-text">windows消息机制知道吗，请说一说</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E7%9A%84%E9%94%81%E4%BD%A0%E7%9F%A5%E9%81%93%E5%87%A0%E7%A7%8D"><span class="nav-number">14.</span> <span class="nav-text">C++的锁你知道几种?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E7%94%A8%E5%88%B0%E7%9A%84%E9%94%81"><span class="nav-number">15.</span> <span class="nav-text">说一说你用到的锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">16.</span> <span class="nav-text">内存溢出和内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%A0%E9%83%BD%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">17.</span> <span class="nav-text">你都使用什么线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%BE%AE%E5%86%85%E6%A0%B8%E4%B8%8E%E5%AE%8F%E5%86%85%E6%A0%B8"><span class="nav-number">18.</span> <span class="nav-text">说一下微内核与宏内核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">19.</span> <span class="nav-text">说一下僵尸进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E9%97%AEgdb%E8%B0%83%E8%AF%95%E7%94%A8%E8%BF%87%E5%90%97%E4%BB%80%E4%B9%88%E6%98%AF%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9"><span class="nav-number">20.</span> <span class="nav-text">请问GDB调试用过吗，什么是条件断点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%8Dio%E6%A8%A1%E5%9E%8B"><span class="nav-number">21.</span> <span class="nav-text">5种IO模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1server%E4%BD%BF%E5%BE%97%E8%83%BD%E5%A4%9F%E6%8E%A5%E6%94%B6%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%AF%B7%E6%B1%82"><span class="nav-number">22.</span> <span class="nav-text">如何设计server，使得能够接收多个客户端的请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E5%BE%AA%E7%8E%AF%E6%9D%A5%E8%BF%9E%E6%8E%A5%E6%97%B6%E6%96%B0%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%88%E7%8E%87%E6%9C%89%E7%82%B9%E4%BD%8E%E6%80%8E%E4%B9%88%E6%94%B9%E8%BF%9B"><span class="nav-number">23.</span> <span class="nav-text">死循环+来连接时新建线程的方法效率有点低，怎么改进？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">24.</span> <span class="nav-text">怎么实现线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0"><span class="nav-number">25.</span> <span class="nav-text">内存池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">26.</span> <span class="nav-text">动态链接库与静态链接库的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">27.</span> <span class="nav-text">C语言函数调用的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB"><span class="nav-number">28.</span> <span class="nav-text">分页和分段存储管理有何区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E8%99%9A%E5%87%BD%E6%95%B0%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="nav-number">29.</span> <span class="nav-text">多重继承虚函数怎么实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">30.</span> <span class="nav-text">C++原子类型如何实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="nav-number">31.</span> <span class="nav-text">进程调度算法详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BD%AE%E6%B5%81%E6%89%93%E5%8D%B01-100"><span class="nav-number">32.</span> <span class="nav-text">多个线程轮流打印1-100</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inline-%E5%92%8C-define%E5%8C%BA%E5%88%AB"><span class="nav-number">33.</span> <span class="nav-text">inline 和 define区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AF%B9%E4%B8%80%E4%B8%AAint-a-1-%E7%9A%84%E5%8F%98%E9%87%8F%E5%90%8C%E6%97%B6%E8%BF%9B%E8%A1%8C-a-%E6%93%8D%E4%BD%9C%E4%B8%80%E4%B8%87%E6%AC%A1%E9%82%A3%E4%B9%88%E6%9C%80%E5%90%8Ea%E7%9A%84%E5%80%BC%E6%98%AF%E5%A4%9A%E5%B0%91%E5%91%A2"><span class="nav-number">34.</span> <span class="nav-text">两个线程对一个int a &#x3D; 1 的变量同时进行 a++ 操作一万次，那么最后a的值是多少呢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">35.</span> <span class="nav-text">什么是闭包 lambda表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c11-vector%E5%BA%93%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E6%94%B9%E8%BF%9B"><span class="nav-number">36.</span> <span class="nav-text">C++11 vector库中有什么改进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="nav-number">37.</span> <span class="nav-text">模板类和泛型编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98io%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">38.</span> <span class="nav-text">磁盘IO的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E6%89%A7%E8%A1%8C-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C-voliate"><span class="nav-number">39.</span> <span class="nav-text">序执行 内存屏障 voliate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="nav-number">40.</span> <span class="nav-text">Linux的字符集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">41.</span> <span class="nav-text">读写锁的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="nav-number">42.</span> <span class="nav-text">C++死锁检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">43.</span> <span class="nav-text">操作系统的内存映射是如何实现的 （共享内存如何实现的）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E8%83%BD%E6%94%BE%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E7%94%A8%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">44.</span> <span class="nav-text">共享内存能放什么样的数据结构，是用什么数据结构实现的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%9C%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%98%E5%9C%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">45.</span> <span class="nav-text">进程在操作系统的存在方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll%E5%8E%9F%E7%90%86%E5%92%8C%E7%B1%BB%E4%BC%BC%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%ABselectpoll"><span class="nav-number">46.</span> <span class="nav-text">epoll原理和类似的中间件之间的区别（select，poll）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%86%85%E6%A0%B8%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">47.</span> <span class="nav-text">消息队列内核是如何实现的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8Flinux%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">48.</span> <span class="nav-text">信号量Linux是如何实现的，如何进行进程的通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E4%BA%86%E8%A7%A3%E5%90%97%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%80%9A%E4%BF%A1%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">49.</span> <span class="nav-text">信号了解吗，进程的信号通信底层是如何实现的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B2%E8%AE%B2io%E6%A8%A1%E5%9E%8B"><span class="nav-number">50.</span> <span class="nav-text">讲讲I&#x2F;O模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pv%E6%93%8D%E4%BD%9C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">51.</span> <span class="nav-text">PV操作如何实现的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E6%96%AD"><span class="nav-number">52.</span> <span class="nav-text">什么是中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#liunx%E4%B8%8B%E5%A6%82%E4%BD%95shell%E4%B8%8B%E6%9F%A5%E7%9C%8Bcpu%E5%86%85%E5%AD%98%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E7%94%A8%E4%BB%80%E4%B9%88%E5%91%BD%E4%BB%A4"><span class="nav-number">53.</span> <span class="nav-text">liunx下如何shell下查看cpu内存资源使用情况用什么命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bio%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">53.1.</span> <span class="nav-text">介绍一下IO多路复用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8Flrulfu"><span class="nav-number">54.</span> <span class="nav-text">缓存的管理方式（LRU，LFU）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E4%BB%8E%E5%86%85%E5%AD%98%E4%B8%AD%E5%86%99%E5%85%A5%E7%A3%81%E7%9B%98%E8%AE%BE%E8%AE%A1%E4%B8%80%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%A5%E5%8A%A0%E9%80%9F%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B"><span class="nav-number">54.1.</span> <span class="nav-text">将一个文件从内存中写入磁盘，设计一种数据结构来加速这个过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95"><span class="nav-number">55.</span> <span class="nav-text">负载均衡算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cpu%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="nav-number">56.</span> <span class="nav-text">CPU流水线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE"><span class="nav-number">57.</span> <span class="nav-text">缓存一致性协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E9%80%9A%E8%BF%87%E5%9C%B0%E5%9D%80%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">58.</span> <span class="nav-text">程序中通过地址读取一个变量的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8Ccpu%E7%9A%84%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC"><span class="nav-number">59.</span> <span class="nav-text">进程优先级和CPU的任务调度策略（优先级反转）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E5%90%8C%E6%97%B6%E6%93%8D%E4%BD%9C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97"><span class="nav-number">60.</span> <span class="nav-text">高并发下同时操作任务队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux"><span class="nav-number"></span> <span class="nav-text">Linux</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">常若望</p>
  <div class="site-description" itemprop="description">可乐</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">144</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/changruowang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;changruowang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/changruowang@qq.com" title="E-Mail → changruowang@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>

  <div id="sidebar-dimmer"></div>



      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        


<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">常若望</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
