<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设计模式概述</title>
    <url>/posts/31788/</url>
    <content><![CDATA[<p>总结了设计模式相关的知识点，内容几乎来自 <a href="http://www.cyc2018.xyz/">CS-NOTE</a> ，以及 <a href="https://refactoringguru.cn/design-patterns/">设计模式</a></p>
<span id="more"></span>
<h2 id="设计原则">设计原则</h2>
<p><a href="./设计模式/面向对象.md">设计原则</a></p>
<h2 id="什么是设计模式">什么是设计模式</h2>
<p>设计模式（Design pattern）是指在软件设计中 <strong>被反复使用的一种代码设计经验</strong>，设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
<h2 id="为什么要使用设计模式">为什么要使用设计模式</h2>
<p>使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度。设计模式主要是基于 <code>OOP</code>编程提炼的，并遵守上述设计原则。</p>
<h2 id="类别">类别</h2>
<p>设计模式把一些常用的设计思想提炼出一个个模式，然后给每个模式命名，这样在使用的时候更方便交流。GoF 把23个常用模式分为创建型模式、结构型模式和行为型模式三类。</p>
<blockquote>
<p>设计模式这个术语是上个世纪90年代由Erich Gamma、Richard Helm、Raplh Johnson和Jonhn Vlissides四个人总结提炼出来的，并且写了一本<a href="https://en.wikipedia.org/wiki/Design_Patterns">Design Patterns</a>的书。这四人也被称为四人帮（GoF）。</p>
</blockquote>
<h3 id="创建型">创建型</h3>
<ul>
<li><a href="./设计模式/单例.md">单例</a></li>
<li><a href="./设计模式/简单工厂.md">简单工厂</a></li>
<li><a href="./设计模式/工厂方法.md">工厂方法</a></li>
<li><a href="./设计模式/抽象工厂.md">抽象工厂</a></li>
<li><a href="./设计模式/生成器.md">生成器</a></li>
<li><a href="./设计模式/原型模式.md">原型模式</a></li>
</ul>
<h3 id="行为型"><a href="./设计模式/行为型.md">行为型</a></h3>
<ul>
<li>责任链</li>
<li>命令</li>
<li>解释器</li>
<li>迭代器</li>
<li>中介者</li>
<li>备忘录</li>
<li>观察者</li>
<li>状态</li>
<li>策略</li>
<li>模板方法</li>
<li>访问者</li>
</ul>
<h3 id="结构型"><a href="./设计模式/结构型.md">结构型</a></h3>
<ul>
<li>适配器</li>
<li>桥接</li>
<li>组合</li>
<li>装饰</li>
<li>外观</li>
<li>享元</li>
<li>代理</li>
</ul>
<h3 id="面经-设计模式"><a href="./设计模式/面经-设计模式.md">面经-设计模式</a></h3>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络概述</title>
    <url>/posts/10890/</url>
    <content><![CDATA[<span id="more"></span>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210627153314.png" alt="" /><figcaption>计算机网络基础</figcaption>
</figure>
<p><a href="https://mm.edrawsoft.cn/map.html?sharecode=60d8280c354e13a33437421">计算机网络基础xmin源文件</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title>题目汇总总结</title>
    <url>/posts/56771/</url>
    <content><![CDATA[<p>对写过的题进行分类整理</p>
<span id="more"></span>
<h2 id="动态规划"><a href="./算法思想/leecode_动态规划.md">动态规划</a></h2>
<ul>
<li>连续子数组问题</li>
<li>相邻元素状态转换</li>
<li>背包问题</li>
<li>中心扩散</li>
<li>记忆搜索</li>
<li>错排问题</li>
<li>子序列/两个字符串问题</li>
<li>矩阵路径问题</li>
</ul>
<h2 id="分治"><a href="./算法思想/leecode_分治.md">分治</a></h2>
<h2 id="回朔"><a href="./算法思想/leecode_回朔.md">回朔</a></h2>
<h2 id="双指针"><a href="./算法思想/leecode_双指针.md">双指针</a></h2>
<h2 id="贪心"><a href="./算法思想/leecode_贪心.md">贪心</a></h2>
<h2 id="dfs_bfs"><a href="./算法思想/leecode_DFS_BFS.md">DFS_BFS</a></h2>
<h2 id="数学"><a href="./算法思想/leecode_数学.md">数学</a></h2>
<h2 id="位运算"><a href="./算法思想/leecode_位运算.md">位运算</a></h2>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>leecode</tag>
      </tags>
  </entry>
  <entry>
    <title>python常用语法</title>
    <url>/posts/8787/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="python-的用法">python * ** 的用法</h2>
<figure>
<img src="figs/1566285511946.png" alt="" /><figcaption>1566285511946</figcaption>
</figure>
<h3 id="用在函数的输入参数">用在函数的输入参数</h3>
<p>​ 在定义一个方法时，使用*表示输入参数列表不确定。会将输入的参数放入一个元组中，函数内可通过访问元组的方法访问里面的数据。使用**arg也可以表示不确定参数列表，但是会将输入参数打包为字典结构。因此函数内部可以通过访问字典结构的方法访问输入参数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myprint</span>(<span class="params">*arg</span>)</span></span><br><span class="line"><span class="function">	<span class="title">print</span> <span class="title">arg</span></span></span><br><span class="line"><span class="function"><span class="title">myprint</span>(<span class="params"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span>)</span></span><br><span class="line"><span class="function">#打印的结果是一个元组</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">myprint</span>(<span class="params">*arg</span>)</span></span><br><span class="line"><span class="function">	<span class="title">for</span> <span class="title">i</span> <span class="title">in</span> <span class="title">range</span>(<span class="params"><span class="built_in">len</span>(<span class="params">arg</span>)</span>)</span></span><br><span class="line"><span class="function">#输出1，2，3，4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myprint</span>(<span class="params">**arg</span>)</span></span><br><span class="line"><span class="function">	<span class="title">print</span>(<span class="params">arg</span>)</span></span><br><span class="line"><span class="function"><span class="title">myprint</span>(<span class="params">a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span></span>)</span></span><br><span class="line">#打印结果：&#123;&#x27;a&#x27;:1, &#x27;b&#x27;:2, &#x27;c&#x27;:3&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解包">解包</h3>
<p>​ 与上述过程相反</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>（<span class="title">x</span>，<span class="title">y</span>）:</span></span><br><span class="line">    <span class="built_in">print</span> x+y</span><br><span class="line">para =  (<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">add(*para)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="built_in">print</span> x+y</span><br><span class="line">kkwd = &#123;<span class="string">&#x27;x&#x27;</span> :<span class="number">1</span>,<span class="string">&#x27;y&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line">add(**kkwd)</span><br></pre></td></tr></table></figure>
<h2 id="值传递引用传递-可变对象不可变对象">值传递，引用传递 ，可变对象，不可变对象</h2>
<p>一般来说，将数字、字符串、元组是不可变对象，传入函数，相当于对内存进行了拷贝，在函数内修改其值不会改变函数外的值。但是对于列表、字典等可以增删的数据结构，传入函数后，相当于传递进去的是c语言中的指向地址的指针。所以在函数内对其进行有关地址的操作都可以修改函数外的变量的值。</p>
<p>参考链接：https://blog.csdn.net/qq_41987033/article/details/81675514</p>
<h2 id="使用tensorboard数据可视化">使用tensorboard数据可视化</h2>
<h3 id="安装">安装</h3>
<p>​ 对于pytorch1.0 torch.utils.tensorboard中有这个文件，但是直接在程序中导入会报错，不考虑这个，自行安装tensorboardX。 需要安装tensorboardX为python代码执行，实现pytorch到tensorflow的转化生成一个日志文件，还需要安装tensorflow，才能调用tensorboard命令解析日志文件并上传到浏览器</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">pip install tensorboardX</span><br><span class="line">pip install tensorflow <span class="comment">#安装的gpu版本</span></span><br></pre></td></tr></table></figure></p>
<h3 id="简单使用">简单使用</h3>
<p>​ 在程序调用一下api确保生成日志文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">writer &#x3D; SummaryWriter(&#39;runs&#x2F;fashion_mnist_experiment_1&#39;)  </span><br><span class="line">writer.add_image(&#39;four_fashion_mnist_images&#39;, img_grid)</span><br><span class="line">writer.close()   #必须有close 否则内容写不进去</span><br></pre></td></tr></table></figure>
<p>​ 在系统命令行输入以下命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensorboard --logdir runs  </span><br></pre></td></tr></table></figure>
<p>​ 上述的runs为刚才在py中生成日志文件的路径，得确保该路径下存放得有生成得日志文件 ​ 输入上述命令后，会产生如下输出，在google浏览器打开http://DESKTOP-F3BBIIO:6006 如果浏览被拒，改为 http://localhost:6006。如果是本机电脑链接远程服务器，则将服务器名字改为服务器的ip地址</p>
<h2 id="pytorch的用法">pytorch的用法</h2>
<h3 id="pytorch踩坑">pytorch踩坑</h3>
<ul>
<li>load模型时，他会自动将其加载在这个模型训练时所在的gpu上 此时若这个gpu刚好满了就不能加载。所以最好每次加自增加 map_location='cpu' 参数 load完毕后再to到需要的gpu上</li>
<li></li>
</ul>
<h3 id="cat-stack-unqueeze用法总结">cat stack unqueeze用法总结</h3>
<p>​ 相同： cat, stack 输入都为 1. tensor列表，2.另一个参数是维度 （n为输入tensor的维度数）</p>
<ul>
<li>cat : 将输入的tensor按照指定维度连接， 不要求输入的尺寸完全相同。dim的范围为 0~n-1 按照b, c, h, w的顺序对应dim从小到大。例如输入为二维矩阵，dim=0/1 =0表示在 h 维度拼接，即输出矩阵的行数为输入之和。</li>
<li>stack: 将输入tensor增加维度堆叠，要求输入的尺寸完全相同。dim范围0~n 也是按照bchw的顺序对应dim。输出的tensor dim=n+1。对于输二维矩阵，dim=0，在c维度堆叠；dim=1，提取每个输入的行向量按行堆叠构成输出的一个通道，输入矩阵有多少行就有多少通道；dim=2，提取每个输入的行向量按列堆叠构成输出的一个通道，输入矩阵有多少行就有多少通道。对于输入三维张量，同理。</li>
</ul>
]]></content>
      <categories>
        <category>其他笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>面试记录</title>
    <url>/posts/51622/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="字节视频算法实习">字节视频算法实习</h3>
<h4 id="知道的分类网络">知道的分类网络</h4>
<h4 id="mobile-net-v3的结构">mobile-net-v3的结构</h4>
<h4 id="gan有没有采用特殊的训练技巧">GAN有没有采用特殊的训练技巧</h4>
<h4 id="知道的注意力机制">知道的注意力机制</h4>
<h4 id="了解过transformer嘛">了解过transformer嘛</h4>
<h4 id="根据mask的分割还问了分割算法">根据mask的分割，还问了分割算法</h4>
<h4 id="知道的图像去噪方法">知道的图像去噪方法</h4>
<h4 id="知道的图像模糊的方法">知道的图像模糊的方法</h4>
<h4 id="双边滤波的原理">双边滤波的原理</h4>
<h4 id="代码c实现的时候用了什么">代码C++实现的时候用了什么</h4>
<h4 id="开闭操作">开闭操作</h4>
<h4 id="对图像增强这项任务的理解">对图像增强这项任务的理解</h4>
<h4 id="和其他-low-level-网络结构有啥区别-在训练数据重组的情况下-有什么区别">和其他 low-level 网络结构有啥区别 在训练数据重组的情况下 有什么区别</h4>
<h4 id="包含正数和负数的数组求乘积最大连续子数组">包含正数和负数的数组，求乘积最大连续子数组</h4>
<h4 id="丢鸡蛋问题">丢鸡蛋问题</h4>
<h3 id="腾讯后端实习">腾讯后端实习</h3>
<h4 id="重载和继承">重载和继承</h4>
<h4 id="知道哪些智能指针">知道哪些智能指针</h4>
<h4 id="线程和进程区别">线程和进程区别</h4>
<h4 id="知道进程通信的方法嘛线程通信呢">知道进程通信的方法嘛，线程通信呢</h4>
<h4 id="了解linux哪些锁">了解linux哪些锁</h4>
<h3 id="tp-图像优化岗">TP 图像优化岗</h3>
<h4 id="怎么解决过拟合">怎么解决过拟合</h4>
<h4 id="预编译的作用">预编译的作用</h4>
<h4 id="图像处理流程了解嘛">图像处理流程了解嘛</h4>
<p>回答 ISP</p>
<h4 id="用了什么设计模式">用了什么设计模式</h4>
<h4 id="红外细节增强项目候遇到过什么问题">红外细节增强项目候遇到过什么问题</h4>
<p>我完成这个任务的流程是，先在Matlab上验证算法的效果，然后确是可行后再转为C++实现，因此遇到的比较难搞的问题还是Matlab算法调试阶段时候效果出不来。比如前面细节层拉伸后光晕问题，产生分析和解决，还有比如细节层调整，之前都是设置固定参数，但是很难用一套参数处理好，才想到用图像熵做个参数自动搜索。最后落地实现，都是一些代码编写的问题印象不深了。</p>
<h4 id="拉普拉斯金字塔存储的是什么">拉普拉斯金字塔存储的是什么</h4>
<h4 id="对于目标检测识别深度学习能都替代传统方法">对于目标检测识别深度学习能都替代传统方法</h4>
<p>不太了解检测识别 直接围绕回答的增强</p>
<h4 id="项目里的提亮效果如何评价">项目里的提亮效果如何评价</h4>
<p>因为前景不对齐，所以主要还是在测试集上定性观察。其次在测试集上手工将运动区域过滤掉然后定量对比背景的相似度，对于运动的前景由于不对齐可以采用类似NIQE LOE这种无参考图像质量评价的标准，但是最后一个评估方法当时并没有尝试，因为虽然一些常规得指标是普适于大规模的自然数据集 但是应用于这个任务中这个指标的评价效果是否可靠也不一定。</p>
<h4 id="怎么组织团队合作的">怎么组织团队合作的</h4>
<p>不同人的代码风格不一样怎么办？</p>
<h4 id="深度学习方法怎么确定一个模块的效果">深度学习方法，怎么确定一个模块的效果？</h4>
<p>当时说了个啥奇奇怪怪的词没听懂</p>
<h4 id="概率题-红蓝车撞人目击正确的概率">概率题 红蓝车撞人，目击正确的概率</h4>
<h4 id="验证毒药的问题">验证毒药的问题</h4>
<h3 id="总结">总结</h3>
<p>要重新组织一下语言 项目详细介绍的时候脱稿 不然回答的逻辑很混乱，方法介绍要简化一点。</p>
<h4 id="觉得自己做的比较好的项目">觉得自己做的比较好的项目</h4>
<h4 id="怎么做研究">怎么做研究</h4>
<h4 id="怎么较好的完成项目">怎么较好的完成项目</h4>
<h4 id="研究问题的思路">研究问题的思路</h4>
<h4 id="红外图像和rgb图像的特性">红外图像和RGB图像的特性</h4>
<p>红外成像原理 红外成像设备是通过探测周围环境的热辐射特性，将它以图像的形式显示出来。特点：</p>
<ol type="1">
<li>灰度集中 对比度差</li>
<li>噪声多样性，一方面是动态噪声 如 热噪声 散粒噪声，光子噪声 形成机理复杂；另一方面是各探测元对相同辐射的反应具有不一致性，在红外图像上会产生固定的模式噪声，这种噪声是稳定的。现阶段高动态范围的红外设备也越来越多，这类红外设备有更高的灵敏度可以探测更小的热量差异，每个像元有2^14 2^16个灰度级，而现阶段普通设备….需要压缩动态范围</li>
</ol>
<h3 id="yuv-图像格式和用处">YUV 图像格式和用处</h3>
<h4 id="图像hdr">图像HDR</h4>
<h4 id="为什么选nltv算法">为什么选NLTV算法</h4>
<h4 id="https深入">https深入</h4>
<h4 id="怎么和他人合作">怎么和他人合作</h4>
<h4 id="印象最深刻的事儿">印象最深刻的事儿</h4>
]]></content>
      <categories>
        <category>其他笔记</category>
      </categories>
  </entry>
  <entry>
    <title>STL容器原理</title>
    <url>/posts/30429/</url>
    <content><![CDATA[<p>总结了STL容器的原理</p>
<span id="more"></span>
<h1 id="容器">容器</h1>
<p>C++ 提供的容器有 vector , map , unordered_map , set , list , dequeue等</p>
<h2 id="应用场景">应用场景</h2>
<h3 id="set-和-map">set 和 map</h3>
<ol type="1">
<li>共同点：都是C++的关联容器,只是通过它提供的接口对里面的元素进行访问，底层都是采用<strong>红黑树</strong>实现。</li>
<li>不同点：
<ul>
<li>set：用来判断某一个元素是不是在一个组里面，使用的比较少；</li>
<li>map：映射，相当于字典，把一个值映射成另一个值，可以创建字典</li>
</ul></li>
<li>优点：查找某一个数的时间为<strong>O(log n)</strong>；遍历时采用 iterator，效果不错</li>
<li>缺点：每次插入值的时候，都需要调整红黑树，效率有一定影响</li>
</ol>
<h3 id="unordered_map">unordered_map</h3>
<p>Hash表实现，虽然功能上 和 map 有点像，但是由于原理上本质的区别，它是不能遍历迭代的，即无序。速度快 查找时间复杂度 <strong>O(1)</strong></p>
<h3 id="vector">vector</h3>
<p>是<strong>动态数组</strong>，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后，内存也不会释放；如果新值大于当前大小时才会重新分配内存。</p>
<ol type="1">
<li>优点：拥有一段连续的内存空间，并且起始地址不变，因此能够非常好的支持随机存取，即[]操作符；<strong>O(1)</strong></li>
<li>缺点：对头部和中间进行添加删除元素操作需要移动内存，如果元素是结构或类，那么移动的同时还会进行构造和析构操作，所以性能不高</li>
</ol>
<h3 id="list">list</h3>
<p><strong>双向链表</strong>，元素也存放在堆中，每个元素都是放在一块内存中，他的内存空间可以是不连续的，通过指针来进行数据的访问。</p>
<ol type="1">
<li>缺点：这个特点使得它的随机存取变得非常没有效率，因此它没有提供[]操作符的重载。访问元素的时间复杂度 <strong>O(N)</strong>。</li>
<li>优点：它可以很有效率的支持任意地方的删除和插入操作。所以常用来做<strong>随机插入和删除</strong>操作容器。</li>
</ol>
<h3 id="deque">deque</h3>
<p>deque是一种优化了的对序列两端元素进行添加和删除操作的基本序列容器。通常由<strong>一些独立的区块组成，第一区块朝某方向扩展，最后一个区块朝另一方向扩展</strong>。它允许较为快速地随机访问但它不像vector一样把所有对象保存在一个连续的内存块，而是多个连续的内存块。并且在一个映射结构中保存对这些块以及顺序的跟踪。（因此在任意位置插入元素，不需要移动后面所有的元素，只用修改一页的内容）</p>
<ul>
<li>优点：随机插入删除元素的速度 介于 vector 和 list 之间，因为不需要复制所有元素</li>
<li>缺点：随机读取元素的速度 也是 介于 list 和 vector之间，因为deque需要处理内部跳转，读取速度没vector快，不支持resize 和 reserve 操作即不能自己显式的控制内存的大小。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210404172935.png" alt="image-20210404172337830" style="zoom:50%;" /></p>
<h2 id="迭代失效问题">迭代失效问题</h2>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 34%" />
<col style="width: 31%" />
<col style="width: 12%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th style="text-align: center;"><strong>vector</strong></th>
<th><strong>deque</strong></th>
<th><strong>list</strong></th>
<th><strong>set、map</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>内部数据结构</strong></td>
<td style="text-align: center;"><strong>数组(一段连续内存空间)</strong></td>
<td><strong>数组(多段连续内存空间)</strong></td>
<td><strong>双向环状链表</strong></td>
<td><strong>红黑树</strong></td>
</tr>
<tr class="even">
<td><strong>插入操作</strong></td>
<td style="text-align: center;">插入后元素总数不大于capacity，插入位置之后的迭代器会失效；大于capacity,所有迭代器都会失效</td>
<td>两端插入, 不会引起迭代器失效；中间插入, 所有迭代器失效</td>
<td>不会出现迭代器失效</td>
<td>不会出现迭代器失效</td>
</tr>
<tr class="odd">
<td><strong>删除操作</strong></td>
<td style="text-align: center;">删除位置之后的迭代器都会失效,但是erase会返回下一个有效的迭代器</td>
<td>两端删除, 被删除元素的迭代器失效中间删除, 所有迭代器失效</td>
<td>被删除节点的迭代器失效</td>
<td>被删除节点的迭代器失效</td>
</tr>
<tr class="even">
<td><strong>解决方法</strong></td>
<td style="text-align: center;">iter =cont.erase(iter)</td>
<td></td>
<td>m.erase(iter++)</td>
<td>m.erase(iter++)</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要求删除键值为偶数的键值对</span></span><br><span class="line"> map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//错误实现：</span></span><br><span class="line"> <span class="keyword">while</span> (it != m.<span class="built_in">end</span>())&#123;</span><br><span class="line">   <span class="keyword">if</span>(it-&gt;second % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">     m.<span class="built_in">erase</span>(it);</span><br><span class="line">   &#125;</span><br><span class="line">   it++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//正确实现：</span></span><br><span class="line"> <span class="keyword">while</span> (it != m.<span class="built_in">end</span>())&#123;</span><br><span class="line">   <span class="keyword">if</span>(it-&gt;second % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">     m.<span class="built_in">erase</span>(it++); <span class="comment">//重点！！！  it++的写法才行不能  m.rease(it); it++;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">     it++;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>库函数</category>
      </categories>
      <tags>
        <tag>STL库</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title>STL库常用API汇总</title>
    <url>/posts/24907/</url>
    <content><![CDATA[<p>汇总了c++ STL 库中常用的API用法</p>
<span id="more"></span>
<h1 id="常用api">常用API</h1>
<h2 id="vector">vector</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">a.<span class="built_in">resize</span>(N);						  <span class="comment">// 扩容</span></span><br><span class="line"><span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());  		    <span class="comment">//倒序</span></span><br><span class="line"><span class="built_in">swap</span>(a[<span class="number">0</span>], a[<span class="number">1</span>]);  					   <span class="comment">//交换位置0 和 1的元素</span></span><br><span class="line">a.<span class="built_in">assign</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());            <span class="comment">// b 拷贝到 a</span></span><br><span class="line">a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>);				    <span class="comment">//删除第一个元素</span></span><br></pre></td></tr></table></figure>
<h2 id="sort">sort</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> idx_, <span class="keyword">int</span> w_, <span class="keyword">int</span> p1_, <span class="keyword">int</span> p2_)&#123;</span><br><span class="line">        idx = idx_; w = w_; p1 = p1_; p2 = p2_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node&amp; data)&#123;     <span class="comment">// 升序排列</span></span><br><span class="line">        <span class="keyword">return</span> w &lt; data.w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> p1;</span><br><span class="line">    <span class="keyword">int</span> p2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Node&gt; test;</span><br><span class="line"><span class="built_in">sort</span>(test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>());            <span class="comment">//结构体中重载 &lt; 符号 来对自定义的 vector升序排序，要实现逆序排列 可以重载</span></span><br></pre></td></tr></table></figure>
<h2 id="string">string</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string a = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">string b = a.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">1</span>);   <span class="comment">//第一个参数代表起始位置，第二个为长度 提取子串</span></span><br><span class="line">string a = <span class="built_in">string</span>(<span class="number">5</span>,<span class="string">&#x27;0&#x27;</span>);   <span class="comment">//初始化长度为5的全0填充的字符串  &quot;00000&quot;</span></span><br><span class="line">a.<span class="built_in">at</span>(<span class="number">0</span>);                 	<span class="comment">//访问0位置的字符</span></span><br><span class="line">a.<span class="built_in">resize</span>(N); 			   <span class="comment">//和vector一样的扩容方法</span></span><br><span class="line">a.<span class="built_in">erase</span>(<span class="number">10</span>, <span class="number">4</span>)              <span class="comment">//从位置=10的字符开始 删除4个；不带第二个参数 表示删到结尾</span></span><br><span class="line">a.<span class="built_in">insert</span>(<span class="number">14</span>,<span class="number">6</span>,<span class="string">&#x27;*&#x27;</span>)		   <span class="comment">//向 位置14前面 插入 6 个 &quot;*&quot;</span></span><br><span class="line">a.<span class="built_in">find</span>(<span class="string">&quot;b&quot;</span>,<span class="number">5</span>)               <span class="comment">//从下标5开始查找 字符串“b”出现的位置  用if(pos == string::npos) 用来判断是否找到子串。</span></span><br><span class="line"></span><br><span class="line">a.<span class="built_in">erase</span>(<span class="number">0</span>,a.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; &quot;</span>));   <span class="comment">//去掉字符串左右两端的空格</span></span><br><span class="line">a.<span class="built_in">erase</span>(a.<span class="built_in">find_last_not_of</span>(<span class="string">&quot; &quot;</span>) + <span class="number">1</span>);</span><br><span class="line"><span class="comment">/// 用 stringstream 分割 指定字符 分开的 字符串</span></span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(a)</span></span>;</span><br><span class="line">string item;</span><br><span class="line"><span class="keyword">while</span>(ss &gt;&gt; item)	cout &lt;&lt; item &lt;&lt; endl;   <span class="comment">//获取 字符串中的单词 按空格分割</span></span><br><span class="line"><span class="keyword">while</span> (std::<span class="built_in">getline</span>(ss, item, <span class="string">&#x27;_&#x27;</span>))&#123;</span><br><span class="line">    cout &lt;&lt; item &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 字符串按照 特定字符分割   “11*11+12”</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">split_string</span><span class="params">(string&amp; s)</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; p2 &lt; s.<span class="built_in">size</span>(); p2++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[p2] == <span class="string">&#x27;+&#x27;</span> || s[p2] == <span class="string">&#x27;-&#x27;</span> || s[p2] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                re.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(p1, p2-p1)));</span><br><span class="line">                re.<span class="built_in">push_back</span>(s[p2]);</span><br><span class="line">                p1 = p2+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        re.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(p1, p2-p1)));</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="stringstream用法">stringstream用法</h3>
<p>头文件 <code>include&lt;sstream&gt;</code></p>
<h3 id="字符串分割函数">字符串分割函数</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">const</span> string s, vector&lt;string&gt;&amp; vs, <span class="keyword">const</span> <span class="keyword">char</span> delim= <span class="string">&#x27; &#x27;</span>)</span></span>&#123;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(s)</span></span>;</span><br><span class="line">    string temp;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(iss,temp,delim))&#123;</span><br><span class="line">        vs.<span class="built_in">emplace_back</span>(<span class="built_in">move</span>(temp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">back</span>() == delim) vs.<span class="built_in">push_back</span>(&#123;&#125;);<span class="comment">//加这句的原因是getline不会识别最后一个delim,避免误判&quot;172.16.254.1.&quot;,&quot;2001:0db8:85a3:0:0:8A2E:0370:7334:&quot;之类的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hash">Hash</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;string, <span class="keyword">int</span>&gt;  dict; <span class="comment">// 声明unordered_map对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据的三种方式</span></span><br><span class="line">dict.<span class="built_in">insert</span>(pair&lt;string,<span class="keyword">int</span>&gt;(<span class="string">&quot;apple&quot;</span>,<span class="number">2</span>));</span><br><span class="line">dict.<span class="built_in">insert</span>(unordered_map&lt;string, <span class="keyword">int</span>&gt;::<span class="built_in">value_type</span>(<span class="string">&quot;orange&quot;</span>,<span class="number">3</span>));</span><br><span class="line">dict[<span class="string">&quot;banana&quot;</span>] = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 判断是否有元素</span></span><br><span class="line"><span class="keyword">if</span>(dict.<span class="built_in">empty</span>())</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;该字典无元素&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;该字典共有&quot;</span>&lt;&lt;dict.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;个元素&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">unordered_map&lt;string, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line"><span class="keyword">for</span>(iter=dict.<span class="built_in">begin</span>();iter!=dict.<span class="built_in">end</span>();iter++)</span><br><span class="line">    cout&lt;&lt;iter-&gt;first&lt;&lt;ends&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">dict.<span class="built_in">erase</span>(<span class="string">&#x27;a&#x27;</span>); </span><br></pre></td></tr></table></figure>
<h2 id="queue">queue</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*队列*/</span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*优先队列*/</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, std::less&lt;<span class="keyword">int</span>&gt; &gt; maxHeap;    <span class="comment">// 大顶堆 堆顶的元素最大</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, std::greater&lt;<span class="keyword">int</span>&gt; &gt; minHeap; <span class="comment">// 小顶堆 堆顶元素最小</span></span><br><span class="line"><span class="comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</span></span><br><span class="line"><span class="keyword">int</span> a = maxHeap.<span class="built_in">top</span>();  <span class="comment">//获取堆顶最大元素</span></span><br><span class="line">maxHeap.<span class="built_in">pop</span>();          <span class="comment">//弹出堆顶元素</span></span><br><span class="line">maxHeap.<span class="built_in">push</span>();         <span class="comment">//向堆中增加元素 堆顶元素永远最大</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*双端队列*/</span></span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt; a;     			<span class="comment">// 双端队列 结合了栈和队列的性质，既可以从头部插入 也可以从尾部插入 </span></span><br><span class="line"><span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(a)</span></span>;  			<span class="comment">// 定义并用双端队列a初始化双端队列b</span></span><br><span class="line"><span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(&amp;n[<span class="number">1</span>], &amp;n[<span class="number">4</span>])</span></span>;  <span class="comment">// 将n[1]、n[2]、n[3]作为双端队列a的初值</span></span><br><span class="line">deq.<span class="built_in">size</span>();</span><br><span class="line">deq.<span class="built_in">resize</span>();</span><br><span class="line">deq.<span class="built_in">push_front</span>(<span class="keyword">const</span> T&amp; x);  <span class="comment">// 头部添加元素</span></span><br><span class="line">deq.<span class="built_in">push_back</span>(<span class="keyword">const</span> T&amp; x);   <span class="comment">//尾部添加元素</span></span><br><span class="line">deq.<span class="built_in">insert</span>(iterator it, <span class="keyword">const</span> T&amp; x);  <span class="comment">//任意位置插入一个元素</span></span><br><span class="line">deq.<span class="built_in">pop_front</span>(); 			<span class="comment">// 头部删除元素</span></span><br><span class="line">deq.<span class="built_in">pop_back</span>();				<span class="comment">//末尾删除元素</span></span><br><span class="line">deq.<span class="built_in">front</span>();				<span class="comment">//访问第一个元素</span></span><br><span class="line">deq.<span class="built_in">back</span>();					<span class="comment">//访问最后一个元素</span></span><br></pre></td></tr></table></figure>
<h3 id="优先队列-priority_queue">优先队列 priority_queue</h3>
<p>头文件<code>#include &lt;queue&gt;</code>, 可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队。本质是通过大小顶堆这种数据结构实现。</p>
<h4 id="定义">定义</h4>
<p>priority_queue&lt;Type, Container, Functional&gt;</p>
<p><em>Type</em> 就是数据类型，<em>Container</em> 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），<em>Functional</em> 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆</p>
<p>基本操作:</p>
<ul>
<li>top 访问队头元素</li>
<li>empty 队列是否为空</li>
<li>size 返回队列内元素个数</li>
<li>push 插入元素到队尾 (并排序)</li>
<li>emplace 原地构造一个元素并插入队列</li>
<li>pop 弹出队头元素</li>
<li>swap 交换内容</li>
</ul>
<h4 id="自定义类型用法">自定义类型用法</h4>
]]></content>
      <categories>
        <category>C++</category>
        <category>库函数</category>
      </categories>
      <tags>
        <tag>STL库</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title>streamstream用法</title>
    <url>/posts/48793/</url>
    <content><![CDATA[<p>总结了 streamstream 用法</p>
<span id="more"></span>
<h1 id="stringstream用法">stringstream用法</h1>
<p>参考链接 https://www.cnblogs.com/gamesky/archive/2013/01/09/2852356.html</p>
<p>需要在源程序文件中包含头文件<code>include&lt;sstream&gt;</code></p>
<p>包含的类 有 <strong>stringstream、istringstream、ostringstream</strong></p>
<h2 id="数组转字符串">数组转字符串</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> pi = <span class="number">3.141592653589793</span>;</span><br><span class="line">    <span class="keyword">float</span> dollar = <span class="number">1.00</span>;</span><br><span class="line">    <span class="keyword">int</span> dozen = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">35</span>;</span><br><span class="line">    </span><br><span class="line">    stringstream ss;</span><br><span class="line">    </span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;dozen: &quot;</span> &lt;&lt; dozen &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示小数</span></span><br><span class="line">    ss.<span class="built_in">setf</span>(ios::fixed);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示2位小数</span></span><br><span class="line">    ss.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;dollar: &quot;</span> &lt;&lt; dollar &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示10位小数</span></span><br><span class="line">    ss.<span class="built_in">precision</span>(<span class="number">10</span>);</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;pi: &quot;</span> &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//按十六进制显示整数</span></span><br><span class="line">    ss.<span class="built_in">unsetf</span>(ios_base::dec);</span><br><span class="line">    ss.<span class="built_in">setf</span>(ios::hex);</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;number: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    string text = ss.<span class="built_in">str</span>();</span><br><span class="line">    cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://img-blog.csdn.net/20180413072211763?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbmppbmdfY3Nkbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" /><figcaption>img</figcaption>
</figure>
<p><strong>这个示例的本质是：数字 -&gt; stringstream对象 -&gt; string</strong></p>
<h2 id="字符串-数字">字符串-&gt;数字</h2>
<p>string -&gt; double/int</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">double</span>  dVal;    </span><br><span class="line">    <span class="keyword">int</span>     iVal;</span><br><span class="line">    string  str;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// string -&gt; double</span></span><br><span class="line">    str = <span class="string">&quot;123.456789&quot;</span>;  </span><br><span class="line">    ss &lt;&lt; str;</span><br><span class="line">    ss &gt;&gt; dVal;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;dVal: &quot;</span> &lt;&lt; dVal &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// string -&gt; int</span></span><br><span class="line">    str = <span class="string">&quot;654321&quot;</span>;  </span><br><span class="line">    ss.<span class="built_in">clear</span>();</span><br><span class="line">    ss &lt;&lt; str;</span><br><span class="line">    ss &gt;&gt; iVal;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iVal: &quot;</span> &lt;&lt; iVal &lt;&lt; endl;  </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p><strong>这个示例的本质是：string -&gt; stringstream对象 -&gt; 数字</strong></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>库函数</category>
      </categories>
      <tags>
        <tag>STL库</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-创建型-单例</title>
    <url>/posts/17300/</url>
    <content><![CDATA[<p><strong>单例模式</strong>是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p>
<span id="more"></span>
<h2 id="意图">意图</h2>
<p>单例模式（Singleton）是一种创建型设计模式， 让你<strong>能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</strong></p>
<h2 id="结构">结构</h2>
<p>使用下三部分来实现：</p>
<ul>
<li>私有构造函数：私有构造函数保证了不能通过构造函数来创建对象实例</li>
<li>一个私有静态变量：私有静态变量用于指向实例化的对象，全局唯一</li>
<li>一个公有静态函数：只能通过公有静态函数返回<strong>唯一的私有静态变量</strong></li>
</ul>
<h2 id="实现">实现</h2>
<p>主要分为懒汉式 和 饿汉式 两种实现方式。区别就是实例化唯一的对象的位置。而懒汉式又有两种实现，一个线程安全，一个线程不安全</p>
<ul>
<li>懒汉式：延迟实现，只有当调用公用静态函数，且静态指针为空的时候才实例化对象，存在线程不安全问题
<ul>
<li>线程安全的修改</li>
</ul></li>
<li>饿汉式：当程序运行的时候就 初始化 私有静态指针，因此线程安全</li>
</ul>
<p>C++ 代码实现</p>
<h3 id="饿汉式-懒汉式">饿汉式 / 懒汉式</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> std::string value): <span class="built_in">value_</span>(value)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Singleton* singleton_;</span><br><span class="line">    std::string value_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// 全局静态函数 用于实例化唯一的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton *<span class="title">GetInstance</span><span class="params">(<span class="keyword">const</span> std::string&amp; value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton_==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            singleton_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton_;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">string <span class="title">value</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> value_;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 如果是饿汉模式，在初始化的时候就 用 new 分配内存，如果懒汉模式，初始静态指针设置为 null 只有调用静态函数的时候才new</span></span><br><span class="line"><span class="comment">// 由于 singleton_ 指针是 私有静态变量，因此只能在函数外部，全局初始化，而不能放在任何一个函数里 去修改（包括mian函数），会编译报错</span></span><br><span class="line">Singleton* Singleton::singleton_= <span class="keyword">new</span> <span class="built_in">Singleton</span>(<span class="string">&quot;Init&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFoo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Following code emulates slow initialization.</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">    Singleton* singleton = Singleton::<span class="built_in">GetInstance</span>(<span class="string">&quot;FOO&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; singleton-&gt;<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadBar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Following code emulates slow initialization.</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">    Singleton* singleton = Singleton::<span class="built_in">GetInstance</span>(<span class="string">&quot;BAR&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; singleton-&gt;<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当两个线程输出的 结果 不一样时，说明产生了线程不安全的问题</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(ThreadFoo)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(ThreadBar)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同过上述代码可以看出，懒汉式饿汉式的区别：</p>
<ul>
<li>饿汉式：在 main 函数的执行之前，就调用了 new 实例化了对象，因此是线程安全的；缺点是由于一开始就申请了空间，会有资源浪费的问题。</li>
<li>懒汉式：只有在程序 调用 公有静态函数，需要获取对象时，才会判断该对象有没有实例化，没的话再实例化。优点是 延迟实例化带来的节约资源的好处。缺点是 这是线程不安全的。
<ul>
<li>例如当两个线程同时 调用 <code>GetInstance</code>函数，并且都同时通过了 <code>singleton_</code>指针空的判断，就会实例化出两个对象，所以上述代码输出的现象就是，两个线程输出的value值不一样。</li>
</ul></li>
</ul>
<h3 id="懒汉式-线程安全">懒汉式-线程安全</h3>
<p>为了解决上述 懒汉式 线程不安全的问题就是 对 <code>GetInstance</code> 函数加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次。但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 <code>Singleton</code>已经被实例化了(即 <code>singleton_</code>指针不为空)。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。可以使用 <strong>双重校验锁</strong> 的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单的加锁</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::GetInstance</span><span class="params">(<span class="keyword">const</span> std::string&amp; value)</span></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(singleton_==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        singleton_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 双重校验锁</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::GetInstance</span><span class="params">(<span class="keyword">const</span> std::string&amp; value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(singleton_！=<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> singleton_;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; <span class="built_in">lock</span>(mutex_);</span><br><span class="line">        <span class="keyword">if</span>(singleton_==<span class="literal">nullptr</span>)</span><br><span class="line">            singleton_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>(value);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上述代码实现可以看出，双重校验锁的原理是，只有当判断 <code>singleton_</code>为空，即还未实例化的时候，才需要加锁操作，因为这时候肯定是要进行对象实例化操作，即写操作。如果已经实例化了，直接返回地址即可，不用加锁读。但是加锁后又判断了一遍是否指针空，因为还是可能存在两个线程同时进入了第一个 指针判断 空的语句，由于有锁，一个线程实例化对象，并修改指针为非空，完毕后释放锁。此时如果另一个线程不再判断一次为空就会 再次 new 实例化，还是存在线程不安全的问题。</p>
<p>或者直接这么理解，双重校验就是在 原本的基础上 先判断指针是否为空，空的化直接返回指针，不必校验。而不为空，才加锁判断。</p>
<p><strong>优点：</strong>双重校验锁，即是延迟实例化的，可以节省资源，还是线程安全的，且不会因为锁的存在使得线程阻塞时间过长。</p>
<h3 id="volatile-关键字">volatile 关键字</h3>
<p>singleton_ 采用 volatile 关键字修饰也是很有必要的，<code>singleton_ = new Singleton(value)</code> 这段代码其实是分为三步执行：</p>
<ol type="1">
<li>为 <code>Singleton</code>分配内存空间</li>
<li>初始化 <code>Singleton</code></li>
<li>将 <code>singleton_</code>指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行</p>
<p><a href="../语言特性/volatile关键字.md">C++ volatile关键字作用</a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-创建型-工厂方法</title>
    <url>/posts/22335/</url>
    <content><![CDATA[<p><strong>工厂方法</strong>是一种创建型设计模式，是基于简单工厂的改进</p>
<span id="more"></span>
<h2 id="意图">意图</h2>
<p>简单工厂中，一个工厂类统一实例化所有的产品，而工厂方法，每个产品用特定的工厂子类实例化。定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p>
<h3 id="和简单工厂对比">和简单工厂对比</h3>
<p>在简单工厂方法中，同一接口的不同产品对象都由一个工厂创建出来。这种做法存在两个问题：</p>
<ul>
<li>当产品对象很多时，工厂就会成为一个“过大类”</li>
<li>当新增产品对象时，需要在工厂中增加一个分支。这就违反了“开闭原则”</li>
</ul>
<p>第一条很好理解，一个工厂负责生产所有的产品，不断增加产品的种类，工厂中的 if 语句也就越多。同时，由于增加一个新的产品种类，就要修改工厂的代码，因此违反了开闭原则，开闭原则希望当增加新功能时不用修改原有的代码，只用通过新增代码就完成。</p>
<p>所以工厂方法，特定的 产品使用特定的 工厂方法生产，当新增一个方法时，只用新增一个生产它的工厂子类即可。因此针对产品不会频繁变化，且产品种类较少的情景下 使用简单工厂反而好些。</p>
<h2 id="实现">实现</h2>
<p>从代码可以看出实现的核心是：</p>
<ul>
<li>不同子类重写不同的new 产品的函数，主工厂中首先调用 获取产品的函数获取产品，再执行功能。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产品抽象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Product</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">Operation</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 子类产品1 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> :</span> <span class="keyword">public</span> Product &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::string <span class="title">Operation</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;Result of the ConcreteProduct1&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 子类产品2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> :</span> <span class="keyword">public</span> Product &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::string <span class="title">Operation</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;Result of the ConcreteProduct2&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂主类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Creator</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Product* <span class="title">FactoryMethod</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">SomeOperation</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在工厂主类中 生产 产品，FactoryMethod 是由对应的子类重写了，因此不同的子类会返回不同的产品</span></span><br><span class="line">    <span class="comment">// 然后再 调用产品完成特定的功能</span></span><br><span class="line">    Product* product = <span class="keyword">this</span>-&gt;<span class="built_in">FactoryMethod</span>();</span><br><span class="line">   </span><br><span class="line">    std::string result = <span class="string">&quot;Creator: The same creator&#x27;s code has just worked with &quot;</span> + product-&gt;<span class="built_in">Operation</span>();</span><br><span class="line">    <span class="keyword">delete</span> product;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂1 用于生产产品1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCreator1</span> :</span> <span class="keyword">public</span> Creator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Product* <span class="title">FactoryMethod</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProduct1</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 工厂2 用于生产产品2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCreator2</span> :</span> <span class="keyword">public</span> Creator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Product* <span class="title">FactoryMethod</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProduct2</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClientCode</span><span class="params">(<span class="keyword">const</span> Creator&amp; creator)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Client: I&#x27;m not aware of the creator&#x27;s class, but it still works.\n&quot;</span></span><br><span class="line">            &lt;&lt; creator.<span class="built_in">SomeOperation</span>() &lt;&lt; std::endl;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;App: Launched with the ConcreteCreator1.\n&quot;</span>;</span><br><span class="line">  Creator* creator = <span class="keyword">new</span> <span class="built_in">ConcreteCreator1</span>();</span><br><span class="line">  <span class="built_in">ClientCode</span>(*creator);</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;App: Launched with the ConcreteCreator2.\n&quot;</span>;</span><br><span class="line">  Creator* creator2 = <span class="keyword">new</span> <span class="built_in">ConcreteCreator2</span>();</span><br><span class="line">  <span class="built_in">ClientCode</span>(*creator2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> creator;</span><br><span class="line">  <span class="keyword">delete</span> creator2;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/posts/22548/</url>
    <content><![CDATA[<p>使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象</p>
<span id="more"></span>
<p>和拷贝构造函数的区别</p>
<p>原型模式需要子类实现一个clone的接口，这个clone函数又依赖于子类的拷贝构造函数。<strong>那么clone和拷贝构造函数的区别在于，clone函数可以对一个基类指针进行自我拷贝</strong>，如果基类指针指向的是一个子对象，那么就可以拷贝出一个一样的子类对象，而赋值构造函数只能对具体类别对象进行复制构造，无法将指向子类的基类指针通过拷贝构造函数拷贝，即使可以，也得事先知道他指向的是那个子类对象，然后通过指针的强制类型转换再取值拷贝。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-创建型-抽象工厂</title>
    <url>/posts/48237/</url>
    <content><![CDATA[<p>提供一个接口，用于创建 <strong>相关的对象家族</strong> 。</p>
<span id="more"></span>
<h2 id="结构">结构</h2>
<p><strong>抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。</strong></p>
<p>抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。</p>
<p>至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。</p>
<p>从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210522151302.png" alt="image-20210522151255026" style="zoom:67%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210522151657.png" alt="image-20210522151657700" style="zoom:67%;" /></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-创建型-简单工厂</title>
    <url>/posts/39057/</url>
    <content><![CDATA[<p><strong>简单工厂</strong>是一种创建型设计模式，在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p>
<span id="more"></span>
<h2 id="目的">目的</h2>
<p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p>
<h2 id="结构">结构</h2>
<p><strong>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化</strong>。这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p>
<h2 id="实现">实现</h2>
<p>根据下面代码可以看出，简单工厂的实现要点</p>
<ul>
<li>用户并不需要指导具体的子类的名称，只需要根据参数来向工厂获取 产品。而用户只用使用 基类指针来指向 工厂创建的子类对象，即多态机制，来完成子类的特定功能。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Phone</span>() &#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoMi</span>:</span> <span class="keyword">public</span> Phone&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">XiaoMi</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;This is xiao mi phone&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span>:</span> <span class="keyword">public</span> Phone&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Apple</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;This is apple phone&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 简单工厂类，客户使用简单工厂来获取对应的产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">SimpleFactory</span>()&#123;&#125;;</span><br><span class="line">        <span class="function">Phone* <span class="title">create</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;   <span class="comment">// 注意返回类型为 基类 指针</span></span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (type)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">XiaoMi</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Apple</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SimpleFactory factory = <span class="built_in">SimpleFactory</span>();</span><br><span class="line">    Phone* ptr = factory.<span class="built_in">create</span>(<span class="number">0</span>);</span><br><span class="line">    ptr-&gt;<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    ptr = factory.<span class="built_in">create</span>(<span class="number">1</span>);</span><br><span class="line">    ptr-&gt;<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>生成器</title>
    <url>/posts/25129/</url>
    <content><![CDATA[<p><strong>生成器模式</strong>是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。</p>
<span id="more"></span>
<h2 id="目的">目的</h2>
<p>对于一个包含复杂对象，在对其构造的时候可能包含很多部分，例如盖房子，可能会有窗户，门，游泳池，车库….等很多部件。创建不同类型的房子可能需要构建不同的部件。例如有的房子有游泳池，有的没有，有的有车库有的没有。对于这种情况，虽然可以使用包含很多部件的初始化函数来构造，例如：</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210522153343.png" alt="image-20210522153343513" style="zoom:67%;" /></p>
<p>通常情况下， 绝大部分的参数都没有使用， 这使得<a href="https://refactoringguru.cn/smells/long-parameter-list">对于构造函数的调用十分不简洁</a>。 例如， 只有很少的房子有游泳池， 因此与游泳池相关的参数十之八九是毫无用处的。</p>
<p>生成器模式建议将对象构造代码从产品类中抽取出来， 并将其放在一个名为<em>生成器</em>的独立对象中。该模式会将对象构造过程划分为一组步骤， 比如 <code>build­Walls</code>创建墙壁和 <code>build­Door</code>创建房门创建房门等。 每次创建对象时， 你都需要通过生成器对象执行一系列步骤。 重点在于你无需调用所有步骤， 而只需调用创建特定对象配置所需的那些步骤即可。</p>
<h2 id="结构">结构</h2>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210522171541.png" alt="image-20210522171541073" style="zoom:67%;" /></p>
<p>总的来说，就是产品（对象）的构造从他自己的构造函数中独立出来，使用一个单独的 <code>bullder</code>类，来管理对象的构造。如果对象需要产品A，就调用构造A部件的函数。并且最后还可以通过一个主管类来封装构造特定对象的步骤。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * It makes sense to use the Builder pattern only when your products are quite</span></span><br><span class="line"><span class="comment"> * complex and require extensive configuration.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unlike in other creational patterns, different concrete builders can produce</span></span><br><span class="line"><span class="comment"> * unrelated products. In other words, results of various builders may not</span></span><br><span class="line"><span class="comment"> * always follow the same interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product1</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;std::string&gt; parts_;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ListParts</span><span class="params">()</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Product parts: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;parts_.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parts_[i]== parts_.<span class="built_in">back</span>())&#123;</span><br><span class="line">                std::cout &lt;&lt; parts_[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                std::cout &lt;&lt; parts_[i] &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n\n&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The Builder interface specifies methods for creating the different parts of</span></span><br><span class="line"><span class="comment"> * the Product objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Builder</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Builder</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ProducePartA</span><span class="params">()</span> <span class="keyword">const</span> </span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ProducePartB</span><span class="params">()</span> <span class="keyword">const</span> </span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ProducePartC</span><span class="params">()</span> <span class="keyword">const</span> </span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The Concrete Builder classes follow the Builder interface and provide</span></span><br><span class="line"><span class="comment"> * specific implementations of the building steps. Your program may have several</span></span><br><span class="line"><span class="comment"> * variations of Builders, implemented differently.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder1</span> :</span> <span class="keyword">public</span> Builder&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    Product1* product;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A fresh builder instance should contain a blank product object, which is</span></span><br><span class="line"><span class="comment">     * used in further assembly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ConcreteBuilder1</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">Reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ConcreteBuilder1</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span> product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;product= <span class="keyword">new</span> <span class="built_in">Product1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * All production steps work with the same product instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ProducePartA</span><span class="params">()</span><span class="keyword">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;product-&gt;parts_.<span class="built_in">push_back</span>(<span class="string">&quot;PartA1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ProducePartB</span><span class="params">()</span><span class="keyword">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;product-&gt;parts_.<span class="built_in">push_back</span>(<span class="string">&quot;PartB1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ProducePartC</span><span class="params">()</span><span class="keyword">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;product-&gt;parts_.<span class="built_in">push_back</span>(<span class="string">&quot;PartC1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Concrete Builders are supposed to provide their own methods for</span></span><br><span class="line"><span class="comment">     * retrieving results. That&#x27;s because various types of builders may create</span></span><br><span class="line"><span class="comment">     * entirely different products that don&#x27;t follow the same interface.</span></span><br><span class="line"><span class="comment">     * Therefore, such methods cannot be declared in the base Builder interface</span></span><br><span class="line"><span class="comment">     * (at least in a statically typed programming language). Note that PHP is a</span></span><br><span class="line"><span class="comment">     * dynamically typed language and this method CAN be in the base interface.</span></span><br><span class="line"><span class="comment">     * However, we won&#x27;t declare it there for the sake of clarity.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Usually, after returning the end result to the client, a builder instance</span></span><br><span class="line"><span class="comment">     * is expected to be ready to start producing another product. That&#x27;s why</span></span><br><span class="line"><span class="comment">     * it&#x27;s a usual practice to call the reset method at the end of the</span></span><br><span class="line"><span class="comment">     * `getProduct` method body. However, this behavior is not mandatory, and</span></span><br><span class="line"><span class="comment">     * you can make your builders wait for an explicit reset call from the</span></span><br><span class="line"><span class="comment">     * client code before disposing of the previous result.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Please be careful here with the memory ownership. Once you call</span></span><br><span class="line"><span class="comment">     * GetProduct the user of this function is responsable to release this</span></span><br><span class="line"><span class="comment">     * memory. Here could be a better option to use smart pointers to avoid</span></span><br><span class="line"><span class="comment">     * memory leaks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Product1* <span class="title">GetProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Product1* result= <span class="keyword">this</span>-&gt;product;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">Reset</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The Director is only responsible for executing the building steps in a</span></span><br><span class="line"><span class="comment"> * particular sequence. It is helpful when producing products according to a</span></span><br><span class="line"><span class="comment"> * specific order or configuration. Strictly speaking, the Director class is</span></span><br><span class="line"><span class="comment"> * optional, since the client can control builders directly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span>&#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @var Builder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Builder* builder;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The Director works with any builder instance that the client code passes</span></span><br><span class="line"><span class="comment">     * to it. This way, the client code may alter the final type of the newly</span></span><br><span class="line"><span class="comment">     * assembled product.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_builder</span><span class="params">(Builder* builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;builder=builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The Director can construct several product variations using the same</span></span><br><span class="line"><span class="comment">     * building steps.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuildMinimalViableProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;builder-&gt;<span class="built_in">ProducePartA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuildFullFeaturedProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;builder-&gt;<span class="built_in">ProducePartA</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;builder-&gt;<span class="built_in">ProducePartB</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;builder-&gt;<span class="built_in">ProducePartC</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The client code creates a builder object, passes it to the director and then</span></span><br><span class="line"><span class="comment"> * initiates the construction process. The end result is retrieved from the</span></span><br><span class="line"><span class="comment"> * builder object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * I used raw pointers for simplicity however you may prefer to use smart</span></span><br><span class="line"><span class="comment"> * pointers here</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClientCode</span><span class="params">(Director&amp; director)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ConcreteBuilder1* builder = <span class="keyword">new</span> <span class="built_in">ConcreteBuilder1</span>();</span><br><span class="line">    director.<span class="built_in">set_builder</span>(builder);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Standard basic product:\n&quot;</span>; </span><br><span class="line">    director.<span class="built_in">BuildMinimalViableProduct</span>();</span><br><span class="line">    </span><br><span class="line">    Product1* p= builder-&gt;<span class="built_in">GetProduct</span>();</span><br><span class="line">    p-&gt;<span class="built_in">ListParts</span>();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Standard full featured product:\n&quot;</span>; </span><br><span class="line">    director.<span class="built_in">BuildFullFeaturedProduct</span>();</span><br><span class="line"></span><br><span class="line">    p= builder-&gt;<span class="built_in">GetProduct</span>();</span><br><span class="line">    p-&gt;<span class="built_in">ListParts</span>();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remember, the Builder pattern can be used without a Director class.</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Custom product:\n&quot;</span>;</span><br><span class="line">    builder-&gt;<span class="built_in">ProducePartA</span>();</span><br><span class="line">    builder-&gt;<span class="built_in">ProducePartC</span>();</span><br><span class="line">    p=builder-&gt;<span class="built_in">GetProduct</span>();</span><br><span class="line">    p-&gt;<span class="built_in">ListParts</span>();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> builder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Director* director= <span class="keyword">new</span> <span class="built_in">Director</span>();</span><br><span class="line">    <span class="built_in">ClientCode</span>(*director);</span><br><span class="line">    <span class="keyword">delete</span> director;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>结构型</title>
    <url>/posts/57512/</url>
    <content><![CDATA[<p>结构型模式</p>
<span id="more"></span>
<h2 id="适配器">适配器</h2>
<h3 id="概述">概述</h3>
<p>本质上就是将一个对象接口和另一个对象的接口适配。实现上很简单，适配器继承+覆盖目标对象的方法，并在覆盖的方法中调用源对象的方法，达到偷梁换柱的功能</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210525211505.png" alt="image-20210525211505334" style="zoom:50%;" /></p>
<h2 id="桥接">桥接</h2>
<h3 id="概述-1">概述</h3>
<p>将抽象与实现分离开来，使它们可以独立变化。 这是官方的解释，通俗的讲。某个类具有两个或者以上的维度变换，例如 交通工具行驶在路上，路面的材质有多种，交通工具也有多种，如果直接使用继承实现 那么 就有 MxN 种子类 太多了麻烦，桥接模式就是用于解决这种问题。</p>
<h3 id="结构">结构</h3>
<p>桥接模式建议将抽象和实现分开。对于上述例子，路面作为抽象接口，抽象出 driverOnRoad 接口，同时包含一个 车 的指针，不同类型的车重写 driver 函数用于输出不同的车类型，在 driverOnRoad 函数中调用 车 的driver()接口，并结合 路面的材质一起输出，就完成了 车种类+路面材质的组合输出。如果要实现 另一种路面的组合，可以对路面重写 driverOnRoad 函数，更改里面的路面材质。</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210525220123.png" alt="image-20210525220123356" style="zoom:50%;" /></p>
<h2 id="组合">组合</h2>
<h3 id="概述-2">概述</h3>
<p>将对象组合成<strong>树形结构</strong>来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。</p>
<h3 id="结构-1">结构</h3>
<p>这玩意就是一个 树 形状的结构，因此同组合中的元素的访问其实就是递归访问的方式。组合对象即为 节点，组件即为叶子节点，组合对象可以包含一个或多个组件，而每个组件可能类型不同，因此如果要统计一个根 组合（节点/容器）中的所有组件信息，那么里面就要区分容器/不同组件等区别，这是很难完成的。组合模式建议将 所有 组合 和 组件（节点和叶子）都抽象出几个统一的接口。组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。</p>
<p>总之，就是将组合 和 组件抽象为 节点 和 叶子的关系，使用同一个接口 （图中的 Component ） 去返回组合/组件中拥有的信息。靠多态的机制实现不同的类的对象调用相同的接口来获得他们的信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210525221708.png" alt="image-20210525221708582" style="zoom:50%;" /></p>
<h2 id="装饰">装饰</h2>
<h3 id="概述-3">概述</h3>
<p>为对象动态地添加功能，例如 咖啡的本体是 咖啡豆的品种，必定要选咖啡豆的种类。但是可以增加其他配料，例如牛奶，糖等，也可以啥都不加。使用这个模式之后就可以方便动态的往初始咖啡豆的种类中增加 其他配料，然后统计总的价格。</p>
<p>注意有个关键点，必定有个基础配置，即咖啡豆的种类；否则不选咖啡豆种类，反而选牛奶，那主体就不是咖啡了，因此此为 装饰 的本意。</p>
<h3 id="结构-2">结构</h3>
<p>要实现上述功能，首先要获取每个配料 component 的价格和描述，必然要实现 get_discription 和 cost 的接口用于返回描述和花费。对于咖啡豆的种类实现这个接口即可，对于装饰类，还要继承 component 后 还要 增加一个 component 指针用于指向下一个对象。<strong>因此整个装饰器的结构就好像 一个单向链表</strong>。末端是初始的 咖啡豆种类，前一个可以是增加的某种配料，并且它的 component 指针指向咖啡豆对象，这样一次往前增加配料，最终返回的是链表头的对象。返回 cost 的时候递归的 统计链表中所有节点的 cost 和。（图中的 otherOperation 即为它指向的下一个 装饰器的 operation）</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210525224942.png" alt="image-20210525224942473" style="zoom:50%;" /></p>
<h3 id="小结">小结</h3>
<p>组合模式更像是一个树状的层次结构，也是递归的形式统计。而装饰模式更像是一个链式结构，只不过它一定会有基础节点，否就违背了装饰的本意。 感觉这个和桥接模式也很像，但是区别在于，桥接模式没有串联递归，例如桥接的 咖啡豆+甜度组合，像是 选择+组合问题，但是桥接模式就 类似 无语义重叠的集合问题 例如 咖啡豆组合 + 牛奶 + 糖 + … 同样都是解决静态继承很繁杂的问题，并采用动态的方式来结合。</p>
<h2 id="外观模式">外观模式</h2>
<h3 id="概述-4">概述</h3>
<p>就是将 子类 的所有类似功能的接口统一，然后使用一个外观对象 对他们进行统一调用，这样简化了客户端的操作。例如 睡觉前要 关电视 关灯 关空调等操作，客户一个个操作很麻烦，就将他们的开闭都统一成一个相同的接口，然后用一个遥控器统一完成他们的开闭操作。用户就只用对遥控器发送一次指令，然后由遥控器分别操作其他子类。</p>
<h2 id="享元模式">享元模式</h2>
<h3 id="概述-5">概述</h3>
<p>利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。 当每个对象中存在大部分相同的共享状态时，就将这些相同的状态（内部状态，不会随着环境改变而改变）提取出来放在 池 中，以减少不必要的内存占用。（<strong>共享技术</strong>）</p>
<h3 id="结构-3">结构</h3>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210526213050.png" alt="image-20210526213049994" style="zoom:67%;" /></p>
<ul>
<li>Contex 情景：可以类比为强站游戏中每个 子弹的原始对象，它包含颜色，大小，位置等属性。将他们分为外部状态 即子弹的位置，这是会随时间改变的不共享，和内部状态，即不变的属性，将这些内部属性包装为 Flyweight 结构。</li>
<li>Flyweight：将共享状态包装进这个类中，即参数 repeatState</li>
<li>FlyweightFactory : 工厂类，即内存池的实现吧，将 相同的状态封装为一个 享元类，并用 map 结构保存。</li>
</ul>
<p>综上，<strong>首先 将共享状态封装为 Flyweight 对象，然后用 FlyweightFactory 对象实现一个内存池，存储所有共享状态</strong>。如果要根据内部状态外部状态初始化一个原始对象，外部状态作为对象的私有参数开辟内存存储，内部状态从工厂中获取，工厂返回给它一个 Flyweight 对象 的地址。要获取当前对象的所有状态，根据Flyweight 中开辟的接口获取即可。</p>
<h2 id="代理">代理</h2>
<h3 id="概述-6">概述</h3>
<p>控制对其他对象的访问。</p>
<h3 id="结构-4">结构</h3>
<p>将原始服务对象 使用一个新的类（代理）对他进行封装，客户通过代理的接口间接地对原始服务端访问。</p>
<p>为什么要增加代理呢？</p>
<ol type="1">
<li>虚拟代理：对于原始服务对象 很大且使用频率不高的服务对象，使用代理可以将<strong>原始对象的延迟初始化</strong>到请求时再执行，并且代理可以自动根据当前客户的使用服务器的频率选择释放代理。同样的也能<strong>延迟访问</strong> ，例如一个加载很慢的图片，可以由虚拟代理先获得图像大小信息生成一个临时图片代替原始图片。</li>
<li>远程代理：就是将访问远程服务器的复杂地址请求逻辑由代理 封装，像不同的地址空间发送请求。</li>
<li>保护代理：可以根据客户端的权限，由代理选择给哪些客户端访问服务器的权限</li>
<li>智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它….以及缓存一下重复的请求结果减少重复访问。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210526221955.png" alt="image-20210526221954964" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象</title>
    <url>/posts/38994/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="面向对象思想">面向对象思想</h1>
<h2 id="三大特性">三大特性</h2>
<h3 id="封装">封装</h3>
<p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型内部，尽可能隐藏内部的细节，只保留一些对外交互的接口使其与外部发生联系。</p>
<p>优点：</p>
<ul>
<li>减少耦合：可以独立开发、测试、优化、修改、调试。因此也可以减轻维护的负担。</li>
<li>有效的调节性能：可以通过剖析来确定哪些模块影响了系统的性能</li>
<li>提高软件的可重用性</li>
<li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li>
</ul>
<h3 id="继承">继承</h3>
<p>继承实现了 <strong>IS-A</strong> 关系（IS-A是一种继承关系，has-A是一种包含关系，例如一个类中包含另一个类）</p>
<p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象</p>
<h3 id="多态">多态</h3>
<p>多态分为编译时多态和运行时多态：</p>
<ul>
<li>编译时多态主要指方法的重载 模板</li>
<li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li>
</ul>
<p>运行时多态有三个条件：</p>
<ul>
<li><p>继承</p></li>
<li><p>覆盖（重写）</p></li>
<li><p>向上转型</p>
<h2 id="类图">类图</h2></li>
</ul>
<h2 id="设计原则">设计原则</h2>
<h3 id="单一责任原则">单一责任原则</h3>
<p>让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。</p>
<h3 id="开放封闭原则">开放封闭原则</h3>
<p>该原则要求在添加新功能时不需要修改代码。符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。</p>
<h3 id="里氏替换原则">里氏替换原则</h3>
<p>子类对象必须能够替换掉所有父类对象。继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。</p>
<h3 id="接口分离原则">接口分离原则</h3>
<p>不应该强迫客户依赖于它们不用的方法。因此使用多个专门的接口比使用单一的总接口要好。</p>
<h3 id="依赖倒置原则">依赖倒置原则</h3>
<p>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。</p>
<p>相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。<strong>在java中，抽象指的是接口或者抽象类，细节就是具体的实现类</strong>，<strong>使用接口或者抽象类的目的是制定好规范和契约</strong>，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</p>
<p>依赖倒置原则的核心思想是<strong>面向接口编程</strong></p>
<p>依赖于抽象意味着：</p>
<ul>
<li>任何变量都不应该持有一个指向具体类的指针或者引用；</li>
<li>任何类都不应该从具体类派生；</li>
<li>任何方法都不应该覆写它的任何基类中的已经实现的方法</li>
</ul>
<h2 id="其他设计原则">其他设计原则</h2>
<p>除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。</p>
<h3 id="迪米特法则">迪米特法则</h3>
<p>迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话</p>
<h3 id="合成复用原则">合成复用原则</h3>
<p>尽量使用对象组合，而不是通过继承来达到复用的目的。</p>
<h3 id="共同封闭原则">共同封闭原则</h3>
<p>一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里</p>
<h3 id="稳定抽象原则">稳定抽象原则</h3>
<p>最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比</p>
<h3 id="稳定依赖原则">稳定依赖原则</h3>
<p>包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。</p>
<h2 id="section"></h2>
]]></content>
      <categories>
        <category>C++</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>面向对象思想</tag>
      </tags>
  </entry>
  <entry>
    <title>责任模式</title>
    <url>/posts/10008/</url>
    <content><![CDATA[<p>行为模型模式</p>
<span id="more"></span>
<h2 id="责任链">责任链</h2>
<h3 id="概述">概述</h3>
<p>责任链就是 将所有对象按照链条的形式串联，请求按照顺序从这个链条的起始对象开始往后传递，如果遇到一个对象可以处理该消息，那么处理返回，否则就将消息传递给它指向的下一个对象。</p>
<h3 id="结构">结构</h3>
<p>实现上，每个类别存放一个指向下一个对象的指针（类似单向链表）。子类要重写基类的处理函数Handle，子类中判断该消息是否可以处理，如果能就处理然后返回；如果不能，就传递给指向的下一个对象执行，这个操作逻辑可以直接调用基类的Handle执行，在基类中完成向下一个对象传递消息并执行的逻辑。</p>
<h2 id="命令">命令</h2>
<h3 id="概述-1">概述</h3>
<p>？？？</p>
<p>将命令封装成对象中，具有以下作用：</p>
<ul>
<li>使用命令来参数化其它对象</li>
<li>将命令放入队列中进行排队</li>
<li>将命令的操作记录到日志中</li>
<li>支持可撤销的操作</li>
</ul>
<h3 id="结构-1">结构</h3>
<ul>
<li>Command：命令</li>
<li>Receiver：命令接收者，也就是命令真正的执行者</li>
<li>Invoker：通过它来调用命令</li>
<li>Client：可以设置命令与命令的接收者</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210522221426.png" alt="image-20210522221413603" style="zoom:67%;" /></p>
<h2 id="迭代器">迭代器</h2>
<h3 id="概述-2">概述</h3>
<p>提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。这样不同类型的容器就可以使用统一的迭代器进行容器内部元素的按序访问。这个在<code>stl</code>库里很常用</p>
<h3 id="结构-2">结构</h3>
<ul>
<li>Aggregate 是聚合类，其中<code>createIterator()</code> 方法可以产生一个 Iterator；</li>
<li><code>Iterator</code>主要定义了 <code>hasNext()</code>和 <code>next()</code>方法；</li>
<li>Client 组合了 Aggregate，为了迭代遍历 Aggregate，也需要组合 Iterator</li>
</ul>
<p><img src="C:/Users/10729/AppData/Roaming/Typora/typora-user-images/image-20210523165653286.png" alt="image-20210523165653286" style="zoom: 67%;" /></p>
<h2 id="中介者">中介者</h2>
<h3 id="概述-3">概述</h3>
<p>该模式中，建议将对象之间的复杂的沟通和控制方式转换为简单的星形方式。所有组件都通过中介对象向其他组件发送命令。</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210524195212.png" alt="image-20210524195212430" style="zoom: 33%;" /></p>
<h3 id="结构-3">结构</h3>
<p>有点像 qt 中的信号和槽的机制。实现上，首先每个组件 都需要继承包含中介对象指针，每个组件都要有设置中介对象的接口。然后中介对象中有一个 notify() 函数，某个组件想要通知另一个组件干什么事儿，就调用自己类里的 中介对象的 notify() 函数向中介发送消息。然后在 notify函数中根据消息类型来处理事件。初始的时候，将所有组件注册进中介对象，以方便中介对象 notify() 函数中能够操作任意连接的对象。</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210524200417.png" alt="image-20210524200417504" style="zoom: 67%;" /></p>
<h2 id="备忘录">备忘录</h2>
<h3 id="概述-4">概述</h3>
<p>允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。说白了对历史存快照，并 实现撤回。</p>
<h3 id="结构-4">结构</h3>
<ul>
<li>原始对象：需要对原始对象中表示状态的 公有/私有成员变量做 备份</li>
<li>Memento： 备忘录对象，将原始对象中的状态变量封装在这个类中，作为和外界（Caretaker）沟通的状态包。</li>
<li>Caretaker：负责人，将历史状态包保存为数组，用于撤回功能，它无法访问 Memento 中封装的状态对象</li>
</ul>
<p>为何会有单独的这个模式？如果要是实现撤回，必然要对对象的状态做保存，但是对象中的成员变量可能有的是私有的变量，外界（按下保存状态按钮后）无法访问，也就无法获取状态。这个模式就是建议，新增一个备忘录对象作为 原始对象 和 Caretaker负责人沟通的桥梁，原始对象通过 <code>save</code> 接口将自身状态相关变量封装在 备忘录对象中 输出，给负责人存下。负责人将历史的 备忘录对象 给原始对象的 <code>restore</code> 接口用于恢复对象。（getState函数可以设置为友元函数，这样只有红框里的是一起的可以调用）</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210524204959.png" alt="image-20210524204959467" style="zoom: 67%;" /></p>
<h2 id="观察者">观察者</h2>
<h3 id="概述-5">概述</h3>
<p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p>
<h3 id="结构-5">结构</h3>
<ul>
<li>发布者对象：发布者状态更新后，通知与它相连的所有观察者状态发生了变化</li>
<li>观察者对象：有多个观察者对象，对发布者 “侦听”</li>
</ul>
<p>实现起来很简单，每个类型的观察者都要重写 <code>upadate</code>函数，就是在 发布者对象中设置一个链表（或者集合），保存所有的观察者对象的指针，更新的时候就挨个调用观察者对象中的 <code>upadate</code>函数 类似回调函数吧。</p>
<h2 id="状态模式">状态模式</h2>
<h3 id="概述-6">概述</h3>
<p>一般的有限状态机的写法 有许多 判别语句，这个模式可以避免写判断语句。这个模式 将每个状态设置为一个单独的状态对象，通过切换不同的状态独享来切换他们的行为。</p>
<p>状态模式让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样</p>
<h3 id="结构-6">结构</h3>
<p>状态 抽象为一个接口，然后每个状态都对接口（即触发状态转移的条件，图中的 request ）重新实现 ， 不同状态对象，就会调用它重新实现的触发函数，并在其中将状态修改，当前状态使用一个上下文对象保存即可，<strong>状态切换实质就是将 基类状态指针指向不同的 实例对象，不同的实例对象又对状态转移条件接口有不同的实现，这就完成了 根据不同状态，不同的状态转移条件 做状态切换的逻辑</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210524213503.png" alt="image-20210524213503558" style="zoom:33%;" /></p>
<p>本质上的原理是通过多态性质来完成不同状态下的不同方法。考虑下面简单的状态转移，A状态 在 request 条件下 切换成 B 状态，B状态又在request 条件下切换为A状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  一般的 SWITCH CASE  语句写有限状态机</span></span><br><span class="line">string state = <span class="string">&quot;A&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> state&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>: </span><br><span class="line">        <span class="keyword">if</span>(request)	state = <span class="string">&quot;B&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span>(request)	state = <span class="string">&quot;A&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 状态模式中的写法</span></span><br><span class="line"><span class="comment">// 将每个状态 中的状态转移条件抽象为一个结构，然后每个状态都对接口重新实现，就表明了 在当前状态下 request条件发生时应该进行的操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">state</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Context* context;              <span class="comment">// 保存状态上下文  使用该对象切换状态</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>= <span class="number">0</span>;    <span class="comment">// 状态转移的条件 抽线为函数来触发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">public</span> state&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前状态A 触发了条件，转化为状态B&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;context-&gt;<span class="built_in">set_state</span>(<span class="keyword">new</span> B);   <span class="comment">// 当状态为 A 状态时，并且出发了 条件，就切换为B状态，即将上下文中的状态改为B状态 后面再触发该条件，调用的就是 B 状态重写的触发条件函数。</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> state&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;当前状态B 触发了条件，转化为状态A&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;context-&gt;<span class="built_in">set_state</span>(<span class="keyword">new</span> A);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	state* now_state;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set_state</span><span class="params">(state* new_st)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now_state != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">delete</span> now_state;</span><br><span class="line">        now_state = new_st;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        now_state-&gt;<span class="built_in">request</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Context *ct = <span class="built_in">Context</span>();</span><br><span class="line">    ct-&gt;<span class="built_in">set_state</span>(<span class="keyword">new</span> A);  <span class="comment">//设置初始状态</span></span><br><span class="line">    </span><br><span class="line">    ct-&gt;<span class="built_in">request</span>(); <span class="comment">// 状态切换</span></span><br><span class="line">    ct-&gt;<span class="built_in">request</span>(); <span class="comment">// 状态切换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="策略模式">策略模式</h2>
<h3 id="概述-7">概述</h3>
<p>定义一系列算法，封装每个算法，并使它们可以互换。</p>
<h3 id="结构-7">结构</h3>
<ul>
<li>Strategy 接口定义了一个算法族，它们都实现了 behavior() 方法。</li>
<li>Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(Strategy) 方法可以动态地改变 strategy 对象，也就是说能动态地改变 Context 所使用的算法。</li>
</ul>
<h3 id="与状态模式的比较">与状态模式的比较</h3>
<p>状态模式主要是在运行过程中 根据 触发条件来自动的 更改状态，从而改变 Context对象的行为。而策略模式主要是用来封装以组可以相互替代的算法簇并且可以根据需要动态地去替换 Context 使用地算法。<strong>他们实现上类似，都是通过Contex对象中地算法簇指针指向不同地对象，来实现它调用的算法的动态改变，但是切换的时机不一样。</strong></p>
<h2 id="模板方法">模板方法</h2>
<h3 id="概述-8">概述</h3>
<p>定义算法框架，并将一些步骤的实现延迟到子类。通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。 例如：对于一个目标跟踪任务，处理流程是 读图像-&gt; 图像预处理 -&gt; 钩子函数-&gt; 跟踪 -&gt; 输出；此时如果我要换中间的 图像预处理的算法，那么我在子类实现的时候重写 图像预处理函数即可。这样可以使得算法结构不变，且可以方便地复用子过程。</p>
<h3 id="结构-8">结构</h3>
<p>就是将算法流程抽象为几个分开步骤，写成虚函数</p>
<h2 id="访问者模式">访问者模式</h2>
<h3 id="概述-9">概述</h3>
<p>为一个对象结构（比如组合结构）增加新的功能。一个对象中包含了很多类型的子对象，例如 公司结构中每个员工是一个节点。访问者模式提供了访问对象结构中每个节点的方法。</p>
<h3 id="结构-9">结构</h3>
<p>将访问者 用一个单独的类 Visitor 实现，为每个 对象结构中的每个节点提供 的访问实现一个 visit (ElementA* elm) 接口。在每个节点结构中实现一个 accept (Visitor* ) 函数，并在函数中 调用 Visitor 的 visit 函数，以自身作为参数传入给 Visitor 访问。这样就实现了 Visitor 访问节点的功能。</p>
<p>为何要这样？<a href="https://www.jianshu.com/p/1f1049d0a0f4">参考链接</a></p>
<p>首先这里使用了 函数重载的功能，如果节点对象的类型有很多种，例如 3个节点对象A 3个节点对象B。那么在对每个节点对象进行遍历的时候势必要写一个判断语句，if( it is ElementA ) … else if( it is ElementB) … 当种类多的时候就很麻烦。而我们在 Visitor中的 visit 函数重载了不同类型节点的访问函数，就避免了写判断语句。</p>
<p><img src="C:/Users/10729/AppData/Roaming/Typora/typora-user-images/image-20210525205621893.png" alt="image-20210525205621893" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>面经-设计模式</title>
    <url>/posts/33486/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="请问你了解哪些设计模式">请问你了解哪些设计模式？</h3>
<p>常见的设计模式如下：</p>
<p>单例模式：确保单例类全局只有一个实例，并提供该实例的全局访问点。单例模式的实现核心是将 类 的构造函数设置为私有，并预留一个获取全局唯一对象的静态函数，用于外界获得该实例。根据实例化的时间可以分为懒汉模式和饿汉模式，区别就在于是使用的时候实例化还是在系统启动的时候就初始化。</p>
<p>工厂模式：是一个创建对象的接口，但是由子类决定实例化哪个类。工厂方法把实例化操作延迟到子类。</p>
<p>生成器模式：是一个创建型设计模式，如果一个类包含大量的部件，可以通过一个额外的生成器来分步骤创建复杂的对象，然后将创建的对象返回。</p>
<p>模板模式：定义算法框架，并将一些步骤延迟到子类实现，例如 常见的目标检测，包含了图像读取，预处理，检测，可视化，这几个子过程。如果更改其中的预处理的方法，那么只用在子类中重写预处理函数即可，其他过程都可以复用。weak_ptr</p>
<p>观察者模式：原理类似于所有观察者都实现一个 updata 接口，然后将所有的观察者注册进被观察者中，当被观察者状态变化时循环通过 update 接口通知所有观察者。</p>
<p>装饰模式：是静态继承的一种替代，通过装饰模式可以动态的给原有的对象增加新的功能。装饰类和被装饰类之间不存在耦合不相互影响。这种模式对被装饰类进行包装，在装饰类中持有被装饰类的对象，实现在保持原有功能前提下实现新的功能。除了最底层的原始对象不需要依赖以外，其他装饰对象都要携带一个指针指向它装饰的对象，装饰的过程像一个链表层层叠加。</p>
<h3 id="请你说一说oop的设计模式的五项原则">请你说一说OOP的设计模式的五项原则</h3>
<p><strong>单一职责原则</strong>：每个类只负责单一的责任，如果一个任务很复杂，应该将他分散的多个类种实现，减少类的耦合，提高类的复用性。 <strong>依赖倒置原则</strong>：核心是面向接口编程的思想。高层模块不能依赖于底层模块，他们应该共同依赖于抽象（接口），因为抽象更稳定。在高层模块和底层模块之间抽象出一个稳定的接口层，降低他们之间的耦合。 <strong>里氏替换原则</strong>：这个原则是说 子类对象要能够完全替换父类，即可以使用父类的地方也要能使用子类替换。并在客户端中使用父类指针或引用类型来引用子类，以实现动态绑定。 <strong>接口隔离原则</strong>：不应该强迫客户依赖于它们不用的方法。因此使用多个专门的接口比使用单一的总接口要好。 <strong>开放-封闭原则</strong>：在新增功能时，不需要修改原有的代码 <strong>最少知识原则</strong>：</p>
<h3 id="请问如何保证单例模式只有唯一实例你知道的都有哪些方法">请问如何保证单例模式只有唯一实例？你知道的都有哪些方法？</h3>
<p>构造函数设置为私有属性，只有通过该类提供的静态方法来得到该类的唯一实例。在静态方法中判断 指向实例的静态成员指针为空，就实例化类，否则直接返回。（必须是静态成员指针，因为静态成员函数无法访问非静态成员变量）</p>
<p>单例模式有懒汉模式，可能会线程不安全，如果多个线程同时通过了指针空判断，就会创建出多个实例，通过双重锁来实现线程安全。（判空，上锁，再判空，为啥要用双重锁？如果已经实例化了，通过第一个判空操作能避免读的时候加锁等待，提高性能。第二个锁就是为了防止创建对象的时候多线程竞争） 另一个是饿汉模式，在程序运行时就完成了对象初始化，因此不存在不安全问题。</p>
<h3 id="请你说说工厂模式的优点">请你说说工厂模式的优点？</h3>
<p>为了解耦，将对象的使用过程和创建过程分离。如果对象创建过程包含了复杂的创建逻辑，可以统一放在工厂类中实现，实现代码复用。充分利用了面向对象的多态性质，工厂对象返回的是指向具体子类的基类指针，如果后续修改了子类的业务逻辑，也只用修改工厂中的初始化逻辑，方便维护。</p>
<h3 id="请你说一下观察者模式">请你说一下观察者模式</h3>
<p>观察者模式中分为观察者和被观察者，当被观察者发生装填改变时，观察者会受到通知。主要为了解决对象状态改变给其他对象通知的问题，其实现类似于观察者在被观察者那注册了一个回调函数。</p>
<h3 id="说一说装饰模式">说一说装饰模式</h3>
<p>是静态继承的一种替代，通过装饰模式可以动态的给原有的对象增加新的功能。装饰类和被装饰类之间不存在耦合不相互影响。这种模式对被装饰类进行包装，在装饰类中持有被装饰类的对象，实现在保持原有功能前提下实现新的功能。除了最底层的原始对象不需要依赖以外，其他装饰对象都要携带一个指针指向它装饰的对象，装饰的过程像一个链表层层叠加。</p>
<p>使用场景：1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p>
<h3 id="手撕单例模式">手撕单例模式</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span>&#123;</span></span><br><span class="line">	<span class="keyword">private</span>: </span><br><span class="line">    	<span class="keyword">static</span> Single* ptr;</span><br><span class="line">    	std::mutex mtx_;</span><br><span class="line">    	<span class="built_in">Single</span>()&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">static</span> <span class="title">getSingeTon</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(ptr == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                mtx_.<span class="built_in">lock</span>();</span><br><span class="line">                <span class="keyword">if</span>(ptr == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                	ptr = <span class="keyword">new</span> <span class="built_in">Single</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                mtx_.<span class="built_in">unlock</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Single* Single::ptr = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>C++Lambda表达式</title>
    <url>/posts/476/</url>
    <content><![CDATA[<p>C11Lambda表达式</p>
<span id="more"></span>
<h1 id="c-11-lambda表达式">C++ 11 Lambda表达式</h1>
<p>C++11的一大亮点就是引入了Lambda表达式。利用Lambda表达式，可以方便的定义和创建匿名函数。</p>
<h2 id="基本形式">基本形式</h2>
<p>Lambda表达式完整的声明格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[capture list] (params list) mutable exception-&gt; return type &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<p>各项具体含义如下</p>
<ol type="1">
<li>capture list：捕获外部变量列表</li>
<li>params list：形参列表</li>
<li>mutable指示符：用来说用是否可以修改捕获的变量</li>
<li>exception：异常设定</li>
<li>return type：返回类型</li>
<li>function body：函数体</li>
</ol>
<p>此外，我们还可以省略其中的某些成分来声明“不完整”的Lambda表达式，常见的有以下几种：</p>
<table>
<thead>
<tr class="header">
<th>序号</th>
<th>格式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>[capture list] (params list) -&gt; return type {function body}</td>
</tr>
<tr class="even">
<td>2</td>
<td>[capture list] (params list) {function body}</td>
</tr>
<tr class="odd">
<td>3</td>
<td>[capture list] {function body}</td>
</tr>
</tbody>
</table>
<p>其中：</p>
<ul>
<li>格式1声明了const类型的表达式，这种类型的表达式不能修改捕获列表中的值。</li>
<li><strong>格式2省略了返回值类型，但编译器可以根据以下规则推断出Lambda表达式的返回类型：</strong> （1）：如果function body中存在return语句，则该Lambda表达式的返回类型由return语句的返回类型确定； （2）：如果function body中没有return语句，则返回值为void类型。</li>
<li>格式3中省略了参数列表，类似普通函数中的无参函数。</li>
</ul>
<h2 id="基本例子">基本例子</h2>
<p>在C++11之前，我们使用STL的sort函数，需要提供一个谓词函数。如果使用C++11的Lambda表达式，我们只需要传入一个匿名函数即可，方便简洁，而且代码的可读性也比旧式的做法好多了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; myvec&#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">lbvec</span><span class="params">(myvec)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">end</span>(), cmp); <span class="comment">// 旧式做法</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;predicate function:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> it : myvec)</span><br><span class="line">        cout &lt;&lt; it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(lbvec.<span class="built_in">begin</span>(), lbvec.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">bool</span> &#123; <span class="keyword">return</span> a &lt; b; &#125;);   <span class="comment">// Lambda表达式</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda expression:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> it : lbvec)</span><br><span class="line">        cout &lt;&lt; it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="捕获外部变量">捕获外部变量</h2>
<p>Lambda表达式通过在最前面的方括号[]来明确指明其内部可以访问的外部变量。可以使用其可见范围内的外部变量，但必须明确声明（明确声明哪些外部变量可以被该Lambda表达式使用），圆括号里的属于输出参数，是调用的时候输入函数的参数列表。</p>
<h3 id="对比">对比</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：123</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//或通过“函数体”后面的‘()’传入参数</span></span><br><span class="line">    <span class="keyword">auto</span> x = [](<span class="keyword">int</span> a)&#123;cout &lt;&lt; a &lt;&lt; endl;&#125;(<span class="number">123</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个例子对比了 使用捕获变量 和 参数传递的方式 两种用法。第一个捕获了外部的变量a，可以在匿名函数中直接使用，第二个，则是在调用函数x的时候，通过()传递的123给匿名函数的入口参数，和前面申明的a没有任何关系。</p>
<h3 id="值捕获">值捕获</h3>
<p>顾名思义，就是直接捕获外部变量的值，在申明匿名函数的时候捕获到值后，如果该变量值被修改，然后再调用匿名函数，那么匿名函数使用的值还是原先的值，这就是值捕获的特定，只是在捕获的那一刻对值进行了拷贝，类似于函数值传递的特点一样。如下例子。<strong>值捕获的变量，在函数内部不能修改该外部变量的值，会出发编译错误</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用捕获">引用捕获</h3>
<p>使用引用捕获一个外部变量，只需要在捕获列表变量前面加上一个引用说明符。同理，引用捕获的变量使用的实际上就是该引用所绑定的对象，因此随后对被捕获变量的修改会影响影响Lambda表达式中的值。（可以修改外部变量）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：321</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="隐式捕获">隐式捕获</h3>
<p>上面的值捕获和引用捕获都需要我们在捕获列表中显示列出Lambda表达式中使用的外部变量。除此之外，我们还可以让编译器根据函数体中的代码来推断需要捕获哪些变量，这种方式称之为隐式捕获。隐式捕获有两种方式，分别是[=]和[&amp;]。[=]表示以值捕获的方式捕获外部变量，[&amp;]表示以引用捕获的方式捕获外部变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [=] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    <span class="comment">// 值捕获</span></span><br><span class="line">    a = <span class="number">342</span>;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：123</span></span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    <span class="comment">// 引用捕获</span></span><br><span class="line">    a = <span class="number">321</span></span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：321</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="混合方式">混合方式</h3>
<table>
<thead>
<tr class="header">
<th>捕获形式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[]</td>
<td>不捕获任何外部变量</td>
</tr>
<tr class="even">
<td>[变量名, …]</td>
<td>默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp;说明符）</td>
</tr>
<tr class="odd">
<td>[this]</td>
<td>以值的形式捕获this指针</td>
</tr>
<tr class="even">
<td>[=]</td>
<td>以值的形式捕获所有外部变量</td>
</tr>
<tr class="odd">
<td>[&amp;]</td>
<td>以引用形式捕获所有外部变量</td>
</tr>
<tr class="even">
<td>[=, &amp;x]</td>
<td>变量x以引用形式捕获，其余变量以传值形式捕获</td>
</tr>
<tr class="odd">
<td>[&amp;, x]</td>
<td>变量x以值的形式捕获，其余变量以引用形式捕获</td>
</tr>
</tbody>
</table>
<h2 id="修改捕获变量的值">修改捕获变量的值</h2>
<p>又想用值捕获，又想用值捕获的方式，就需要使用mutable关键字，该关键字用以说明表达式体内的代码可以修改值捕获的变量。(引用捕获就可以修改外部变量的值，mutable方式可能是针对指针变量使用的吧)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [a]()<span class="keyword">mutable</span> &#123; cout &lt;&lt; ++a; &#125;; <span class="comment">// 不会报错</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 输出：123</span></span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：124</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lambda表达式的参数">Lambda表达式的参数</h2>
<p>Lambda表达式的参数和普通函数的参数类似，单是在Lambda表达式中传递参数还有一些限制，主要有以下几点：</p>
<ol type="1">
<li>参数列表中不能有默认参数</li>
<li>不支持可变参数</li>
<li>所有参数必须有参数名</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++可变参数模板</title>
    <url>/posts/46846/</url>
    <content><![CDATA[<p>C11可变参数模板</p>
<span id="more"></span>
<h1 id="c11可变参数模板">C++11可变参数模板</h1>
<p>C++11的新特性--可变模版参数（variadic templates）是C++11新增的最强大的特性之一，它对参数进行了高度泛化，它能表示0到任意个数、任意类型的参数 https://www.cnblogs.com/qicosmos/p/4325949.html</p>
<h2 id="定义">定义</h2>
<p>可变参数模板和普通模板的语义是一样的，只是写法上稍有区别，声明可变参数模板时需要在typename或class后面带上省略号“...”。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T... args)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面的可变模版参数的定义当中，省略号的作用有两个：</p>
<ol type="1">
<li>声明一个<strong>模板参数包</strong>T... args，这个参数包中可以包含 0 到任意个模板参数；</li>
<li>在模板定义的右边，可以将<strong>参数包 即 args</strong>展开成一个一个独立的参数。</li>
</ol>
<p>上面的参数args前面有省略号，所以它就是一个可变模版参数，我们把带省略号的参数称为“参数包”，它里面包含了0到N（N&gt;=0）个模版参数。我们无法直接获取参数包args中的每个参数的，只能通过展开参数包的方式来获取参数包中的每个参数，这是使用可变模版参数的一个主要特点。</p>
<p>可变模版参数和普通的模版参数语义是一致的，所以可以应用于函数和类，即可变模版参数函数和可变模版参数类</p>
<h2 id="可变参数函数模版">可变参数函数模版</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl; <span class="comment">//打印变参的个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>();        <span class="comment">//0</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>, <span class="number">2</span>);    <span class="comment">//2</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>, <span class="number">2.5</span>, <span class="string">&quot;&quot;</span>);    <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<h3 id="递归函数方式展开参数包">递归函数方式展开参数包</h3>
<p>通过递归函数展开参数包，需要提供一个<strong>参数包展开的函数</strong>和一个<strong>递归终止函数</strong>，递归终止函数正是用来终止递归的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//递归终止函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//展开函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> ...<span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T head, Args... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;parameter &quot;</span> &lt;&lt; head &lt;&lt; endl;</span><br><span class="line">   <span class="built_in">print</span>(rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例会输出每一个参数，直到为空时输出empty。展开参数包的函数有两个，一个是递归函数，另外一个是递归终止函数，参数包Args...在展开的过程中递归调用自己，每调用一次参数包中的参数就会少一个，直到所有的参数都展开为止，当没有参数时，则调用非模板函数print终止递归过程。</p>
<p>递归调用的过程是这样的:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//print(1,2,3,4);</span></span><br><span class="line"><span class="comment">//print(2,3,4);</span></span><br><span class="line"><span class="comment">//print(3,4);</span></span><br><span class="line"><span class="comment">//print(4);</span></span><br><span class="line"><span class="comment">//print();</span></span><br></pre></td></tr></table></figure>
<p>上面的递归终止函数还可以写成这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//print(1,2,3,4);</span></span><br><span class="line"><span class="comment">//print(2,3,4);</span></span><br><span class="line"><span class="comment">//print(3,4);</span></span><br><span class="line"><span class="comment">//print(4);</span></span><br></pre></td></tr></table></figure>
<h3 id="逗号表达式展开参数包">逗号表达式展开参数包</h3>
<h2 id="可变模版参数类">可变模版参数类</h2>
]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>const和constexptr</title>
    <url>/posts/55521/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="const-和-constexpr">const 和 constexpr</h1>
<h2 id="const">const</h2>
<p><a href="https://zhuanlan.zhihu.com/p/90720012">参考链接</a></p>
<h3 id="const-修饰变量">const 修饰变量</h3>
<p>无论const修饰全局还是函数的局部变量，那么该变量都不能被程序员显式的修改，否则编译器会报错。但是变量本质都是地址，因此可以对他取地址给指针，然后通过指针再去修改该值。这样操作编译器不会报错。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span>* p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;N);</span><br><span class="line">*p = <span class="number">102</span>;   <span class="comment">// 这样就将N的值修改了</span></span><br></pre></td></tr></table></figure>
<ul>
<li>全局 const 变量：存储在只读存储区，使用上面的方法可以修改 会导致运行错误</li>
<li>函数局部的 const 变量：存在栈里，使用上面的方法修改它的值，且不会产生运行错误</li>
</ul>
<p>c++ 对 const 会对默认类型的变量（非自定义的结构体成员变量，常规的int float 等会优化）在编译时期会优化，上面的例子中 会将所有地方的 N 像宏定义一样直接替换为 1000；例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; N &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *p;</span><br><span class="line"><span class="comment">// N: 输出1000  *P输出102  </span></span><br></pre></td></tr></table></figure>
<p><strong>因此 推荐将变量定义为 const 类型 这样编译器会直接替换为值，后面就减少一次内存访问请求</strong> 相对宏定义的优势就是 有类型检查</p>
<h3 id="const-类对象">const 类对象</h3>
<p>定义 const 类对象 或者 结构体变量一样，代表他们的成员都不能被修改。并且，const 类对象只能调用它的 const 成员函数，而不能调用普通的非const成员函数。</p>
<figure>
<img src="https://pic3.zhimg.com/80/v2-f86a180355890874db6c2d3873bdda5a_720w.jpg" alt="" /><figcaption>img</figcaption>
</figure>
<h3 id="const指针">const指针</h3>
<ul>
<li>一种指 指向的地址的内容不可以修改 但是它可以转而指向别的地址 (结合最开始的例子可以看出 <strong>编译器是通过 “指针的类型” 来判断是否只读的，因此如果普通指针指向const的变量地址，它的值仍然可以修改</strong>) <code>const int *p</code></li>
<li>指向的地址可以修改，但是它不能再指向别人 <code>int * const p = &amp;a</code> ( 就看const 后面跟的是啥 啥就不能变)</li>
</ul>
<h3 id="const-成员函数">const 成员函数</h3>
<p>代表该成员函数 不能修改类中的成员变量，同时也正是这个特性，const 类的对象只能调用 ocnst 修饰的成员函数</p>
<h2 id="constexpr">constexpr</h2>
<p><a href="https://zhuanlan.zhihu.com/p/256416683">参考链接</a></p>
<p>constexpr是C++11中新增的关键字，其语义是“常量表达式”，也就是在编译期可求值的表达式。最基础的常量表达式就是字面值或全局变量/函数的地址或sizeof等关键字返回的结果，而其它常量表达式都是由基础表达式通过各种确定的运算得到的。constexpr值可用于enum、switch、数组长度等场合。</p>
<h3 id="编译时常量常量表达式">编译时常量/常量表达式</h3>
<ul>
<li>必须是可以在编译阶段被识别的。比如模版的参数／数组的大小</li>
<li>例如 const int a = 5; 此时 5 就是一个常量表达式 sizeof() 就是个常量表达式 在编译时期就能确定 可以能用来初始化数组大小 case语句的分支等</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fixed_size_list</span></span></span><br><span class="line"><span class="class">&#123;</span> <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"></span><br><span class="line">fixed_size_list&lt;X&gt; mylist;     <span class="comment">// &lt;-- X必须是字面值类型</span></span><br><span class="line"><span class="keyword">int</span> numbers[X];   <span class="comment">// &lt;-- X必须是字面值类型</span></span><br></pre></td></tr></table></figure>
<h3 id="特性">特性</h3>
<p>constexpr 在修饰函数的时候</p>
<ul>
<li>如果函数的入口参数 是使用的字符常量，在编译时期可以确定 那么这个函数就是常量表达式 返回值可以直接用来初始化数组大小</li>
<li>如果入口参数的值编译时期无法直接确定 那么他就是个普通函数</li>
</ul>
<p>constexpr的好处：</p>
<ol type="1">
<li>是一种很强的约束，更好地保证程序的正确语义不被破坏。</li>
<li>编译器可以在编译期对constexpr的代码进行非常大的优化，<strong>比如将用到的constexpr表达式都直接替换成最终结果等。</strong></li>
<li>相比宏来说，没有额外的开销，但更安全可靠</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
  </entry>
  <entry>
    <title>C++inline关键字</title>
    <url>/posts/46417/</url>
    <content><![CDATA[<p>inline 关键字</p>
<span id="more"></span>
<p><a href="https://zhuanlan.zhihu.com/p/151995167">参考链接</a></p>
<p>当程序执行函数调用指令时，CPU将存储该函数调用后指令的内存地址，将函数的参数复制到堆栈上，最后将控制权转移到指定的函数。然后，CPU执行函数代码，将函数返回值存储在预定义的内存位置/寄存器中，并将控制权返回给调用函数。如果函数的执行时间少于从调用者函数到被调用函数（被调用者）的切换时间，则这可能会成为开销。对于大型函数和/或执行复杂任务的函数，与函数运行所花费的时间相比，函数调用的开销通常微不足道。但是，对于小型的常用功能，进行函数调用所需的时间通常比实际执行函数代码所需的时间多得多。对于小功能，由于小功能的执行时间少于切换时间，因此会产生开销。</p>
<p><strong>C++提供了inline函数，以减少函数调用的开销。内联函数是在调用时在行中扩展的函数。调用内联函数时，将在内联函数调用时插入或替换内联函数的整个代码。替换由C++编译器在编译时执行。如果内联函数很小，则可以提高效率。</strong></p>
<p>inline函数看起来像函数，动作像函数，但是又比宏方便很多，调用inline函数省去了参数压栈、生成汇编语言的 CALL调用、返回参数、执行return等过程所花费的额外开销。不过inline函数也有缺点：增加目标码的大小。因为inline函数的设计思想是对该函数的所有调用都用函数本身替换掉，和宏定义一样，但是比宏定义用起来要简单很多。而且inline的调试同样很难。所以，inline函数对于函数体积很小，却又频繁调用这样的函数来说，可能比函数调用产生的代码更少，但是效率却不可同日而语。有一点需要注意的是：<strong>inline只是对编译器提出一个申请，并不是强制命令。编译器可以忽略内联请求。</strong> 在以下情况下，编译器可能不会执行内联：</p>
<ul>
<li>如果函数包含循环。（对于while，do-while）</li>
<li>如果函数包含静态变量。</li>
<li>如果函数是递归的。</li>
<li>如果函数的返回类型不是void，并且函数主体中不存在return语句。</li>
<li>如果函数包含switch或goto语句。</li>
</ul>
<h2 id="使用">使用</h2>
<p>inline可以显示声明，也可以隐式声明。<strong>隐式声明方式是将函数定义在类定义之中</strong>（函数定义时没有inline关键字），编译器也会当作inline函数。另外，定义在类中的friend函数也会被隐式声明为inline函数。</p>
<p>显式声明的时候必须<strong>与函数定义体放在一起才能使函数成为内联</strong>，仅将inline放在函数声明前面不起任何作用。定义函数内联的语法为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">return</span>-type function-<span class="built_in">name</span>(parameters)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// function code</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此外，inline函数通常放在头文件中，因为大多数 build environments 在<strong>编译期进行inlining</strong>，编译器必须知道函数什么样子才能把<em>函数调用</em>替换成<em>函数本体</em>。大多数virtual函数不能inlining：因为virtual直到<em>运行时</em>才知道调用哪个函数，而inline是在执行前进行替换。此外，对于<em>通过函数指针进行的调用</em>编译器通常不会inlining</p>
<h2 id="优缺点">优缺点</h2>
<p>优点</p>
<ol type="1">
<li>不会发生函数调用开销。</li>
<li>调用函数时，还节省了push / pop变量在栈上的开销。</li>
<li>它还节省了从函数返回调用的开销。</li>
<li>内联函数时，可以使编译器对函数主体执行特定于上下文的优化。对于正常的函数调用，这种优化是不可能的。通过考虑调用上下文和被调用上下文的流程可以获得其他优化。</li>
<li>内联函数可能对于嵌入式系统有用（如果很小），因为内联函数所产生的代码少于函数调用的前导和返回。</li>
</ol>
<p>缺点：</p>
<ol type="1">
<li>内联函数中添加的变量消耗了额外的寄存器，在内联函数之后，如果要使用寄存器的变量编号增加，则它们可能会增加寄存器变量资源利用的开销。这意味着当在函数调用点替换内联函数主体时，该函数使用的变量总数也会被插入。因此，将用于变量的寄存器数量也将增加。因此，如果函数内联后的变量数急剧增加，则肯定会导致寄存器利用率增加。</li>
<li>如果使用太多的内联函数，则由于重复执行相同的代码，二进制可执行文件的大小将很大。</li>
<li>过多的内联也会降低指令Cache命中率，从而降低了从高速缓存到主存储器的指令获取速度。</li>
<li>如果有人更改了内联函数中的代码，则内联函数可能会增加编译时间开销，然后必须重新编译所有调用位置，这是因为编译器将需要再次替换所有代码以反映更改，否则它将继续使用旧功能。</li>
<li>内联函数对于许多嵌入式系统可能没有用。因为在嵌入式系统中，代码大小比速度更重要。</li>
<li>内联函数可能会导致崩溃，因为内联可能会增加二进制可执行文件的大小。内存溢出会导致计算机性能下降。</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++static关键字</title>
    <url>/posts/28181/</url>
    <content><![CDATA[<p>C++static关键字</p>
<span id="more"></span>
<h1 id="static关键字">static关键字</h1>
<ul>
<li>面向对象 （变量、函数）
<ul>
<li>静态成员变量</li>
<li>静态成员函数</li>
</ul></li>
<li>面向过程
<ul>
<li>静态全局变量</li>
<li>静态局部变量</li>
<li>静态函数</li>
</ul></li>
</ul>
<h2 id="静态成员变量">静态成员变量</h2>
<p>在类内成员变量的声明前加上关键字static，该数据成员就是类内的静态数据成员。</p>
<h3 id="静态成员变量特点">静态成员变量特点：</h3>
<ol type="1">
<li><strong>静态成员变量是该类的所有对象所共有的</strong>。对于普通成员变量，每个类对象都有自己的一份拷贝。而静态成员变量一共就一份，无论这个类的对象被定义了多少个，静态成员变量只分配一次内存，由该类的所有对象共享访问。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；</li>
<li>因为<strong>静态数据成员在全局数据区分配内存</strong>，由本类的所有对象共享，所以，它不属于特定的类对象，<strong>不占用对象的内存</strong>，而是在所有对象之外开辟内存，在没有产生类对象时其作用域就可见。因此，<strong>在没有类的实例存在时，静态成员变量就已经存在，我们就可以操作它；</strong></li>
<li>因为静态成员变量 不随 一个类的实例化 而重新开辟内存。所以 <strong>静态成员变量，必须在类外定义</strong>，如例子中的 <code>int Myclass::Sum;</code> 在这儿定义了之后，<strong>才会被分配内存</strong>，因此不定义的话就会报错。但是可以不初始化，<strong>静态成员变量存储在全局数据区</strong>，编译器就默认0.</li>
<li>static 成员变量和普通 static 变量一样，<strong>编译时在静态数据区分配内存，到程序结束时才释放</strong>，不随对象的销毁而释放内存。</li>
<li>静态成员变量定义 初始化 可以不加 static 关键字 如例子。<code>＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞</code></li>
<li>静态成员变量可以不通过 类对象 访问</li>
<li><strong><code>sizeof</code> 运算符不会计算 静态成员变量</strong></li>
<li>静态数据成员和普通数据成员一样遵从public,protected,private访问规则；</li>
</ol>
<p>### 应用场景</p>
<p>如果想在同类的多个对象之间实现数据共享，又不要用全局变量，那么就可以使用静态成员变量。静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处：</p>
<ol type="1">
<li>不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，节省存储空间。</li>
<li>一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了。</li>
</ol>
<h3 id="相对全局变量的优点">相对全局变量的优点</h3>
<ol type="1">
<li>静态成员变量没有进入程序的全局命名空间，因此不存在与程序中其它全局命名冲突的可能。</li>
<li>可以实现信息隐藏。静态成员变量可以是private成员，而全局变量不能。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyclass</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s;</span><br><span class="line">&#125;;    <span class="comment">//则sizeof（CMyclass）等于4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Myclass</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a=a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b=b;</span><br><span class="line">        <span class="keyword">this</span>-&gt;c=c;</span><br><span class="line">        Sum+=a+b+c;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetSum</span><span class="params">()</span></span>&#123;    </span><br><span class="line">	    cout&lt;&lt;<span class="string">&quot;Sum=&quot;</span>&lt;&lt;Sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a,b,c;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> Sum;<span class="comment">//声明静态数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Myclass::Sum=<span class="number">10</span>;    <span class="comment">//定义并初始化静态数据成员  不初始化的话 编译链接通不过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Myclass <span class="title">M</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">	M.<span class="built_in">GetSum</span>();</span><br><span class="line">	<span class="function">Myclass <span class="title">N</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line">	N.<span class="built_in">GetSum</span>();</span><br><span class="line">	M.<span class="built_in">GetSum</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">Sum=16</span></span><br><span class="line"><span class="comment">Sum=31</span></span><br><span class="line"><span class="comment">Sum=31</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="静态成员函数">静态成员函数</h2>
<p>与静态成员变量类似，我们也可以声明一个静态成员函数。</p>
<h3 id="特点">特点</h3>
<ol type="1">
<li>出现在类体外的函数定义不能指定关键字static； (就是static关键字只能出现在类里)</li>
<li><strong>静态成员之间可以相互访问，即静态成员函数（仅）可以访问静态成员变量、静态成员函数；</strong></li>
<li><strong>静态成员函数不能访问非静态成员函数和非静态成员变量；</strong></li>
<li>非静态成员函数可以任意地访问静态成员函数和静态数据成员；</li>
<li><strong>由于没有this指针的额外开销，静态成员函数与类的全局函数相比速度上会稍快；</strong> （也正是因为没有this指针，静态成员函数不能访是虚函数，也不能访问非静态成员）</li>
<li>调用静态成员函数，两种方式 通过对象 和 不通过对象 调用</li>
</ol>
<h3 id="拷贝构造函数的问题">拷贝构造函数的问题</h3>
<p>例如下面的例子中，调用拷贝构造函数生成临时隐藏类对象时，这个临时对象在消亡时会调用析构函数 会 执行 totle_num–。简言之，就是在使用 拷贝构造时 对静态成员变量的操作要注意时 成对的 否则会出bug</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Example 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">char</span> *name;</span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">float</span> score;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> num;  	<span class="comment">//学生人数</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">float</span> total;  <span class="comment">//总分</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Student</span>(<span class="keyword">char</span> *, <span class="keyword">int</span>, <span class="keyword">float</span>);</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getAverage</span><span class="params">()</span></span>;  <span class="comment">//静态成员函数，用来获得平均成绩</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Student::num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> Student::total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">   <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">   <span class="keyword">this</span>-&gt;score = score;</span><br><span class="line">   num++;</span><br><span class="line">   total += score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::say</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout&lt;&lt;name&lt;&lt;<span class="string">&quot;的年龄是 &quot;</span>&lt;&lt;age&lt;&lt;<span class="string">&quot;，成绩是 &quot;</span>&lt;&lt;score&lt;&lt;<span class="string">&quot;（当前共&quot;</span>&lt;&lt;num&lt;&lt;<span class="string">&quot;名学生）&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Student::getAverage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> total / num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   (<span class="keyword">new</span> <span class="built_in">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">15</span>, <span class="number">90</span>))-&gt;<span class="built_in">say</span>();</span><br><span class="line">   (<span class="keyword">new</span> <span class="built_in">Student</span>(<span class="string">&quot;李磊&quot;</span>, <span class="number">16</span>, <span class="number">80</span>))-&gt;<span class="built_in">say</span>();</span><br><span class="line">   (<span class="keyword">new</span> <span class="built_in">Student</span>(<span class="string">&quot;张华&quot;</span>, <span class="number">16</span>, <span class="number">99</span>))-&gt;<span class="built_in">say</span>();</span><br><span class="line">   (<span class="keyword">new</span> <span class="built_in">Student</span>(<span class="string">&quot;王康&quot;</span>, <span class="number">14</span>, <span class="number">60</span>))-&gt;<span class="built_in">say</span>();</span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;平均成绩为 &quot;</span>&lt;&lt;Student::<span class="built_in">getAverage</span>()&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">小明的年龄是 <span class="number">15</span>，成绩是 <span class="number">90</span>（当前共<span class="number">1</span>名学生）</span><br><span class="line">李磊的年龄是 <span class="number">16</span>，成绩是 <span class="number">80</span>（当前共<span class="number">2</span>名学生）</span><br><span class="line">张华的年龄是 <span class="number">16</span>，成绩是 <span class="number">99</span>（当前共<span class="number">3</span>名学生）</span><br><span class="line">王康的年龄是 <span class="number">14</span>，成绩是 <span class="number">60</span>（当前共<span class="number">4</span>名学生）</span><br><span class="line">平均成绩为 <span class="number">82.25</span></span><br></pre></td></tr></table></figure>
<h2 id="静态全局变量">静态全局变量</h2>
<h3 id="特点-1">特点</h3>
<ol type="1">
<li>该<strong>变量在全局数据区分配内存；</strong></li>
<li>未经初始化的静态全局变量会被程序自动初始化为0（自动变量的自动初始化值是随机的）；</li>
<li><strong>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；</strong> 　</li>
</ol>
<p>对于一个完整的程序，在内存中的分布情况如下：</p>
<blockquote>
<p>【代码区】【全局数据区】【堆区】【栈区】</p>
<p>堆区：一般程序的由new产生的动态数据存放在 栈区：函数内部的自动变量存放在栈区，自动变量一般会随着函数的退出而释放空间 全局数据区：静态数据（即使是函数内部的静态局部变量）存放在全局数据区。而全局数据区的数据并不会因为函数的退出而释放空间。</p>
</blockquote>
<h3 id="优点">优点</h3>
<ol type="1">
<li>静态全局变量不能被其它文件所用；（即使在其它文件中使用extern 进行声明也不行）</li>
<li>其它文件中可以定义相同名字的变量，不会发生冲突；</li>
</ol>
<h2 id="静态局部变量">静态局部变量</h2>
<p>在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。</p>
<p>通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，这给程序的维护带来不便。静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。</p>
<h3 id="特点-2">特点</h3>
<ol type="1">
<li>静态局<strong>部变量在全局数据区分配内存；</strong></li>
<li>静态局部<strong>变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化</strong>；</li>
<li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；</li>
<li>静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；</li>
<li></li>
</ol>
<h2 id="静态函数">静态函数</h2>
<p>在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。</p>
<ol type="1">
<li>静态函数不能被其它文件所用；</li>
<li>其它文件中可以定义相同名字的函数，不会发生冲突；</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ volatile关键字</title>
    <url>/posts/15030/</url>
    <content><![CDATA[<p>C++volatile关键字</p>
<span id="more"></span>
<p>参考链接：https://zhuanlan.zhihu.com/p/62060524</p>
<h2 id="volatile-的作用">volatile 的作用</h2>
<p>volatile 关键字是一种类型修饰符，<strong>用它声明的类型变量表示可以被某些编译器未知的因素更改</strong>。比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，<strong>编译器对访问该变量的代码就不再进行优化，系统总是重新从它所在的内存读取数据</strong>，从而可以提供对特殊地址的稳定访问。</p>
<h3 id="为什么可以提供特殊地址的稳定访问">为什么可以提供特殊地址的稳定访问？</h3>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a = i;</span><br><span class="line"><span class="keyword">int</span> b = i; </span><br></pre></td></tr></table></figure>
<p>volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。而优化做法是，<strong>由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i是一个寄存器变量或者表示一个端口数据就容易出错</strong>，所以说 volatile 可以保证对特殊地址的稳定访问。</p>
<blockquote>
<p>更多的可能是多线程并发访问共享变量时，一个线程改变了变量的值，怎样让改变后的值对其它线程 visible</p>
</blockquote>
<p>下面通过插入汇编代码，测试有无 volatile 关键字，对程序最终代码的影响：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> a = i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面汇编语句的作用就是改变内存中 i 的值</span></span><br><span class="line">    <span class="comment">// 但是又不让编译器知道</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov dword ptr [ebp<span class="number">-4</span>], <span class="number">20</span>h</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b = i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d&quot;</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后，在 Debug 版本模式运行程序，输出结果如下： i = 10   i = 32</span></span><br><span class="line"><span class="comment">// 然后，然后，在 Release 版本模式运行程序 输出结果如下： i = 10   i = 10  加上 volatile 关键字 就不会这样了</span></span><br></pre></td></tr></table></figure>
<p>输出的结果明显表明，Release 模式下，编译器对代码进行了优化，第二次没有输出正确的 i 值。</p>
<blockquote>
<p>内嵌汇编操纵栈”这种方式属于编译无法识别的变量改变</p>
</blockquote>
<h3 id="使用场景">使用场景</h3>
<p>一般说来，volatile用在如下的几个地方：</p>
<ul>
<li><strong>中断服务程序中修改的供其它程序检测的变量需要加volatile；</strong></li>
<li><strong>多任务环境下各任务间共享的标志应该加volatile；</strong></li>
<li><strong>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</strong></li>
</ul>
<h2 id="volatile指针">volatile指针</h2>
<p>和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cpch;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">char</span>* vpch;  <span class="comment">// 修饰由指针指向的对象、数据是 const 或 volatile 的：</span></span><br><span class="line"><span class="keyword">char</span>* pch;</span><br><span class="line"><span class="keyword">volatile</span> a = <span class="number">1</span>;</span><br><span class="line">pch = &amp;a       <span class="comment">// 错误</span></span><br><span class="line">vpch = &amp;a      <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> pchc;</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">volatile</span> pchv;  <span class="comment">// 指针自身的值——一个代表地址的整数变量，是 const 或 volatile 的：</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol type="1">
<li>可以把一个非volatile int赋给volatile int，<strong>但是不能把非volatile对象赋给一个volatile对象</strong>。</li>
<li>除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。</li>
<li>用户只能用const_cast来获得对类型接口的完全访问。此外，<strong>volatile像const一样会从类传递到它的成员</strong>。</li>
<li><strong>和 const 类似， 只能将 volatile 的对象的地址 赋给 可以指向volitatlie对象的指针，只能将volatile 对象绑定到 volatile 引用上</strong>。</li>
<li><strong>一个对象即可以是 volatile 属性的 同时 也是 const 属性，不冲突，例如只读的寄存器值</strong>。</li>
<li><strong>和 const 的重要的区别是，不能使用 合成的 拷贝构造函数及赋值运算符初始化 volatitle 对象或从 volatile 对象赋值</strong>，需要重新实现。</li>
</ol>
<h2 id="多线程下的-volatile">多线程下的 volatile</h2>
<p>有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，该关键字的作用是<strong>防止优化编译器把变量从内存装入CPU寄存器中。</strong>如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是<strong>让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值，</strong>如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> BOOL bStop = FALSE;</span><br><span class="line"><span class="comment">// 在一个线程中</span></span><br><span class="line"><span class="keyword">while</span>( !bStop ) &#123; ... &#125; </span><br><span class="line">bStop = FALSE; </span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line"><span class="comment">//在另一个线程中 要终止上面的线程循环。</span></span><br><span class="line">bStop  =  TRUE;  </span><br><span class="line"><span class="keyword">while</span>(  bStop  ); </span><br></pre></td></tr></table></figure>
<p>等待上面的线程终止，如果bStop不使用volatile声明，那么这个循环将是一个死循环，因为bStop已经读取到了寄存器中，寄存器中bStop的值永远不会变成FALSE，加上volatile，程序在执行时，每次均从内存中读出bStop的值，就不会死循环了。</p>
<h2 id="volatile与多线程">volatile与多线程</h2>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
详细见参考博文，感觉这块水挺深 以后再说</li>
<li><input type="checkbox" disabled="" />
CPU 的乱序执行，为了提高效率，CPU会乱序执行。例如如果当前需要从内存中读取变量的a的值，但是这个要等，为了效率，CPU可能会将后面不需要等待的，且和a变量完全不相关的指令先执行（这个不相关，不仅仅指依赖关系）。单核单线程下，不会存在这种操作没问题，最终结果看起来也像串行的。但是如果是多线程，乱序就会有问题，通常来说，多线程下，不能寄希望于使用 volatile 来解决 并发引起的冲突问题。要使用原子操作。</li>
<li><input type="checkbox" disabled="" />
CPU乱序执行的证明？肯定要用多线程证明 https://hihen.github.io/posts/cpu-exec-out-of-order/</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++仿函数</title>
    <url>/posts/3085/</url>
    <content><![CDATA[<p>C++中的仿函数介绍</p>
<span id="more"></span>
<h1 id="仿函数">仿函数</h1>
<h2 id="常见场景">常见场景</h2>
<p>当需要将函数作为一个参数传递进另一个函数时，可以使用函数指针。例如下面的例子：</p>
<blockquote>
<p>假设我们现在有一个数组，数组中存有任意数量的数字，我们希望能够统计出这个数组中大于 10 的数字的数量，你的代码很可能是这样的：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RecallFunc</span><span class="params">(<span class="keyword">int</span> *start, <span class="keyword">int</span> *end, <span class="keyword">bool</span> (*pf)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> *i=start;i!=end+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	count = <span class="built_in">pf</span>(*i) ? count+<span class="number">1</span> : count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsGreaterThanTen</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num&gt;<span class="number">10</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">10</span>,<span class="number">100</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">19</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">RecallFunc</span>(a,a+<span class="number">4</span>,IsGreaterThanTen);</span><br><span class="line">    cout&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，如果此时希望将判定的阈值也作为一个变量传入，变为如下函数就不可行了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsGreaterThanThreshold</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> threshold)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num&gt;threshold ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这个函数看起来比前面一个版本更具有一般性，但是它不能满足已经定义好的函数指针参数的要求，因为函数指针参数的类型是<code>bool (*)(int)</code>，与函数<code>bool IsGreaterThanThreshold(int num, int threshold)</code>的类型不相符。如果一定要完成这个任务，按照以往的经验，我们可以考虑如下可能途径：</p>
<p>（1）阈值作为函数的局部变量。局部变量不能在函数调用中传递，故不可行； （2）函数传参。这种方法我们已经讨论过了，多个参数不适用于已定义好的 RecallFunc() 函数。 （3）全局变量。我们可以将阈值设置成一个全局变量。这种方法虽然可行，但是不优雅，且非常容易引入 Bug，比如全局变量容易同名，造成命名空间污染。</p>
<p>那么有什么好的处理方法呢？仿函数应运而生。</p>
<h2 id="用法">用法</h2>
<p>编程者要将某种“操作”当做算法的参数，一般有两种方法：</p>
<p>（1）一个办法就是先将该“操作”设计为一个函数，再将函数指针当做算法的一个参数。上面的实例就是该做法； （2）将该“操作”设计为一个仿函数（就语言层面而言是个 class），再以该仿函数产生一个对象，并以此对象作为算法的一个参数。</p>
<p>仿函数写法： 写一个简单类，除了维护类的基本成员函数外（<code>struct</code>也可），<strong>只需要重载 operator() 运算符</strong> 。这样既可以免去对一些公共变量的维护，也可以使重复使用的代码独立出来，以便下次复用。</p>
<h3 id="示例">示例</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mycmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;a, vector&lt;<span class="keyword">int</span>&gt; &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsGreaterThanThresholdFunctor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">IsGreaterThanThresholdFunctor</span><span class="params">(<span class="keyword">int</span> t)</span>:threshold(t)&#123;</span>&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> num)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num &gt; threshold ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> threshold;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RecallFunc</span><span class="params">(<span class="keyword">int</span> *start, <span class="keyword">int</span> *end, IsGreaterThanThresholdFunctor myFunctor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> *i = start; i != end + <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		count = <span class="built_in">myFunctor</span>(*i) ? count + <span class="number">1</span> : count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">10</span>,<span class="number">100</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">19</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="built_in">RecallFunc</span>(a, a + <span class="number">4</span>, <span class="built_in">IsGreaterThanThresholdFunctor</span>(<span class="number">10</span>));</span><br><span class="line">	cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++强制类型转换</title>
    <url>/posts/2117/</url>
    <content><![CDATA[<p>C++强制类型转换</p>
<span id="more"></span>
<h1 id="强制类型转换">强制类型转换</h1>
<p>C 风格的强制类型转换 如下，不管什么类型的转换都可以使用使用下面的方式。</p>
<blockquote>
<p>TypeName b = (TypeName)a;</p>
</blockquote>
<p>C++也是支持C风格的强制转换,但是C风格的强制转换可能带来一些隐患,让一些问题难以察觉.所以C++提供了一组可以用在不同场合的强制转换的函数 包含：</p>
<ul>
<li>const_cast</li>
<li>static_cast</li>
<li>dynamic_cast</li>
<li>reinterpret_cast</li>
</ul>
<h2 id="const_cast">const_cast</h2>
<p>主要用于 去掉 指针和引用的 的 const 属性。</p>
<ol type="1">
<li>常量指针 / 引用 被转化成非常量的指针，并且仍然指向原来的对象；</li>
<li>const_cast一般用于修改指针。如const char *p形式</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*c_ptr = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *ptr = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(c_ptr);  <span class="comment">// 通过const_cast&lt;Ty&gt; 去常量 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下的情况 对定义的常变量直接转换的方法  最好不要用  在不同编译器下可能会有不同的结果  </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_val = <span class="number">233</span>;  <span class="comment">//声明为常量类型</span></span><br><span class="line"><span class="keyword">int</span> &amp;use_val = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(c_val); <span class="comment">//使用去const 引用</span></span><br><span class="line"><span class="keyword">int</span> *ptr_val = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;c_val);<span class="comment">//使用去const 指针</span></span><br></pre></td></tr></table></figure>
<h2 id="static_cast">static_cast</h2>
<ol type="1">
<li>static_cast 作用和C语言风格强制转换的效果基本一样 <strong>这个和C相同 是指 ，可能会修改二进制的数据</strong>
<ul>
<li><strong>用于基本数据类型之间的转换</strong>（int char bool 等），如把int转换成char，把int转换成enum。这种转换的安全性需要开发者来维护。</li>
</ul></li>
<li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。注意：<strong>进行上行转换</strong>（把派生类的指针或引用转换成基类表示）<strong>是安全的</strong>；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的</li>
<li>不能去掉原有的 属性 如 const voliate</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 常规的使用方法 */</span></span><br><span class="line"><span class="keyword">float</span> f_pi=<span class="number">3.141592f</span></span><br><span class="line"><span class="keyword">int</span>   i_pi=<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(f_pi); <span class="comment">/// i_pi 的值为 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* class 的上下行转换 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  上行 Sub -&gt; Base</span></span><br><span class="line"><span class="comment">//编译通过，安全</span></span><br><span class="line">Sub sub;</span><br><span class="line">Base *base_ptr = <span class="keyword">static_cast</span>&lt;Base*&gt;(&amp;sub);  </span><br><span class="line"><span class="comment">//下行 Base -&gt; Sub</span></span><br><span class="line"><span class="comment">//编译通过，不安全</span></span><br><span class="line">Base base;</span><br><span class="line">Sub *sub_ptr = <span class="keyword">static_cast</span>&lt;Sub*&gt;(&amp;base);  </span><br></pre></td></tr></table></figure>
<h2 id="dynamic_cast">dynamic_cast</h2>
<p>c++ 多态性，例如在基类中定义一个虚函数，然后 子类 继承这个类并 实现虚函数，不同的子类可以有不同的虚函数实现。当我们将基类的指针指向子类的对象时，就会自动调用 对应子类的 虚函数的实现，这就体现出了多态性。</p>
<p>这个类型转换是 C 语言替代不了的 因为涉及到 C++ 的多态特性。对于C++ 中的类 的子类 和 基类 之间的指针或引用的转换，因该用dynamic 或者 static 转换。</p>
<ol type="1">
<li>当 将基类指针转换为 子类指针时，不能直接强转，也不能用static_cast。这是因为子类除了继承基类的变量和方法之外，还可能有自己新的扩充的定义，即 基类 &lt; 子类，强转就可能出现指针越界。应该使用 dynamic_cast 来完成，因为dynamic 可以在程序运行过程中 对转换的可行性进行检查，如果无法完成，会返回空指针。</li>
<li>dynamic_cast 的检查依赖于RTTI 实现，需要类中含有虚函数，没有虚函数 编译不通过。</li>
<li>dynamic_cast 运行检查是有开销的 所以 如果是 子类 像 基类的 上行转换 用 staic_cast 比较快。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I&#x27;m Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">i_am_virtual_foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sub</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Sub</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I&#x27;m Sub&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">i_am_virtual_foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sub-&gt;Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Sub * sub = <span class="keyword">new</span> <span class="built_in">Sub</span>();</span><br><span class="line">    sub-&gt;<span class="built_in">print</span>();</span><br><span class="line">    Base* sub2base = <span class="keyword">dynamic_cast</span>&lt;Base*&gt;(sub);</span><br><span class="line">    <span class="keyword">if</span> (sub2base != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        sub2base-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&lt;sub-&gt;base&gt; sub2base val is: &quot;</span> &lt;&lt; sub2base &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Base-&gt;Sub&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Base *base = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    base-&gt;<span class="built_in">print</span>();</span><br><span class="line">    Sub  *base2sub = <span class="keyword">dynamic_cast</span>&lt;Sub*&gt;(base);</span><br><span class="line">    <span class="keyword">if</span> (base2sub != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        base2sub-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;&lt;base-&gt;sub&gt; base2sub val is: &quot;</span>&lt;&lt; base2sub &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> sub;</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* vs2017 输出为下</span></span><br><span class="line"><span class="comment">Sub-&gt;Base</span></span><br><span class="line"><span class="comment">I&#x27;m Sub</span></span><br><span class="line"><span class="comment">I&#x27;m Base</span></span><br><span class="line"><span class="comment">&lt;sub-&gt;base&gt; sub2base val is: 00B9E080   // 注:这个地址是系统分配的,每次不一定一样</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Base-&gt;Sub</span></span><br><span class="line"><span class="comment">I&#x27;m Base</span></span><br><span class="line"><span class="comment">&lt;base-&gt;sub&gt; base2sub val is: 00000000   // VS2017的C++编译器,对此类错误的转换赋值为nullptr</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="reinterpret_cast">reinterpret_cast</h2>
<ul>
<li>强制类型转换符用来<strong>处理无关类</strong>型转换的 (例如指针 和 long long（64位机器指针是八字节） 的转换)</li>
<li>为操作数的位模式提供较低层次的重新解释！但是他仅仅是重新解释了给出的对象的比特模型，并没有进行二进制的转换！</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *ptr = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">233</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> ptr_addr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(ptr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr 的地址: &quot;</span> &lt;&lt; hex &lt;&lt; ptr &lt;&lt; endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;ptr_addr 的值(hex): &quot;</span> &lt;&lt; hex &lt;&lt; ptr_addr &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++字节对齐</title>
    <url>/posts/41102/</url>
    <content><![CDATA[<p>C++字节对齐</p>
<span id="more"></span>
<h3 id="字节对齐">字节对齐</h3>
<p>有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那 么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数 据。显然在读取效率上下降很多。为了保证读取效率，c/c++变量地址要保证字节对齐。</p>
<ol type="1">
<li>结构中变量的起始地址 要为该变量类型 大小的整数倍，例如 sizeof(int) = 4 那么结构体中这个变量的存储起始地址 % 4 == 0才行。如果不行，会在前方自动填充0。</li>
<li>最后即便前面所有都填充完了，最后总的占用的字节数 要是 结构中最大类型数据所占用字节数的倍数，如果不是，最后再填充一次。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">char</span> dda;　　　　　　　　　　　　　　<span class="comment">//偏移量为0，满足对齐方式，dda占用1个字节； </span></span><br><span class="line"><span class="keyword">double</span> dda1;　　　　　　　　　　　　<span class="comment">//下一个可用的地址的偏移量为1，不是sizeof(double)=8的倍数，需要补足7个字节才能使偏移量变为8（满足对齐方式），因此VC自动填充7个字节，dda1存放在偏移量为8的地址上，它占用8个字节。 </span></span><br><span class="line"><span class="keyword">int</span> type；　　　　　　　　　　　　　<span class="comment">//下一个可用的地址的偏移量为16，是sizeof(int)=4的倍数，满足int的对齐方式，所以不需要VC自动填充，type存放在偏移量为16的地址上，它占用4个字节。 </span></span><br><span class="line">&#125;；　　　　　　　　　　　　　　　　　<span class="comment">//所有成员变量都分配了空间，空间总的大小为1+7+8+4=20，不是结构的节边界数（即结构中占用最大空间的类型所占用的字节数sizeof(double)=8）的倍数，所以需要填充4个字节，以满足结构的大小为sizeof(double)=8的倍数。 </span></span><br><span class="line"><span class="comment">////  24 </span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++模板和泛型编程</title>
    <url>/posts/54163/</url>
    <content><![CDATA[<p>面向对象编程 （<code>OOP</code>）和泛型编程都能处理 <strong>在编写程序不知道类型的情况</strong>。不同之处在于 ，<code>OOP</code>能处理类型在<strong>程序运行之前都未知的情况</strong>，而泛型编程中，在编译时就能获知类型了。而模板是C++泛型编程的基础。</p>
<span id="more"></span>
<p>C++是一门强类型语言，所以无法做到像动态语言（<code>python javascript</code>）那样子，编写一段通用的逻辑，可以把任意类型的变量传进去处理。泛型编程弥补了这个缺点，通过把通用逻辑设计为模板，摆脱了类型的限制，提供了继承机制以外的另一种抽象机制，极大地提升了代码的可重用性。</p>
<h2 id="函数模板">函数模板</h2>
<p>如果希望编写一个函数比较两个值，在实际中由于比较的类型不知道，可以通过函数重载的方式写多个同名的函数，编译器会根据不同的调用参数选择对应的函数执行。但是这样编码很麻烦。我们可以通过定义一个通用的函数模板，来简化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 &lt; v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul class="task-list">
<li><p><input type="checkbox" disabled="" />
模板有关的其他知识</p></li>
<li><p><input type="checkbox" disabled="" />
模板偏特化</p></li>
<li><p><input type="checkbox" disabled="" />
模板全特化</p></li>
<li><p><input type="checkbox" disabled="" />
实参推断</p></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++右值和左值</title>
    <url>/posts/41383/</url>
    <content><![CDATA[<p>C++右值和左值</p>
<span id="more"></span>
<h1 id="左值右值右值引用">左值/右值/右值引用</h1>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406214837.png" alt="" /><figcaption>image-20210406214830548</figcaption>
</figure>
<h2 id="左值右值的区别">左值右值的区别</h2>
<h3 id="左值">左值</h3>
<p>左值：有名字的，可以取地址的就是左值。</p>
<ul>
<li>函数名和变量名</li>
<li>返回左<strong>值引用</strong>的函数调用</li>
<li><strong>前置自增/自减运算符连接的表达式++i/--i</strong></li>
<li>由赋值运算符或复合赋值运算符连接的表达式(a=b、a+=b、a%=b）</li>
<li>解引用表达式*p</li>
<li><strong>字符串字面值"abc"</strong></li>
</ul>
<h3 id="右值">右值</h3>
<p>右值：不是左值，就一定是右值。右值又分为纯右值 和 将亡值。</p>
<ol type="1">
<li><p>纯右值：指的是临时变量值、不跟对象关联的字面量值，这是C98中的定义。</p>
<ul>
<li><p><strong>除字符串字面值以外的字面值</strong></p></li>
<li><p>返回非引用类型的函数调用</p></li>
<li><p>后置自增/自减运算符连接的表达式i++/i-- (<strong>可以理解为在 cpu 中运算产生的临时值，左值一定在内存中，右值有可能在内存中也有可能在寄存器中</strong>）</p></li>
<li><p>算术表达式（a+b、a&amp;b、a&lt;&lt;b）, 逻辑表达式（a&amp;&amp;b、a||b、~a）取地址表达式（&amp;a）</p></li>
</ul></li>
<li><p>将亡值：这是 C11 扩充的概念，新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用）。将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通<strong>过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期</strong>。</p>
<ul>
<li>返回右值引用的函数的调用表达式</li>
<li>转换为右值引用的转换函数的调用表达</li>
<li>举例：std::move()、static_cast&lt;X&amp;&amp;&gt;(x) （X是自定义的类，x是类对象），这两个函数常用来将左值强制转换成右值，从而使拷贝变成移动（就是浅拷贝），提高效率。</li>
</ul></li>
</ol>
<h2 id="左右值引用">左/右值引用</h2>
<p>左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。</p>
<p>左值引用通常只能绑定到左值，不能绑定到右值，但是<strong>常量左值引用</strong> 是个万能的应用类型，它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的，因此优先使用右值引用去绑定右值，这样被绑定的右值也可以被修改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;a = <span class="number">2</span>;       <span class="comment">// 左值引用绑定到右值，编译失败</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;        <span class="comment">// 非常量左值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c = b; <span class="comment">// 常量左值引用绑定到非常量左值，编译通过</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> d = <span class="number">2</span>;  <span class="comment">// 常量左值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;e = c; <span class="comment">// 常量左值引用绑定到常量左值，编译通过</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b = <span class="number">2</span>;  <span class="comment">// 常量左值引用绑定到右值，编程通过</span></span><br></pre></td></tr></table></figure>
<p>右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r1 = c;             <span class="comment">// 编译失败</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r2 = std::<span class="built_in">move</span>(a);  <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure>
<h2 id="引用重载优先级">引用重载优先级</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Data&amp;  data)</span></span>;  <span class="comment">// 1, data is l-ref</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Data&amp;&amp; data)</span></span>;  <span class="comment">// 2, data is r-ref</span></span><br><span class="line">Data   data;</span><br><span class="line"></span><br><span class="line">Data&amp;  data1 = data;             <span class="comment">// OK</span></span><br><span class="line">Data&amp;  data1 = Data&#123;&#125;;           <span class="comment">// not compile: invalid binding</span></span><br><span class="line">Data&amp;&amp; data2 = Data&#123;&#125;;           <span class="comment">// OK</span></span><br><span class="line">Data&amp;&amp; data2 = data;             <span class="comment">// not compile: invalid binding</span></span><br><span class="line">Data&amp;&amp; data2 = std::<span class="built_in">move</span>(data);  <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(data);    <span class="comment">// 1, data is lvalue</span></span><br><span class="line"><span class="built_in">f</span>(Data&#123;&#125;);  <span class="comment">// 2, data is rvalue</span></span><br><span class="line"><span class="built_in">f</span>(data1);   <span class="comment">// 1, data1 is l-ref type and lvalue</span></span><br><span class="line"><span class="built_in">f</span>(data2);   <span class="comment">// 2, data2 is r-ref type but lvalue</span></span><br></pre></td></tr></table></figure>
<p>同理，由于常引用既可以绑定到左值，又可以绑定到右值 （但是不能修改绑定的右值），因此：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">const</span> Data&amp; data)</span></span>;  <span class="comment">// data is c-ref  即可以接受左值 又可以接受右值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">g</span>(data);    <span class="comment">// ok, data is lvalue</span></span><br><span class="line"><span class="built_in">g</span>(Data&#123;&#125;);  <span class="comment">// ok, data is rvalue</span></span><br></pre></td></tr></table></figure>
<p>但是C++ 对引用参数的重载也有优先级，在 对于传入的右值，优先选择右值引用的形参列表，而不是常引用，具体如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Data&amp; data)</span></span>;  <span class="comment">// 1, data is c-ref</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Data&amp;&amp; data)</span></span>;       <span class="comment">// 2, data is r-ref</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(Data&#123;&#125;);  <span class="comment">// 2, prefer 2 over 1 for rvalue</span></span><br></pre></td></tr></table></figure>
<p>针对不同左右值 <strong>实参</strong> <em>(argument)</em> 重载 引用类型 <strong>形参</strong> <em>(parameter)</em> 的优先级如下。(数值越小，优先级越高；如果不存在，则重载失败)</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406220917.jpeg" alt="preview" style="zoom:50%;" /></p>
<h2 id="引用折叠">引用折叠</h2>
<p>既然有了 左值引用 和 右值 引用，那么 将两种引用排列组后 就可以得到四种组合，但是最终确定变量的引用类型只可能是左值引用或右值引用，所以引用折叠的目的就是根据 一定的规则 将引用简化。</p>
<ul>
<li>规则：如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 左值-左值 T&amp; &amp; </span><br><span class="line">- 左值-右值 T&amp; &amp;&amp;</span><br><span class="line">- 右值-左值 T&amp;&amp; &amp;</span><br><span class="line">- 右值-右值 T&amp;&amp; &amp;&amp;</span><br></pre></td></tr></table></figure>
<p>但是， 在编译器中编写以下代码，是会报错的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;ra = a;</span><br><span class="line"><span class="keyword">int</span> &amp; &amp;rra = ra;  <span class="comment">// 编译器报错：不允许使用引用的引用！</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>编译器不允许我们写下类似<code>int &amp; &amp;&amp;</code>这样的代码，但是它自己却可以推导出<code>int &amp; &amp;&amp;</code>代码出来。它的理由就是：我(编译器)虽然推导出<code>T</code>为<code>int&amp;</code>，但是我在最终生成的代码中，<strong>利用引用折叠规则</strong>，将<code>int &amp; &amp;&amp;</code>等价生成了<code>int &amp;</code>。推导出来的<code>int &amp; &amp;&amp;</code>只是过渡阶段，最终版本并不存在。所以也不算破坏规定咯。</p>
<h3 id="通用引用">通用引用</h3>
<p>所谓的<strong>万能引用</strong>并不是C++的语法特性，而是我们利用现有的C++语法，自己实现的一个功能。因为这个功能既能接受左值类型的参数，也能接受右值类型的参数。所以叫做万能引用。有两个必要的条件：</p>
<ol type="1">
<li>必须满足<code>T&amp;&amp;</code>这种形式</li>
<li><strong>类型<code>T</code>必须是通过推断得到的</strong></li>
</ol>
<p>所以，在我们完美转发这个部分的例子当中，我们所使用的这种引用，其实是通用引用，而不是所谓的单纯的右值引用。因为我们的函数是模板函数，<code>T</code>的类型是推断出来的，而不是指定的。那么相应的，如果有一段这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;&#125; <span class="comment">//这个T&amp;&amp;  不是一个通用引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的这个<code>T</code>是不是通用引用呢？答案是不是。因为当这个类初始化的时候这个<code>T</code>就已经被确定了，不需要推断。所以，可以构成通用引用的有如下几种可能：</p>
<ol type="1">
<li>函数模板参数（function template parameters）</li>
<li><code>auto</code>声明（auto declaration）</li>
<li><code>typedef</code>声明（typedef declaration）</li>
<li><code>decltype</code>声明（decltype declaration）</li>
</ol>
<p>通用引用的特点是 ： <strong>传进来的如果是左值引用那就是左值引用，如果是右值引用那就是右值引用</strong>。</p>
<h3 id="通用引用原理">通用引用原理</h3>
<p>总结上面的结论。编程的时候，编译器不允许显式的出现重叠的引用情况，但是在需要编译器推断类型的场景，可以重叠引用，编译器会根据折叠引用规则简化为最终的 左/右值引用。应用这个特性，从而可以实现通用引用的功能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// 一个通用引用的例子</span></span><br><span class="line"><span class="function">ReturnType <span class="title">Function</span><span class="params">(T&amp;&amp; parem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 函数功能实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintType</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 利用Boost库打印模板推导出来的 T 类型</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T type：&quot;</span> &lt;&lt; type_id_with_cvr&lt;T&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; endl; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用Boost库打印形参的类型</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;param type:&quot;</span> &lt;&lt; type_id_with_cvr&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;                              <span class="comment">// 左值</span></span><br><span class="line">	<span class="built_in">PrintType</span>(a);                           <span class="comment">// 传入左值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> &amp;lvalue_refence_a = a;              <span class="comment">// 左值引用</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * T type      : int &amp;</span></span><br><span class="line"><span class="comment"> * T &amp;&amp;        : int &amp; &amp;&amp;</span></span><br><span class="line"><span class="comment"> * param type  : int &amp;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="built_in">PrintType</span>(lvalue_refence_a);            <span class="comment">// 传入左值引用</span></span><br><span class="line">	<span class="built_in">PrintType</span>(<span class="built_in"><span class="keyword">int</span></span>(<span class="number">2</span>));                      <span class="comment">// 传入右值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * T type      : int</span></span><br><span class="line"><span class="comment"> * T &amp;&amp;        : int &amp;&amp;</span></span><br><span class="line"><span class="comment"> * param type  : int &amp;&amp;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例子中，当传入左值时，param 最终为左值引用，编译器会将 T 推导为左值引用的类型（详情模板推导的规则），替换后 变为 int&amp; &amp;&amp; 最终就是左值引用，所以它能接受一个左值。当传入的就是左值引用类型时，int&amp; &amp;&amp; 还是左值引用，当传入的是右值 int &amp;&amp; &amp;&amp; 最终还是右值引用，即万能引用，既可以传入 左值/右值/左值引用/右值引用（右值引用实际就是左值了，所以如果传入的是右值引用，因为右值引用有了具体的名字，它实际也是一个左值了，在传入这个函数，进来就是左值了，这就不符合完美转发的要求）</p>
<h2 id="右值引用的目的">右值引用的目的</h2>
<h3 id="语义移动">语义移动</h3>
<p>传统的拷贝构造函数的入口参数为 常左值引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">string</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span>(<span class="keyword">const</span> string&amp; other);  <span class="comment">// 拷贝构造函数, exists pre C++11</span></span><br><span class="line">    <span class="built_in">string</span>(string&amp;&amp; other)&#123;       <span class="comment">// 移动构造函数, new in C++11</span></span><br><span class="line">        length = other.length;</span><br><span class="line">        capacity = other.capacity;</span><br><span class="line">        data = other.data;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> string&amp; other); <span class="comment">// Copy assn operator, pre C++11</span></span><br><span class="line">  	string&amp; <span class="keyword">operator</span>=(string&amp;&amp; other) &#123;     <span class="comment">// Move assn operator, new in C++11</span></span><br><span class="line">        length = other.length;</span><br><span class="line">        capacity = other.capacity;</span><br><span class="line">        <span class="keyword">delete</span> data;                        <span class="comment">// OK even if data is null</span></span><br><span class="line">        data = other.data;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>;</span><br><span class="line">   	    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> length;</span><br><span class="line">    <span class="keyword">size_t</span> capacity;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">string <span class="title">a</span><span class="params">(get_string())</span></span>;  <span class="comment">// move constructor</span></span><br><span class="line"><span class="function">string <span class="title">b</span><span class="params">(a)</span></span>;             <span class="comment">// copy constructor</span></span><br><span class="line"><span class="function">string <span class="title">c</span><span class="params">(std::move(b))</span></span>;  <span class="comment">// move constructor</span></span><br></pre></td></tr></table></figure>
<p>问题：上述例子中 get_string 返回的是临时右值，如果不存在 移动构造函数，会调用类别的拷贝构造函数，将临时右值中内存区域的东西在内内拷贝出另一份，然后再把临时右值的内存释放掉。但是如果存在 移动构造函数，会被优先重载（入口参数为右值引用），那么在移动构造函数中，只是将临时右值的内存转给了类管理。这样并没有重新拷贝内存，实际也没有释放掉临时右值，它被右值引用延长了生命周期。这两种函数的对比如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406223806.png" alt="image-20210406223806748" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406223821.png" alt="image-20210406223821469" style="zoom:67%;" /></p>
<h3 id="完美转发">完美转发</h3>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relay</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in relay&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">relay</span>(<span class="built_in">Test</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子当中，我们的期待是，我们在<code>main</code>当中调用<code>relay</code>，<code>Test</code>的临时对象作为一个右值传入<code>relay</code>，在<code>relay</code>当中又被转发给了<code>func</code>，那这时候转发给<code>func</code>的参数<code>t</code>也应当是一个右值。也就是说，我们希望：<strong>当<code>relay</code>的参数是右值的时候，<code>func</code>的参数也是右值；当<code>relay</code>的参数是左值的时候，<code>func</code>的参数也是左值</strong>。</p>
<p>但是结果与我们预想的似乎并不相同：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">default constructor</span><br><span class="line">in relay</span><br><span class="line">copy constructor</span><br><span class="line">in func</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br></pre></td></tr></table></figure>
<p>我们看到，在<code>relay</code>当中转发的时候，调用了复制构造函数，也就是说编译器认为这个参数<code>t</code>并不是一个右值，而是左值，<strong>因为它有一个名字</strong>。<strong>那么如果我们想要实现我们所说的，如果传进来的参数是一个左值，则将它作为左值转发给下一个函数；如果它是右值，则将其作为右值转发给下一个函数</strong>。</p>
<p>这时，我们需要<code>std::forward&lt;T&gt;()</code>。与<code>std::move()</code>相区别的是，<code>move()</code>会无条件的将一个参数转换成右值，而<code>forward()</code>则会保留参数的左右值类型。所以我们的代码应该是这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in func &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relay</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in relay &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">default constructor</span><br><span class="line">in relay</span><br><span class="line">move constructor</span><br><span class="line">in func</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br></pre></td></tr></table></figure>
<p>而如果我们的调用方法变成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="built_in">relay</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么输出就会变成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default constructor</span><br><span class="line">in relay</span><br><span class="line">copy constructor</span><br><span class="line">in func</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br></pre></td></tr></table></figure>
<p>完美地实现了我们所要的转发效果。但是这个例子中，t 明明是左值，为何可以传入右值引用的函数中？这里的 <code>void relay(T&amp;&amp; t)</code>其实是通用引用，即通过上面的引用折叠规则 由编译器推断得出的。</p>
<h4 id="完美转发原理">完美转发原理</h4>
<p><code>std::forward</code>的源码形式大致是这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  精简了标准库的代码，在细节上可能不完全正确，但是足以让我们了解转发函数 forward 的了</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(T &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++智能指针</title>
    <url>/posts/19243/</url>
    <content><![CDATA[<p>C++智能指针</p>
<span id="more"></span>
<h1 id="智能指针">智能指针</h1>
<p>智能指针的设计目的 是因为 当 new 一个指针时 如果忘记释放就会带来内存泄漏的问题。因此C++提供了智能指针的方法来“智能地”管理指针所指的内存，自动给你释放。通过new 申请返回的是指向 内存的 指针，智能指针是通过类 来对 这个指针进行管理。当超出了类的作用域，就会自动触发类的析构函数完成该指针指向的内存的释放功能。</p>
<p>综上所述，智能指针是通过类 来 对指针进行管理，当超过类的作用域 类的析构函数自动完成指针所指向的内存的释放功能。而为了使智能指针的表达具有 “指针变量” 类似的形式，需要对 指针变量常用的操作符 例如 “-&gt; * = ” 等重定义。</p>
<ul>
<li>auto_ptr (c++11弃用)</li>
<li>share_ptr (c++11)</li>
<li>weak_ptr (c++11)</li>
<li>unique_ptr (c++11)</li>
</ul>
<h2 id="auto_ptr"><strong>auto_ptr</strong></h2>
<p>auto_ptr 就是对开头的思想进行了实现，是c98里的东西，由于有很多缺陷，c11中已经被弃用。</p>
<ol type="1">
<li>所有权问题。当把 一个auto_ptr 对象 A 通过拷贝构造给了 对象 B 此时A就是个空类，你再试图访问A所指向的空间就会越界。</li>
<li>不支持组管理 就是 通过 <code>new int[ 500]</code> 这种分配的数组 ，它无法管理，因为这时候释放应该使用 <code>delete  []  A</code>而 auto_ptr中只支持 delete A直接释放内存。</li>
<li>不支持容器</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> a = <span class="number">0</span> ) : <span class="built_in">m_a</span>(a) &#123; &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>( )</span><br><span class="line">    &#123; </span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;Calling destructor&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>: <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">std::auto_ptr&lt;Test&gt; <span class="title">p</span><span class="params">( <span class="keyword">new</span> Test(<span class="number">5</span>) )</span></span>; </span><br><span class="line">    cout &lt;&lt; p-&gt;m_a &lt;&lt; endl;  <span class="comment">//当退出  test 函数时 会自动释放 new 的内存</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//// 缺陷1 举例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">(auto_ptr&lt;Test&gt; p1 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;p1-&gt;m_a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::auto_ptr&lt;Test&gt; <span class="title">p</span><span class="params">( <span class="keyword">new</span> Test(<span class="number">5</span>) )</span></span>; </span><br><span class="line">    <span class="built_in">Fun</span>(p);  </span><br><span class="line">    cout&lt;&lt;p-&gt;m_a&lt;&lt;endl;  </span><br><span class="line"><span class="comment">// 此时再访问  P  就越界 因为 在调用 Fun 函数时，实际完成了一次拷贝构造 将指针所有权交给了 函数Fun中的局部变量并随着函数的退出而释放。所以 此时 p就是野指针了。</span></span><br><span class="line">	<span class="function">std::auto_ptr&lt;Test&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">5</span>])</span></span>;  <span class="comment">// 不能管理申请的数组指针</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="unique_ptr">unique_ptr</h2>
<p><strong><code>unique_ptr</code>也是对<code>auto_ptr</code>的替换</strong>。<code>unique_ptr</code>遵循着独占语义。在任何时间点，资源只能唯一地被一个<code>unique_ptr</code>占有。当<code>unique_ptr</code>离开作用域，所包含的资源被释放。如果资源被其它资源重写了，之前拥有的资源将被释放。所以它保证了他所关联的资源总是能被释放。但是如果程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;hello world&quot;</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;string&gt; pu2;</span><br><span class="line">pu2 = pu1;                                      <span class="comment">// #1 not allowed</span></span><br><span class="line">unique_ptr&lt;string&gt; pu3;</span><br><span class="line">pu3 = unique_ptr&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;You&quot;</span>));   <span class="comment">// #2 allowed</span></span><br><span class="line">pu2 = <span class="built_in">move</span>(pu1);                                <span class="comment">// #3 allowed</span></span><br></pre></td></tr></table></figure>
<h3 id="特性">特性</h3>
<ol type="1">
<li><code>unique_ptr</code>的创建方法和<code>shared_ptr</code>一样，除非创建一个指向数组类型的<code>unique_ptr</code>。</li>
<li><code>unique_ptr</code>提供了创建数组对象的特殊方法，当指针离开作用域时，调用<code>delete[]</code>代替<code>delete</code>。当创建<code>unique_ptr</code>时，这一组对象被视作模板参数的部分。这样，程序员就不需要再提供一个指定的析构方法</li>
<li><code>unique_ptr</code>拷贝赋值和拷贝构造都不可以（编译报错），只支持移动语义(<code>move semantics</code>).</li>
</ol>
<h3 id="接口">接口</h3>
<p>unique_ptr提供的接口和传统指针差不多，但是不支持指针运算。</p>
<p><code>unique_ptr</code>提供一个<code>release()</code>的方法，释放所有权。<code>release</code>和<code>reset</code>的区别在于，<code>release</code>仅仅释放所有权但不释放资源，<code>reset</code>也释放资源。</p>
<h2 id="share_ptr">share_ptr</h2>
<p>对于上面 auto_ptr 最基本的 当拷贝构造后 指针的所有权被剥离 只剩野指针的问题，share_ptr 通过共享所有权的概念解决。share_ptr通过计数的机制实现 共享。</p>
<ul>
<li>多个智能指针可以共同拥有/指向同一个 申请的内存/对象，当最后个智能指针离开作用域的时候，内存才会自动释放</li>
<li>包含两种计数 ： 强引用计数 弱引用计数</li>
</ul>
<h3 id="创建">创建</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sptr1</span><span class="params">( <span class="keyword">new</span> <span class="keyword">int</span> )</span></span>;   </span><br><span class="line">    shared_ptr&lt;<span class="keyword">int</span>&gt; sptr2 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>);  <span class="comment">// 使用 make_shared 加速创建过程</span></span><br><span class="line">    shared_ptr&lt;<span class="keyword">int</span>&gt; sptr3 = sptr1;   <span class="comment">//  此时 sptr1 和 3 同时指向同一片内存 强引用计数 值 加 1</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; sptr3.<span class="built_in">use_count</span>();  <span class="comment">// 可以获得 强引用计数值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="析构">析构</h3>
<p><code>shared_ptr</code>默认调用<code>delete</code>释放关联的资源。如果用户采用一个不一样的析构策略时，他可以自由指定构造这个<code>shared_ptr</code>的策略。应该调用<code>delete[]</code>来销毁这个数组。用户可以通过调用一个函数，例如一个<code>lamda</code>表达式，来指定一个通用的释放步骤</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Class Test</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">shared_ptr&lt;Test&gt; <span class="title">sptr1</span><span class="params">( <span class="keyword">new</span> Test[<span class="number">5</span>] )</span></span>;  <span class="comment">// 默认析构无法释放 数组</span></span><br><span class="line">    <span class="comment">// 正确的方法  指定析构函数</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">sptr1</span><span class="params">( <span class="keyword">new</span> Test[<span class="number">5</span>], [ ](Test* p) &#123; <span class="keyword">delete</span>[ ] p; &#125; )</span></span>;   <span class="comment">// 参见 lambda 用法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口-1">接口</h3>
<p>除了 指针常用的 操作 符<code>*</code>,<code>-&gt;</code> 之外 它还提供了一些有用的接口</p>
<ul>
<li><code>get()</code>: 获取<code>shared_ptr</code>绑定的资源</li>
<li>swap()：交换两个 share_ptr 对象 交换所有权</li>
<li><code>reset()</code>: 释放关联内存块的所有权，如果是最后一个指向该资源的<code>shared_ptr</code>,就释放这块内存</li>
<li><code>unique</code>: 判断是否是唯一指向当前内存的 <code>shared_ptr</code></li>
<li><code>operator bool</code> : 判断当前的<code>shared_ptr</code>是否指向一个内存块，可以用 if 表达式判断</li>
</ul>
<h3 id="问题">问题</h3>
<ol type="1">
<li>对同一个裸指针使用两个 shared_ptr初始化管理。应该尽量避免这种情况。当其中一个智能指针离开作用域后释放该指针 另一个再用就出问题。尽量不要从一个裸指针<code>(naked pointer)</code>创建<code>shared_ptr</code>.</li>
<li>循环引用问题。如下面的例子，当离开main函数时，<code>sptrB</code> 和 <code>sptrA</code>离开了作用域 （他们俩是在main函数中申请的一个类）就会导致计数值减一，但是不会释放内存，因为此时 new 的 结构 A 和 B 中包含的智能指针还在相互引用呢</li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210331213732.png" alt="" /><figcaption>image-20210103170722316</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sptr1</span><span class="params">( p)</span></span>;  <span class="comment">//  sptr1 和 sptr2 此时属于不同组 但是指向了同一个资源。不同组的智能指针的计数值不共享</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sptr2</span><span class="params">( p)</span></span>;  <span class="comment">// 尽量不要从一个裸指针`(naked pointer)`创建`shared_ptr`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题2 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">A</span>(  ) : <span class="built_in">m_sptrB</span>(<span class="literal">nullptr</span>) &#123; &#125;;</span><br><span class="line">     ~<span class="built_in">A</span>( )</span><br><span class="line">     &#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot; A is destroyed&quot;</span>&lt;&lt;endl;</span><br><span class="line">     &#125;</span><br><span class="line">     shared_ptr&lt;B&gt; m_sptrB;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(  ) : <span class="built_in">m_sptrA</span>(<span class="literal">nullptr</span>) &#123; &#125;;</span><br><span class="line">    ~<span class="built_in">B</span>( )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; B is destroyed&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    shared_ptr&lt;A&gt; m_sptrA;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//*************当sptrA和sptrB离开作用域时，它们的引用计数都只减少到1，所以它们指向的资源并没有释放！！！！</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">sptrB</span><span class="params">( <span class="keyword">new</span> B )</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">sptrA</span><span class="params">( <span class="keyword">new</span> A )</span></span>;</span><br><span class="line">    sptrB-&gt;m_sptrA = sptrA;</span><br><span class="line">    sptrA-&gt;m_sptrB = sptrB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="简单实现">简单实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// 注意模板类的使用方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPointer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* p_;</span><br><span class="line">	<span class="keyword">size_t</span>* count_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数   注意初始值的设置方法</span></span><br><span class="line">	<span class="built_in">SmartPointer</span>(T* ptr = <span class="literal">nullptr</span>) : <span class="built_in">p_</span>(ptr) &#123;</span><br><span class="line">        <span class="comment">// 构造函数代表新定义了一个 管理某指针的 类，所以要分配 计数变量并初始化为0  从无到有</span></span><br><span class="line">		<span class="keyword">if</span> (p_) &#123;</span><br><span class="line">			count_ = <span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			count_ = <span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="comment">// 拷贝构造函数  就是类似值传递这种场合会使用的情形 所以输入是 const 引用</span></span><br><span class="line">    <span class="comment">// 拷贝构造其实是由 多到跟多的过程 多以 计数值加 1 即刻</span></span><br><span class="line">	<span class="built_in">SmartPointer</span>(<span class="keyword">const</span> SmartPointer&amp; ptr) &#123;</span><br><span class="line">		p_ = ptr.p_;</span><br><span class="line">		count_ = ptr.count_;</span><br><span class="line">		(*count_)++;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="comment">// 赋值构造函数重载 注意 = 是有返回值的 返回的是本身 因为有这种用法 int b = 0; c = b = a;连续赋值</span></span><br><span class="line">	SmartPointer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPointer&amp; ptr) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p_ == ptr.p_) &#123;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		&#125; </span><br><span class="line">    <span class="comment">//赋值构造函数要考虑以下情况：是不是自己给自己赋值，被赋值对象是不是已经有管理的对象了，那么要先释放之前管理的指针</span></span><br><span class="line">    <span class="comment">// 最后变更指针指向的地址，计数值增加</span></span><br><span class="line">		<span class="keyword">if</span> (p_) &#123;</span><br><span class="line">			<span class="keyword">if</span> (--(*count_) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">delete</span> p_;</span><br><span class="line">				<span class="keyword">delete</span> count_;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p_ = ptr.p_;</span><br><span class="line">		count_ = ptr.count_;</span><br><span class="line">		(*count_)++;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="comment">//析构函数 计数值减1后是否到0 </span></span><br><span class="line">	~<span class="built_in">SmartPointer</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (--(*count_) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> p_;</span><br><span class="line">			<span class="keyword">delete</span> count_;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">size_t</span> <span class="title">use_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> *count_;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="weak_ptr">weak_ptr</h2>
<p>根据上面的分析，导致相互引用内存无法释放的主要原因是 两个类内部的<code>share_ptr</code>之间的相互引用。导致管理该类的智能指针无法释放内存。因此提出 通过 <code>weak_ptr</code>来 替代 类内部的 <code>shared_ptr</code>。<code>weak_ptr</code>只能由 <code>shared_ptr</code>拷贝初始化，并且只增加 <code>shared_ptr</code>的弱引用计数值，而在释放内存时只考虑强引用计数值，不管弱引用计数值为多少都不影响内存的释放。</p>
<p>基于以上思路，完善一下 weak_ptr 的定义和性质。</p>
<ul>
<li><code>weak_ptr</code> 只能由 <code>share_ptr</code>指针创建初始化，只增加 弱引用计数。将一个<code>weak_ptr</code>赋给另一个<code>weak_ptr</code>会增加弱引用计数(<code>weak reference count</code>)</li>
<li><code>weak_ptr</code> 没有 <code>*</code> <code>-&gt;</code>操作，它并不包含资源所以也不允许程序员操作资源。但是 在需要访问资源的时候，可以先将它转换为shared_ptr 再访问 如下：
<ol type="1">
<li>调用<code>expired()</code>方法 判断<code>weak_ptr</code>是否指向有效资源</li>
<li>从<code>weak_ptr</code>调用<code>lock()</code>可以得到<code>shared_ptr</code> 或者直接将<code>weak_ptr</code>转型为<code>shared_ptr</code></li>
</ol></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">A</span>(  ) : <span class="built_in">m_a</span>(<span class="number">5</span>)  &#123; &#125;;</span><br><span class="line">     ~<span class="built_in">A</span>( )</span><br><span class="line">     &#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot; A is destroyed&quot;</span>&lt;&lt;endl;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">PrintSpB</span><span class="params">( )</span></span>;</span><br><span class="line">     weak_ptr&lt;B&gt; m_sptrB;   <span class="comment">/// 类中使用了 弱 智能指针  不会强行占用资源  在使用时转换为 shared_ptr才会增加强引用计数，但是此时因为还在调用类的变量，说明这个类正在被使用就不可能是离开了作用域</span></span><br><span class="line">     <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">B</span>(  ) : <span class="built_in">m_b</span>(<span class="number">10</span>) &#123; &#125;;</span><br><span class="line">     ~<span class="built_in">B</span>( )</span><br><span class="line">     &#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot; B is destroyed&quot;</span>&lt;&lt;endl;</span><br><span class="line">     &#125;</span><br><span class="line">     weak_ptr&lt;A&gt; m_sptrA;</span><br><span class="line">     <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::PrintSpB</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>( !m_sptrB.<span class="built_in">expired</span>() )</span><br><span class="line">     &#123;  </span><br><span class="line">      cout&lt;&lt; m_sptrB.<span class="built_in">lock</span>( )-&gt;m_b&lt;&lt;endl;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="function">shared_ptr&lt;B&gt; <span class="title">sptrB</span><span class="params">( <span class="keyword">new</span> B )</span></span>;</span><br><span class="line">     <span class="function">shared_ptr&lt;A&gt; <span class="title">sptrA</span><span class="params">( <span class="keyword">new</span> A )</span></span>;</span><br><span class="line">     sptrB-&gt;m_sptrA = sptrA;</span><br><span class="line">     sptrA-&gt;m_sptrB = sptrB;</span><br><span class="line">     sptrA-&gt;<span class="built_in">PrintSpB</span>( ); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++模板</title>
    <url>/posts/28513/</url>
    <content><![CDATA[<p>C++模板推导规则</p>
<span id="more"></span>
<h1 id="模板推导规则">模板推导规则</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(expr); <span class="comment">// deduce T and ParamType from expr</span></span><br></pre></td></tr></table></figure>
<p>在编译期间，编译器通过expr推导T和ParamType的类型。直觉上，T的类型总是与expr一致，然而实际上，T的类型推到结果，不仅仅依赖于expr的类型，还取决于ParamType的形式。</p>
<p>ParamType 可以写为 <code>T&amp;  /  T&amp;&amp;  / T*</code> 分为为 引用/万能引用/指针</p>
<h2 id="指针或引用">指针或引用</h2>
<p>若expr是引用（左值引用或右值引用），则先将引用部分忽略；然后，对expr的类型和ParamType的类型进行模式匹配，来决定T的类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>; <span class="comment">// ParamType 为左值引用的形参</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;rx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;crx = x;</span><br><span class="line"><span class="built_in">f</span>(x); <span class="comment">// T is int, param&#x27;s type is const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx); <span class="comment">// T is int, param&#x27;s type is const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(crx); <span class="comment">// T is int, param&#x27;s type is const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> y = <span class="number">28</span>;</span><br><span class="line"><span class="built_in">f</span>(y); <span class="comment">// T is int, param&#x27;s type is const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr = <span class="number">27</span>;</span><br><span class="line"><span class="built_in">f</span>(rr); <span class="comment">// T is int, param&#x27;s type is const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;&amp;crr = <span class="number">28</span>;</span><br><span class="line"><span class="built_in">f</span>(crr); <span class="comment">// T is int, param&#x27;s type is const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = &amp;x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *cp = &amp;x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> ccp = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="built_in">f</span>(p); <span class="comment">// T is int*, param&#x27;s type is int* const &amp;</span></span><br><span class="line"><span class="built_in">f</span>(cp); <span class="comment">// T is const int*, param&#x27;s type is const int* const &amp;</span></span><br><span class="line"><span class="built_in">f</span>(ccp); <span class="comment">// T is const char*, param&#x27;s type is const char* const &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>); <span class="comment">// T is int, param&#x27;s type is const int &amp;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++虚函数</title>
    <url>/posts/4015/</url>
    <content><![CDATA[<p>C++虚函数</p>
<span id="more"></span>
<h1 id="多态">多态</h1>
<p>多态 包含 静态多态 和 动态多态，前者是在编译时确定的，通过函数重载实现。后者是通过虚函数实现的，是运行时类指针或引用和它所绑定的对象不同所体现的。</p>
<p>虚函数 原理： https://www.jianshu.com/p/d07e0ac0ba3c?from=singlemessage 虚函数 实现原理： https://blog.twofei.com/496/ 虚函数总结： https://blog.csdn.net/qq_39477053/article/details/80322260</p>
<h2 id="虚拟函数">虚拟函数</h2>
<p>虚函数的实现是由两个部分组成的，虚函数指针与虚函数表。</p>
<h3 id="虚函数指针和表">虚函数指针，和表</h3>
<p>虚函数指针是确实存在的数据类型，在一个被实例化的对象中，它总是被存放在该对象的地址首位。某一个基类（没有继承别人），它其中有好几个虚函数，那么这几个虚函数的地址组成了一个表。当示例化这个类后，称为该类的对象，那么对象只是新增了一个虚函数指针，该虚函数指针指向了虚表的首地址。对于继承该类的派生类的对象，它也有一个虚函数指针，如果它的派生类的虚函数重写了，那么它的虚表和基类的虚表不同。因此虚函数指针的指向地址也不同。</p>
<h3 id="纯虚函数">纯虚函数</h3>
<p>纯虚函数 就是 后面加 0 的虚函数，它没有对虚函数进行实现，包含纯虚函数的类称为抽象类，它不能被实例化因为它虚函数没实现，一般用于接口的定义。只有它的派生类并实现了虚函数的 才能实例化。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++隐式类型转换</title>
    <url>/posts/33418/</url>
    <content><![CDATA[<p>C++隐式类型转换</p>
<span id="more"></span>
<h1 id="隐式类型转换">隐式类型转换</h1>
<p>在C++语言中，类型转换有两种方式，隐式类型转换和显示类型转换。在有隐式类型转换的表达式中，使用者不需要明确指定一个类型的对象该转换为另外哪一个类型，这个工作将隐含地由编译器来完成，编译器将分析表达式的含义，进行类型转换。隐式类型转换针对不同的类型有不同的转换方式，总体可以分为两种类型：（显示类型转换即为 static_cast …这些关键字）</p>
<ul>
<li>算术类型</li>
<li>类类型</li>
</ul>
<h2 id="算术类型转换">算术类型转换</h2>
<p>低精度的变量给高精度变量赋值会发生隐式类型转换。算术类型转换的设计原则就是尽可能避免损失精度。</p>
<h2 id="类类型转换">类类型转换</h2>
<p>在类类型转换中，我们通常有两个需求，<strong>一个是将其他类型的数据转换为我们自定义类的类型，另一个是将自定义类的类型在需要的时候转换为其他的数据类型</strong>。在C++中，可以前者可以通过定义<strong>单参数构造函</strong>数实现，后者通过定义<strong>转换函数</strong>来进行类类型转换。这种方式也称为用户定义的转换（User-Defined Conversion）。这种方式在使用的时候不需要指明转换类型，而是由编译器自动进行选择转换函数，所以也是一种隐式类型转换。</p>
<p>编译器每次只能执行一种类类型的转换。如果一个对象需要从类型A自动转换为类型C，则类型A必须有直接转换为类型C的函数。</p>
<h3 id="转换构造函数">转换构造函数</h3>
<p>如果一个类的某个构造函数只接受一个参数，且没有被声明为explicit，则它实际上定义了将这个参数的类型转换为此类类型的隐式转换机制，我们把这种构造函数称为转换构造函数。在转换构造函数中只允许一步类类型的转换。可以通过将构造函数声明为explicit来阻止隐式转换。</p>
<p>最常见的例子就是将C类型字符串转换为string类型。string(const char *s)。自定义类的转换 如下例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BOOK</span>  //定义了一个书类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        string _bookISBN ;  <span class="comment">//书的ISBN号</span></span><br><span class="line">        <span class="keyword">float</span> _price ;    <span class="comment">//书的价格</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//定义了一个成员函数，这个函数即是那个“期待一个实参为类类型的函数”</span></span><br><span class="line">        <span class="comment">//这个函数用于比较两本书的ISBN号是否相同</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isSameISBN</span><span class="params">(<span class="keyword">const</span> BOOK &amp; other )</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> other._bookISBN==_bookISBN;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//类的构造函数，即那个“能够用一个参数进行调用的构造函数”（虽然它有两个形参，但其中一个有默认实参，只用一个参数也能进行调用）</span></span><br><span class="line">        <span class="built_in">BOOK</span>(string ISBN,<span class="keyword">float</span> price=<span class="number">0.0f</span>):_bookISBN(ISBN),_price(price)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BOOK <span class="title">A</span><span class="params">(<span class="string">&quot;A-A-A&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">BOOK <span class="title">B</span><span class="params">(<span class="string">&quot;B-B-B&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;A.<span class="built_in">isSameISBN</span>(B)&lt;&lt;endl;   <span class="comment">//正经地进行比较，无需发生转换</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;A.<span class="built_in">isSameISBN</span>(<span class="built_in">string</span>(<span class="string">&quot;A-A-A&quot;</span>))&lt;&lt;endl; <span class="comment">//此处即发生一个隐式转换：string类型--&gt;BOOK类型，借助BOOK的构造函数进行转换，以满足isSameISBN函数的参数期待。</span></span><br><span class="line">    cout&lt;&lt;A.<span class="built_in">isSameISBN</span>(<span class="built_in">BOOK</span>(<span class="string">&quot;A-A-A&quot;</span>))&lt;&lt;endl;    <span class="comment">//显式创建临时对象，也即是编译器干的事情。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型转换函数">类型转换函数</h3>
<p>类型转换函数一般形式，虽然实现这种方式，可以通过系定义函数来返回对应的值，但是也可以像下面这样写。另外</p>
<blockquote>
<p>输入操作符 &gt;&gt; 是二元操作符，返回做操作数作为其表达式结果，因此cin &gt;&gt; num返回cin,然而cin是输入流istream的对象，该对象能出现在条件表达式中，是因为在istream中定义了类型转换函数 operator bool()</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">operator</span> 目标类型()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> 目标类型数据;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> <span class="keyword">int</span> x) : _x(x) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _x; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> res = a + <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; std::endl;  <span class="comment">// 输出结果为30.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>附加</title>
    <url>/posts/64084/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="struct和union的区别">struct和union的区别</h3>
<h3 id="memcpy实现">memcpy实现</h3>
<p>要 考虑函数的鲁棒性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mymemcpy</span><span class="params">(<span class="keyword">void</span>* src, <span class="keyword">void</span>* dst, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 多字节复制  要判断两个地址是不是有重叠，如果有重叠要反向赋值</span></span><br><span class="line">    <span class="keyword">if</span>(!dst || !src)    <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = len / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> n = len % <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//倒序</span></span><br><span class="line">    <span class="keyword">if</span>(src + len &gt; dst &amp;&amp; dst &gt; src)&#123;</span><br><span class="line">        <span class="keyword">char</span>* p1 = (<span class="keyword">char</span>*)(src + len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">char</span>* p2 = (<span class="keyword">char</span>*)(dst + len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            *p2-- = *p1--;</span><br><span class="line">        &#125;</span><br><span class="line">        p1++; p2++;   <span class="comment">// 注意内存覆盖</span></span><br><span class="line">        <span class="keyword">int</span>* p3 = (<span class="keyword">int</span>*)p1;</span><br><span class="line">        <span class="keyword">int</span>* p4 = (<span class="keyword">int</span>*)p2;</span><br><span class="line">        p3--; p4--;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            *((<span class="keyword">char</span>*)p4++) = *((<span class="keyword">char</span>*)p3++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 正向拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="手写一下智能指针">手写一下智能指针</h3>
<h3 id="weak_ptr-内部实现-可以实现观察者模式">weak_ptr 内部实现, 可以实现观察者模式</h3>
<p>这是因为 weak_ptr 只会增加弱引用计数，它不会影响指向的对象的生命周期，多以可以在被观察者中使用weak_ptr去指向观察者，观察者对象的释放与否都不会影响被观察者的运行结果，当被观察者需要向观察者传递消息时只需要将弱指针提升为智能指针再去访问。</p>
<p>解决内存泄漏….</p>
<h3 id="智能指针是线程安全的嘛">智能指针是线程安全的嘛</h3>
<p>引用计数是原子的，线程安全的，对共享内存的操作不是，多线程写会出现问题</p>
<h3 id="hash-怎么做成线程安全">Hash 怎么做成线程安全</h3>
<p>Hash表本质是一个数组，可以直接全表上锁，但是这样锁冲突的概率很大。可以分段上锁，因为本质上 就是一个线程修改数组中的某一个元素，同时另一个线程可以修改数组的其他元素。只有当要hash扩容的时候才需要全表上锁</p>
<h3 id="菱形继承">菱形继承</h3>
<p>主要总结了三块儿知识点</p>
<ol type="1">
<li>普通的菱形继承的内存分布，比如 D: public B1, public B2, 内存模型可以看作 [B1:B 组成的一块儿内存] + [B2:B组成的一块儿内存] + [D 自己定义的一块儿内存]，就是三段儿。但是这样会有二义性，比如B1里面的变量b 和 B2里面的变量b，访问就要家类型限定，来指定你要访问的是 B1 还是 B2 里面的。</li>
<li>虚继承的菱形继承问题：首先 虚继承就是说 子类如果定义了父类中存在的变量，那么就不再覆写，将父类的变量放在内存最后，同时在首地址需要存放一个 vbptr ，vbptr第一项指示相对起始虚表指针的偏移，第二项来指示基类变量的偏移，这样通过 vbptr可以直接跳转到基类变量上。那么菱形继承的内存布局就是 [B1:覆写B的变量和B1独有的变量] + [B2:B2覆写B的变量和B2独有的] + [D自己定义的变量] + [基类B的一份变量]；也就是说 可以指定 B1/B2/B 来选择要访问谁的变量</li>
<li>带虚函数的菱形继承（不考虑虚继承）：这种情况下 首先很重要的- 一个 D对象只能用 B1 或者 B2类型的指针去指向，而不能用 B的指针指向D会报错。会有两个虚函数表 B1的虚函数表 + B2 的虚函数表； D自己单独写的新的虚函数被放在了第一个虚表中的最后。B1虚表中有完备的 B1+B类的所有虚函数，如果D重写了就替换，同理 B2 虚表中有完备的B2+B的所有虚函数 ，这样无论是取B1指针指向D对象 还是 B2指针指向D对象，都能调用B1中所有的虚函数 或者 B2中的所有虚函数</li>
<li>带虚函数的菱形继承（考虑虚继承）….</li>
</ol>
<p><a href="https://blog.csdn.net/AgoniAngel/article/details/105893798">参考链接</a> <a href="https://blog.csdn.net/AgoniAngel/article/details/105449238">参考链接</a></p>
<h3 id="设计模式解释一下proactor">设计模式：解释一下proactor。</h3>
<h3 id="const-的作用作用于函数-的特点">const 的作用，作用于函数 的特点</h3>
<ul>
<li>const 作用于局部变量它存放在栈中 可以通过地址间接修改变量值 作用于全局变量 存在只读数据存储区，如果修改它的值会产生运行错误</li>
<li>const 作用于成员函数 那么 代表它不会修改所有非 static 的成员变量（实际就是 const this 指针实现）；因此const 对象也就只能调用 const 修饰的成员函数</li>
</ul>
<h3 id="野指针空指针的区别内存泄漏问题如何解决">野指针，空指针的区别；内存泄漏问题；如何解决</h3>
<h3 id="在不知道头节点的情况下删除某个节点">在不知道头节点的情况下删除某个节点</h3>
<h3 id="c能否在有参构造函数中调用无参构造函数无参构造函数中如果有修改类成员会不会对当前正在构造的类产生影响这种调用方式有什么优势或者缺点">C++能否在有参构造函数中调用无参构造函数，无参构造函数中如果有修改类成员会不会对当前正在构造的类产生影响，这种调用方式有什么优势或者缺点。</h3>
<p>可以 会修改 代码复用</p>
<h3 id="面向过程和面向对象各自的优缺点">面向过程和面向对象各自的优缺点</h3>
<h3 id="内存屏障volatile作用是否具有原子性使用volatile会对编译器有什么影响">内存屏障，volatile作用，是否具有原子性，使用volatile会对编译器有什么影响</h3>
<h3 id="可执行文件的文件格式elf文件格式">可执行文件的文件格式（ELF文件格式）</h3>
<h3 id="c的构造析构顺序">C++的构造析构顺序</h3>
<h3 id="怎么用一个指向子类的基类指针调用基类的虚函数">怎么用一个指向子类的基类指针调用基类的虚函数</h3>
<p>（强制转换或者指明作用域d-&gt;Base::fun()）</p>
<h3 id="写一个字符串类的移动构造拷贝构造赋值构造并模拟这几个过程">写一个字符串类的移动构造，拷贝构造，赋值构造并模拟这几个过程</h3>
<h3 id="快排的时间复杂度什么时候最坏什么时候最好">快排的时间复杂度，什么时候最坏，什么时候最好</h3>
<h3 id="什么情况下会出现段错误为什么段错误程序会直接终止">什么情况下会出现段错误，为什么段错误程序会直接终止</h3>
<h3 id="大文件排序问题">大文件排序问题</h3>
<p>题目：有一个大文件，里面记录了若干数字，把这些数字进行排序。文件大小远大于内存大小</p>
<p>基本思想都是要归并 将大文件分成多个小文件 分别排序，然后合并的。最后合并的时候每个小文件只读入一部分，同时留一个输出缓冲区用于存储已经排好的数据。等输出缓冲区满了之后就把他存到外存然后清空输出缓冲区。</p>
<p>topK的问题类似，一部分一部分的读入 用堆选择topK大的数据</p>
<p><a href="https://www.cnblogs.com/linguanh/p/8532641.html">参考</a></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210619101337.png" alt="" /><figcaption>image-20210619101337401</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210619101332.png" alt="" /><figcaption>image-20210619101325346</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210619101347.png" alt="" /><figcaption>image-20210619101347480</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210619102250.png" alt="" /><figcaption>image-20210619102250262</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210619103938.png" alt="" /><figcaption>image-20210619103938330</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210619105006.png" alt="" /><figcaption>image-20210619105006188</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210619105210.png" alt="" /><figcaption>image-20210619105210585</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210619105741.png" alt="" /><figcaption>image-20210619105741668</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210619105924.png" alt="" /><figcaption>image-20210619105924199</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210619111012.png" alt="" /><figcaption>image-20210619111011948</figcaption>
</figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>面经C++汇总</category>
      </categories>
  </entry>
  <entry>
    <title>面经C++11新特性</title>
    <url>/posts/7697/</url>
    <content><![CDATA[<p>面经C++11新特性</p>
<span id="more"></span>
<h3 id="请问c11有哪些新特性">请问C++11有哪些新特性？</h3>
<ol type="1">
<li>新增 auto 关键字，可以根据变量的初始值推断变量类型，但是对于函数的参数和数组的类型不能推断</li>
<li>新增 nullptr 关键字，可以代表任意类型的指针。C中的 NULL 为宏定义0，在函数重载的时候可能会有歧义，int or 指针？</li>
<li>新增 share_ptr, weak_ptr 等智能指针</li>
<li>新增了右值引用 &amp;&amp; ，实现了语义移动和完美转发的功能，大大减少了临时变量的重复构造析构的次数，提高了性能</li>
<li>新增了STL 容器 array tuple</li>
<li>支持使用初始化列表对类进行初始化 好像只有构造函数支持初始化列表</li>
<li>atomic 原子操作用于多线程资源互斥操作</li>
</ol>
<p>…</p>
<h3 id="详细介绍一下c11中的可变参数模板">详细介绍一下C++11中的可变参数模板</h3>
<p>c++11的可变参数模板对参数进行了高度泛化，可以表示任意数目、任意类型的参数，其语法为在 class 或者 typename 后面带上省略号。省略号作用如下：</p>
<ul>
<li><strong>声明</strong>一个包含0到任意个模板的参数的参数包</li>
<li>在模板定义的右边，可以将参数包<strong>展成一个个独立的参数</strong></li>
</ul>
<p>C++11可以使用递归函数的方式展开参数包，获得可变参数的每个值。<strong>通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数</strong>。例如。参数包Args ...在展开的过程中递归调用自己，每调用一次参数包中的参数就会少一个，直到所有参数都展开为止。当没有参数时就会调用非模板函数printf终止递归过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> ...<span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T a, Args ...rest)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>(rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="详细介绍一下c11右值引用">详细介绍一下C++11右值引用</h3>
<h3 id="c11-constexpr">C++11 constexpr</h3>
<p>c++11之前 const 并无法显式的定义编译时常量和运行时常量 ，</p>
<ul>
<li>constexpr 作用于函数他的返回值一定是constexpr; 如果该函数的返回值在编译时期就能确定，那么编译器会将函数优化为一个常量表达式,在编译时就确定它的值，如果不能确定，就和普通的函数一样。</li>
<li>作用于 类的构造函数 那么所有成员都是 constexpr 类型的 且 参数的初始化必通过初始化列表来完成，构造函数体为空</li>
<li>使用它的优点就是 如果在编译时期就能确定的值 可以在编译时期直接替换 提高运行时的效率 同时相对 宏定义 又有类型检查更安全</li>
</ul>
<h3 id="详细介绍一下c11-lambda新特性">详细介绍一下C++11 lambda新特性</h3>
<h3 id="编译器怎么处理右值">编译器怎么处理右值</h3>
<h3 id="static-线程优化">static 线程优化</h3>
<h3 id="c编译优化有哪些操作">C++编译优化有哪些操作</h3>
<h3 id="编译前端操作-有啥-怎么处理语法问题">编译前端操作 有啥 怎么处理语法问题</h3>
]]></content>
      <categories>
        <category>C++</category>
        <category>面经C++汇总</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>面经C++基础知识2</title>
    <url>/posts/25230/</url>
    <content><![CDATA[<p>面经 C++ 基础知识</p>
<span id="more"></span>
<h3 id="介绍fork函数">介绍fork函数</h3>
<p>创建一个和当前进程映像一样的<strong>进程</strong>可以通过fork( )系统调用。成功调用fork 会返回一个大于等于0 的数，对于主进程，返回的是子进程的pid，子进程中返回的是0；可以通过if判断来确定是在子进程还是父进程中，然后执行不同的功能，两个进程执行的先后顺序完全由系统调度决定。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#inclde<span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="友元">友元</h3>
<p>友元函数：如果一个函数需要访问一个类的的成员，那么可以将该函数申明为类的友元函数。即在类中增加<code>friend 类型 函数名(形式参数);</code>申明语句，申明位置在 private 或者 public下都一样。一个函数可以同时是多个类的友元函数。</p>
<p>友元类：friend声明在哪个类中就是哪个类的友元类，不是双向的，不能传递。可以使用声明所在类的所有成员变量和函数。</p>
<h3 id="模板">模板</h3>
<p>C++是一门强类型语言，所以无法做到像动态语言（<code>python javascript</code>）那样子，编写一段通用的逻辑，可以把任意类型的变量传进去处理。泛型编程弥补了这个缺点。</p>
<p>模板分为函数模板 和 类模板，建立一个通用的规则 在函数调用时才区推导具体的参数类型，因此模板的实例化是在 编译期间确定的而不是链接时确定的，所以不能将模板定义和声明分散到多个文件，这可能会导致在链接期间找不到对应的实例。</p>
<h3 id="深拷贝和浅拷贝">深拷贝和浅拷贝</h3>
<p>当类中含有动态分配的数据空间时 直接调用 赋值 运算符 难么就是浅拷贝，只能将类中定义的成员变量拷贝过去，而指针指向的动态分配的内存无法拷贝。需要手动定义拷贝构造函数 来完成深拷贝。</p>
<h3 id="c类中数据成员初始化顺序">C++类中数据成员初始化顺序</h3>
<ol type="1">
<li>成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，<strong>只与定义成员变量的顺序有关</strong>。</li>
<li>如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。</li>
<li>类中 const 成员常量必须在构造函数初始化列表中初始化</li>
<li>类中static成员变量，只能在类外初始化(同一类的所有实例共享静态成员变量)。</li>
</ol>
<p><strong>初始化顺序：先静后成员变量、先基后派生</strong></p>
<ol type="1">
<li>基类的静态变量或全局变量</li>
<li>派生类的静态变量或全局变量</li>
<li>基类的成员变量</li>
<li>派生类的成员变量</li>
</ol>
<h3 id="类的大小">类的大小</h3>
<p>sizeof(A) 空类 =1（占位s） class A { virtual Fun(){} }; sizeof(A) =4/8 虚函数指针大小</p>
<h3 id="c中大端小端的优缺点">C++中大端小端的优缺点</h3>
<p>大端模式： 低位存在高地址 小端：低位存在低地址；使用 联合体判断，因为联合体存放顺序是所有成员都从低地址开始存放</p>
<p>判定：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">    &#125; u;</span><br><span class="line">    u.i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u.c == <span class="number">1</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;小端&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;大端&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>作用：</p>
<p>大端模式：第一个字节一定包含符号位 所以方便判定不同长度数据的符号 小端模式：强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样。（直接截断 否则大端模式 还存在错位拷贝）</p>
<h3 id="c中和同时使用是什么意思">C++中*和&amp;同时使用是什么意思</h3>
<p>*表示传进来的是指针，只能改变指针指向地址的值，不能改变指针本身</p>
<p>int * &amp;p表示既能改变地址中的值，又能改变指针</p>
<h3 id="i和.ati访问有什么区别">[i]和.at(i)访问有什么区别</h3>
<p><strong>.at</strong>有越界检查，如果越界会报错，[]为了效率就没有</p>
<h3 id="fork-wait-exec函数">fork wait exec函数</h3>
<h3 id="select-函数">select 函数</h3>
]]></content>
      <categories>
        <category>C++</category>
        <category>面经C++汇总</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>面经C++容器和算法</title>
    <url>/posts/976/</url>
    <content><![CDATA[<p>面经C++容器和算法</p>
<span id="more"></span>
<h2 id="容器和算法">容器和算法</h2>
<h3 id="map和set有什么区别分别怎么实现">map和set有什么区别，分别怎么实现</h3>
<p>​ map 和 set 在 c++ 中底层都是红黑树实现。他们的区别在于：</p>
<ol type="1">
<li>map的存储形式是key value的形式，在树中对 key关键字进行排序。而set就是以集合种元素本身作为建立红黑树的关键子，set只存储元素。</li>
<li>对map 迭代时，可以对 value修改，但是不能对key修改，因为红黑树以Key为依据建树，一旦修改红黑树就会自动调整，这时候迭代器的指向顺序就乱了。而同理 set 是直接对 集合中的元素建树，所以set迭代时是不可修改的</li>
<li>map 支持下标操作，可以通过关键字访问对应的元素，但是在使用下标访问时，如果map中存在该键就将值返回，否则以默认值新建该键值关系，因此在只需要判断该键存在与否的时候 使用 find最好。set 不行。</li>
</ol>
<h3 id="stl的allocaotr">STL的allocaotr</h3>
<p>c++的内存管理使用 new/delete 关键字管理。new/delete的具体执行过程：</p>
<ul>
<li>new分为两个阶段 : 1. 调用::operator new内存配置 2. 调用构造函数</li>
<li>delete:分为两个阶段： 1. 调用对象析构函数 2. 调用::operator delete释放内存</li>
</ul>
<p>而 STL 中 为了精密分工，将两个阶段（内存配置和对象构造 / 内存释放和对象析构函数）分开操作</p>
<ol type="1">
<li>alloc::allocate() 内存配置</li>
<li>alloc::deallocate() 内存释放</li>
</ol>
<p>同时SGI STL采用了两级内存配置，当分配的内存低于128B 时 使用 内存池技术，通过空闲链表链表管理内存，防止内存碎片化，当分配的内存大于128B时，直接使用malloc realloc free等函数分配一整块内存。</p>
<h3 id="stl-迭代删除元素">STL 迭代删除元素</h3>
<p>主要考虑迭代器失效的问题。</p>
<ul>
<li>对于序列容器中的vector deque ，删除当前元素，后面的元素都会往前移动一个位置，导致后面的迭代器失效（deque的头尾插除外），而 <code>erase</code> 函数会返回下一个迭代器，因此使用返回值即可。</li>
<li>对于 list 是由双向环形链表构成，因此也只是当前的迭代器失效，不影响后面的。它的erase方法也会返回下一个有效的iterator。</li>
<li>对于关联容器，map 和 set 底层都是红黑树，删除当前元素只是当前迭代元素失效，后面的不影响, 备份即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要求删除键值为偶数的键值对</span></span><br><span class="line"> map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//错误实现：</span></span><br><span class="line"> <span class="keyword">while</span> (it != m.<span class="built_in">end</span>())&#123;</span><br><span class="line">   <span class="keyword">if</span>(it-&gt;second % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">     m.<span class="built_in">erase</span>(it);</span><br><span class="line">   &#125;</span><br><span class="line">   it++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//正确实现：</span></span><br><span class="line"> <span class="keyword">while</span> (it != m.<span class="built_in">end</span>())&#123;</span><br><span class="line">   <span class="keyword">if</span>(it-&gt;second % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">     m.<span class="built_in">erase</span>(it++); <span class="comment">//重点！！！  it++的写法才行不能  m.rease(it); it++;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">     it++;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="stl有什么基本组成">STL有什么基本组成</h3>
<ol type="1">
<li>容器：STL内部封装好的数据结构，是一种class template，常用的包括vector、list、deque、set、map等</li>
<li>算法：是一种函数模板，常用的有sort、search、copy等，STL中算法与数据相分离（不像面向对象中将算法与数据封装在class中）。</li>
<li>迭代器：类似于泛化的指针，用来访问可迭代序列。</li>
<li>适配器：提供转换操作，有容器适配器、仿函数适配器、迭代器适配器。</li>
<li>分配器：负责空间配置与管理，用以支持容器。是一种class template。</li>
<li>仿函数：行为类似函数，就是使一个类的使用看上去像一个函数。它的具体实现就是通过在类中重载了operator()，使这个类具有了类似函数的行为。</li>
</ol>
<p>关系：分配器用于给容器分配空间，算法通过迭代器访问容器中的数据从而完成一定的功能，配接器用于适配套接仿函数或容器，或者说通过一定的方法进行封装。例如 queue 和 stack 基本模型都是 deque 通过配接器实现而来。仿函数可以协助算法完成各种操作。</p>
<h3 id="stl中map与unordered_map">STL中map与unordered_map</h3>
<ul>
<li>底层数据结构不一样，map 是使用 红黑数实现，un..使用hash表</li>
<li>因此查询效率等都不一样</li>
<li>map 是有序的 un 是无序的 不能迭代访问</li>
</ul>
<h3 id="vector和list的区别应用越详细越好">vector和list的区别，应用，越详细越好</h3>
<p>1、区别：</p>
<ol type="1">
<li>vector底层实现是数组；list是双向 链表。</li>
<li>vector支持随机访问，list不支持。</li>
<li>vector是顺序内存，list不是。</li>
<li>vector在中间节点进行插入删除会导致内存拷贝，list不会。</li>
<li>vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。</li>
<li>vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。</li>
</ol>
<p>2、应用</p>
<ul>
<li>vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。</li>
<li>list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。</li>
</ul>
<h3 id="stl中迭代器的作用有指针为何还要迭代器">STL中迭代器的作用，有指针为何还要迭代器</h3>
<p>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</p>
<p>他本质是类模板，表现的像指针，重载了 ++ – 和 -&gt;等操作，封装了原生指针，更像智能指针，可以根据不同的数据结构类型来实现不同的++ –等操作。迭代器返回的是对象的引用而不是对象的值。</p>
<h3 id="stl迭代器是怎么删除元素">STL迭代器是怎么删除元素</h3>
<p>考察的是迭代器失效的问题。</p>
<h3 id="找到数组中每个元素后面比他大的第一个数">找到数组中每个元素后面比他大的第一个数</h3>
<p>单调栈 <a href="https://leetcode-cn.com/problems/next-greater-element-ii/">下一个更大元素 II</a></p>
<h3 id="stl中resize和reserve区别">STL中resize和reserve区别</h3>
<p>resize 和 size 参数相关，reserve函数和 capacity参数相关。</p>
<ul>
<li>size指容器当前拥有的元素个数，它代表的空间是初始化了的 可以直接访问</li>
<li>capacity则指容器在必须分配新存储空间之前可以存储的元素总数，只是空间预分配，未初始化，不可访问</li>
</ul>
<p>调用 resize(n) 函数后，容器的 size = n； 如果 n 不超过最大容量capacity，则不需要重新分配内存，capacity不变；反之则重新分配内存 capacity = size；</p>
<p>调用 reserve(n) 函数后，如果 n 不大于 capacity ，capacity不变，否则重新分配 n 的内存使得capcity等于n，同时将之前 size 的内容拷贝过来。</p>
<h3 id="c-stl-的内存优化">C++ STL 的内存优化</h3>
<h4 id="二级配置器结构">二级配置器结构</h4>
<p>STL 内存管理使用二级内存配置器</p>
<ol type="1">
<li><p>第一级配置器。当分配的内存数大于128字节时，直接使用 malloc free realloc 等函数执行实际的内存分配，和释放等操作。</p></li>
<li><p>第二级配置器，当分配的内存少于128字节时，使用内存池管理。又称之次层配置（sub-allocation）。每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。</p>
<ol type="a">
<li><p>通过size找到合适的空闲链表，如果链表不为空，则直接返回第一个node</p></li>
<li><p>如果链表为空，则使用 blockAlloc 请求分配 node ，即从图中的 start_free-end_free 中的空闲区域再划分出多个连续的node出来。</p></li>
</ol>
<ul>
<li>如果有足够一个node 的空间，就尽可能的分配多的node （最多20）个，将一个Node返回，其他的添加到空闲链表中</li>
<li>如果一个多的空闲node都没有，再次向操作系统请求分配内存
<ul>
<li>若分配成功 再次使用 b 步骤，分配 block</li>
<li>若分配失败，循环各个自由链表寻找空间，如果寻找到了，再次进行 b 过程，否则抛出异常</li>
</ul></li>
</ul></li>
<li><p>用户调用deallocate释放内存空间，如果要求释放的内存空间大于128bytes，直接调用free。否则按照其大小找到合适的自由链表，并将其插入</p></li>
</ol>
<p>上述步骤有三个关键函数：</p>
<ol type="1">
<li><p>空间配置函数<code>allocate</code>：</p>
<p>检查申请的空间大小，大于128字节就调用一级空间配置器使用malloc分配，否则就调用二级空间配置器，从空闲链表中拿数据块。如果空闲链表为空，则调用 refill 函数重新填充空闲链表。</p></li>
<li><p>重新填充空闲链表 <code>refill</code></p>
<p>在使用 allocate 配置空闲空间时，如果对应的空闲链表中没有可用的块（Node）。那么就会调用该函数充填空闲链表。新的空间取自内存池。默认取出 20 个数据块，如果内存池的空间不够，能取多少取多少。从内存池中取空闲块给空闲链表是由函数 <code>chunk_alloc</code>完成</p></li>
<li><p>从内存池取空闲块<code>chunk_alloc</code></p>
<p>首先根据<strong>end_free - start_free</strong>来判断内存池中的剩余空间是否足以调出nobjs个大小为size的数据块出去。如果内存连一个数据块的空间都无法供应，需要用 malloc 取堆中申请内存。假如山穷水尽，整个系统的堆空间都不够用了，malloc失败，那么chunk_alloc会从空闲链表中找是否有大的数据块，然后将该数据块的空间分给内存池（这个数据块会从链表中去除）。</p></li>
<li><p>空间释放函数 <code>deallocate</code></p></li>
<li><p>首先先要检查释放数据块的大小，如果大于128字节就调用第一级配置器，小于128字节则根据数据块的大小来判断回收后的空间会被插入到哪个空闲链表。</p></li>
</ol>
<figure>
<img src="https://pic2.zhimg.com/v2-d34206291e7b3af0208c63395757f101_r.jpg" alt="" /><figcaption>preview</figcaption>
</figure>
<p><img src="https://img-blog.csdn.net/20180128161817846?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjYxMTg3OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" style="zoom: 50%;" /></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>面经C++汇总</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>面经C++类和数据抽象</title>
    <url>/posts/40698/</url>
    <content><![CDATA[<p>经C++类和数据抽象</p>
<span id="more"></span>
<h3 id="c中类成员的访问权限">C++中类成员的访问权限</h3>
<p>C++ 通过 pubilc, protected, private 三个关键字来控制成员的访问权限。</p>
<ul>
<li>在类的内部，可以随意访问三种属性的变量</li>
<li>在派生类中，不可以访问父类 私有的 成员</li>
<li>在类的外部，只能通过对象访问成员，并且只能访问public 属性的成员</li>
</ul>
<h3 id="c中-struct-和class的区别">C++中 struct 和class的区别</h3>
<ul>
<li>c++ 可以用 struct 和 class 定义类，都可以用来继承，但是 struct 默认是公开的属性，而class默认成员是私有的类型。</li>
<li>class 这个关键字还可以使用 模板，模板类 而 struct 不能</li>
</ul>
<h3 id="c类内可以定义引用数据成员吗">C++类内可以定义引用数据成员吗</h3>
<p>可以，必须通过成员函数初始化列表初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ref</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数形参为传值，不能保证正确性</span></span><br><span class="line">        <span class="comment">// Ref (int target) :myref(target) &#123;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;Ref constructor&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 函数体对引用赋值，编译错误：引用未初始化</span></span><br><span class="line">        <span class="comment">// Ref (int &amp;target)  &#123;</span></span><br><span class="line">            <span class="comment">// myref = target;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;Ref constructor&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果成员为变量为引用类型，那么构造函数的参数为引用类型  这个好理解 因为你都是引用外界的数据，如果用值传递，进来的只是个临时值，再对临时值做引用，显然有问题。</span></span><br><span class="line">        <span class="comment">// 引用必须在成员初始化列表里面初始化，不能在函数体里面初始化。构造函数的参数列表在构造函数之前执行</span></span><br><span class="line">        <span class="comment">// 在函数体里面修改myref，相当于赋值，显然引用不能赋值</span></span><br><span class="line">        <span class="built_in">Ref</span> (<span class="keyword">int</span> &amp;target) :<span class="built_in">myref</span>(target) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Ref constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;myref is: &quot;</span> &lt;&lt; myref &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Ref</span> () &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> &amp;myref;</span><br><span class="line">        <span class="comment">/* data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="右值引用跟左值有什么区别">右值引用，跟左值有什么区别</h3>
<p>左值：指可以取地址的，或者有具体名字的变量/对象</p>
<ul>
<li>左值可以被赋值，寻址，可变</li>
</ul>
<p>右值：c98中包含纯右值，即临时值，和将亡值，通过右值引用绑定的右值，一般右值都是临时的，表达式结束右值便不再存在（右值引用可以延续右值的生命周期）</p>
<ul>
<li>右值不可变，不可寻址</li>
</ul>
<p>能将 左值绑定到左值引用上，右值能绑定到右值引用以及const 类型的左值引用上。右值引用的主要目的是提高右值的声明周期，绑定到右值引用上的右值相当于有了新的名字，接管了临时值的内存，成为了左值，便不会再被释放。右值引用的主要应用有 语义移动和完美转发。通过语义移动功能可以将左值转换为右值，如果直接传递左值，中间会多出临时变量的拷贝构造过程，使用右值可以避免这个开销。完美转发就是 输入函数的是左值/右值，经过他转发后还是左值/右值，主要是函数嵌套调用的时候，如果传入第一个函数的是个右值，经过右值引用之后实际他就变成了左值。</p>
<p>右值引用是c11的新特性，它主要有两个方面的优势：</p>
<ol type="1">
<li>右值引用可以减少拷贝构造或者赋值构造中 对临时变量的 重复拷贝。</li>
<li>能够更简洁明确的定义泛函数<br />
</li>
<li>完美转发 和 语义移动</li>
</ol>
<p>语义移动 实现原理 static_cast 强转为 右值引用 完美转发 实现原理 模板 + 引用折叠的原理共同决定 static_cast 的是强转为 右值引用还是左值引用 如果输入的是右值</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>面经C++汇总</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>面经C++编译和底层</title>
    <url>/posts/50038/</url>
    <content><![CDATA[<p>面经 C++ 编译和底层</p>
<span id="more"></span>
<h3 id="c源文件从文本到可执行文件经历的过程">C++源文件从文本到可执行文件经历的过程</h3>
<p>四个过程。</p>
<ol type="1">
<li>预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译 .i 文件</li>
<li>编译阶段：对预编译文件进行语法分析（关键字、标识符），语义分析等，转换成特定汇编代码，生成.s汇编文件</li>
<li>汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件 .o 文件</li>
<li>链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件。连接过程主要解决源代码的相互依赖问题，分为静态连接和动态连接。</li>
</ol>
<h3 id="include尖括号和双引号的区别">#include尖括号和双引号的区别</h3>
<p>编译器预处理阶段查找头文件的路径不一样。</p>
<ul>
<li>尖括号：直接从系统目录里查找 头文件。系统目录主要有：编译时 -I 参数指定的头文件搜索路径，系统变量<code>CPLUS_INCLUDE_PATH</code>/<code>C_INCLUDE_PATH</code>指定的头文件路径</li>
<li>双引号：先从当前目录搜索头文件，然后从系统目录中搜索</li>
</ul>
<h3 id="include头文件的顺序">include头文件的顺序</h3>
<h3 id="malloc原理以及系统调用">malloc原理，以及系统调用</h3>
<p>Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。</p>
<p>当进行内存分配时，Malloc会通过显式链表，根据待分配内存大小在直接从合适的链表中寻找空闲块；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。</p>
<p>Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。</p>
<h3 id="c的内存管理">C++的内存管理</h3>
<p>对于32位CPU可寻址4G线性空间，其中0-3G是用户态空间，3-4G是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中,其逻辑地址其划分如下: (前三个为静态区 后 三个为动态区)</p>
<ul>
<li>代码段：用于存放代码和字符常量</li>
<li>数据段：用于存放已经初始化的全局变量和局部静态变量</li>
<li>bss段：用于存放未初始化的全局变量和局部静态变量，或初始化未0的全局局部静态变量</li>
<li>堆区：用于程序运行过程中，用户自行动态分配的管理的内存区域</li>
<li>栈区：用于函数调用时，存放函数的局部变量，函数返回地址，返回值等，由操作系统分配和管理。在创建进程时会有一个最大栈大小</li>
<li>mmap映射区：用于存储动态库等文件映射，同时malloc也可以通过系统调用申请大内存</li>
</ul>
<h3 id="如何判断内存泄漏">如何判断内存泄漏</h3>
<p>内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。为了判断内存是否泄露，我们一方面可以使用linux环境下的内存泄漏检查工具Valgrind，另一方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。</p>
<p>内存泄漏的分类：</p>
<ol type="1">
<li>堆内存泄漏 （Heap leak）。堆内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.</li>
<li>系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 <strong>Bitmap,handle ,SOCKET</strong>等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</li>
<li>没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</li>
</ol>
<h3 id="什么时候会发生段错误">什么时候会发生段错误</h3>
<p>段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：</p>
<ul>
<li>使用野指针</li>
<li>试图修改字符串常量的内容</li>
</ul>
<h3 id="说一下共享内存相关api">说一下共享内存相关api</h3>
<p>Linux允许不同进程访问同一个逻辑内存，提供了一组API，头文件在<code>sys/shm.h</code>中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 新建共享内存: </span></span><br><span class="line"><span class="comment">key：共享内存键值，可以理解为共享内存的唯一性标记。</span></span><br><span class="line"><span class="comment">size：共享内存大小</span></span><br><span class="line"><span class="comment">shmflag：创建进程和其他进程的读写权限标识。</span></span><br><span class="line"><span class="comment">返回值：相应的共享内存标识符，失败返回-1*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key,<span class="keyword">size_t</span> size,<span class="keyword">int</span> shmflg)</span></span>;  <span class="comment">// 新建共享内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 连接共享内存到当前进程的地址空间shmat</span></span><br><span class="line"><span class="comment">shm_id：共享内存标识符</span></span><br><span class="line"><span class="comment">shm_addr：指定共享内存连接到当前进程的地址，通常为0，表示由系统来选择。</span></span><br><span class="line"><span class="comment">shmflg：标志位</span></span><br><span class="line"><span class="comment">返回值：指向共享内存第一个字节的指针，失败返回-1*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id,<span class="keyword">const</span> <span class="keyword">void</span> *shm_addr,<span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当前进程分离共享内存shmdt */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制共享内存shmctl</span></span><br><span class="line"><span class="comment">和信号量的semctl函数类似，控制共享内存</span></span><br><span class="line"><span class="comment">shm_id：共享内存标识符</span></span><br><span class="line"><span class="comment">command: 有三个值   IPC_STAT:获取共享内存的状态，把共享内存的shmid_ds结构复制到buf中。</span></span><br><span class="line"><span class="comment">                   IPC_SET:设置共享内存的状态，把buf复制到共享内存的shmid_ds结构。</span></span><br><span class="line"><span class="comment">                   IPC_RMID:删除共享内存</span></span><br><span class="line"><span class="comment">				  buf：共享内存管理结构体。*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id,<span class="keyword">int</span> command,struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p>shmget 将键和共享内存 绑定，返回的是一个类似文件句柄的东西（只不过这个文件的存储载体是内存）；shmat 将前面的文件映射至当前进程的 文件映射区，返回映射后的地址，这个地址是用户地址空间文件映射区的地址。 通过 shmctl 读写共享内存</p>
<h3 id="new-和-malloc-的区别">new 和 malloc 的区别</h3>
<ol type="1">
<li>new 是 c++ 的一个关键字，而 malloc 是函数。</li>
<li>new 会根据对象的大小自动分配相同大小的内存，并且会默认调用类的构造函数，而malloc只能自己使用sizeof设定需要分配大小</li>
<li>new分配的后返回的是指向类的指针，而 malloc返回的是void指针，需要自行进行类型转换</li>
<li>new分配使用delete释放，malloc与之对应的是free</li>
<li>new如果内存申请失败会抛出异常，而malloc则返回空指针</li>
<li>malloc分配的内存不够时，可以调用 relloc 进行扩容，而new没有这个操作</li>
<li>申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。</li>
</ol>
<p>在默认情况下，new操作的自由存储区和堆等价，<strong>但是可以通过重载操作符，改用其他内存来实现自由存储</strong>，例如全局变量做的对象池，这时自由存储区就区别于堆了。</p>
<h3 id="c如何处理内存泄漏">C++如何处理内存泄漏</h3>
<ol type="1">
<li>首先可以 使用 编辑器的 查找功能查看是否使用了 成对的 new 和 delete 语句。这样能有个粗略的判断。</li>
<li>然后话可以在 类中增加一个<strong>静态成员变量</strong>，在构造函数中 加，在析构函数中减；最后程序结束输出该计数值，应该为0才对，但是这样只能解决自身编写的类来检查</li>
<li>有可能是 析构函数不是虚函数，就无法调用子类的析构函数释放子类申请的空间，还要注意子类中有没有调用父类的析构函数释放父类中申请空间。</li>
<li>认真检查代码逻辑，是否有提前跳出的位置。</li>
<li>可以使用智能指针代替指针</li>
</ol>
<p>使用varglind，mtrace检测</p>
<h3 id="c函数编译">C++函数编译</h3>
<p>无论是全局函数，还是类中的成员函数，C++都是将函数名重新编码为一个新的函数名。如果在类中的函数，它会根据类的名字和函数名字共同编码生成一个新的名字，保证全局所有函数的名字唯一性。而类的成员函数在编译阶段如何和类以及成员变量关联的呢？方法就是给成员函数添加一个隐藏的对象指针，函数内部访问类成员时通过对象指针访问，这样就将成员函数和成员变量关联了起来。同理，我们常用的 bin 的绑定方法，绑定类成员函数的方法，可以指定不同的对象指针，他们的成员函数的值可能不同，就实现了不同对象的成员函数的绑定。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>面经C++汇总</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理-3A算法和ISP</title>
    <url>/posts/42532/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="a算法">3A算法</h1>
<p>3A技术即自动对焦（AF）、自动曝光（AE）和自动白平衡（AWB），3A数字成像技术利用了AF、AE、AWB算法实现图像对比度最大、改善目标拍摄物过曝光或曝光不足情况，使画面在不同光线照射下的色差得到补偿，从而呈现较高画质的图像信息。</p>
<h2 id="自动对焦af">自动对焦AF</h2>
<p>计算当前图像的对比度，然后调整焦距，最终使得图像的对比度最大。这里对合适的焦距可以采用 爬山法 搜索。因为一开始你并不知道当前焦距下成像是最清晰的，那么爬山法的原理和梯度下降有点类似。搜索当前点领域空间的点，选其中反馈最大的位置作为下一步迭代的点。即不断往上“怕山”，直到遇到局部最优值，即领域的值都比它差。</p>
<p>那么自动对焦算法中有两个关键步骤</p>
<ul>
<li>图像清晰度评价指标：图像熵，灰度方差，拉普拉斯梯度和，变分损失等</li>
<li>搜索算法： 上述的爬山法的 优点是 避免了全局搜索，效率高。 但是会陷入局部最优，一个替代的方法是 模拟退火法。他的思路是当找到局部最优值后，以一定的概率接受往周围稍差的值前进，即以一定概率接受走下坡路，但是这个概率是越来越低的，直至收敛。因此这样就可能跳出局部最优值，而搜索到更好的结果。</li>
</ul>
<h2 id="自动曝光ae">自动曝光AE</h2>
<p>一般的自动曝光算法通过获取图像的亮度调节相应的曝光参数，得到合适的曝光量。曝光参数包括光圈大小, 快门速度和摄像头传感器的亮度增益。</p>
<p>获取图像亮度,可采用的方法有：</p>
<ol type="1">
<li>平均亮度</li>
<li>分区域加权平均，可以将关注区域集中在屏幕某个具体位置 或者具体对象</li>
<li>直方图信息等</li>
<li>设置不同的亮度文献，对背光、正光和强光进行区分</li>
</ol>
<p>调整参数的主要方法：</p>
<ol type="1">
<li>查表法：系统内部可能预先存储了一张曝光参数的调整步长与图像亮度之间的关系查找表，根据当前的亮度去获取调整值，使得图像亮度接近期望值。</li>
<li>迭代法：</li>
<li>数值计算法</li>
</ol>
<h2 id="自动白平衡awb">自动白平衡AWB</h2>
<p>白平衡，这是和光源的色温息息相关的概念。例如 早期的灯泡，都是光色的暖光源，在暖光源下成像的整体颜色就偏黄，白炽灯是冷色光源，成像效果就偏蓝。为了使得成像效果不受光源色温影响，尽可能还原出场景的本身颜色，就有了自动白平衡算法。</p>
<p>常用的白平衡算法有以下两种：</p>
<ol type="1">
<li>选白点算法：所谓白点就是图像中原本应该是白色的点。白点算法就是首先找到图像中 可能的 “白色的点”，然后将白色点矫正会去RGB={255，255，255}，以此为标准，就能知道变换矩阵将其他颜色的像素点都还原回去。这里的 可能的白点 是选的图像中 RGB 值和最大的点，这个最大的也是一个阈值。</li>
<li>灰度世界假设：类似上面的白点算法。灰度世界原理是，对于一个丰富的场景的图，它全图 R G B 三通道的均值应该接近，基于此就可以算出各个通道的变换倍数。</li>
<li>色温估计：这个算法原理是，预先在不同的光源下，记录一个合适的校准值保存。在测试的时候，先根据图像估算色温，然后去查表找到当前色温的校准值。至于如何估计色温，可以将图像分块，然后针对每个块做一个白点的计算，得到色温估算。</li>
</ol>
<h1 id="isp">ISP</h1>
<p><a href="https://blog.csdn.net/Z_HUALIN/article/details/78017314">安卓相机处理流程</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/115321553">参考链接</a></p>
<p>ISP 图像信号处理器，用于处理图像传感器的原始数据。它首先是一个处理器，然后由运行在其上的软件来控制整个ISP流程。软件结构按照层级可以划分为如下三层，分别为 顶层的 ISP控制逻辑， 3A算法库，传感器控制库 和 基础ISP算法。如下图所示。</p>
<p>​ <img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210608223056.png" alt="image-20210608223056771" style="zoom:50%;" /></p>
<ul>
<li>SENSOR 3A：我理解为控制相机硬件的库，例如控制相机的快门，光圈大小等，因此它服务于 3A库，3A算法需要根据当前图像的统计信息反馈来调整这些硬件参数。</li>
<li>SENSOR ISP：其他的一些算法库，例如 黑电平矫正，黑点矫正等算法</li>
<li>3A LIB：就是上面介绍的3A算法</li>
<li>ISP CTRL：整个 ISP 的控制逻辑，从传感器读取数据，然后通过回调函数调用底层的ISP算法，完成整个ISP的流程，然后输出图像，同时还负责处理外部用户通过IIC / SPI 等输入的控制指令。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210608215513.png" alt="image-20210608215513588" style="zoom: 67%;" /></p>
<p>常规的步骤可以 以 3A 算法作为依据划分为算个阶段。因为其实 白平衡 亮度 和 焦距 他们存在依赖关系。因此需要有序调整。从上图可以大致看出，先自动调整白平衡，然后自动调整曝光，最后自动对焦</p>
<h3 id="黑电平矫正">黑电平矫正</h3>
<p>由于传感器存在漏电流，当全黑时成的像由于漏电流的存在而不是全黑的，减去偏移值即可</p>
<h3 id="镜头阴影矫正">镜头阴影矫正</h3>
<p>或者叫非均匀矫正，镜头中央进光比较均匀，四周少，表现就是纯色场景 四周有暗角。这也是相机的固有缺陷，可以实现矫正</p>
<h3 id="坏点矫正">坏点矫正</h3>
<p>相机传感器难免有一些成像单元损坏，会导致最后的图像有一些坏点。找坏点，做中值滤波即可</p>
<h3 id="颜色插值">颜色插值</h3>
<p>相机的成像元件是按照 拜尔排列，和屏幕的显示彩色图像一样，他是红绿蓝三个颜色滤镜分别采集RGB信号，因此输出的图像也就是 RawRGB格式，那么就需要对R G B 三通道都进行颜色插值，</p>
<p>​ <img src="C:/Users/10729/AppData/Roaming/Typora/typora-user-images/image-20210608215036384.png" alt="image-20210608215036384" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210608215107.png" alt="image-20210608215107199" style="zoom: 33%;" /></p>
<h3 id="去噪">去噪</h3>
<p>对图像传统的去噪方法 ….</p>
<h3 id="颜色矫正">颜色矫正</h3>
<ul>
<li>RGB： 是一种均匀性较差的颜色空间，人眼对于三个颜色分量的敏感程度是不一样的，<strong>如果颜色的相似性直接用欧氏距离来度量，其结果与人眼视觉会有较大的偏差</strong>。在RGB颜色系统中，<strong>三个颜色分量之间是高度相关的，即只要亮度改变，三个分量都会相应的改变</strong>，如果一个颜色的某一个分量发生了一定程度的改变，那么这颜色很可能也要发生改变。</li>
<li>HSI：用色调（Hue）、饱和度（Saturation或Chroma）和亮度（Intensity或Brightness）来描述颜色。 I 分量与颜色信息无关，H和S分量与人感受彩色的方式相似，彩色图像中的每一个均匀性彩色区域都对应一个相一致的色度和饱和度，色度和饱和度能够被用来进行独立于亮度的彩色区域分割。</li>
<li>YUV：Y就是常说的灰度</li>
</ul>
<h3 id="gamma矫正">gamma矫正</h3>
<p>人眼对亮度的敏感度不是线性变化的，在低照度下 人眼对亮度变化敏感，在高亮度下人眼对亮度变化没那么敏感，因此使用gamma矫正对输入图像的灰度做一个非线性操作，拉伸低亮度的值，压缩高亮度的像素值</p>
<h3 id="色彩空间转换">色彩空间转换</h3>
<p>了解一下常用的色彩空间和运用</p>
<h3 id="彩色去噪">彩色去噪</h3>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>传统图像处理</category>
      </categories>
  </entry>
  <entry>
    <title>图像处理-双噪声相似性的去噪方法</title>
    <url>/posts/59491/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="双噪声相似度的变分去噪">双噪声相似度的变分去噪</h1>
<h2 id="变分去噪tv">变分去噪(TV)</h2>
<p>假设图像的成像模型为加性噪声，变分去噪模型包含两项，一项是数据保真项，一项是图像的全变分，即图像的梯度。两项都是无约束凸优化问题。由于噪声区域通常都是梯度异常的区域，因此TV项用在去噪中的作用就是保持图像的光滑性，但是也会对图像的细节丢失。</p>
<h2 id="非局部均值滤波-nlm">非局部均值滤波 （NLM）</h2>
<p>相对对传统邻域滤波方法的一种改进滤波，考虑到了图像的自相似性质，它充分利用了图像中的冗余信息，在去噪的同时能够最大程度的保持图像的细节特征。</p>
<h2 id="非局部变分去噪nltv">非局部变分去噪（NLTV）</h2>
<p>借鉴了 非局部 均值滤波中的思想，原始的 变分损失就是度量的当前像素和领域像素的差值，即梯度，作为约束，期望平滑。在非局部变分损失中，将梯度重新定义为其领域一个像素与当前像素之间的差值，权重为以二者像素中心的patch之间的相似度。然后使用 split Bregman算法来求解非局部TV模型</p>
<h2 id="双噪声相似性的非局部变分去噪">双噪声相似性的非局部变分去噪</h2>
<p>在NLTV去噪算法中，度量像素之间的相似性是根据初始噪声图像计算的，没有考虑到算法迭代过程中像素之间的相似性，由于在迭代过程中，像素之间的相似性可能会改变，若一直利用初始噪声的相似权重可能会不准确。因此在计算像素之间的相似性时同时利用初始噪声图像的相似性和迭代过程中像素之间的相似性来计算，以增强度量像素相似性的准确性。</p>
<p>总的来说，就是每次迭代求解过程中 都更新一下权重矩阵，原始的非局部变分损失中的 权重 计算的是原始噪声图像的各个patch之间的相似性，双噪声相似性算法中 在权重中额外添加了一个 当前迭代结果的像素间的相似性作为参考。</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210607111125.png" alt="image-20210607111125324" style="zoom:67%;" /></p>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>传统图像处理</category>
      </categories>
  </entry>
  <entry>
    <title>图像处理-双边滤波</title>
    <url>/posts/4294/</url>
    <content><![CDATA[<span id="more"></span>
<p>A Fast Approximation of the Bilateral Filter using a Signal Processing Approach</p>
<h2 id="双边滤波">双边滤波</h2>
<p>​ 和高斯滤波一样都是用周围像素的加权平均的方式来代替某个像素点的亮度。与高斯滤波不同的是，双边滤波不仅考虑了中心像素和周围像素之间的欧式距离，还考虑了像素间的差异。使得双边滤波具有保持边缘的同时又具有平滑降噪的效果。如下图。高斯滤波器在图像的任意位置采用相同的高斯核, 这种处理的缺点是在实现对图像的有效平滑的同时也模糊了边缘信息, 图像的边缘区域不能很好的保持。<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328205215.png" alt="1594710775288" /></p>
<p>由定义可以看出, 在高斯滤波的基础上双边滤波器加入了正则系数和值域权重, 双边滤波里的两个权重域的概念：<code>空间域（spatial domain S）</code>和<code>像素值域（range domain R）</code>, 这个是它跟高斯滤波等方法的最大不同点。</p>
<ul>
<li>在图像的平坦区域，像素值变化很小，对应的像素范围域权重接近于1，此时空间域权重起主要作用，相当于进行高斯模糊</li>
<li>在图像的平坦区域，像素值变化很小，对应的像素范围域权重接近于1，此时空间域权重起主要作用，相当于进行高斯模糊</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328205234.png" alt="" /><figcaption>1594710898655</figcaption>
</figure>
<h3 id="快速双边滤波">快速双边滤波</h3>
<p>​ 直接计算的话，上述运算量很大 因为每个位置的 值域的 权重都得重新计算。；滤波窗口越大计算量也越大。快速算法的思想是在原本的二维图像上增加一个新的值域维度。然后使用3维卷积滤波，加速计算。下面以一个一维信号来举例。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328205143.png" alt="" /><figcaption>1594711300931</figcaption>
</figure>
<ul>
<li>第一步创建双边网格。将整个网格初始化为0 。对于上右图所示的一维信号而言，如果不考虑downsample unsample sliceing的过程。将一维信号变为二维的方法就是 若原信号x位置的 值 为20，则对于 左边的wi 双边网格的 (x,y) 坐标 填充为20； 右边的w双边网格的 (x, y) 坐标位置填充 1 (为填充的位置初始为0) 这样将原始x信号依次填充 网格</li>
<li>使用一个二维高斯核 分别对 上述的wi ，w 双边网格滤波。高斯核的横轴代表空域，纵轴代表像素值域。可以 想想，原本x空域相邻的两个位置的值如果 差别很大，比如2和200，在填充双边网格时，他们在值域（图中的y轴）会被拉的很开，此时二者之间的关联在滤波核y方向的作用下被削弱甚至完全抑制。</li>
<li>wi / w 做除法。之所以做除法是保证加权滤波的权重和为1。从图中可以看出在第二步滤波中，实际有很多为 0 的位置（其实就是没有像素对应的位置）也参与了滤波，因为这些为0的无效位置也占了权重，因此如果不归一化会拉低像素值。相当于 (0.5x20 + 0.3x15 + 0.2x0) / (0.5x1 + 0.3x1 + 0.2x0) 其中右边为0 的位置就是不存在像素的位置。而双边网格 i (0/1 标记有意义和无意义的位置) 的目的就是记录有效像素的滤波核的权重和。</li>
</ul>
<p>​ 对于二维图像，增加一个值域坐标轴 就是三维的了 过程类似。同时为了降低计算量。原文作者的双边网格其实是在较原图较小的分辨率上做的。对于在一个bin里面的很多像素取平均.... 在低分辨率下得到的双边网格最后插值的方法上采样即可。具体算法流程如下：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328205234.png" alt="" /><figcaption>1594713161307</figcaption>
</figure>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>传统图像处理</category>
      </categories>
  </entry>
  <entry>
    <title>图像处理-传统去噪算法汇总</title>
    <url>/posts/24335/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="传统去噪算法">传统去噪算法</h1>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210606193900.png" alt="image-20210606193900333" style="zoom: 67%;" /></p>
<h2 id="图像噪声">图像噪声</h2>
<h3 id="噪声种类">噪声种类</h3>
<p><a href="https://blog.csdn.net/weixin_40446557/article/details/81451651">图像噪声</a></p>
<ul>
<li>高斯白噪声：分布符合高斯分布的噪声，功率谱密度服从均匀分布，类似于白光中包含了可见光中所有频率 并且在各个频率上的功率谱密度都是一样的。高斯白噪声与光强无关，无论何时噪声的平均水平都是0。</li>
<li>泊松噪声（散粒噪声）：符合泊松分布的噪声模型。泊松噪声随着光强增大，平均噪声也增大，但是信噪比其实随着光强增大而增大了的。</li>
<li>椒盐噪声：椒盐噪声主要来自于传输介质和记录设备不完善等导致。</li>
<li>乘性噪声：乘性噪声一般由信道不理想引起，它们与信号的关系是相乘，信号在它在，信号不在他也就不在。</li>
</ul>
<blockquote>
<p>泊松分布适合于描述单位时间内随机事件发生的次数的概率分布，如某一服务设施在一定时间内受到的服务请求的次数。因为光是由离散的光子构成（光的粒子性），到达光电检测器表面的量子数目存在统计涨落，因此，图像监测具有颗粒性，这种颗粒性造成了图像对比度的变小以及对图像细节信息的遮盖，我们对这种因为光量子而造成的测量不确定性成为图像的泊松噪声</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210701112412.png" alt="image-20210701112412122" style="zoom:50%;" /></p>
<h3 id="高斯白噪声">高斯白噪声</h3>
<p>通常讨论的高斯白噪声是 加性 高斯白噪声（AWGN ），它有如下几个特点：</p>
<ol type="1">
<li>加性</li>
<li>高斯</li>
<li>白噪声：功率谱密度服从均匀分布，类似于白光中包含了可见光中所有频率 并且在各个频率上的功率谱密度都是一样的。</li>
</ol>
<p>加性噪声有一个很重要的性质：</p>
<p><strong>每个像素点的噪声 在 空域 和 时域都是独立无关的</strong>，即当前像素的噪声值，和它领域的像素的噪声值 是无关的变量。在时域是指，同一个像素位置，不同时间拍的照，噪声强度也是相互独立的。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210630214759.png" alt="" /><figcaption>image-20210630214759894</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210630215237.png" alt="" /><figcaption>image-20210630215237457</figcaption>
</figure>
<p>其中 u 为干净的图像，n 为高斯白噪声。常用的均值滤波的方法，是多个像素点取平均，每个像素的噪声是独立无关的，加入这几个像素的 u(x) 都一样，即是相似像素。那么 多个像素值取平均 后 分布变为：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210630215244.png" alt="" /><figcaption>image-20210630215244594</figcaption>
</figure>
<p>如果 u(xi) 是常数，那么加权平均后的 u(x) 不变；对于第二项，噪声的方差明显成比例的缩小。 例如 一个噪声分布 nx(0, 1) ny(0,1) 对他俩加权平均 0.5 x nx 之后 分布变为 nx(0, 0.5^2) ny(0, 0.5^2) 两个乘系数后的分布再求和 n(0, 0.5^2 + 0.5^2) = n(0, 0.5) 所以均值后方差缩小了很多，就得到更干净的图像。</p>
<p>上述理论也是 目前各种 空域去噪方法 例如 均值滤波，高斯滤波， 非局部均值去噪 的理论基础。</p>
<p>像素取均值可以使高斯噪声方差成比例的缩小，但是上述推导中 是假设 加权的像素原始灰度值一致，最后均值滤波后才能保证 不改变原有信号，同时使得噪声的方差成比例缩小。但是 领域的均值像素他们原始的 u(x）不一定相似，所以均值滤波一定成度上也会使得原图的纹理和边缘模糊，便有了以下方法的改进来尽可能保留细节。</p>
<p><strong>高斯滤波对领域像素加上了权重来避免过多的模糊原始的信息</strong></p>
<p><strong>非局部均值滤波，根据相似块的相似度来加权</strong></p>
<p><strong>双边滤波同时考虑空域和值域相似性，所以它的细节保留效果更好</strong></p>
<p><strong>多帧去噪方法则利用了噪声时域上的独立性，同时如果帧之间像素完全对齐，那么这种完全没有模糊原始细节的问题</strong></p>
<h2 id="变换域去噪">变换域去噪</h2>
<h3 id="图像频谱图">图像频谱图</h3>
<p>将图像进行二维傅里叶变换，可以得到图像的频谱图</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">I=imread(<span class="string">&#x27;C:\Users\10729\Desktop\1.PNG&#x27;</span>);</span><br><span class="line">I=rgb2gray(I);</span><br><span class="line">I=im2double(I);</span><br><span class="line"><span class="comment">% [w, h] = size(I);       </span></span><br><span class="line"><span class="comment">% I = ones(w,h) * 0.5;   %频谱图中心有个亮点，其他全0</span></span><br><span class="line"><span class="comment">% I = randn(w,h);        %高斯噪声的频谱图，也是高斯，即每个频率带所占的比重也是个高斯分布</span></span><br><span class="line">F=fft2(I);  </span><br><span class="line">F=fftshift(F); <span class="comment">%% 将0频率点移到中间</span></span><br><span class="line">F=<span class="built_in">abs</span>(F);      </span><br><span class="line">T=<span class="built_in">log</span>(F+<span class="number">1</span>);    <span class="comment">%% 压缩一下，否则直流分量太多</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先，图像的频谱图实际是和空域图像的梯度大小和方向息息相关。频谱图中心代表 频率为0的直流分量，两个轴一个为 x 方向的频率，一个是 y 方向的频率。但是不存在负频率。我理解的频谱图应该是 中心对称的。距离中心 O 越远代表频率越高，即空域图中梯度越大（离x轴越远代表该方向的频率越大，离y轴越远表示另一方向的频率越大，可以简单理解为 dx dy）。</p>
<p>频谱图的：</p>
<ul>
<li><p>x, y 轴：代表两个方向的频率（可以理解为两个方向的梯度）</p></li>
<li><p>距离轴的距离：中心处为直流分量，距离轴越远表示频率越大</p></li>
<li><p>x, y 唯一确定了一个频率带</p></li>
<li><p>频谱图的像素值大小：代表能量的大小 例如 全 0.1 的图像的频谱图中心直流分量 &gt; 全05的图像的频谱中心直流分量</p></li>
<li><p>空域图中 相同频率的像素越多，那么在频谱图中聚集起来能量也会越大。例如 将图像尺寸缩放前后，大图的直流分量幅值更大</p></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210827170604.png" alt="image-20210630212324839" style="zoom:50%;" /></p>
<h3 id="高斯白噪声正交变换">高斯白噪声正交变换</h3>
<p><strong>结论</strong>：高斯白噪声的正交变换（傅里叶变换）任然是高斯白噪声；或者说 高斯白噪声的正交变换系数同样是高斯白噪声</p>
<p>可以做如下试验，取一个含有高斯白噪声的图，把他看作空域图像。对他做傅里叶变换，得到一个频谱图，发现它个变换之前的分布类似。即 上述结论。</p>
<p><strong>直观的理解</strong>：对于图像空域像素中每个点，该点的像素值是个符合高斯分布的随机值，它和它领域的点是独立互不相关的，因此它领域的点也是个高斯随机值。那么他俩做差即为图像的梯度，这个差值 = 高斯分布1 - 高斯分布2，所以差值的大小依然服从高斯分布 。而根据频谱图的直观理解，频带 近似于 梯度。高斯图像的梯度幅值是高斯分布，那么可以等同理解为 高斯图的频谱图也是 高斯分布的，即再每个频带上的像素比例是个不确定的比例，它服从同样的高斯分布，只不过变换前后 像素值大小的物理意义变了。详细证明：<a href="https://blog.csdn.net/qq_33552519/article/details/108372176">证明</a></p>
<h3 id="常用的频域滤波方法">常用的频域滤波方法</h3>
<h4 id="低高带通滤波">低/高/带通滤波</h4>
<p>这个就是利用 频谱图 分离频率的特性，使用一个掩码对 频谱图指定的频带进行过滤。然后反变换，使用高斯高通滤波可以 起到瑞华边缘的作用，高斯低通滤波可以起到模糊的作用</p>
<h4 id="阈值滤波">阈值滤波</h4>
<p>首先，常规的干净图像，它的频谱图在直流分量应该有较大的幅值。而高斯白噪声的正交变换后的频谱图依然是 同分布的高斯白噪声，例如下图：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210701200050.png" alt="" /><figcaption>image-20210701200050585</figcaption>
</figure>
<p>叠加有高斯白噪声的图像的频谱图相当于 在 相对原图 在每个频带 又叠加了一个高斯白噪声。但是这个高斯白噪声的幅值分布范围是是在 3 sigma 以内，当噪声sigma较小时，可以采用一个阈值法将频谱图 <strong>较低 幅值</strong> 的地方直接设置为0，认为这些是噪声对应的频带，但是这样无法去除隐藏在 直流分量中的噪声，所以不彻底。并且当噪声sigma较大时，也会使得 噪声和 部分图像的其他分量混合导致误杀，使图像模糊。</p>
<h4 id="协同滤波">协同滤波</h4>
<p>协同滤波其实是在 频域 中利用了 多帧去噪的原理。上述阈值滤波存在的问题是，当噪声幅值较大时，会和边缘细节混合在一起，导致阈值无法区分。协同滤波的关键步骤： 高斯白噪声无论变换几次，依然是同分布的，即幅值不会增大</p>
<p>以一个一维度的原始干净信号（干净图像的某一行为例子）</p>
<ol type="1">
<li>干净的原始一维信号正交变换后如左上角图所示，大部分平缓低频信号 （将直流分量置0了，免得影响观察（红线））</li>
<li>在干净信号上加较大方差的高斯噪声后，噪声在各个频带上的能量都有，且大小可以和干净信号的幅度相当，无法阈值滤除</li>
<li>取多个这种信号组成一个二维数据，现在原始维度上正交变换，再在新增的叠加维度上正交变换，然后取第一行，在新增维度上正交变换后 直流分量聚集向第一行（这里又是直流分量了，因为叠加的是相同的原始信号，他们在每个频带上的能量分布是一样的），所以在新增维度上正交变换会把每个原始信号的每个频带的能量聚集在第一行。取出此时的第一行显示。</li>
<li>从上述看出 <strong>新增维度得是相似的原始信号，这样他们在对应频带上能量分布才能一致，这样在新增维度变换时，可以将这个一致的能量当作直流信号聚集起来。否则会引入新的高频信息，但是这部分高频信息如果无法和噪声区分就会被滤掉</strong>，而噪声无论正交变换几次分布不变，能量不变。这样就拉开了噪声和信号能量之间的差距，再通过阈值即可得到较好的效果</li>
<li>为什么不直接像素位置取平均呢？<strong>如果仅仅是相似的图像块，直接取平均很明显会情况更糟</strong>，而且频域取平均和时域取平均没区别。</li>
<li>协同滤波中相似块的堆叠 其实和 非局部均值滤波思想类似，只不过<strong>一个是在时域对相似块的利用，一个在频域利用</strong>，后者计算复杂度低很多，但是对细节保留效果不好，因为<strong>该算法本身并没有把噪声的方差缩小</strong>，而无论我们怎样把低频分量的能量集中，总会有一些细节部分的的能量会被淹没在噪声当中，无法恢复。</li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210701213303.png" alt="" /><figcaption>image-20210701213302939</figcaption>
</figure>
<h4 id="维也纳滤波">维也纳滤波</h4>
<p><a href="./图像处理-逆滤波和维纳滤波.md">图像处理-逆滤波和维纳滤波</a></p>
<p><strong>维纳滤波</strong>是在频域中处理图像的一种算法，是一种非常经典的图像增强算法，<strong>不仅可以进行图像降噪，还可以消除由于运动等原因带来的图像模糊</strong>。运动模糊可以在空域建模为卷积退化，将退化图像变换到频域，可以将 卷积 分解为点乘，然后寻求一个和干净图像的频谱均方差最小的解。将卷积信号设置为 1 即 不存在运动模糊时，就变为单纯的去噪方法，为下式：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210701214422.png" alt="" /><figcaption>image-20210701214422250</figcaption>
</figure>
<p>对于输入图像的功率普，干净图像的功率谱接近可以近似，噪声的功率谱使用固定方差去生成噪声图然后计算功率谱（所以这就得知道噪声的方差否则去噪效果不好）</p>
<p>从上式直观的看，其实<strong>和前面的阈值滤波有点相似，本质上也是对噪声频谱的幅值进行抑制</strong>，只不过这个通过优化推导出的是最优解。当某个频带 原始信号能量 远大于 噪声信号能量，那么幅值系数接近于1不抑制。当原始信号能量 远小于 噪声信号能量，系数接近于0，抑制噪声。<strong>维纳收缩</strong></p>
<h3 id="同态滤波">同态滤波</h3>
<p><a href="./图像处理-同态滤波.md">图像处理-同态滤波</a></p>
<p>其实这是一种 频域图像增强方法。低光照图 = 反射分量 x 纹理值 ，反射分量比较平滑对应低频分量，而纹理对应高频。首先取对数 将乘变为加 然后 变换到频域使用 高通滤波 最后 恢复。即可剔除反射分量，提亮。</p>
<h2 id="空域去噪">空域去噪</h2>
<h3 id="高斯滤波">高斯滤波</h3>
<p>高斯滤波可以单独分为 x 方向和 y 方向分别卷积，从而降低计算的复杂度，时域卷积也可以在空域加速</p>
<h3 id="双边滤波">双边滤波</h3>
<p>基本原理是 空域距离和像素的值域相似度相结合， 相对高斯滤波是一种保边滤波，但是会有梯度反转的卡通效应。并且运算量大，但是有加速算法</p>
<h3 id="引导滤波">引导滤波</h3>
<p>基本原理有两点，首先输出假设为输入图像的局部窗口的线性表示，其次是设定一个指导图像。最终优化输出图像和指导图像的 L2 损失，是个凸优化问题。最终的效果就是 在局部高方差的区域 不平滑，在低方差的区域做均值。当指导图像为输入图像时他就是保边滤波。</p>
<h3 id="非局部均值滤波">非局部均值滤波</h3>
<p>NL 考虑了和周围区域的相似度</p>
<h3 id="tv变分去噪">TV变分去噪</h3>
<p>有一系列的TV损失的变种，例如变分去噪法，非局部变分去噪，双噪声相似的非局部变分去噪 <a href="./图像处理-双噪声相似性的去噪方法.md">图像处理-双噪声相似性的去噪方法.</a></p>
<p>## 混合域去噪</p>
<h3 id="bm3d">BM3D</h3>
<p><strong><a href="https://blog.csdn.net/qq_33552519/article/details/108632146">BM3D去噪方法讲解</a></strong></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210701223354.png" alt="" /><figcaption>image-20210701223354016</figcaption>
</figure>
<p>BM3D 方法其实是 协同滤波 和 维纳滤波的结合。分为两个步骤：</p>
<p>步骤一：</p>
<ol type="1">
<li>在图像领域内寻找相似块堆叠成一个 3D 块进行协同滤波，采用硬阈值的方法过滤。同时统计 非0的像素点的个数</li>
<li>逆变换，并将图像块还原到原来的位置。（由于一个图像块可能处在不同的 3D图像组中，因此前面统计的系数可用于加权融合 来自不同滤波组的同一个图像块）</li>
<li>上述步骤后得到一个初步的滤波结果</li>
</ol>
<p>步骤二：</p>
<ol type="1">
<li>有了初步滤波结果，重新匹配相似块（由于初步滤波后，相似度量结果更可靠）</li>
<li>将相似块组成 3D 组进行变换，类似协同滤波，但是变换后不适用 硬阈值 过滤，因为硬阈值始终存在误杀的情况。由于前面已经有了一个初步硬阈值滤波后的结果，因此 结合 维纳滤波的 维纳萎缩法，已知原始干净图像的信号能量（即初步滤波后的结果）和 噪声的能量（用方差模拟），那么可以更精确地对 新的 3D组 的系数进行抑制。</li>
<li>抑制完毕 逆变换 ….</li>
</ol>
<h2 id="tv-类去噪">TV 类去噪</h2>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>传统图像处理</category>
      </categories>
  </entry>
  <entry>
    <title>图像处理-同态滤波</title>
    <url>/posts/65493/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="同态滤波">同态滤波</h1>
<p><a href="https://zhuanlan.zhihu.com/p/161667344">参考链接</a></p>
<h2 id="基本原理">基本原理</h2>
<p>同态变换一般是指将非线性组合信号通过某种变换，使其变成线性组合信号，从而可以更方便的运用线性操作对信号进行处理。</p>
<p>所谓非线性组合信号，举例来说，比如 z(t) = x(t) y(t)，两个信号相乘得到组合信号，由于时域相乘等价于频率域卷积，所以无法在频率域将其分开。但是我们应用一个log算子，对两边取对数，则有： log(z(t)) = log(x(t)) + log(y(t))，这样一来，就变成了线性组合的信号，log(x(t)) 和 log(y(t)) 时域相加，所以频域也是相加的关系，如果它们的频谱位置不同，就可以傅里叶变换后较好的分开，以便进行后续的分别的操作，比如应用高、低通滤波或者其他手工设计的滤波器等，然后再将结果傅里叶反变换，得到处理过的 ，在取幂，就可以得到最终的处理结果。</p>
<h2 id="图像中的同态滤波">图像中的同态滤波</h2>
<p>在图像处理中，常常遇到动态范围很大但是暗区的细节又不清楚的现象，我们希望增强暗区细节的同时不损失亮区细节，一般来说，我们可以将图像f(x,y)建模成 <strong>照射强度（illumination）</strong> i(x,y) 和 <strong>反射强度（reflection）</strong> r(x,y)的乘积，所以有：</p>
<figure>
<img src="C:/Users/10729/AppData/Roaming/Typora/typora-user-images/image-20210606115221662.png" alt="" /><figcaption>image-20210606115221662</figcaption>
</figure>
<p>一般来说，自然图片的光照一般是均匀渐变的，所以i应该是低频分量，而不同物体对光的反射是具有突变的，所以r是高频分量。现在我们对两边取对数，并做Fourier变换，得到线性组合的频率域。</p>
<figure>
<img src="C:/Users/10729/AppData/Roaming/Typora/typora-user-images/image-20210606115234960.png" alt="" /><figcaption>image-20210606115234960</figcaption>
</figure>
<p>我们希望对低频能量进行压制（抑制掉 光照分量），这样就降低了动态范围，而要对高频进行提高，这样就增强了图像的对比度，示意图如下：</p>
<figure>
<img src="C:/Users/10729/AppData/Roaming/Typora/typora-user-images/image-20210606115250493.png" alt="" /><figcaption>image-20210606115250493</figcaption>
</figure>
<p>所以采用的滤波器为：</p>
<figure>
<img src="C:/Users/10729/AppData/Roaming/Typora/typora-user-images/image-20210606115300446.png" alt="" /><figcaption>image-20210606115300446</figcaption>
</figure>
<p>操作完成后在按照之前介绍的步骤，反变换，求幂，即可得到处理后的图像，整个过程的流程图如下：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210606115350.png" alt="" /><figcaption>image-20210606115350488</figcaption>
</figure>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>传统图像处理</category>
      </categories>
  </entry>
  <entry>
    <title>图像处理-图像分割</title>
    <url>/posts/59399/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="图像分割">图像分割</h1>
<p>简单了解一下传统图像分割中常用的两个算法</p>
<h2 id="ostu">OSTU</h2>
<p>大津法自适应图像二值化方法。自适应的计算二值化的分割阈值。他的原理是：将图像发为前景和背景区域，大于阈值的为前景，小于阈值的背景。设置某个阈值，计算前景区域的像素均值w1 背景区域的像素均值 w2 以及全图的像素均值 w ，期望 w 和 w1 w2 的方差最大，即类间方差最大化的分割阈值即为所求。</p>
<h2 id="标记分水岭">标记分水岭</h2>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>传统图像处理</category>
      </categories>
  </entry>
  <entry>
    <title>图像处理-形态学滤波</title>
    <url>/posts/59990/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="形态学滤波">形态学滤波</h1>
<h2 id="腐蚀">腐蚀</h2>
<p>操作过程：构建一个核，并指定核的锚点，用该核与图像卷积，计算核覆盖区域的像素点最小值，将其作为图像在锚点位置的像素值 效果：使暗的更暗</p>
<p><img src="C:/Users/10729/AppData/Roaming/Typora/typora-user-images/image-20210609200614322.png" alt="image-20210609200614322" style="zoom:50%;" /></p>
<h2 id="膨胀">膨胀</h2>
<p>操作过程：构建一个核，并指定核的锚点，用该核与图像卷积，计算核覆盖区域的像素点最大值，将其作为图像在锚点位置的像素值 效果：使亮的更亮</p>
<p><img src="C:/Users/10729/AppData/Roaming/Typora/typora-user-images/image-20210609200712018.png" alt="image-20210609200712018" style="zoom:50%;" /></p>
<h2 id="开运算">开运算</h2>
<p>先腐蚀后膨胀，消除小物体和小连接点</p>
<h2 id="闭运算">闭运算</h2>
<p>先膨胀后腐蚀，连接缝隙，填充小黑洞</p>
<h2 id="形态学梯度">形态学梯度</h2>
<p>基本梯度：膨胀的图 - 腐蚀的图</p>
<p>内部梯度：原图 - 腐蚀的图</p>
<p>外部梯度：膨胀的图 - 原图</p>
<p>效果：<strong>保留物体边缘轮廓</strong></p>
<h2 id="顶帽">顶帽</h2>
<p>原图 - 开运算 （这个内部梯度的区别，内部梯度只是腐蚀，因此物体的轮廓会小一圈，而开运算是去掉了小的点，原本物体的大小不会变化因为他是腐蚀+膨胀）</p>
<p>获取：获取图像小区域，例如比较小的背景，会被开运算去掉，再用原图一减提取的便是背景</p>
<p><img src="C:/Users/10729/AppData/Roaming/Typora/typora-user-images/image-20210609201359570.png" alt="image-20210609201359570" style="zoom:50%;" /></p>
<h2 id="黑帽">黑帽</h2>
<p>闭运算 - 原图 闭运算突出了原本暗的区域，或者连接的空区域，那么黑帽 就是 凸显了暗区域</p>
<p><img src="C:/Users/10729/AppData/Roaming/Typora/typora-user-images/image-20210609201609775.png" alt="image-20210609201609775" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>传统图像处理</category>
      </categories>
  </entry>
  <entry>
    <title>图像处理-拉普拉斯融合</title>
    <url>/posts/63908/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="拉普拉斯融合">拉普拉斯融合</h1>
<p><a href="https://www.jianshu.com/p/e3570a9216a6">参考链接</a></p>
<ol type="1">
<li>为什么在处理高斯金字塔的时候需要采用滤波呢，直接下采样不可以吗？ 如果把图像看做频率信号的话，直接进行下采样则会出现采样不足的情况，消除这种情况的方法是采用低通滤波器（高斯滤波器）对图像进行滤波，将采样不足的高频信号过滤掉，这样在进行下采样的时候就保证了不出现采样不足的情况。</li>
<li>拉普拉斯金字塔的理解？ 拉普拉斯金字塔可以看做一个带通滤波器，在每一级都保留了图像某个频率值附近的成分。（这一点与高斯金字塔不同，高斯金字塔是低通金字塔）两个低通滤波器的差值就构成了一个带通滤波器。高斯金字塔构建过程中的 低通 +下采样必然会丢失部分频率的信息，因此通过高斯金字塔可以记录丢失的信息，所以高斯金字塔可以用于图像的还原</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210606222608.png" alt="image-20210606222607987" style="zoom: 50%;" /></p>
<h2 id="拉普拉斯算子">拉普拉斯算子</h2>
<p>其实拉普拉斯算子就是一个二阶微分算子，可用于图像锐化，因为二阶微分可以检测出图像的突变边缘，用于图像锐化，而不是缓变边缘。拉普拉斯算子在泊松融合中也有应用。</p>
<h2 id="拉普拉斯融合-1">拉普拉斯融合</h2>
<p>融合的方法使用的拉普拉斯金字塔融合的方式。</p>
<ol type="1">
<li><p>首先对每张图像分别构建 高斯金字塔 和 拉普拉斯金字塔。</p></li>
<li><p>高斯金字塔 构建过程就是 模糊 + 下采样 =&gt; 高一层的图像。</p></li>
<li><p>拉普拉斯金字塔构建的方法是，将步骤2的高斯图再上采样 + 模糊 ，这样相对原始没 模糊下采样的图 肯定有信息损失。拉普拉金子塔就是保存这个残差。即 原图 - 模糊上采样后的结果 4. 按照上述方法可知，高斯金字 N 那么拉普拉斯金字塔就是 N-1。需要保留高斯金子塔最顶层的图像，后面用于恢复。</p></li>
<li><p>融合就是，将每张图的金子塔的同一层 拉普拉斯结果融合，加权系数为 他们对应的 高斯金子塔的值。整个过程就看作每张图相同层的拉普拉斯加权平均吧，权重是高斯金子塔的值。最顶层的就直接是 高斯图的平均。</p></li>
<li><p>按照5最后获得的结果就是，除了最顶层是 高斯图，其他层都是拉普拉斯，将高斯 上采样+模糊+拉普拉斯 即可恢复</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210425163023.png" alt="" /><figcaption>image-20201223210726030</figcaption>
</figure></li>
</ol>
<h2 id="其他融合方法">其他融合方法</h2>
<p><a href="https://blog.csdn.net/ZHANG2012LIANG/article/details/85031065">图像融合</a></p>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>传统图像处理</category>
      </categories>
  </entry>
  <entry>
    <title>图像处理-指导滤波</title>
    <url>/posts/58737/</url>
    <content><![CDATA[<span id="more"></span>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>传统图像处理</category>
      </categories>
  </entry>
  <entry>
    <title>图像处理-泊松融合</title>
    <url>/posts/44214/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="泊松方程">泊松方程</h1>
<p>https://zhuanlan.zhihu.com/p/68349210</p>
<h2 id="什么是泊松方程">什么是泊松方程</h2>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210413095650.png" alt="image-20210413095650362" style="zoom:67%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210413095715.png" alt="image-20210413095715839" style="zoom:67%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210413095740.png" alt="image-20210413095740231" style="zoom: 67%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210413095828.png" alt="image-20210413095828715" style="zoom:67%;" /></p>
<p>所以需要知道图像周围一圈的边界值，那么上述的方程就有解了。这就是边界条件。边界条件一般有两种：</p>
<ul>
<li><strong>Neumann 边界</strong>，译为纽曼边界或黎曼边界，给出函数在边界处的二阶导数值；</li>
<li><strong>Dirichlet 边界</strong>，狄利克雷边界，给出边界处函数在边界处的实际值。</li>
</ul>
<p>但给定边界条件之后，就可以有 16 个方程式组成的方程组了，矩阵化表示此方程组之后，得到形式为 Ax = b</p>
<p>可以通过离散正弦变换加速泊松方程的求解，复杂度为N log(N)</p>
<h2 id="泊松融合">泊松融合</h2>
<p>泊松融合的思路就是 将源图像的目标图像的 梯度 图 使用 mask 拼接后，使用泊松方程把mask后的梯度图还原出融合后的图</p>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>传统图像处理</category>
      </categories>
  </entry>
  <entry>
    <title>图像处理-直方图均衡化</title>
    <url>/posts/25754/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="图像直方图">图像直方图</h1>
<h2 id="直方图均衡化">直方图均衡化</h2>
<p>https://zhuanlan.zhihu.com/p/44918476</p>
<p>假如图像的灰度分布不均匀，其灰度分布集中在较窄的范围内，使图像的细节不够清晰，对比度较低。直方图均衡化，对图像进行非线性拉伸，是一种灰度的变换过程，将当前的灰度分布通过一个变换函数，变换为范围更宽、灰度分布更均匀的图像。这样，原来直方图中间的峰值部分对比度得到增强，而两侧的谷底部分对比度降低，<strong>输出图像的直方图是一个较为平坦的直方图。</strong></p>
<h3 id="原理">原理</h3>
<p><img src="https://pic4.zhimg.com/80/v2-f6e89ba884fdb32d3aae4f2d19a4688f_720w.jpg" alt="img" style="zoom:50%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210412214539.png" alt="image-20210412214531999" style="zoom:50%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210412214543.png" alt="image-20210412214543352" style="zoom:50%;" /></p>
<h3 id="计算步骤">计算步骤</h3>
<ol type="1">
<li>计算原始图像的直方图</li>
<li>计算累计直方图 CDF</li>
<li>映射为 256 /（m x n ） x CDF</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># calculate histogram</span></span><br><span class="line">hists = histogram(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># caculate cdf</span></span><br><span class="line">hists_cumsum = np.cumsum(hists)</span><br><span class="line">const_a = level / (m * n)</span><br><span class="line">hists_cdf = (const_a * hists_cumsum).astype(<span class="string">&quot;uint8&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># mapping</span></span><br><span class="line">img_eq = hists_cdf[img]</span><br></pre></td></tr></table></figure>
<h2 id="直方图匹配">直方图匹配</h2>
<p>https://blog.csdn.net/qq_31347869/article/details/89514253</p>
<p>如果希望得到具有规定形状的直方图，就需要用到一种特殊的处理方法：直方图匹配 (直方图规定化)。原理很简单，有了参考图，可以计算它到规范化后的变换 ，同时也可以计算 低光图到 规范化后的变换。r -&gt; s -&gt; z s是中间规范化后的像素值 。最后求逆映射的时候不用显式的求，找最近的即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">img = cv2.imread(<span class="string">&#x27;C:\\Users\\admin\\Desktop\\original_img3\\testimg\\lena_300_500.jpg&#x27;</span>)</span><br><span class="line">ref = cv2.imread(<span class="string">&#x27;C:\\Users\\admin\\Desktop\\original_img3\\testimg\\messi_300_500.jpg&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">out = np.zeros_like(img)</span><br><span class="line">_, _, colorChannel = img.shape</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(colorChannel):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    hist_img, _ = np.histogram(img[:, :, i], <span class="number">256</span>)   <span class="comment"># get the histogram</span></span><br><span class="line">    hist_ref, _ = np.histogram(ref[:, :, i], <span class="number">256</span>)</span><br><span class="line">    cdf_img = np.cumsum(hist_img)   <span class="comment"># get the accumulative histogram</span></span><br><span class="line">    cdf_ref = np.cumsum(hist_ref)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        tmp = <span class="built_in">abs</span>(cdf_img[j] - cdf_ref)</span><br><span class="line">        tmp = tmp.tolist()</span><br><span class="line">        idx = tmp.index(<span class="built_in">min</span>(tmp))   <span class="comment"># 找近似 即为逆映射</span></span><br><span class="line">        out[:, :, i][img[:, :, i] == j] = idx</span><br><span class="line"> </span><br><span class="line">cv2.imwrite(<span class="string">&#x27;C:\\Users\\admin\\Desktop\\lena.jpg&#x27;</span>, out)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Done&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="局部对比度增强">局部对比度增强</h2>
<p>就是将全局直方图均衡的思想应用于邻域直方图处理中</p>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>传统图像处理</category>
      </categories>
  </entry>
  <entry>
    <title>图像处理-相机响应函数</title>
    <url>/posts/1886/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="相机响应模型">相机响应模型</h1>
<p>这是在阅读下面这个文献是遇到的概念</p>
<blockquote>
<p>A New Low-Light Image Enhancement Algorithm using Camera Response Model ∗</p>
</blockquote>
<h2 id="相机响应曲线">相机响应曲线</h2>
<p>首先，物体在反射光进入相机后，相机成像具有一个响应曲线，理论上响应曲线应该是对不同波段不同强度的光能线性还原。但是实际为一个S曲线，例如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210606215823.png" alt="image-20210606215822976" style="zoom:50%;" /></p>
<p>横坐标为 实际的进入相机的亮度，而纵坐标代表感光元件量化后的像素值强度，例如纵坐标为50就代表成像后的像素值为0.5x255…同时上图中 ISO 的调节可以将相机响应曲线平移，但是并不能改变相机响应曲线的形状。在x轴上平移就使得相机对不同的输入光强更敏感。ISO（感光度）</p>
<p>因此相机响应函数就是指的上面这个曲线</p>
<p><strong>ISO 控制传感器自身对亮度的感知范围</strong>，而 <strong>快门+光圈 = 曝光</strong>，快门控制进光时间，光圈代表进光的窗口大小</p>
<h2 id="方法">方法</h2>
<p>LIME以及其他使用Retinex分解的方法中，都认为 I = V X R 这个 V 是图像的亮度（或者叫曝光，曝光本质就是进入摄像机的总的光量），但其实更准确的说，这个 V 应该是物体反射后的光的强度。但是经过成像后，是有个相机响应模型的后处理，因此 这篇文章中认为 I = f(V) x R =&gt; R = I / f(V) =&gt; 其中V使用和LIME中类似的估计。而 f 函数是相机的响应曲线，对于固定的相机，这个响应曲线应该是固定的，因此在 一个数据集上 去 标定相机响应曲线的参数即可。</p>
<p>那么增强的步骤就是：估计 亮度 V 带入抑制的相机响应模型对图像提亮</p>
<p>（具体公式还得详细推导）</p>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>传统图像处理</category>
      </categories>
  </entry>
  <entry>
    <title>图像处理-逆滤波和维纳滤波</title>
    <url>/posts/46151/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="维纳滤波">维纳滤波</h1>
<h2 id="逆滤波">逆滤波</h2>
<p>用于不含噪声的图像去模糊</p>
<h2 id="维纳滤波-1">维纳滤波</h2>
<p>用于含有噪声的图像去模糊 以及去噪</p>
<p><a href="https://blog.csdn.net/weixin_44580210/article/details/105106563">参考链接</a></p>
<h3 id="基本原理">基本原理</h3>
<p><a href="https://blog.csdn.net/weixin_44580210/article/details/105106563">维纳滤波详解</a></p>
<p>在图像拍摄过程中由于各种原因会造成图像退化，图像退化模型如下：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210630222253.png" alt="" /><figcaption>image-20210630222253821</figcaption>
</figure>
<p>其中，⋆ 为卷积符号，f ( x , y ) 为输入图像，g ( x , y ) 为退化图像，h ( x , y ) 为退化函数，η ( x , y ) 为加性噪声，将上式进行傅里叶变换有（根据傅里叶变换的特性，<strong>空间域中的卷积相当于频率域中的乘积</strong>）：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210630222401.png" alt="" /><figcaption>image-20210630222401374</figcaption>
</figure>
<p><strong>(1) 如果不考虑退化函数</strong>，图像退化模型就简化为图像噪声模型</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210630222436.png" alt="" /><figcaption>image-20210630222435984</figcaption>
</figure>
<p>图像增强问题成为单纯的图像去噪问题，可以通过空间域滤波等众多方法解决。</p>
<p><strong>(2) 如果不考虑加性噪声</strong>，图像退化模型就简化为</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210630222453.png" alt="" /><figcaption>image-20210630222453569</figcaption>
</figure>
<p>这种问题可以通过逆滤波解决，即通过傅里叶变化以及阵列除法即可获得恢复后的图像频谱：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210630222524.png" alt="" /><figcaption>image-20210630222524519</figcaption>
</figure>
<p>但是对于退化模型 H 如何获取呢？数字图像处理中有 观察估计法，试验估计法和建模估计。例如建模估中可以通过运动数学模型将退化函数构造为：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210630222732.png" alt="" /><figcaption>image-20210630222732217</figcaption>
</figure>
<p><strong>(3) 如果退化函数和加性噪声都考虑</strong>，空域滤波器无法解决图像退化问题，逆滤波效果因为噪声的存在会变得非常差，这个时候就需要用到<strong>维纳滤波</strong>，（维纳滤波的推导写在结论中）维纳滤波公式如下：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210630222742.png" alt="" /><figcaption>image-20210630222742064</figcaption>
</figure>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>传统图像处理</category>
      </categories>
  </entry>
  <entry>
    <title>Briinging-old-photo</title>
    <url>/posts/55304/</url>
    <content><![CDATA[<span id="more"></span>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频修复</category>
      </categories>
  </entry>
  <entry>
    <title>BM3D</title>
    <url>/posts/44176/</url>
    <content><![CDATA[<span id="more"></span>
<p>https://blog.csdn.net/qq_33552519/article/details/108632146</p>
<p>https://www.codenong.com/cs105736895/</p>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频去噪</category>
      </categories>
  </entry>
  <entry>
    <title>图像视频去噪综述</title>
    <url>/posts/62084/</url>
    <content><![CDATA[<span id="more"></span>
<p>https://segmentfault.com/a/1190000021721649</p>
<p>https://soaringleefighting.github.io/2019/05/29/%E3%80%90CV%E7%B3%BB%E5%88%97%E3%80%91%E5%9B%BE%E5%83%8F%E5%8E%BB%E5%99%AA%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6%EF%BC%88%E5%8E%BB%E5%99%AA+%E9%94%90%E5%8C%96%EF%BC%89/</p>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频去噪</category>
      </categories>
  </entry>
  <entry>
    <title>Domain Adaptation for Image Dehazing</title>
    <url>/posts/16507/</url>
    <content><![CDATA[<span id="more"></span>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频去雾</category>
      </categories>
  </entry>
  <entry>
    <title>ALEN_Attention-based</title>
    <url>/posts/22637/</url>
    <content><![CDATA[<span id="more"></span>
<p>Attention-based network for low-light image enhancement</p>
<h2 id="主要贡献">主要贡献</h2>
<ul>
<li>设计了一个端到端的应用于原始图像的增强网络，结合了 通道注意力 和 空间注意力模式，结合了局部和全局信息。</li>
<li>为了减少信息损失，设计了一个 ISL层 来 取代 max pooling</li>
<li>在SID数据集上评估了算法的有效性</li>
</ul>
<h2 id="non-local-operation">Non-local operation</h2>
<p>原始文献：Non-Local neural networks</p>
<p>​ 传统的卷积神经网络 其实只关注 局部图像的相关信息，而如果要获得全局信息，要通过很多层的卷积堆叠来扩大感受野，进而使网络形成全局信息的关注。全连接就是non-local的，而且是global的。但是全连接带来了大量的参数，给优化带来困难。基于此，作者根据 传统计算机视觉方法中的 非局部均值去噪滤波 的思想，设计了应用于CNN的 non-local操作。</p>
<ul>
<li>non-local operations通过计算任意两个位置之间的交互直接捕捉远程依赖，而不用局限于相邻点，其相当于构造了一个和特征图谱尺寸一样大的卷积核, 从而可以维持更多信息。</li>
<li>non-local可以作为一个组件，和其它网络结构结合，用于其他视觉任务中</li>
</ul>
<h3 id="非局部均值去噪滤波">非局部均值去噪滤波</h3>
<p>​ 传统的均值滤波的方法是 取目标像素位置的 领域区域的所有像素均值作为该位置滤波后的结果。而非局部的特点就是根据根据该局部区域和全局区域的相似度 作为加权系数来 加权平局。具体的过程如下图</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424115930.png" alt="" /><figcaption>1590138706176</figcaption>
</figure>
<p>w(x,y)一般定义为一个与欧式距离(2范数)相关的函数，设x，y的邻域宏块的欧式距离为d。对于待求位置x处的输出滤波，取x领域的小block 在周围大区域上滑动计算相似度，例如y位置处的相似度 d=||block(x)-block(y)||/block_size；则y加权到x点的加权因子为 w(x,y)=exp(-(dxd / (hxh))) 这个式子将原本的距离d转化为了 0-1之间的一个加权因子w(x,y)。h为衰减因子，h越小，加权因子越小，则加权点对当前点的影响越小，一般边缘保持得好但是噪声会严重，反之则边缘保持差图像更加光滑。计算欧式距离时，有时会考虑周围点对中心点的影响，会利用核函数对欧式距离加权。加权矩阵W要归一化。参考链接：https://blog.csdn.net/qianhen123/article/details/81043217</p>
<h3 id="non-local-表达式">Non-local 表达式</h3>
<p><span class="math display">\[\mathrm{y}_{i}=\frac{1}{\mathcal{C}(\mathrm{x})} \sum_{\forall j} f\left(\mathrm{x}_{i}, \mathrm{x}_{j}\right) g\left(\mathrm{x}_{j}\right)\]</span></p>
<p>​ 上面的公式中，输入是x，输出是y，i和j分别代表输入的某个空间位置，x_i是一个向量，维数跟x的channel数一样，f是一个计算任意两点相似关系的函数，g是一个映射函数，将一个点映射成一个向量，可以看成是计算一个点的特征。也就是说，为了计算输出层的一个点，需要将输入的每个点都考虑一遍，而且考虑的方式很像attention：输出的某个点在原图上的attention，而mask则是相似性给出。参看下图</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424115941.png" alt="" /><figcaption>1590139796102</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424115944.png" alt="" /><figcaption>1590139576348</figcaption>
</figure>
<p>为了简化问题，作者简单地设置g函数为一个1*1的卷积。相似性度量函数f的选择有多种。具体参考链接：</p>
<p>https://zhuanlan.zhihu.com/p/33345791 https://blog.csdn.net/shanglianlm/article/details/104371212</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#### pytorch  non-local实现</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonLocalBlock</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, channel</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(NonLocalBlock, self).__init__()</span><br><span class="line">        self.inter_channel = channel // <span class="number">2</span></span><br><span class="line">        self.conv_phi = nn.Conv2d(in_channels=channel, out_channels=self.inter_channel, kernel_size=<span class="number">1</span>, stride=<span class="number">1</span>,padding=<span class="number">0</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.conv_theta = nn.Conv2d(in_channels=channel, out_channels=self.inter_channel, kernel_size=<span class="number">1</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.conv_g = nn.Conv2d(in_channels=channel, out_channels=self.inter_channel, kernel_size=<span class="number">1</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.softmax = nn.Softmax(dim=<span class="number">1</span>)</span><br><span class="line">        self.conv_mask = nn.Conv2d(in_channels=self.inter_channel, out_channels=channel, kernel_size=<span class="number">1</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>, bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># [N, C, H , W]</span></span><br><span class="line">        b, c, h, w = x.size()</span><br><span class="line">        <span class="comment"># [N, C/2, H * W]</span></span><br><span class="line">        x_phi = self.conv_phi(x).view(b, c, -<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># [N, H * W, C/2]</span></span><br><span class="line">        x_theta = self.conv_theta(x).view(b, c, -<span class="number">1</span>).permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>).contiguous()</span><br><span class="line">        x_g = self.conv_g(x).view(b, c, -<span class="number">1</span>).permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>).contiguous()</span><br><span class="line">        <span class="comment"># [N, H * W, H * W]</span></span><br><span class="line">        mul_theta_phi = torch.matmul(x_theta, x_phi)</span><br><span class="line">        mul_theta_phi = self.softmax(mul_theta_phi)</span><br><span class="line">        <span class="comment"># [N, H * W, C/2]</span></span><br><span class="line">        mul_theta_phi_g = torch.matmul(mul_theta_phi, x_g)</span><br><span class="line">        <span class="comment"># [N, C/2, H, W]</span></span><br><span class="line">        mul_theta_phi_g = mul_theta_phi_g.permute(<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>).contiguous().view(b,self.inter_channel, h, w)</span><br><span class="line">        <span class="comment"># [N, C, H , W]</span></span><br><span class="line">        mask = self.conv_mask(mul_theta_phi_g)</span><br><span class="line">        out = mask + x</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    model = NonLocalBlock(channel=<span class="number">16</span>)</span><br><span class="line">    <span class="built_in">print</span>(model)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">input</span> = torch.randn(<span class="number">1</span>, <span class="number">16</span>, <span class="number">64</span>, <span class="number">64</span>)</span><br><span class="line">    out = model(<span class="built_in">input</span>)</span><br><span class="line">    <span class="built_in">print</span>(out.shape)</span><br></pre></td></tr></table></figure>
<h2 id="主要方法">主要方法</h2>
<h3 id="网络结构">网络结构</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424115953.png" alt="" /><figcaption>1590137632181</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424115957.png" alt="" /><figcaption>1590137855616</figcaption>
</figure>
<h3 id="inverted-shufﬂe-layer">Inverted Shufﬂe Layer</h3>
<p>​ 作者说 设计这个的目的是因为常规的max pooling 虽然可以将低计算量但是会损失较多的信息，因此作者将 shuffle的思想应用到这个设计中。文章没有具体描绘结构 只是文字表述了一下，没懂到底怎样的结构</p>
<blockquote>
<p>Inspired by pixel shufﬂe in [18], we proposed a new pooling operation, named ISL, which includes inverted shufﬂe and convolution operation. After an inverted shufﬂe operation, the size of the feature map reduces to half of the original and the number of channels quadruples. Convolution layer with 1×1 kernels is performed after the inverted shufﬂe, which plays a role in selecting useful information while compressing the number of channels. In general, ISL not only has the effect of reducing the computation as a pooling layer but also makes the network more ﬂexible to select features.</p>
</blockquote>
<h3 id="损失函数">损失函数</h3>
<p>就是采用常用的 SSIM 和 L2损失结合。</p>
<h2 id="实验结果">实验结果</h2>
<h3 id="训练">训练</h3>
<p>这个文章可以算 learn to see in the dark 文章的补充，和它一样使用原始图像数据，只不过将注意机制等融入网络设计。训练集和测试集都是用的 SID。</p>
<h3 id="结果">结果</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424120001.png" alt="" /><figcaption>1590140337600</figcaption>
</figure>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>CURL</title>
    <url>/posts/313/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="curl-neural-curve-layers-for-global-image-enhancement">CURL: Neural Curve Layers for Global Image Enhancement</h1>
<h2 id="主要贡献">主要贡献</h2>
<ul>
<li>基于多颜色空间的曲线调整块 CURL 神经修饰块。通过神经网络学习一条离散的点，代表一条曲线。使用该曲线分别在 Lab RGB 以及 HSV空间 对图像进行全局调整。</li>
<li>提出了多颜色空间损失函数 就是每个颜色空间调整完后的结果都有个损失函数约束</li>
<li>改进了U-NET的编解码结构，提出TED的backbone。降低参数量的同时提升了性能</li>
</ul>
<h2 id="主要内容">主要内容</h2>
<h3 id="主要结构">主要结构</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424120017.png" alt="" /><figcaption>image-20210114110645797</figcaption>
</figure>
<p>主要流程从上图可以看出 首先使用一个编解码结构对输入图像处理，作者使用的是自己改进的TED结构做backbone。backbone输出一个特征图记为 F（多通道），取特征图 F 的前三通道为编解码器输出的RGB图像，后面的通道为特征。接着的CURL模块就是对这个RGB图做<strong>全局调整</strong>。首先将前三通道RGB图转为Lab格式，然后和剩余的特征图一起输入第一个块，输出得到一个向量（代表曲线），并使用这个曲线对Lab空间下的图调整后转为RGB格式 输入下一部分曲线调整模块。以此类推。</p>
<h3 id="ted">TED</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424120021.png" alt="" /><figcaption>image-20210114111442957</figcaption>
</figure>
<p>TED的核心结构和UNET类似，右下角所示结构。和UNET的差别是，首先取消了UNET的每一层的跳跃连接，只保留了最高层的连接，并且这个连接作者称为 <code>MSCA-skip</code> 如图中红色的连线。MSCA结构是左边大图所示，有三个分支，最上面的分支是全局连接，有几个步长为2的卷积加最后一个全连接。中间分支是卷积率为2的分支，最下面是卷积率为4的分支。最后concat 1x1卷积压缩输出。输入输出特征图尺寸通道数一致。作者对比了他提出的这个TED 结构和 UNET的准确率参数量，可以看出参数量较少但是准确率还比较高。同时还看出只有第一层跨层连接参数量少很多但是效果不输全部都连接的情况。</p>
<p>另外，作者还讨论了两种输入模式，RGB-to-RGB, RAW-to-RGB 两种情况。对于RAW格式的输出，需要稍微欸修改backbone的编码结构，具体的就是使用 pixel-shuffle层将输入RAW格式 转化为 (H/r) (W/r) r^2 然后再输入bacnkbone的下采样路径，这样输出的尺寸是RGB的四分之一，再使用pixel shuffle的上采样方法获得和RGB输如一样大的特征图。RGB格式的输入就不使用 pixel shuffle操作了。RAW需要pixel-shuffle主要是因为RAW格式数据的特殊存储格式吧。</p>
<h3 id="curl模块">CURL模块</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424120025.png" alt="" /><figcaption>image-20210114113514372</figcaption>
</figure>
<p>可以看出 前面 backbone输出的是一个 特征图 取特征图前3通道（蓝色部分为RGB图）曲线就是对这个进行全局调整的。神经网络的输出曲线是由全连接层产生，即离散的点。调整公式如下。 M代表输出点的个数，km代表第m个点的值，I 代表输入像素值，S代表输出的调整缩放因子。因此最终的调整结果为 S*I <strong>这样的另一个巧妙之处在于</strong>，例如HSV通道，可以使用 hue 对 saturation 进行调整（色相至饱和度曲线），换句话说缩放因子用 通道hue 计算，但是用算出来的缩放因子对saturation 通道调整。</p>
<blockquote>
<p>we arrange the neural curve layers in a particular sequence, adjusting firstly luminance and the a, b chrominance channels (using three curves respectively) in CIELab space. Afterwards, we adjust the red, green, blue channels (using three curves respectively) in RGB space. Lastly hue is scaled based on hue, saturation based on saturation, <strong>saturation based on hue</strong>, and value based on value (using four curves respectively) in HSV space</p>
</blockquote>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424120028.png" alt="" /><figcaption>image-20210114113729720</figcaption>
</figure>
<p>这个公式这么理解：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424120032.png" alt="" /><figcaption>image-20210114115936548</figcaption>
</figure>
<h3 id="损失函数">损失函数</h3>
<p>上面的模块中涉及到 颜色空间的变换 作者使用的是 pytorch 可微分的变换实现。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424120040.png" alt="" /><figcaption>image-20210114120611354</figcaption>
</figure>
<p><strong>为什么 要用乘积？</strong> S V乘积相同但是 相反表示不同深浅的颜色，但是损失依然为0？所以为啥要乘积相等？</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424120042.png" alt="" /><figcaption>image-20210114154837650</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424120043.png" alt="" /><figcaption>image-20210114154911861</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424120046.png" alt="" /><figcaption>image-20210114154919143</figcaption>
</figure>
<p>最后一个损失很明显是约束曲线 的斜率 不要有太大的突变 防止过拟合 即相邻点之间的直线的斜率差距不要太大。</p>
<h2 id="实验">实验</h2>
<p>作者在三个数据集上验证了算法</p>
<ul>
<li>Samsung S7 90张训练 10张测试 10张验证 包含RAW/RGB图像对</li>
<li>MIT-Adobe5k-DPE 5000张图，有专家调整的参考图 2250对训练图 500张测试 从训练集随机选择了500个做验证</li>
<li>MIT-Adobe5k-UPE</li>
</ul>
<h3 id="消融实验">消融实验</h3>
<h3 id="和其他方法对比">和其他方法对比</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424120100.png" alt="" /><figcaption>image-20210114160519085</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424120104.png" alt="" /><figcaption>image-20210114160656667</figcaption>
</figure>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>DRBN</title>
    <url>/posts/46341/</url>
    <content><![CDATA[<span id="more"></span>
<p>From Fidelity to Perceptual Quality: A Semi-Supervised Approach for Low-Light Image Enhancement CVPR2020</p>
<p>DRBN</p>
<h2 id="思考">思考</h2>
<p>值得注意的地方：</p>
<ol type="1">
<li>设计了 一个 递归的网络结构，结构比较有新意，第一阶段训练始终将特征分为三个分辨率频带，并且不同频带间使用残差学习的结构。</li>
<li>将对抗损失引入，用来提高 第一阶段 端到端学习生成图像饱和度 亮度等依然不足存在的问题。而这个对抗损失的训练又可以使用其他不配对的数据。</li>
</ol>
<p>疑问：</p>
<ol type="1">
<li>整个结构还是在学习低光照图像到 正常光照图像间的 端到端的映射，而且 以这个方式在LOL数据集上训练 最终在其他无参考图像数据上的泛化能力如何 还未知，文章也未做对比试验。所以感觉泛化能力不行，估计不如使用retinex的网络。</li>
<li>LOL数据集的成对图像本来就不适合这种端到端的学习，因为它的正常光照图像其实很多效果都不是很好(亮度不够，可能只是没有噪声)，因为这个数据集的主要目低时提供不同曝光度的图像对 用于光照估计分解。所以作者不得不在第二阶段加入 一个类似对比度增强的变换网络。</li>
<li>有待在其他数据集上验证效果。</li>
</ol>
<h2 id="主要贡献">主要贡献</h2>
<p>首先提出了一个深度(D)递归(Recursive)带(Band)网络(Network) 使用成对的 正常/低光照图像 去学习增强的正常光照图像的线性递归带表示。然后使用另一个网络来学习线性变换 提高上一阶段输出图像的视觉效果，此阶段基于 未配对的 感知质量驱动的对抗学习损失训练。</p>
<ul>
<li>这是首次 提出 适用于低光照图像增强任务的 半监督学习框架，设计了 深度递归带的表示形式，来连接全监督和无监督部分 以整合他们的优点。（什么是无监督 什么是半监督？）</li>
<li>提出的框架经过精心设计，可以提取一系<strong>列粗到细的频带</strong>表示。 通过以递归的方式进行端到端训练，能够消除噪声和校正细节，这些频带表示的估计<strong>是相互受益的</strong>。</li>
<li>在质量感知的对抗性学习的指导下，深层表示被重新变换。基于平均意见得分（MOS）在感知上选择鉴别器的“真实图像”。 低光图像增强任务中的第一个试验。</li>
</ul>
<h2 id="主要内容">主要内容</h2>
<h3 id="动机">动机</h3>
<p><strong>Recursive Band Learning</strong> paired 成对的图像数据 可以对图像细节增强提供强大的约束。所以第一阶段，基于 成对的训练数据的约束，使用 深度递归带 (这里的带 应该代表频带，表示不同分辨率的特征图/图象) 网络 来恢复重建图像的细节信号。这一阶段不仅从输入图像 y 中 生成了最终增强图像 <span class="math inline">\(\hat{x}=\sum_{i=1}^{n} \hat{x}_{s_{i}}^{T}\)</span> ，还生成了 一系列分辨率的特征带 <span class="math display">\[\left\{\Delta \hat{x}_{s_{1}}^{T}, \Delta \hat{x}_{s_{2}}^{T}, \ldots, \Delta \hat{x}_{s_{n}}^{T}\right\}\]</span> 通过对成对的低光/正常光数据进行完全监督来学习 <span class="math inline">\(\Delta \hat{x}_{s_{i}}^{T}\)</span> 。</p>
<p><strong>连接递归带的特征和对抗学习</strong>。但是，第一阶段的首要目的是尽可能恢复信号细节，自然无法获得良好的视觉质量。因此这一阶段对第一阶段学习的 信号带进行重建，来获得更符合人类视觉效果的更好的结果。如下式：</p>
<p><span class="math display">\[\hat{x}=\sum_{i=1}^{n} w_{i}\left(y,\left\{\Delta \hat{x}_{s_{1}}^{T}, \Delta \hat{x}_{s_{2}}^{T}, \ldots, \Delta \hat{x}_{s_{n}}^{T}\right\}\right) \Delta \hat{x}_{s_{i}}^{T}(y)\]</span></p>
<p>上式可以看出 ，首先这阶段的网络输入是 上一阶段生成的几乎无噪声的，细节很好的图像，输出获得具有更好光照更好对比图的图像。网络学习的是变换参数。</p>
<h3 id="网络结构">网络结构</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212517.png" alt="" /><figcaption>1598796721130</figcaption>
</figure>
<p><strong>Recursive Band Learning</strong></p>
<p>这一阶段使用一系列 U-NET类似的网络结构(BLN)来完成迭代。图中的分辨率分别为 1/4， 1/2，1 。首先输入图像y经过一个BLN_F 生成 。f 为每个网络生成的中间特征，有不同分辨率的 和上一轮生成的 f 求和 生成当前层的 x 输出，其次也会直接输入下一层 和下一层的 f 求和。这样以来 每次递归的其实是 学习的 上一轮 生成的 f 的残差。所以说由粗到精细特征。</p>
<p><span class="math display">\[\begin{aligned}
\left[f_{s_{1}}^{1}, f_{s_{2}}^{1}, f_{s_{3}}^{1}\right] &amp;=F_{\mathrm{BLN}_{-}}^{1}(y) \\
\hat{x}_{s_{1}}^{1} &amp;=F_{\mathrm{R}_{-s} 1}^{1}\left(f_{s_{1}}^{1}\right) \\
\hat{x}_{s_{2}}^{1} &amp;=F_{\mathrm{R}_{-s} 2}^{1}\left(f_{s_{2}}^{1}\right)+F_{\mathrm{U}}\left(\hat{x}_{s_{1}}^{1}\right) \\
\hat{x}_{s_{3}}^{1} &amp;=F_{\mathrm{R}_{s_{3}}}^{1}\left(f_{s_{3}}^{1}\right)+F_{\mathrm{U}}\left(\hat{x}_{s_{2}}^{1}\right)
\end{aligned}\]</span></p>
<p>接着是中间层的 不断 递归迭代。输入为 y 和上一层增强的输出。中间<strong>层的递归网络学习的都是前一层的 残差</strong></p>
<p><span class="math display">\[\begin{aligned}
\left[\Delta f_{s_{1}}^{t}, \Delta f_{s_{2}}^{t}, \Delta f_{s_{3}}^{t}\right] &amp;=F_{\mathrm{BLN}_{-} \mathrm{F}}^{t}\left(y, \hat{x}_{s_{3}}^{t-1}\right) \\
f_{s_{i}}^{t} &amp;=\Delta f_{s_{i}}^{t}+f_{s_{i}}^{t-1}, i=1,2,3 \\
\hat{x}_{s_{1}}^{t} &amp;=F_{\mathrm{R}_{s} s_{1}}^{t}\left(f_{s_{1}}^{t}\right) \\
\hat{x}_{s_{2}}^{t} &amp;=F_{\mathrm{R}_{s} s_{2}}^{t}\left(f_{s_{2}}^{t}\right)+F_{\mathrm{U}}\left(\hat{x}_{s_{1}}^{t}\right) \\
\hat{x}_{s_{3}}^{t} &amp;=F_{\mathrm{R}_{s} s_{3}}^{t}\left(f_{s_{3}}^{t}\right)+F_{\mathrm{U}}\left(\hat{x}_{s_{2}}^{t}\right)
\end{aligned}\]</span></p>
<p>最后是 损失函数。可以看出，它是 分别计算在分辨率 s=1 /2 1/4下的SSIM损失 FD为下采样。</p>
<p><span class="math display">\[\begin{aligned}
L_{\mathrm{Rect}}=-&amp;\left(\phi\left(\hat{x}_{s_{3}}^{T}, x\right)+\lambda_{1} \phi\left(\hat{x}_{s_{2}}^{T}, F_{D}\left(x, s_{2}\right)\right)\right.\\
&amp;\left.+\lambda_{2} \phi\left(\hat{x}_{s_{1}}^{T}, F_{D}\left(x, s_{1}\right)\right)\right)
\end{aligned}\]</span></p>
<p>上述的设计有以下好处：</p>
<ul>
<li>上一次迭代生成的高频带将会对这次迭代的低频特征的生成产生影响，因为这次迭代的输入是上一次生成的的高频带特征 S3 和 y的组合。而最终的损失也是高低频带分别计算，所以高低频带之间的连接是相互影响的，双向流动的。</li>
<li>递归学习增强了建模能力。 后面的重复仅需要恢复残差信号，并以先前重复的估计为指导。 因此，可以获得准确的估计，只需将更多的注意力放在细节的恢复上。</li>
</ul>
<p><strong>Band Recomposition</strong></p>
<p>借助配对数据的约束，可以很好地学习从弱光图像到正常光图像的波段恢复过程，同时可以很好地恢复细节并抑制噪声。 由于信号保真度始终无法很好地与人类的视觉感知保持一致，尤其是对于图像的某些全局属性（例如光线，颜色分布）。因此这一部分的目的就是 对上一阶段的频带信号重建，得到视觉效果更好的图像。</p>
<p>首先 可以看出 左半部分还是使用一个UNet结构的网络来学习变换的参数，使用生成的参数对 原始频带型号线性变换。得到新的生成图像，使用 对抗损失 和 SSIM/VGG 损失共同优化网络。而对抗损失 是使用 另一个数据集学习的用于度量图像频分的一个网络 SSIM/VGG损失都是 需要输入的参考图像作为约束的损失。因此这一部分的UNet训练也是需要LOL数据集的，只是对抗损失网络是使用其他不成对的数据训练的。 ​ 损失函数：</p>
<p><span class="math display">\[\begin{aligned}
\left\{w_{1}, w_{2}, w_{3}\right\} &amp;=F_{\mathrm{RC}}\left(\left\{\Delta \hat{x}_{s_{1}}^{T}, \Delta \hat{x}_{s_{2}}^{T}, \Delta \hat{x}_{s_{3}}^{T}\right\}\right) \\
\hat{x}_{3}^{F} &amp;=\sum_{i=1}^{3} w_{i} \Delta \hat{x}_{s_{i}}^{T} \\
\Delta \hat{x}_{s_{i}}^{T} &amp;=\hat{x}_{s_{i}}^{T}-F_{\mathrm{U}}\left(\hat{x}_{s_{i-1}}^{T}\right), i=2,3 \\
\Delta \hat{x}_{s_{1}}^{T} &amp;=\hat{x}_{s_{1}}^{T}
\end{aligned}\]</span></p>
<p><span class="math display">\[\begin{aligned}
L_{\text {Detail }} &amp;=-\phi\left(\hat{x}_{3}^{F}-x\right) \\
L_{\text {Percept }} &amp;=\left\|F_{\mathrm{P}}\left(\hat{x}_{3}^{F}\right)-F_{\mathrm{P}}(x)\right\|_{2}^{2} \\
L_{\text {Quality }} &amp;=-\log D\left(\hat{x}_{3}^{F}\right)
\end{aligned}\]</span></p>
<p>其中 D 是 估计 生成图像符合人眼视觉效果的概率，这个D是在</p>
<blockquote>
<p>high-quality images selected from aesthetic visual analysis dataset</p>
</blockquote>
<p>这个数据集上训练的。Fp是VGG损失。</p>
<h2 id="实验">实验</h2>
<h3 id="训练细节">训练细节</h3>
<p>首先使用 LOL 上成对的数据 先训练第一阶段的网络，然后固定第一阶段 的权重 再训练第二阶段。具体训练方法如下：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424120152.png" alt="" /><figcaption>1598841253259</figcaption>
</figure>
<h3 id="实验结果">实验结果</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424120157.png" alt="" /><figcaption>1598841560362</figcaption>
</figure>
<ol start="3" type="1">
<li></li>
</ol>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>DeepExposure</title>
    <url>/posts/46437/</url>
    <content><![CDATA[<span id="more"></span>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>Deep Retinex Net</title>
    <url>/posts/15395/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="主要贡献">主要贡献</h2>
<ul>
<li>建立了一个 采集与真实场景的 含有成对的低光照/正常光照的大尺度数据集（包含了合成和非合成的图像）</li>
<li>提出了一个基于retinex理论的图像分解的深度神经网络模型。这个模型是端到端训练的。</li>
<li>提出了用于学习图像分解模型的结构加权总变分损失。能够较好的平滑光照图同时保留原本的结构</li>
</ul>
<h2 id="网络结构">网络结构</h2>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424120111.png" alt="" /><figcaption>1572790251537</figcaption>
</figure>
<p>​ 可以看出，整个模型由序列的两部分组成，图像分解，和 去噪以及亮度多尺度调整</p>
<h3 id="数据驱动的图像分解-decom-net">数据驱动的图像分解 Decom-Net</h3>
<p>​ 这一部分将输入图像 S 分解为光照估计 I 和反射分量 R。一种分解反射和光照的方法是使用人工约束条件。然而根据retinex模型的那个式子很难实现，作者使用数据驱动的方式构建一个 Decom-Net来完成。这个网络的特点是损失函数的设计。由上图看出DecomNet的训练不需要低光照图的R和L来直接构建损失，而是通过以下几个约束条件来间接构建损失函数。</p>
<ul>
<li><p>低光照图的反射率图和正常光照的反射率图应该尽可能一样： <span class="math display">\[
\mathcal{L}_{i r}=\left\|R_{l o w}-R_{n o r m a l}\right\|_{1}
\]</span></p></li>
<li><p>应该可以根据R, I 还原重建出 I 对应的 S图 。假设Sn Sl分别为输入正常光照和低光照图像， Il In为分解产生的高低光照图 Rn Rl 为分解产生的对应的反射率。约束1可知Rn应该尽可能接近Rl。 约束2的意思则是： 使用Rn Il 可以还原出Sl 使用Rn In可以还原出Sn 使用Rl Il可以还原出Sl 使用Rl In可以还原出Sn 。 R*I 即根据Retinex理论重建的过程，而-则来度量还原的程度。</p></li>
</ul>
<p><span class="math display">\[
\mathcal{L}_{\text {recon}}=\sum_{i=l o w, n o r m a l} \sum_{j=l o w, n o r m a l} \lambda_{i j}\left\|R_{i} \circ I_{j}-S_{j}\right\|_{1}
\]</span></p>
<ul>
<li>结构平滑损失。即分解产生的光照图应该尽可能的平滑，因为认为一张图上的光照在各个区域是一致的。全变分(TV)损失，最小化整张图的梯度，通常在图像重建中作为先验平滑图像。但是直接应用TV损失来约束平滑光照图会在 图像本身梯度较大的区域失效 （下图黑边）。这是由于不管区域是纹理细节还是强边界，光照梯度都是均匀减少的。因此原本的TV损失对图像的结构是盲目的，如果在图像边缘进行强烈的模糊虽然产生的光照图会平滑但是反射率图会产生黑边。如下图。因此根据对应位置的反射率对光照梯度加上权重。上式 <span class="math inline">\(\nabla I_{i}\)</span> 表示微光图/正常光照图的梯度，一般的TV损失是直接对全图<span class="math inline">\(\nabla I\)</span> 求和作为损失来优化平滑图像。这里相当于根据反射率图像的梯度给梯度加上了一个权值exp()。在反射率图本身梯度大的地方权值小，小的地方权值大。作者认为在物理结构存在梯度的地方光照应该不连续 ？？</li>
</ul>
<p><span class="math display">\[
\mathcal{L}_{i s}=\sum_{i=l o w, n o r m a l}\left\|\nabla I_{i} \circ \exp \left(-\lambda_{g} \nabla R_{i}\right)\right\|
\]</span></p>
<ul>
<li>将上述三部分损失相加即为Decom-Net 采用的损失 <span class="math display">\[
\mathcal{L}=\mathcal{L}_{\text {recon}}+\lambda_{i r} \mathcal{L}_{i r}+\lambda_{i s} \mathcal{L}_{i s}
\]</span> 作者还提到 关于LIME网络也在计算光照图像时考虑到图像原本的结构，但是本质和自己的不同....</li>
</ul>
<blockquote>
<p>For LIME, the total variation constraint is weighted by an initial illumination map, which is the maximum intensity of each pixel in R, G and B channels. Our structure-aware smoothness loss instead is weighted by reflectance. The static initial estimation used in LIME may not depict the image structure as well as reflectance does, since reflectance is assumed as the physical property of an image.</p>
</blockquote>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424120115.png" alt="" /><figcaption>1572858053126</figcaption>
</figure>
<h3 id="多尺度光照调节-adjustment">多尺度光照调节 adjustment</h3>
<p>​ 这个adujust网络的结构类似于<strong>U-net</strong> 的编码解码结构。降采样块包含步长为2的卷积层，上采样块使用resize-convolution层，即先将特征图插值的方法上采样然后使用步长为1的卷积和激活。这一部分的损失即为调整过后的光照图和去噪过后的反射率图重建产生的图像和正常光照图像之间的l1损失。 ​ 可以看到，在这一部分还对反射率图进行了去噪处理，使用的时DMB3</p>
<h2 id="数据集">数据集</h2>
<p>​ 作者提出了一套数据集，包含两部分：成对的合成数据和真实的低光照图。由于真实场景的图像采集正常光照和低光照时会产生错位，作者采用了三步法来矫正。 ​ 合成图像，作者分析了已有的真实低光照图像和真实的正常图像光照的YCbCr中Y的分量，统计Y分量的直方图，根据他们的规律来合成低光照图像。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424120119.png" alt="" /><figcaption>1572858105879</figcaption>
</figure>
<h2 id="结果">结果</h2>
<p>​ 本论文作者并没有贴出指标的定量分析，只是贴了几幅图。图像分解的方法是否有效有待考虑.... ​ 定性分析：</p>
<ol type="1">
<li><p>首先作者为了证明图像分解网络设计的有效性，贴出了和LIME分别对微光图和正常图像分解产生的R , I图，发现LIME在同一个图的低光和正常光图分解的R结果并不一致， 而R反应的应该是物体本身的折射率，在低/正常图下应该一样。</p></li>
<li><p>同样的，在R图中 由于去掉了光照分量，应该不存在阴影，而LIME的R中存在明显的阴影，但是RetinexNet除了有噪 声外是没有阴影的 说明光照分量取出的比较彻底。</p></li>
<li><p>文章所提的方法不会对局部区域过曝，主要是全局光照调节效果好</p></li>
<li><p>得益于加权TV损失，相对于基于DeHz去雾方法 结果中没有黑边</p></li>
<li><p>又对比了同样含有去噪方法的JED 网络，LIME(网络后去噪) 结果，发现Retinex的边缘细节得到较好的保留。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424120123.png" alt="" /><figcaption>1572859097749</figcaption>
</figure></li>
</ol>
<p>感觉这种方法处理的结果</p>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>EnlightenGAN</title>
    <url>/posts/9266/</url>
    <content><![CDATA[<span id="more"></span>
<p>想解决的问题：低光照图像增强</p>
<p>方法：</p>
<ul>
<li>提出非监督的生成对抗网络，EnlightenGAN，训练不需要低光度/正常光度图像对。</li>
<li>提出使用从输入本身提取的信息来规范化不成对的训练</li>
<li>一些创新：
<ul>
<li>global-local判断器结构</li>
<li>self-regularized perceptual loss fusion</li>
<li>注意力机制</li>
</ul></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>DL方法通常用成对图像作为输入，<strong>缺点</strong>：</p>
<ol type="1">
<li>很难在实际中同时采集到同一场景的图像</li>
<li>合成的图像不够真实，引入了许多人为因素</li>
<li>对于低光照问题，没有唯一的或者说定义好的GT</li>
</ol>
<p>解决的问题：</p>
<ul>
<li>对低光照图像进行增强，但不需要成对的训练数据。</li>
</ul>
<p>idea：</p>
<ul>
<li>使用GAN在low和normal light之间建立unpaired mapping，但不依赖任何成对的图像</li>
<li>没有使用cycle-consistency作为prior工作
<ul>
<li>（不懂这个cycle-consistency是什么）</li>
<li>ref：<a href="https://zhuanlan.zhihu.com/p/70592331">参考资料</a></li>
<li>一些point：
<ul>
<li>最早是在朱俊彦的cycleGAN提出，用于在没有配对数据的情况下实现2个domain的image-to-image翻译。基本的思想，假设从X翻译到Y得到F(x)，再翻译回去G(F(x))，G(F(x))应该与X一模一样。</li>
<li></li>
</ul></li>
</ul></li>
<li>一些创新性工作
<ul>
<li>1.提出dual-discriminator平衡全局和局部低光照增强x</li>
<li>2.提出self-regularized perceptual loss来约束输入和增强版本后的特征距离</li>
<li>3.提出开发的输入的光照信息作为self-regularized attentional map，在每个level的深度特征上regularize无监督学习</li>
</ul></li>
</ul>
<p>EnlightenGAN的创新点：</p>
<ol type="1">
<li>第一个将unpaired训练引入低光照增强</li>
<li>self-regularization，通过保留自特征loss和自规则注意力机制实现</li>
<li>增强来自不同domain的真实世界的低光照图像更加简单和灵活</li>
</ol>
<h2 id="related-works">Related Works</h2>
<h3 id="paired-datasetsstatus-quo"><strong>Paired Datasets：Status Quo</strong></h3>
<p>缺点：</p>
<ul>
<li>数据量小，简单地增加或减少曝光时间会增加或减少局部的曝光。</li>
<li>在HDR领域，一些工作首先获取不同光照条件下的图像，然后对其进行排列和融合，但他们不是为单一图像后处理而设计的</li>
</ul>
<h3 id="traditional-approaches">Traditional Approaches</h3>
<p>经典方法：</p>
<ul>
<li>adaptive histogram equalization（AHE），自适应直方图平衡
<ul>
<li>Stephen M Pizer, E Philip Amburn, John D Austin, Robert Cromartie, Ari Geselowitz, Trey Greer, Bart ter Haar Romeny, John B Zimmerman, and Karel Zuiderveld. Adaptive histogram equalization and its variations. Com- puter vision, graphics, and image processing, 39(3):355– 368, <strong>1987.</strong></li>
</ul></li>
<li>Retinex
<ul>
<li>Edwin H Land. The retinex theory of color vision. Scientific american, 237(6):108–129, <strong>1977</strong></li>
</ul></li>
<li>multi-scale Retinex model
<ul>
<li>Daniel J Jobson, Zia-ur Rahman, and Glenn A Woodell. A multiscale retinex for bridging the gap between color images and the human observation of scenes. IEEE Transactions on Image processing, 6(7):965–976, <strong>1997</strong></li>
</ul></li>
<li>提出针对不均匀光照用bi-log信息平衡细节与自然感的增强算法
<ul>
<li>Shuhang Wang, Jin Zheng, Hai-Miao Hu, and Bo Li. Nat- uralness preserved enhancement algorithm for non-uniform illumination images. IEEE Transactions on Image Process- ing, 22(9):3538–3548, <strong>2013</strong></li>
</ul></li>
<li>提出加权变分模型，估计reflectance和illumination
<ul>
<li>Xueyang Fu, Delu Zeng, Yue Huang, Xiao-Ping Zhang, and Xinghao Ding. A weighted variational model for simultane- ous reflectance and illumination estimation. In CVPR, pages 2782–2790, <strong>2016</strong></li>
</ul></li>
<li>LIME，low-light image enhancement，先找到RGB中的最大值作为最初的光照估计，使用结构先验构建光照图
<ul>
<li>Xiaojie Guo, Yu Li, and Haibin Ling. Lime: Low-light im- age enhancement via illumination map estimation. IEEE Transactions on Image Processing, 26(2):982–993, <strong>2017</strong></li>
</ul></li>
<li>通过分解连续图像序列来同时处理低光照和去噪
<ul>
<li>Xutong Ren, Mading Li, Wen-Huang Cheng, and Jiaying Liu. Joint enhancement and denoising method via sequen-tial decomposition. In Circuits and Systems (ISCAS), 2018 IEEE International Symposium on, pages 1–5. IEEE, <strong>2018</strong></li>
</ul></li>
<li>提出更加robust的Retinex模型，与传统的Retinex模型对比，考虑了noise map，通过强噪声提高性能
<ul>
<li>Mading Li, Jiaying Liu, Wenhan Yang, Xiaoyan Sun, and Zongming Guo. Structure-revealing low-light image en- hancement via robust retinex model. IEEE Transactions on Image Processing, 27(6):2828–2841, <strong>2018.</strong></li>
</ul></li>
</ul>
<h3 id="deep-learning-approaches">Deep Learning Approaches</h3>
<p>目前大部分基于DL的方法都依赖于paired image，且图像大部分是从正常图像中人工合成的。</p>
<ul>
<li>LL-Net，堆叠的自动编码器，在patch level同时学习去噪和低光照增强。
<ul>
<li>Kin Gwn Lore, Adedotun Akintayo, and Soumik Sarkar. Ll- net: A deep autoencoder approach to natural low-light image enhancement. Pattern Recognition, 61:650–662, <strong>2017</strong>.</li>
</ul></li>
<li>Retinex-Net，设计了end-to-end框架，结合了Retinex理论
<ul>
<li>Chen Wei, Wenjing Wang, Wenhan Yang, and Jiaying Liu. Deep retinex decomposition for low-light enhancement. arXiv preprint arXiv:1808.04560, <strong>2018</strong>.</li>
</ul></li>
<li>HDR-Net ，将深度网络与双边网格处理（bilateral gird processing）、局部颜色仿射变换（local affine color transforms）
<ul>
<li>Micha¨el Gharbi, Jiawen Chen, Jonathan T Barron, SamuelW Hasinoff, and Fr´edo Durand. Deep bilateral learning for real- time image enhancement. ACM Transactions on Graphics (TOG), 36(4):118, <strong>2017</strong></li>
</ul></li>
<li>以及一些针对HDR领域的多帧低光照增强方法
<ul>
<li>Nima Khademi Kalantari and Ravi Ramamoorthi. Deep high dynamic range imaging of dynamic scenes. ACM Trans. Graph, 36(4):144, <strong>2017</strong>.</li>
<li>ShangzheWu, Jiarui Xu, Yu-Wing Tai, and Chi-Keung Tang. Deep high dynamic range imaging with large foreground motions. In Proceedings of the European Conference on Computer Vision (ECCV), pages 117–132, <strong>2018</strong>.</li>
<li>Jianrui Cai, Shuhang Gu, and Lei Zhang. Learning a deep single image contrast enhancer from multi-exposure images. IEEE Transactions on Image Processing, 27(4):2049–2062, <strong>2018</strong>.</li>
</ul></li>
<li>learning to see in the dark，直接在raw数据上，更注重避开放大的artifacts</li>
</ul>
<h3 id="adversarial-learning">Adversarial Learning</h3>
<p>使用GAN的方法同样使用的是paired训练数据。</p>
<p>一些人提出了无监督的GAN方法，使用对抗学习学习inter-domain。</p>
<p>提出两个方法，通过使用cycle-consistent loss+uppaired data，对两个不同领域之间进行翻译</p>
<ul>
<li>Jun-Yan Zhu, Taesung Park, Phillip Isola, and Alexei A Efros. Unpaired image-to-image translation using cycle- consistent adversarial networks. In ICCV, pages 2223–2232, <strong>2017</strong>.</li>
<li>Ming-Yu Liu, Thomas Breuel, and Jan Kautz. Unsupervised image-to-image translation networks. In Advances in Neural Information Processing Systems, pages 700–708, <strong>2017</strong>.</li>
</ul>
<p>一些最新的工作基于上面的方法论应用在其他low level task（比如，去雾，去噪，SR，手机照片增强等）上：</p>
<ul>
<li>Xitong Yang, Zheng Xu, and Jiebo Luo. Towards percep tual image dehazing by physics-based disentanglement and adversarial training. In The Thirty-Second AAAI Conference on Artificial Intelligence (AAAI-18), <strong>2018</strong>.</li>
<li>Yuan Yuan, Siyuan Liu, Jiawei Zhang, Yongbing Zhang, Chao Dong, and Liang Lin. Unsupervised image super- resolution using cycle-in-cycle generative adversarial net- works. CVPR Workshops, 30:32, <strong>2018</strong>.</li>
<li>Yu-Sheng Chen, Yu-Ching Wang, Man-Hsin Kao, and Yung- Yu Chuang. Deep photo enhancer: Unpaired learning for image enhancement from photographs with gans. In Pro- ceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 6306–6314, <strong>2018</strong>.</li>
<li>Xin Jin, Zhibo Chen, Jianxin Lin, Zhikai Chen, and Wei Zhou. Unsupervised single image deraining with self- supervised constraints. arXiv preprint arXiv:1811.08575, <strong>2018</strong>.</li>
</ul>
<p>EnlightenGAN采用unpaired训练，但是一个轻量级的one-pathGAN结构（即，没有cycle-consistency）,这样的好处是，训练稳定且简单。</p>
<h2 id="method">Method</h2>
<p>网络结构：</p>
<p><a href="https://github.com/GlassyWu/Note/blob/master/Paper/低光照图像增强/img/EnlightenGAN.png"><img src="https://github.com/GlassyWu/Note/raw/master/Paper/%E4%BD%8E%E5%85%89%E7%85%A7%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/img/EnlightenGAN.png" alt="img" /></a></p>
<ul>
<li>采用一个attention-guided U-Net作为生成器</li>
<li>用对偶的判断器判断全局和局部信息（即，一个global和一个local判断器）</li>
<li>使用一个自特征保留loss来引导训练，以及保留纹理和结构</li>
</ul>
<h4 id="global-local-discriminators">（1）Global-Local Discriminators</h4>
<p>用对抗loss来最小化真实和输出的正常光线的分布之间的距离。</p>
<p>image-level的判断器经常在空间变化的光照图像不work，在一些局部区域需要增强的部分和其他区域不太一样（比如，全局大部分是暗的，一个小部分是亮的，这种情况全局生成器可能就不能满足这个需求）。</p>
<p>解决方法：</p>
<p>作者设计了一个global-local判断器结构，都是用PatchGAN来判断真假。</p>
<ul>
<li><p>local判断器：</p>
<ul>
<li>在输出和正常光线图像随机裁剪局部patch，判断器学习判断这些patch的真假。</li>
</ul></li>
<li><p>global判断器：</p>
<ul>
<li>使用了相对判断器结构
<ul>
<li>relativistic discriminator structure：
<ul>
<li>Alexia Jolicoeur-Martineau. The relativistic discriminator: a key element missing from standard gan. arXiv preprint arXiv:1807.00734, 2018</li>
</ul></li>
</ul></li>
<li>在标准的相对判断器上将sigmoid函数改为最小二乘法loss</li>
</ul>
<p>标准相对判断器公式： <span class="math display">\[ D_{Ra}(x_{r},x_{f})=σ(C(x_{r})-E_{x_{f}∼P_{fake}}[C(x_{f})]) \ D_{Ra}(x_{f},x_{r})=σ(C(x_{f})-E_{x_{f}∼P_{real}}[C(x_{r})]) \]</span> 作者进行修改后的loss：</p>
<p><strong>Global：</strong> <span class="math display">\[ L_{D}^{Global}=E_{X_{r}∼P_{real}}[(D_{Ra}(x_{r},x_{f})-1)^2]+E_{x_{f}∼P_{fake}}[D_{Ra}(x_f, x_r)^2] \ L_{G}^{Global}=E_{X_{f}∼P_{fake}}[(D_{Ra}(x_{f},x_{r})-1)^2]+E_{x_{r}∼P_{real}}[D_{Ra}(x_r, x_f)^2] \]</span> <strong>Local:</strong> <span class="math display">\[ L_{D}^{Local}=E_{x_{r}∼P_{real-patches}}[(D(x_{r})-1)^2]+E_{x_{f}∼P_{fake-patches}}[(D(x_{f})-0)^2] \ L_{G}^{Local}=E_{x_{r}∼P_{fake-patches}[(D(x_{f})-1)^2]} \]</span></p></li>
</ul>
<h4 id="self-feature-preserving-loss">（2）Self Feature Preserving Loss</h4>
<p>perceptual loss常用来限制提取的特征与GT尽可能接近，perceptual loss是利用预训练的VGG去模拟图像之间的特征空间距离。</p>
<p><strong>paper</strong>：Justin Johnson, Alexandre Alahi, and Li Fei-Fei. Perceptual losses for real-time style transfer and super-resolution. In European Conference on Computer Vision, pages 694–711. Springer, <strong>2016</strong>.</p>
<p>作者提出限制输入和输出的VGG-frature距离。</p>
<p>作者根据经验观察到当调整输入像素的密度范围，VGG的分类结果不是特别灵敏。（也被论文证实了）</p>
<p>设计了自正则化loss（self-regularzation loss)，以保留图像内容特征。</p>
<p>L_SFP的定义：</p>
<p><a href="https://github.com/GlassyWu/Note/blob/master/Paper/低光照图像增强/img/L_SFP.png"><img src="https://github.com/GlassyWu/Note/raw/master/Paper/%E4%BD%8E%E5%85%89%E7%85%A7%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/img/L_SFP.png" alt="img" /></a></p>
<p>对于裁剪的局部块也进行规则，用L_SFP_Local，此外，还在VGG特征图之后增加了instance normalization，目的是稳定训练。</p>
<h4 id="u-net-generator-guided-with-self-regularized-attention">（3）U-Net Generator Guided with Self-Regularized Attention</h4>
<ul>
<li>U-Net作为backbone</li>
<li>将输入的RGB正则化到[0,1]，用1-I作为self-regularized attention map</li>
<li>然后resize attention map来适配每个feature map，然后与所有中间feature map、输出进行相乘</li>
<li>作者强调attention map也是self-regularization的一部分</li>
</ul>
<p>attention-guided U-Net generator结构：</p>
<ul>
<li>8个conv块 ，每个conv包括LeakyRelU+BN+2个3x3 conv</li>
<li>在上采样阶段，将标准deconvolutional layer替换为双线上采样层（bilinear upsampling）+一个卷积层，目的是减少checkerboard artifacts
<ul>
<li>(不懂bilinear upsampling，checkerboard artifacts)</li>
</ul></li>
</ul>
<h2 id="gan相关论文">GAN相关论文：</h2>
<p>1、Jun-Yan Zhu, Taesung Park, Phillip Isola, and Alexei A Efros. Unpaired image-to-image translation using cycle- consistent adversarial networks. In ICCV, pages 2223–2232, 2017.</p>
<p>2、Ming-Yu Liu, Thomas Breuel, and Jan Kautz. Unsupervised image-to-image translation networks. In Advances in Neural Information Processing Systems, pages 700–708, 2017</p>
<p>3、Alexia Jolicoeur-Martineau. The relativistic discriminator: a key element missing from standard gan. arXiv preprint arXiv:1807.00734, 2018.</p>
<h2 id="其他">其他</h2>
<ul>
<li>HDR(high-dynamic-ranging)
<ul>
<li>高动态范围成像，用来实现比普通数字图像技术更大曝光动态范围（即，更大的明暗差别）的一组技术</li>
<li>目的：正确地表示真实世界中从太阳光直射到最暗的阴影这样大的范围亮度</li>
</ul></li>
<li>ablation analysis
<ul>
<li>消融实验：分析不同参数或结构对实验结果产生的影响从而得到不同成分的作用</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>Extreme-Low-light</title>
    <url>/posts/9641/</url>
    <content><![CDATA[<span id="more"></span>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>Frequence-Decomposition</title>
    <url>/posts/26067/</url>
    <content><![CDATA[<span id="more"></span>
<p>Learning to Restore Low-Light Images via Decomposition-and-Enhancement CVPR2020</p>
<h2 id="思考">思考</h2>
<p>文章主要思想是 频率分解，是个新思路 但是没有在无参考图像上的对比实验，且对比的方法比较旧。文章也使用了VGG损失且确实会有效果。这种分解的思路可以借鉴，对参考图像做处理来指导网络学习期望的效果。</p>
<h2 id="主要思想">主要思想</h2>
<p>​ 作者发现 <strong>低光照图像的噪声在不同频率的层会表现出不同的对比度，在低频层中比在高频层中更容易检测到噪声。</strong>基于此思想，提出了一个基于频率分解-增强的两阶段低光照图像增强模型。也是从粗糙到精细coarse to fine的思路。同时 还提出一个新的包含真实噪声的数据集。如下图：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424120217.png" alt="" /><figcaption>1598948440726</figcaption>
</figure>
<h2 id="主要内容">主要内容</h2>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424120223.png" alt="" /><figcaption>1598949161921</figcaption>
</figure>
<h3 id="整体结构">整体结构</h3>
<p>​ 首先，与直接增强整个图像相比，增强 含有噪声的低光图像的低频层更容易。这是因为低频层的噪声更容易检测和抑制。通过分析图像低频层的全局属性，可以正确地估计图像的光照/颜色；并且图像的边缘或者角点只占图像的很低维度(?)因此，给定基础的低频信息，可以推断出相应的高频信息。</p>
<p>​ 第一阶段，输入图像，学习一个可以获得图像低频信息的网络 获取 增强后的低频图像 content map C(.)，过滤掉了高频信息。然后使用放大函数 A(.) 用作颜色恢复和进一步增强。具体的：</p>
<p><span class="math display">\[I^{a}=\alpha A(C(I)) \cdot C(I)\]</span></p>
<p><span class="math inline">\(I^{a}\)</span>是放大后的低频图像，这里并非retinex的那种illumination map的增强，而是类似于一种attention <span class="math inline">\(\alpha\)</span>也是和C用一个网络生成的。</p>
<p>​ 第二阶段，就是根据第一阶段的<span class="math inline">\(I^{a}\)</span>来恢复高频细节。 第一阶段C的 监督 是 参考图像经过 指导滤波后的图像（详情见损失部分）第二阶段的 监督就是正常参考图。这一部分用了一个残差结构。</p>
<p><span class="math display">\[I^{c}=I^{a}+D\left(I^{a}\right)\]</span></p>
<h3 id="ace模块">ACE模块</h3>
<p>​ 又总的结构图可以看出 在第一第二阶段输入的时候都经过了一个ACE模块，这个模块就是起到筛选 低频/高频 成分的功能。后面接的对应网络完成 低频/高频 图像 中的噪声去除和细节恢复。ACE结构如下：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424120229.png" alt="" /><figcaption>1598951252434</figcaption>
</figure>
<p>ACE 对输入图像做了两个并列的 不同 空洞率的卷积 ，然后做了 <strong>差</strong> 生成了Ca <span class="math inline">\(C_{a}=\operatorname{sigmoid}\left(f_{d 1}\left(x_{i n}\right)-f_{d 2}\left(x_{i n}\right)\right)\)</span> Ca 表明 像素间的相对差异，差异大的就是高频区域 反之低频。将Ca作为一个全图的权重 和 输入特征x_in点乘，来过滤高低频信息（1-Ca） 再后面的部分就是 nonlocal 模块了，作者这里进行了降采样 提高计算速度。这里在第一个图中的两个ACE是共享权重的。</p>
<h3 id="cdt模块">CDT模块</h3>
<p>同ACE DCT首先接入的也是 1-Ca 作为引导滤出高频区域。然后使用self attention生产vector进行channel 的缩放，就是通道注意力模块。CDT模块是为了减小输入特征和增强特征的差距 并 扩大感受野。</p>
<h3 id="损失函数">损失函数</h3>
<p>​ 损失包含了以下三项。其中 C是第一个阶段的content图，GT的指导滤波输出的低频图，最终的增强图和GT图。fi是vgg网络输出的损失。</p>
<p><span class="math display">\[L_{a c c}=\lambda_{1}\left\|C-I_{f}^{g t}\right\|_{2}+\lambda_{2}\left\|I^{c}-I^{g t}\right\|_{2}\]</span></p>
<p><span class="math inline">\(L_{v g g}=\lambda_{3}\left\|\Phi\left(I^{c}\right)-\Phi\left(I^{g t}\right)\right\|_{1}\)</span></p>
<h2 id="实验">实验</h2>
<h3 id="实现细节">实现细节</h3>
<p>​ 第一阶段中的 <span class="math inline">\(\alpha\)</span> 初始设置为 1 。训练图像随机裁剪到 512X384。分辨率为1024x768的输入图像处理耗时0.33s 在1080显卡上。</p>
<h3 id="对比实验">对比实验</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210424120236.png" alt="" /><figcaption>1598952274964</figcaption>
</figure>
<p>一个是 对 网络中的各个模块 ACE DCT等做了对比实验，另一个是 在自己训练用的RGB数据集上和其他发给发做了对比，再就是对 加入去噪流程的其他方法做了对比。</p>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>HDR-Net</title>
    <url>/posts/32828/</url>
    <content><![CDATA[<span id="more"></span>
<p>Deep Bilateral Learning for Real-Time Image Enhancement (HDR-Net)</p>
<p>Deep Bilateral Retinex for Low-Light Image Enhancement</p>
<h2 id="主要思想">主要思想</h2>
<p>借鉴了 双边网格（在快速双边滤波算法中被提出用于加速双边滤波）的思想 和 局部颜色仿射不变性的 特点，将图像缩放至低分辨率 输入网络，学习局部和全局特征，融合之后转换到双边网格中，得到双边网格下的局部仿射变换参数。并行的，对输入图像做仿射变换得到引导图，并将其用来引导前面的双边网格做空间和颜色深度上的插值，恢复到和原来图像一样大小的变换参数。最后根据这个参数对输入图像做仿射变换，得到输出图像。</p>
<h3 id="特点">特点</h3>
<ol type="1">
<li>大部分计算过程是在低分辨率的网格下进行的 - CNN中的局部和全局特征提取都是在低分辨率下执行。</li>
<li>学习的是输入输出的变换矩阵，而不是直接学习输出</li>
<li>虽然主要网络实在低分辨率下进行的 但是损失函数是在原来的分辨率上建立的，从而使得低分辨下的操作去优化原分辨下的图像。</li>
</ol>
<h2 id="主要内容">主要内容</h2>
<p>这篇文章主要是在先前的基础上进一步改进的，包括联合双边上采样（JBU)，这里是通过将双边滤波器作用在高分辨的引导图去产生局部平滑但是也保留边缘的上采样；双边引导上采样（BGU Bilateral Guided Upsampling ）则是引入了在双边网格里进行局部仿射变换，再通过引导图进行上采样。这篇论文实际上就是将BGU里的仿射变换操作通过网络进行学习。</p>
<h3 id="bgu-主要思想">BGU 主要思想</h3>
<p>文章提出了一种加速图像处理的方法。由于很多复杂的滤镜处理速度比较慢，一个很常用的解决思路是对原图 downsample 之后做处理，然后用 upsample 得到处理结果。而在 BGU 这个例子里，利用 bilateral grid 来做 downsample - upsample 的工作，使得效果更为出色。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212354.png" alt="" /><figcaption>1595208512974</figcaption>
</figure>
<ul>
<li>任何滤镜效果，在双边网格的局部小区域内（<strong>空域xy小范围内，以及像素域小范围内</strong>）都可以看做是一个线性变换。</li>
<li>利用 bilateral grid 可以从一个低分辨率的图上 slice 得到高分辨率的结果</li>
<li>upsample 针对的是变换系数，而不是直接针对像素。这样对细节方面损失降低到最小。</li>
</ul>
<p>具体实现步骤如下：</p>
<ol type="1">
<li>对原图 downsample 得到一个小图</li>
<li>在小图上应用滤镜</li>
<li>在小图上划分网格（bilateral graid），拟合每一个网格中的线性变换</li>
<li>线性变换的系数在网格间做平滑（这个平滑不仅在 x y 空间域的平滑，还在像素域z轴平滑，所以才要用双边网格，3D双边网格的作用就是以灰度值做第三维，将灰度差异在x轴上体现）</li>
<li>利用这个网格，根据原始大图在这个网格上做 slicing，得到高分辨率的线性变换系数，进一步得到高分辨率的结果</li>
</ol>
<h3 id="网络的主要结构">网络的主要结构：</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212421.png" alt="" /><figcaption>1595165752929</figcaption>
</figure>
<p>​ <strong>Low-level特征</strong> 首先将输入图像下采样至固定的256x256。然后一组共用的特征提取层，一共四层，每层为步长为2的3x3卷积和激活层。如果这个层数太少缺乏表达力，如下图对比，层数太多后面得到的仿射变换系数太稀疏（决定了双边网格的z轴的bin的数量)。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212416.png" alt="" /><figcaption>1595165304189</figcaption>
</figure>
<p>​ <strong>局部特征提</strong>取有两层卷积，这两个卷积都不改变feature map的尺寸，如果没有局部特征提取层，最后的预测的变换系数会失去空间信息。</p>
<p>​ <strong>全局特征提取</strong> 的支路包含了两个步长为2的卷积层和3个全连接层，最后输出一个包含全局信息的64维的特征向量。网络的输入图在提取特征时已经Resize成256x256了，所以可以直接用全连接。局特征具有的全局信息可以作为局部特征提取的先验，如果没有全局特征去描述图像信息的高维表示，网络可能会做出错误的局部特征表示，从而出现如上图的artifact。</p>
<p><strong>两个特征融合</strong> 论文的公式没看懂，但是看代码就是将来给你个特征直接相加 接一个relu再使用卷积层将维度转换为最终的96。具体的这部分卷积的尺寸如表.</p>
<h3 id="双边网格">双边网格</h3>
<p>​ 前面CNN最终输出的尺寸 为16X16X96 96 = 3X4X8; 输出图像为3通道，对应这里的3，4是每个输出通道的每个像素需要四个系数，三个对应输入图像的三通道值和一个偏移。也就是输出图像的每个像素位置需要一个3x4的变换矩阵。那么8就代表像素域的 bin 的数量。而空间域的bin的数量由输入图像和16的比值决定的。</p>
<p><strong>guide map</strong> 的 分辨率和原图一样，通道数为1 ，由原图通过几个卷积生成。</p>
<p><strong>使用可训练的slicing layer进行上采样 </strong> 这一步是要将上一步的信息转换到输入的高分辨率空间，这步操作基于双边网格里的slicing操作，通过一个单通道的引导图将A进行上采样。利用引导图g对A进行上采样，是利用A的系数进行三次线性插值，位置由g决定： <span class="math display">\[
\bar{A}_{c}[x, y]=\sum_{i, j, k} \tau\left(s_{x} x-i\right) \tau\left(s_{y} y-j\right) \tau(d \cdot g[x, y]-k) A_{c}[i, j, k]
\]</span> 这里 <span class="math display">\[
\tau(.)=\max (1-|\cdot|, 0)
\]</span>表示线性插值，<span class="math inline">\(s_{x}\)</span> <span class="math inline">\(s_{y}\)</span>表示网格的宽度和原图分辨率的长宽比。x 和 y 的位置由这两个长宽比决定其在网格中的对应位置，而我们知道网格z轴的 bin数量是8，应该是将z的8维度插值为 256bins 然后将bin合并成1 那么这里输出图像是 <span class="math inline">\(\bar{A}_{c}\)</span> 的 z 轴在网格对应的深度由guide map决定 即<span class="math inline">\(\bar{A}_{c}[i,j,g[x,y]]\)</span>，这个guide map是网络可训练的，那么最后每个<span class="math inline">\(\bar{A}_{c}\)</span> 像素的颜色深度也就由参与guide map决定，例如guide map上相邻灰度差异很大的像素，那么他们在原始网格也中映射的也是z轴上相距很远的两个bin，而BGU中说网格间是局部平滑，也即i索引的这两个变换矩阵差异会很大。但是这里是基于CNN的 并像BGU中那样直接对网格间的参数做平滑约束，这里就靠数据自己学习吧，最终学出来的也应该会有这个效果。 我感觉 它直接拿原图的灰度版本作为guide map 来指导插值也可以，但是这样相当于固定死了，原图差异多大的灰度，映射到网格中就是固定位置的bins虽然说也合理，但是 使用几层CNN来生成guide 就可学习更灵活了。这中以全分辨率的guide指导上采样 比直接使用 可学习的转置卷积上采样的对比。<strong>与基于转置卷积不同，这种方法在guide map的指导下可以很好的保留图像的边缘。</strong></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212434.png" alt="" /><figcaption>1595211122459</figcaption>
</figure>
<h3 id="获得最终的输出">获得最终的输出</h3>
<p>​ 这一部分和上一部分中的guide map的计算是在全分辨率下进行的。这一步就是将上一步得到的全分辨率的变换矩阵（w x h x 12）用来对原图做变换。公式如下：</p>
<p><span class="math display">\[
\mathrm{O}_{c}[x, y]=\bar{A}_{n_{\phi}+\left(n_{\phi}+1\right) c}+\sum_{c^{\prime}=0}^{n_{\phi}-1} \bar{A}_{c^{\prime}+\left(n_{\phi}+1\right) c}[x, y] \phi_{c^{\prime}}[x, y]
\]</span></p>
<p>其中 <span class="math inline">\(n_{\phi}\)</span> = 3 表示输入图像的通道数，<span class="math inline">\(\phi_{c} = I\)</span>表示输入图像，输出的 <span class="math inline">\(\bar{A}\)</span> 为wxhx12的变换参数 w h 代表图像原图分辨率，12 = 3x4 按照按照 [R R R b1 G G G b2 B B B b3] 的顺序排列 R R R b1意味用于计算输出图像R通道值需要用的四个参数 且 公式中的下标按照feature 的通道序号索引的。 例如输出图像的r通道的某位置的值由 r(out)(x) = [a1, a2, a3] * [r, g, b]‘(input) + instance</p>
<h3 id="损失函数">损失函数</h3>
<p>训练参考图像为人工PS的参考图像，和网络生成的图像做损失即可。由此可见损失的计算是在全分辨率下完成的。</p>
<h2 id="实验">实验</h2>
<p>缺点，这个方法对于其他任务 例如图像去雾 ，深度估计，色彩化等任务上效果较差，这是因为其有较强的假设即输出是由输入的局部仿射变换得到的。 可以通过对输入图做特征进一步的提取特征来增强其表达效果。例如一个网格里使用36个仿射变换系数作用在一个层级为3的高斯金字塔处理的输入图要比原始的bilateral效果更好，尽管速度会变慢</p>
<p>….</p>
<h2 id="主要类容">主要类容</h2>
<p>这篇文章将 HDR中使用到的双边滤波的思想 和 Retinex 结合，来做图像增强。首先和HDR一样，将原始降采样，在低分辨率下进行 变换参数的估计。前半部分和HDR 完全一样，包括 CNN的设计 (全局和局部特征提取，guide map的设计)。只是输出的变换参数 维度为 wxhx(9 + 9x2 + 3x4) 这里 9 + 9x2 为噪声估计用到的变换参数，9是W 9x2是偏移量，相当于可变性卷积的意思；3x4是用于光照图估计的变化参数，和HDR中的方式一样。通过两个变换分别估计出了噪声图和光照图，使用式 <span class="math inline">\(\widetilde{\boldsymbol{R}}=(\boldsymbol{I}-\boldsymbol{N}) \oslash \boldsymbol{E}\)</span> 估计最终增强之后的图像。</p>
<h3 id="网络的主要结构-1">网络的主要结构</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212440.png" alt="" /><figcaption>1595218108228</figcaption>
</figure>
<h3 id="噪声图的估计">噪声图的估计</h3>
<p>根据 变换参数对输入图像变换得到噪声估计图像，变换参数为 9 + 9 x 2 感觉相当于1X1可变性卷积。对于某个像素位置 输入为三通道 输出也为三通道，相当于需要 3x3个1x1卷积核，而 9x2 为x y两个方向上的偏移，即可变性卷积的原理。</p>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
最后的噪声变换 是否为 1x1的可变形卷积？</li>
</ul>
<h3 id="损失函数-1">损失函数</h3>
<p>作者使用 LOL 数据集训练 LOL 包含了 1500 low/noemal 图像对，其中500对是真实数据 其他的为合成数据。这里我饿认为LOL提供的不算参考图吧 只是 一对儿不同曝光度的图像。但是作者直接将high作为参考图像来构建损失函数。 <span class="math display">\[
\mathcal{L}:=\mathcal{L}_{r}(\boldsymbol{R}, \tilde{\boldsymbol{R}})+\lambda_{n} \mathcal{L}_{n}(\boldsymbol{N})+\lambda_{e} \mathcal{L}_{e}(\boldsymbol{E}, \boldsymbol{I})
\]</span> 第一项即估计的R和参考的R的相似度，具体不仅包含了衡量两个R的相似度的L1损失还有两个梯度相似度的L1损失。第二项损失用来尽量保存图像中的边缘。第三项即常规光照平滑损失。</p>
<h3 id="实现细节">实现细节</h3>
<p>​ 在训练的时候将输入图像归一化至[0,1] crop到 256x256 batch size 设置为16可变形卷积设置的K=3 Window size=15 边长缩放比例为16 32</p>
<h3 id="结果">结果</h3>
<p>​</p>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>LEUGAN</title>
    <url>/posts/32466/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="leuganlow-light-image-enhancement-by-unsupervised-generative-attentional-networks">LEUGAN:Low-Light Image Enhancement by Unsupervised Generative Attentional Networks</h1>
<h2 id="亮点">亮点</h2>
<ol type="1">
<li>生成器和判别器都是两分支结构，边缘辅助模块用于辅助边缘增强，一个注意力模块用于恢复颜色</li>
<li>设计了一个新的损失函数</li>
</ol>
<h2 id="结构">结构</h2>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212229.png" alt="" /><figcaption>image-20201230154540024</figcaption>
</figure>
<p>提出的 structure loss 和 SSIM 很像，应该是作用于输入图像和输出图像之间的。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212236.png" alt="" /><figcaption>image-20201230154646501</figcaption>
</figure>
<p><strong>这个损失没看懂</strong></p>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>HDR-survey</title>
    <url>/posts/623/</url>
    <content><![CDATA[<span id="more"></span>
<p><a href="https://blog.csdn.net/ZHANG2012LIANG/article/details/85031065">图像融合</a></p>
<h1 id="hdr-综述">HDR 综述</h1>
<h2 id="hdr-概念">HDR 概念</h2>
<ol type="1">
<li>HDR 动态范围：是指图像的最大亮度和最小亮度的比值。对于一个8位的图像，能够存储的动态的范围只有 10^2量级，但是自然场景以及人眼的感知范围远远大于这个。而显示器可以显示的动态范围也只有 10^2 量级，因此直接显示 HDR 图像也会使细节丢失。</li>
<li>HDR成像：包含两个 过程，一个是成像，相机采集生成位深度为10，12或者16位的高动态图像；另一个过程是 显示，使用特殊的显示器显示高动态范围的图像。</li>
</ol>
<p>我理解的低光图像增强和HDR的区别：</p>
<p>主要就是两种场景：</p>
<ol type="1">
<li>一种是纯黑的图提亮；</li>
<li>一种是光照不均匀的图</li>
</ol>
<p>低光照增强实际就是 8位的 图像 -&gt; 提亮后的8位图像，整个过程图像位深度不变，只是通过算法改变了图像的效果，可以认为是伪HDR图像，因为记录的图像的动态范围并没有增加</p>
<p>HDR技术，则是 8位LDR图像 -&gt; 10/14/16位HDR图像，图像的位深度变大了，图像记录信息的动态范围确确实实增加了。但是显示器能显示的动态范围有限，因此还是要经过 色调映射技术才能在一般的显示器上显示。</p>
<p><img src="C:/Users/10729/AppData/Roaming/Typora/typora-user-images/image-20210706200639404.png" alt="image-20210706200639404" style="zoom:50%;" /></p>
<h2 id="方法分类">方法分类</h2>
<h3 id="tone-map色调映射">Tone Map色调映射</h3>
<p>照相机和摄像机可以捕捉到HDR的影像，渲染过程中可以产生HDR的画面。这些内容如果需要显示到LDR的设备上，就需要一个称为tone mapping的过程，把HDR变成LDR HDR-&gt;LDR显示</p>
<p>Tone Map色调映射算法都可以看作 S 曲线映射 只是不同方法曲线形状不太一样</p>
<h3 id="单帧hdr">单帧HDR</h3>
<p>单帧HDR 是输入为LDR图像，然后提升局部和全部细节输出，感觉输出也是LDR域的伪HDR图像</p>
<ol type="1">
<li>条件编码结构：传统的CNN在图像所有位置都采用相同的滤波器权重处理，但是对于图像中 不同区域的处理是不同的，例如图像超分中 通过预先语义分割的一个map作为条件图来使网络对不同纹理的区域有不同的处理。在HDR中也一样，因此常常会通过一个条件子网络来 做位置相关编码核图像相关编码。但是感觉这种和注意力没啥区别 都是点乘 一个 条件图 + 一个偏置</li>
<li>分频处理的结构：将图像分为不同的频带分别处理 低中高 分别处理融合 例如 DRBN 文中 就是全局三个频带处理，并且再每个阶段会有频带间的信息交流 就是会上采样融合作为下一阶段的输入 同时 全局和局部特征提取结构也是很常见的结构</li>
<li>生成多帧再融合的思路就是将 单张图像 通过 乘系数 或者 通过相机响应模型等方法 扩展为多张亮度等级的图 再采用多帧融合的思路进行 融合</li>
</ol>
<h3 id="多帧hdr">多帧HDR</h3>
<p>多帧HDR 常常是要考虑 动态场景下的 HDR 如果是对齐的 可以之间采用一个蒙板函数融合生成 HDR 图像 然后 ToneMap压缩动态范围再显示。同时多帧HDR可能有下面两种思路</p>
<ul>
<li>使用不同的曝光采集多帧图像 融合 由于不同时间采集的一定会有前景不对齐的问题</li>
<li>采集多张相同的低曝光的图像 HDR+ 中 避免不可逆的过饱和，同时也可以采用多帧降噪方法抑制阴影区域的噪声，但是也存在不对齐的问题</li>
</ul>
<p>网络结构</p>
<ol type="1">
<li>传统思路：传统思路就是 预处理 对齐 融合的 方法；早期的方法都是这样做的</li>
<li>多分支的网络：认为不需要认为做 对齐 CNN有自动对齐的功能，因此直接采用多分枝特征提取 + 融合 + 解码 的结构</li>
<li>在网络中引入 特征对齐网络，相对第二种的朴素思路自然效果更好。具体的可以是 使用可变形卷积构建的多尺度特征对齐模板，也可以是基于自适应卷积滤波器的结构，就是一个分支输出线性变换参数 ，通道数为 cxc 然后对对应位置的特征图的 c x c 领域的特征做线性变换输出。融合的话可以使用注意力机制的特征融合模块</li>
</ol>
<p><a href="https://zhuanlan.zhihu.com/p/21983679">参考链接</a></p>
<p>https://zhuanlan.zhihu.com/p/376246037</p>
<p>https://zhuanlan.zhihu.com/p/361596881</p>
<p>https://blog.csdn.net/weixin_45250844/article/details/103207184</p>
<p>https://mp.weixin.qq.com/s/WxHn33gIArfRlRdg0jDfdw</p>
<p>https://mp.weixin.qq.com/s/Tqxj7UfX8z6o3l8OfAqW0w</p>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>LightenNet</title>
    <url>/posts/34239/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="图像增强研究现状">图像增强研究现状</h2>
<ol type="1">
<li><p>基于直方图的方法：Adaptive histogram equalization and its variations</p></li>
<li><p>基于物理模型的方法：通常产生非自然和不现实的结果，因为一些先验或假设并不总是适用于不同的照明条件 [19, 28]</p></li>
<li><p>基于去雾模型的方法：去雾类方法在一定程度上可以提高微光图像的视觉质量，但这些方法缺乏有说服力的物理解释，容易产生不真实的结果。[4, 9, 28]</p>
<blockquote>
<p>Such a method first inverts an input low-light image, and then employs an image dehazing algorithm on the inverted image, finally achieves the enhanced image by inverting the dehazed image.</p>
</blockquote></li>
<li><p>基于稀疏表示的微光图像增强框架：增强的结果在很大程度上依赖于所学习的字典的准确性 [5]</p>
<blockquote>
<p>Fotiadou et al. used two dictionaries (i.e., night dictionary and day dictionary) to transform the Sparse Representation of low-light image patches to the corresponding enhanced image patches.</p>
</blockquote></li>
<li><p>基于融合的方法： 通过两个设计的权重来 融合亮度增强和对比度增强结果。此外采用多尺度融合的方法来减少放大的伪影。然而，与其他基于融合的图像增强方法一样，这种方法由于忽略了弱光照图像退化的物理特性，容易产生过增强、过饱和和不真实的结果 。 [7]</p></li>
<li><p>LLNet：提出了一种基于深度学习的图像自适应增强和去噪方法，直接采用了现有的深度神经网络结构（堆叠稀疏去噪自动编码器）建立低光图像与增强、去噪图像之间的关系。实验结果表明，基于深度学习的方法适用于微光图像增强。[20]</p></li>
<li><p>LIME: 简单的微光图像增强方法。[11]</p>
<blockquote>
<p>This method first estimated the illumination of each pixel in the low-light image, then refined the initial illumination map by a structure prior, finally the enhanced image was achieved based on Retinex model using the estimated illumination map. Besides, in order to reduce the amplified noise, an existing image denoising algorithm was used as post-processing in the LIME method</p>
</blockquote></li>
</ol>
<h2 id="lightennet">LightenNet</h2>
<h3 id="retinex-model">Retinex model :</h3>
<p>​ Retinex model 源自人类视觉系统研究的颜色恒常性模型（在不同光照条件下，人眼可以产生近乎一致的色彩感知）。意思是 色觉不由射入到人眼的可见光的强度决定，而是由物体的反射率所确定，人眼能够以某种方式过滤掉光照的影响而直接获得物体表面的反射率从而确定颜色 。Retinex 理论方法的发展，促进了其在图像增强中的应用。Retinex 主要用来解决数字图像中的光照不均和色偏等问题，也被广泛用于雾霾图像、水下图像等图像处理任务中以获得高对比度的图像，同时在医学、遥感、公安、交通等各个领域都有成功的应用。该模型可用表示： ​ I(x) = R(x) · L(x) ​ I(x)是观测到的图像, x代表像素位置，R表示该位置表面的光波长反射率， L代表该位置的光照度 反射率是物体本身固有的性质，与光照条件无关。如果能够从衣服图像中获得3个色彩通道对应的反射率R，那么从某种程度上说解读了人类视觉的恒常特性。</p>
<h3 id="贡献">贡献</h3>
<ul>
<li>提出了一个用于低光照图像增强的简单的CNN网络。与以往的使用CNN的直接估计输出方法不同，LightenNet学习低光照图像和其响应光照强度图之间的映射。</li>
<li>基于Retinex模型，提出了一种合成低光照图像的方法。</li>
<li>提出的方法在合成低光照图和实际低光照图上都取得了最好的效果</li>
</ul>
<h3 id="lightennet-1">LightenNet</h3>
<p>​ 通过上述，论文作者的目的通过观测图像预测其的L(x)来实现R(x) 即输入一个弱光照图像，网络通过学习到的映射输出其光照映射图，这个光照映射图接着用于获得增强的图片。</p>
<blockquote>
<p>In this letter, our goal is to achieve the reflectance R(x) from the observed image I(x) by predicting its illumination map L(x)</p>
</blockquote>
<p>​ 论文作者说，LightenNet包含四个卷积层，每层都有不同的作用。比如前两层主要作用于高亮度的区域，第三层作用于低亮度的区域，最后一层用于重建。</p>
<ol type="1">
<li>Patch extraction and representation</li>
<li>Feature enhancement ：将噪声和特征分开映射</li>
<li>Non-linear mapping:</li>
<li>Reconstruction</li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212154.png" alt="" /><figcaption>1572008006804</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212219.png" alt="" /><figcaption>1572008198140</figcaption>
</figure>
<p>损失函数为MSE损失 illu是图像的光照图像？？怎么获得？</p>
<p>​ 在通过CNN获得光照映射图之后，还要进行以下3步，才能获得最终的增强图片。</p>
<ol type="1">
<li><p>Gamma矫正（Gamma correction ） L(x)` = L(x)^γ (r=1.7)</p>
<blockquote>
<p>Following previous method [11], we adjust the estimated illumination map by Gamma correction in order to thoroughly unveil dark regions in the results, which can be expressed as</p>
</blockquote></li>
<li><p>作者在优化CNN模型的时候认为局部的nXn输入图像具有相同的光照强度，因此gamma矫正之后需要通过指导滤波来细化光照图。在导图滤波中，将输入图像的红色通道作为导图，滤波窗口大小为16×16.</p></li>
<li><p>基于Retinex 模型，将低光照输入图/光照强度预测图 得到最终的增强后的输出 拥有了精确的光照强度映射图，就能产生自然的接近真实的增强输出，暗的区域得到增强，亮的区域保持不变。</p></li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212215.png" alt="" /><figcaption>1572010031130</figcaption>
</figure>
<h3 id="具体的实现">具体的实现</h3>
<h4 id="训练参数">训练参数</h4>
<ul>
<li>使用高斯分布初始化权重，偏置设0</li>
<li>初始学习率0.05 每100000个迭代减少0.5</li>
<li>momentum =0.9 batch_size=128</li>
</ul>
<h4 id="样本的合成">样本的合成</h4>
<p>​ 首先，基于图像局部亮度大小恒定的假设制造数据。作者从互联网上收集了600张带有各种内容的清晰的照明图像（光照充足且没有噪声和模糊的图），用于样本对的合成（弱光照图像以及其光照映射）。基于Retinex ，给定实际的清晰图像R(X)，和一个随机光照值L， 一个弱光照图I(x) = R(x)*L 通过这种方式，获得训练图片集patch patch的overlapping pixels = 10 16X16的训练图片 2000..张 （假设输入的16X16图像具有相同的光照映射）</p>
<h3 id="实验结果">实验结果</h3>
<ul>
<li>最后的1X1的Constarint重建对这个模型很重要</li>
<li>最后尝试增加卷积层数没有作用 作者认为的原因是 1.梯度扩散效应 2.简单的原始架构重复导致网络架构不合理 作者将来会考虑使用更复杂的CNN网络来做</li>
<li><strong>Failure cases </strong> 训练的时候使用的都是没有噪声的图像，因此对于带有噪声的微光图像 效果不好</li>
</ul>
<h3 id="研究方向">研究方向</h3>
<ol type="1">
<li>使用复杂的网络</li>
<li>考虑带噪声的低光照图</li>
</ol>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>MSR</title>
    <url>/posts/6701/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="传统算法retinex-系列多尺度视网膜增强算法">传统算法：Retinex 系列多尺度视网膜增强算法</h2>
<h3 id="retinex原理">Retinex原理</h3>
<p>​ I(x) = R(x) · L(x) ​ 对上式子取对数，得到 ​ Log[R(x,y)] = Log[I(x,y)] - Log[L(x,y)] = ​ Log[R(x,y)] = Log[I(x,y)] - Log[I(x,y)*F(x,y)] ( *表示卷积)<br />
把这个技术运用到图像处理上，就是针对我们现在已经获得的一副图像数据I(x,y），计算出对应的R(x,y)，则R(x,y)认为是增强后的图像，现在的关键是如何得到L(X,Y)。Retinex理论的提出者指出这个L(x,y）可以通过对图像数据I(x,y）进行F(x,y)高斯模糊而得到，从实际运用的角度来说，也可以用均值模糊来代替高斯模糊。</p>
<ol type="1">
<li>输入： 原始图像数据I(x,y),尺度（也就是所谓的模糊的半径）</li>
<li>处理：
<ul>
<li>计算原始图像按指定尺度进行模糊后的图像 L(x,y);</li>
<li>按照上式的计算方法计算出 Log[R(x,y)]的值</li>
<li>将 Log[R(x,y)]量化为0到255范围的像素值，作为最终的输出</li>
</ul></li>
</ol>
<p>上述在讲Log[] 量化时，会产生色彩失真。这也是这算法的通病。上述实现的算法通常叫SSR (Single Scale Retinex,单尺度视网膜增强）</p>
<h4 id="msr-multi-scale-retinex">MSR (Multi-Scale Retinex)</h4>
<p>​ 最为经典的就是3尺度的，大、中、小，既能实现图像动态范围的压缩，又能保持色感的一致性较好。同单尺度相比，该算法有在计算Log[R(x,y)]的值时步骤有所不同。</p>
<ul>
<li>需要对原始图像进行每个尺度的高斯模糊，得到模糊后的图像Li(x,y),其中小标i表示尺度数</li>
<li>对每个尺度下进行累加计算 Log[R(x,y)] = Log[R(x,y)] + Weight(i)* ( Log[Ii(x,y)]-Log[Li(x,y)]); 其中Weight(i)表示每个尺度对应的权重，要求各尺度权重之和必须为1，经典的取值为等权重</li>
</ul>
<h4 id="带色彩恢复的多尺度视网膜增强算法msrcrmulti-scale-retinex-with-color-restoration">带色彩恢复的多尺度视网膜增强算法(MSRCR,Multi-Scale Retinex with Color Restoration)</h4>
<p>​ 其改进在于对Log量化过程的改进：</p>
<ol type="1">
<li><p>分别计算出 Log[R(x,y)]中R/G/B各通道数据的均值Mean和均方差Var（注意是均方差）</p></li>
<li><p>利用类似下述公式计算各通道的Min和Max值 Min = Mean - Dynamic * Var; Max = Mean + Dynamic * Var;</p></li>
<li><p>对Log[R(x,y)]的每一个值Value，进行线性映射：</p>
<p>​ R(x,y) = ( Value - Min ) / (Max - Min) * (255-0)</p>
<p>同时要注意增加一个溢出判断,即：</p>
<p>​ if (R(x,y) &gt; 255) R(x,y) =255; else if (R(x,y) &lt; 0) R(x,y)=0</p></li>
</ol>
<h4 id="more...">more...</h4>
<p>参考链接： https://www.cnblogs.com/Imageshop/archive/2013/04/17/3026881.html https://cloud.tencent.com/developer/article/1011768</p>
<h2 id="msr-net">MSR-net</h2>
<p>### 主要贡献：</p>
<ol type="1">
<li>作者认为 传统的MSR多尺度视网膜增强算法的过程可以用神经网络去模拟，并且神经网络的参数可以根据数据自学习。相对传统的采用固定的高斯模糊核要灵活 <strong>多尺度Retinex实际上相当于一个具有残差结构的前馈卷积神经网络</strong></li>
<li>提出MSR-net 基于Retinex模型和神经网络的方法端到端得学习亮暗图之间得映射</li>
</ol>
<h3 id="相关知识">相关知识</h3>
<p>常用得图像增强的方法有</p>
<ol type="1">
<li>直方图均衡化HE<br />
</li>
<li>Gamma Correction 通过压缩亮区像素的范围，扩大暗区域的亮度范围</li>
<li>上述的方法都只关注了单个像素而没有关注其周围的像素信息。文献[5] contextual and variational contrast enhancement ...</li>
</ol>
<h3 id="结构图">结构图</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212112.png" alt="" /><figcaption>1572616376706</figcaption>
</figure>
<h4 id="多尺度对数变换f1">多尺度对数变换f1</h4>
<p><span class="math display">\[
M_{j}=\log _{v_{j}+1}\left(1+v_{j} \cdot X\right), j=1,2, \ldots, n
\]</span></p>
<p>​ 输入的一幅3通道的图像，经过对数变换为 n*3 通道的tensor。 log函数具有压缩高灰度值的数据，拉伸低灰度值的数据。X代表输入图像，vj代表对应的尺度n代表尺度数。 ​ 接着，使用一个卷积+Relu 。上述的操作主要是通过多次对数变换的加权和来得到更好的图像，加速了网络的收敛。</p>
<h4 id="difference-of-convolution-f2">Difference-of-convolution f2</h4>
<p>​ 这里的卷积代表着对不同尺度的图像进行平滑处理。将不同卷积层的输出contact 一起最后来个1X1卷积，相当于MSR中对不同尺度的SSR输出的加权平均。1X1之后引入了一个 <strong>“-”</strong> 操作，与SSR中的 Log[I(x,y)] - Log[L(x,y)] 减 的目的相同，根据模拟产生的L(x,y) 还原出Log[R(x,y)] 深度为K</p>
<h4 id="颜色重建函数-f3">颜色重建函数 f3</h4>
<p>​ 由于上一步 减 的到的是 Log(R(x,y)) 因此最后一个1X1卷积就是用来色彩还原的。 ​ 上述三步的输出结果可视化如下：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212122.png" alt="" /><figcaption>1572618295529</figcaption>
</figure>
<h4 id="损失函数">损失函数</h4>
<p><span class="math display">\[
L=\frac{1}{N} \sum_{i=1}^{N}\left\|f\left(X_{i}\right)-Y_{i}\right\|_{F}^{2}+\lambda \sum_{i=-1}^{K+2}\left\|W_{i}\right\|_{F}^{2}
\]</span></p>
<h3 id="实验">实验</h3>
<h4 id="数据集">数据集</h4>
<p>​ 依然是同时使用合成图像验证，使用公开的真实的数据集。同时还对比了各种超参数对结果的影响。<strong>作者建立了一个新的真实数据集 包含HQ LQ图片</strong> 同时还使用了已有的正式低光照数据集 <strong>MEF NPE VV</strong></p>
<h4 id="训练参数">训练参数</h4>
<p>​ 中间的神经网络的深度为K ， adam 权重衰减为10-6 batch_size为64 初始学习率为10-4 学习率除10每100K到200K iteration。作者实验发现带有第一个对数多尺度变换的要比单尺度变换的效果好 4个变换尺度，分别为1，10，100，300</p>
<h4 id="结果">结果</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212118.png" alt="" /><figcaption>1572779177674</figcaption>
</figure>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>MBLLEN</title>
    <url>/posts/12562/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="主要思想">主要思想</h2>
<p>​ 由于图像内容的复杂性，作者认为简单的网络难以实现高质量的图像增强。因此设计了MBLLEN 的多分枝结构。将图像增强任务分解成和不同特征相关的子问题，不同特征层分别增强，最后通过多分枝结果融合得到搞质量的输出。</p>
<h2 id="网络结构">网络结构</h2>
<h3 id="结构">结构</h3>
<p>​ 由三部分组成，FEM, EM, FM;特征提取模块，增强模块，融合模块。</p>
<ol type="1">
<li>FEM：将三通道微光图像输入FEM模块，FEM模块实际是由10个步长1，3X3卷积Relu层组成的网络。每一层卷积后的feature map一方面作为EM模块的输入，一方面接着传给下一层卷积接着提特征</li>
<li>EM：增强模块，数量等于上一层输出的feature map的个数。每个EM模块都是conv deconv结构，输出的尺寸和原微光图像尺寸相同。所有EM模块输出的featuremap contact 作为FM的输出</li>
<li>FM：多分支融合，将上一层contact的结果用1X1卷积聚合。得到最终的输出</li>
<li>应用在视频....</li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212135.png" alt="" /><figcaption>1572958613424</figcaption>
</figure>
<h3 id="损失函数">损失函数</h3>
<p>​ 传统的MSE或者MAE损失在增强的任务中不能很好的表现，作者使用了更复杂的损失函数，包含结构损失，Context(语义)损失， 区域损失</p>
<ol type="1">
<li>结构损失（structure loss ）：这个损失是为了提高输出图像的视觉 效果。通常低光照图像暗区因为硬件捕获的问题带有模糊和伪影，他们视觉效果不好但是不能被MAE损失表现出来。作者提出的结构损失中包含两部分：简化的SSIM MS-SSIM。</li>
</ol>
<p><span class="math display">\[
L_{S S M}=-\frac{1}{N} \sum_{p \in i m g} \frac{2 \mu_{x} \mu_{y}+C_{1}}{\mu_{x}^{2}+\mu_{y}^{2}+C_{1}} \cdot \frac{2 \sigma_{x y}+C_{2}}{\sigma_{x}^{2}+\sigma_{y}^{2}+C_{2}}
\]</span></p>
<p><span class="math display">\[
L_{S t r}=L_{S S I M}+L_{M S-S S I M}
\]</span></p>
<ol start="2" type="1">
<li>context loss： 作者认为MSE和SSIM智能表示低层信息，认为使用更高级的语义信息是有必要的。采用了SRGAN中相似的做法来设计损失。具体是使用VGG-19 net提取两张图片的特征图。然后比较特征图的差别，如下式，i,j表示VGG-19中第j层特征第i个block的输出特征图。</li>
</ol>
<p><span class="math display">\[
L_{V G G / i, j}=\frac{1}{W_{i, j} H_{i, j} C_{i, j}} \sum_{x=1}^{W_{i, j}} \sum_{z=1}^{C_{i, j}}\left\|\phi_{i, j}(E)_{x, y, z}-\phi_{i, j}(G)_{x, y, z}\right\|
\]</span></p>
<ol start="3" type="1">
<li><strong>region loss</strong> 区域损失：上面两个损失函数都是基于全图的。然而在图像增强任务中，需要对低光照区域提供更多的注意力。因此作者提出这个损失函数来平衡低光照区域和其他区域的损失。作者筛选暗区域的策略是 发现选取一副图中前40%暗的像素作为暗区域最能代表实际的暗区域。<strong>这里可以寻找更恰当的选取暗区域的方法</strong> 式子中，EL GL中的L代表输入图像的暗区域，H代表亮区域 E,G代表输出图像和groundtruth WL=4 WH=1 <span class="math display">\[
L_{R e g i o n}=w_{L} \cdot \frac{1}{m_{L} n_{L}} \sum_{i=1}^{n_{L}} \sum_{j=1}^{m_{L}}\left(\left\|E_{L}(i, j)-G_{L}(i, j)\right\|\right)+w_{H} \cdot \frac{1}{m_{H} n_{H}} \sum_{i=1}^{n_{H}} \sum_{j=1}^{m_{H}}\left(\left\|E_{H}(i, j)-G_{H}(i, j)\right\|\right)
\]</span></li>
</ol>
<h3 id="实现细节">实现细节</h3>
<p>​ 选取PASCAL VOC上的一部分图像使用损及gamma矫正转化为合成的低光照图像，同时加入了泊松噪声。56张验证，144张测试。minibatch 24 256X256X3的图像。VGG损失作者选取的是j=4 i=3处的feature map 。ADAM优化器，学习率0.002 b1=0.9 b2=0.99 e=10-8 学习率每个epoch learnrate * 0.95。</p>
<h2 id="结果">结果</h2>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212143.png" alt="" /><figcaption>1572960634271</figcaption>
</figure>
<h2 id="结论">结论</h2>
<ul>
<li>感觉这篇文章 出发点 很独特，不同于以往的基于retinex模型的方法，提取光照图等等。通过多层特征提取，然后分别增强，最后多分枝融合。思想很独特。</li>
<li>区域损失 值得借鉴和改进 VGG损失？？？</li>
</ul>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>Progressive Retinex</title>
    <url>/posts/47951/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="progressive-retinex-mutually-reinforced-illumination-noise-perception-network-for-low-light-image-enhancement">Progressive Retinex: Mutually Reinforced Illumination-Noise Perception Network for Low Light Image Enhancement</h2>
<h2 id="贡献">贡献</h2>
<ul>
<li>提出了一种基于Retinex模型的 渐进式训练结构，低光图像的照度和噪声以一种相互增强的方式被感知，即光照估计和去噪交替进行训练。一方面用训练的光照图知道去噪网络训练，接着反过来去噪模型知道光照估计，如此交替</li>
<li>提出了两个基于 全point-wise CNN的 光照估计和噪声估计网络</li>
<li>在真实和合成数据集上均效果良好</li>
</ul>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>SID-NISM</title>
    <url>/posts/37892/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="sid-nism-a-self-supervised-low-light-image-enhancement-framework">SID-NISM: A Self-supervised Low-light Image Enhancement Framework</h1>
<h2 id="主要思路">主要思路</h2>
<ol type="1">
<li>类似RetinexNet 的方法构建分解网络，但是在是无监督的 多以区别在于 它 将低光照图的 直方图均衡化版本作为高亮度版本一起分解，构建场景一致性损失。</li>
<li>考虑了噪声，I = R X L + N</li>
<li>第二阶段的 光照调整方法 不是gamma 矫正，是作者自己提出的新的函数 这个可以借鉴</li>
</ol>
<h2 id="主要内容">主要内容</h2>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212012.png" alt="" /><figcaption>image-20201231103107211</figcaption>
</figure>
<h3 id="损失函数">损失函数</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212017.png" alt="" /><figcaption>image-20201231103305198</figcaption>
</figure>
<p>均衡后的图像的 分解产生的 R 要和 低光照图直接分解产生的R 一致</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212022.png" alt="" /><figcaption>image-20201231103339686</figcaption>
</figure>
<p>光照平滑和一致损失，第一项表明 光照分段平滑，以反射率图的梯度加权。第二项以高低光照图自身梯度加权，是为了让在两张图中都是边缘的地方损失小，非共同边缘的地方损失大，即两张光照图的边缘一致。这和RetinexNet中的损失一致</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212027.png" alt="" /><figcaption>image-20201231103645591</figcaption>
</figure>
<p>第一项，意思为增强后的图像的 梯度要比原图像放大beta倍，当然 计算原输入图像 S 的梯度的时，滤掉了梯度较小的地方。第二项是，输入图像的 HSV中的H通道和 分解R的 H通道要一致，防止颜色乱变。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212032.png" alt="" /><figcaption>image-20201231103920053</figcaption>
</figure>
<p>最后一项是噪声 一致的 ，输入图像乘 噪声估计图N ，约束噪声的大小。（不知道为啥）</p>
<h3 id="光照调整">光照调整</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212037.png" alt="" /><figcaption>image-20201231104256103</figcaption>
</figure>
<p>​ 这个阶段是整篇文章比较有意思的地方。它分析了直接用GAMMA矫正来调整光照图带来的问题，然后针对它进行了改进，提出了一个新的光照调整函数。</p>
<p>​ 具体的，图像R的对比度由于暗区域的过度增亮而被破坏。最终增强图像的照明水平仍然不足，因为明亮区域几乎没有变化。一句话总结就是，gamma矫正过分的提高了暗区域的光照，导致R*L 乘回去之后，R衰减的太少，使得整体效果显得过增强。对于亮区域gamma 矫正又几乎不调整，导致亮区域的低光光照被拉低。按它的思路应该是 暗区域亮度拉升变缓，以抑制R的过曝，亮区域亮度要再提高免得亮区域亮度乘上系数后又被压缩回去了。（是这样嘛？？？）</p>
<p>​ 按照上述逻辑 作者提出的曲线波形是NIMS的形状，表达式为：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212042.png" alt="" /><figcaption>image-20201231105830496</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212047.png" alt="" /><figcaption>image-20201231105852294</figcaption>
</figure>
<p>首先对光照图的像素亮度进行聚类，（两类）。分为亮像素和暗像素，去亮像素区的最小亮度值作为T，计算yita。参数 yita 的意义在于，在NISM下将亮像素的最小照明值映射到0.8</p>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>SURVEY</title>
    <url>/posts/27906/</url>
    <content><![CDATA[<span id="more"></span>
<p>Lighting the Darkness in the Deep Learning Era</p>
<p>An Experiment-Based Review of Low-Light Image Enhancement Methods</p>
<h2 id="低光照存在的挑战">低光照存在的挑战</h2>
<p>背光，光照不均匀，弱光照，极低光照，彩色光，噪声等</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210605213901.png" alt="" /><figcaption>image-20210605213359244</figcaption>
</figure>
<h2 id="传统方法">传统方法</h2>
<ul>
<li><p>基于直方图的方法：原理就是将低光照图像的直方图 尽可能调整为 均匀分布，通过原始分布 到 理想均匀分布的约束，来推导像素的变换函数，完成增强。其中用到了累计直方图作为中间桥梁。但是直方图的先验假设也是很强的，在处理彩色图像的时很容易出现颜色失真，噪声等问题。</p></li>
<li><p>基于灰度变换的方法</p>
<ul>
<li>线性变换</li>
<li>非线性变换：常用的非线性函数有 LOG 和 GAMMA 函数。仅仅使用固定的参数来增强，没有考虑到图像的全局信息，因此常常借助以下辅助手段，例如使用图像的累积概率直方图分布来自适应估计获得矫正参数等。</li>
</ul></li>
<li><p>基于 Retinex 模型：这个模型是根据人眼颜色感知恒常特性建立，物体的颜色是由物体对不同波长的光的反射能力决定，而不是由反射光强度的绝对值决定，物体的颜色不受光照非均匀性的影响。</p>
<ul>
<li>单尺度 SSR 多尺度 MSR；MSRCR 外加了颜色矫正，因为前两者都是三通道分离操作，所以颜色失真很严重，而后者效果好很多。</li>
<li>这种方法可以较好的提高对比度和亮度，且在彩色图像处理方面也有更好的优势。但早期的方法基本都是使用高斯核分别对RGB三通道做平滑以近似光照，<strong>对边缘保持能力较差</strong>，会由holo效应，或者会导致过曝（因为光照图一定是小于1的无论如何都会拉量图像）</li>
</ul></li>
<li><p>基于频率域的方法：需要计算量大，并且变换参数，频率选择都存在很强的假设，如果设置不好效果就差</p></li>
<li><p>同态滤波：认为输入图像由 低频光照分量 和 高频的反射率分量，也即Retinex那一套。只不过 频域滤波也只能消除加性的 信号。因此首先在 log 域将 光照和反射率分离，然后在频率域通过高频滤波器滤波，最后还原</p>
<ul>
<li>小波变换</li>
</ul></li>
<li><p>基于融合的方法：泊松融合。在梯度域中将梯度融合</p>
<ul>
<li>单帧图像融合：可以使用 CRF 相机响应模型来生成多曝光图然后融合</li>
<li>多帧图像融合：效果好但是需要同一场景的图像 不好获取</li>
</ul></li>
<li><p>基于去雾模型的方法</p></li>
</ul>
<h2 id="深度学习">深度学习</h2>
<p>### 基于监督学习的方法</p>
<p>基于监督学习的方法大概可以分为 单阶段的 和 多阶段的网络。早期（2018年及以前）的都是单阶段的网络，一个输入，一个输出，损失函数作用于一个位置。</p>
<ul>
<li>例如18年BMVC上的MBLLEN，通过精心设计的多分支特征提取融合的结构增强</li>
</ul>
<p>这种方法完全依赖网络的拟合能力和训练数据。但是自从2019年及以后，几乎都会采用多阶段的网络，他们会利用一定的传统先验，来使网络更容易学习到低光照到参考图之间的函数映射，降低对网络参数量和规模的依赖。</p>
<ul>
<li>典型的是 RetinexNet，KinD等网络。 结合 Retinex 模型的方法，增加一个光照估计阶段，然后使用一个UNET对分解的反射率图进行重建，这样的方式会比直接用UNET对低光照图矫正效果好很多。</li>
<li>基于频率分解的方法，可以使用边缘提取方法预先对图像做边缘提取，分为边缘和细节分别处理。也可以在网络结构上增加学习频率提取的结构（并列空洞卷积做差），这是20年CVPR上的文章DRBN</li>
<li>多曝光融合：AAAI20上的方法，按照单帧HDR的思路，首先对低光图乘系数，然后每个分支分别处理一个输入，并融合</li>
<li>金字塔：也有用拉普拉斯金字塔的，使用拉普拉斯金子塔来对不同频带的图像分别增强，然后恢复。</li>
</ul>
<h4 id="存在的问题">存在的问题</h4>
<p>成对的训练数据缺乏，使用合成数据训练又难以获得较好的泛化性</p>
<h3 id="强化学习">强化学习</h3>
<h3 id="无监督学习">无监督学习</h3>
<p>使用 GAN 来消除网络对成对训练图像的依赖。由于缺乏强监督，使用单一的GAN增强，局部会有不一致的增强效果，EnlightenGAN的做法是通过一个全局和一个局部判别器结合以及感知损失结合的方式，来提高生成图像质量的稳定性。但是它在一些场景中依然存在问题。另一个增加强约束的方式是采用 cycleGAN 结构，cycleGAN的缺点是结构复杂，训练过程更不稳定。</p>
<p>虽然GAN的方法效果不稳定，但是不失为一种值得探索的方向</p>
<h3 id="半监督">半监督</h3>
<p>这种方法就是一部分使用 成对的图像监督 来提高网络对细节的恢复能力。另一方面使用对抗损失提高网络的泛化性</p>
<h3 id="零样本学习">零样本学习</h3>
<p>20年开始有文章尝试零样本的方法构建低光照增强网络，以彻底摆脱对训练数据的依赖。这种方法依赖人工设计的图像鲜艳损失指导网络训练，这就依赖于损失函数的好坏，增强效果不自然。</p>
<h2 id="损失函数">损失函数</h2>
<p>SSIM L1 L2 损失 L2平方损失有模糊效应，用L1损失细节恢复更好，SSIM 也能很好的保留结构和纹理特征</p>
<p>感知损失，即 VGG 提取特征后 衡量特征之间的相似性</p>
<p>平滑损失 ： 变分损失，对梯度约束 达到一定的去噪效果</p>
<p>对抗损失</p>
<p>曝光损失：局部均值和期望曝光值之间的误差</p>
<h2 id="数据集">数据集</h2>
<p>合成数据集：使用gamma矫正 合成低光照数据 或者使用Retinex先分离光照然后把光照调低再还原。现在几乎不用 合成数据的方法了</p>
<p>LOL</p>
<p>SCIE</p>
<p>MIT-Adobe FiveK：主要是用于 色调调整或者增强，但是也有被用于低光照增强的</p>
<p>SID：Raw格式的数据</p>
<p>SMOID</p>
<h2 id="评价指标">评价指标</h2>
<p>PSNR</p>
<p>MAE</p>
<p>MSE</p>
<p>SSIM</p>
<p>LOE</p>
<p>NIQE</p>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>Self-supervised_cnn_enhance</title>
    <url>/posts/49751/</url>
    <content><![CDATA[<span id="more"></span>
<p>Self-supervised Image Enhancement Network: Training with Low Light Images Only</p>
<h2 id="主要贡献">主要贡献</h2>
<ul>
<li>基于最大熵和 Retinex 模型，构建了一个无监督的低光照图像增强网络，不需要paired图像训练。甚至是可以只用一张图像训练网络。</li>
<li>提出的网络速度很快</li>
</ul>
<h2 id="主要方法">主要方法</h2>
<p>​ 文章的思想是。设计一个网络，分解产生 反射率图 和 光照图。而为了实现自监督的目的，即仅仅使用低光照图像来训练，就需要设计一系列的损失函数来约束网络学习的方向。这里主要就用到了熵最大化的约束条件。熵最大化就是当图像的直方图分布服从均匀分布时，它的熵最大，因此 反射率图的学习 很大程度上是依赖这个熵最大化约束，否则在没有参考的正常图像的情况下没法学到合理的 反射率。</p>
<h3 id="损失函数">损失函数</h3>
<ol type="1">
<li><p>重建损失，和常规的一样</p></li>
<li><p>反射率图 R 的约束：</p>
<p><span class="math display">\[l_{R}=\left\|\max _{c \in R, G, B} R^{c}-F\left(\max _{c \in R, G, B} S^{c}\right)\right\|_{1}+\lambda\|\triangle R\|_{1}\]</span></p>
<p>其中 <span class="math inline">\(F(.)\)</span> 代表直方图均衡化后的结果。第一项的含义为，取输入低光照图像的最大亮度通道（并非固定的R,G,B中的一个），对它做直方图均衡化，并将这个作为网络输出的反射率图的最大通达的参考结果。第二项对反射率图的梯度约束的作用是抑制噪声。</p>
<p>使用最大像素通道的目的：</p>
<ul>
<li>对于弱光图像，最大通道对其视觉效果的影响最大</li>
<li>如果选择其他通道，则可能会出现通道值的饱和，因为控制住最大通道得像素值不饱和，那么其他低于他的像素值肯定不会饱和。</li>
<li>如果我们选择其中一个颜色通道，比如R, G或B通道，就不符合自然图像规律。</li>
</ul>
<p>使用直方图均衡化的原因</p>
<ul>
<li>直方图均衡化可以大大提高图像的信息熵。</li>
</ul></li>
<li><p>光照图的约束，采用的即为Retinex-Net 这篇文章中的损失</p></li>
</ol>
<p><span class="math display">\[
\mathcal{L}_{i s}=\sum\left\|\nabla I_{i} \circ \exp \left(-\lambda_{g} \nabla R_{i}\right)\right\|
\]</span></p>
<ol start="4" type="1">
<li>综合上述，即为本文的损失函数</li>
</ol>
<h3 id="优点">优点</h3>
<p>​ 大部分基于模型的方法，其实就是类似上述设计一个根据各种先验设计损失函数，然后将损失函数转换到频域使用FFT加快计算，不断迭代得到增强结果。上式设计的损失函数其实也可以类似优化，但是作者是使用一个小网络来完成的，之所以选用后者的方法，有如下原因：</p>
<ol type="1">
<li><p>使用传统的FFT优化，在每一张图像增强的过程中都需要 迭代优化，而且损失函数越复杂，计算量就越大，不同图像迭代次数也不一样时间开销也不一样。</p></li>
<li><p>同时，传统的解决方案不能利用大数据，以前的数据处理对新的数据处理毫无帮助。</p></li>
<li><p>与有监督的CNN方法比，这种方法不需要精心设计的训练数据就能达到较好的效果，且精心设计的参考图像不一定能包含实际需要的所有场景，泛化能力不好。相对基于模型的传统方法，本文的算法在计算速度上有有优势。</p></li>
</ol>
<h3 id="网络结构">网络结构</h3>
<figure>
<img src="../figs/1590054658337.png" alt="" /><figcaption>1590054658337</figcaption>
</figure>
<p>​ 关于结构，卷积层和sigmod层的叠加也可以产生可以接受的结果。然而，如果添加一些concat层，增强结果将变得更加清晰。作者还采用了上采样和下采样的结构，这样的结构可以起到抑制噪声的作用，但是有些场合中会带来模糊的效果。</p>
<h2 id="实验">实验</h2>
<h3 id="实验细节">实验细节</h3>
<p>​ 使用LOL dataset中的485张 低光照图像训练，15张做测试。batch_size = 16，path_size=48x48</p>
<h3 id="训练时间的影响">训练时间的影响</h3>
<p>​ 作者训练了1000epoch，没20epoch在测试集上计算一次 各种指标，包括GE CE GMI SSIM NIQE.... 最终的结论是，取在 200epoch输出的模型参数。因为随着 epoch的增加，虽然一些表征清晰度的指标会效果变好，但是像SSIM这种有参考图像的指标会越来越差，这是因为噪声的影响。所以为了在噪音和清晰度之间保持一个平衡，选择在200epoch停止。</p>
<h3 id="重复稳定性">重复稳定性</h3>
<p>​ 这部分实验目的就是 反复训练几次，对比每次训练的结果是不是可以反复复现。结论是 一些指标不是特别稳定，这可能是由于 L1 损失函数的解不唯一的原因？但是 整体出来的视觉效果差不多，所以说 该文方法可重复复现，具有稳定性。</p>
<h3 id="与其他方法对比">与其他方法对比</h3>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>UMLE</title>
    <url>/posts/59508/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="umle-unsupervised-multi-discriminator-network-for-low-light-enhancement">UMLE: Unsupervised Multi-discriminator Network for Low Light Enhancement*</h1>
<h2 id="亮点">亮点</h2>
<p>这三类 鉴别器的设计，有效性有待考究，但是从原理上讲的通，它通过 高通/低通滤波器 提取颜色 和 文理部分，分别输入鉴别器。所以可以借鉴用外加手段实验输入图像信息分离的 思路 分开处理。优点类似 今年CVPR2020上的那个频率分解的思路，它是用两个不同卷积率的差去分离频率信息。</p>
<p>另一个采用了鉴别器生成器权重共享的策略，至少证明这个 东西不会影响效果，是轻量化的一个小trick。然后使用不同的CPAM对编码器的编码特征提取。</p>
<h2 id="主要贡献">主要贡献</h2>
<ol type="1">
<li>提出了一个实时的 基于 不成对图像训练的 低光照图像增强网络</li>
<li>使用了 多个 鉴别器，分别从 光照、纹理、和多尺度三个方面 来组合对抗损失 （创新点）</li>
<li>设计了 注意力模块，由通道注意力 和 像素注意力串接而成的 CPAM （最大池化+平均池化组成的像素注意力）</li>
<li>生成器 和 鉴别器 的 编码部分共享权重，说是可以提高训练的稳定性，并减少模型的大小</li>
</ol>
<h2 id="主要内容">主要内容</h2>
<h3 id="结构">结构</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508211942.png" alt="" /><figcaption>image-20201230103849874</figcaption>
</figure>
<p>​ 主要结构 不必 多说 很清晰。主要要注意以下几个点：</p>
<ul>
<li>共享编码区的权重 提高了训练的稳定性，减少了模型大小</li>
<li>采用了 三个 鉴别器
<ul>
<li>多尺度鉴别器就是 在三个不同尺度各一个鉴别器来鉴别真假。因为仅仅一个全局鉴别器很难同时关注所有的区域，大尺度可以更好的关注大区域，小尺度可以更好关注细节区域</li>
<li>颜色鉴别器：注意 图上 未画出。实际在图像输入颜色鉴别器之前首先使用了 一个低通滤波器，以过滤纹理边缘信息，使得鉴别器只关注 颜色</li>
<li>纹理鉴别器：同上，输入鉴别器前，通过高斯高通滤波器提取出了 纹理细节，避免颜色影响。接着再编码-&gt;CPAM-&gt;分类输出结果。</li>
</ul></li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508211948.png" alt="" /><figcaption>image-20201230104605270</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508211954.png" alt="" /><figcaption>image-20201230104650389</figcaption>
</figure>
<p>上式是论文贴的 低通滤波器。</p>
<h3 id="损失">损失</h3>
<ol type="1">
<li>对抗损失</li>
<li><strong>循环一致损失</strong> EnlightenGAN 中提出 由于不成对缺乏 很好的约束 ，所以它采用了 自监督损失（输入输出VGG），但是这里也用了VGG损失，也用了 循环一致损失，为啥？不过可以看出文章作者并未多提 循环一致这个事儿，说明不是创新点。</li>
<li>颜色损失：论文中 单独列出，我以为包含在 对抗损失之中？</li>
<li>保留损失：就是输入输出 VGG损失</li>
<li>重建损失：就是输入输出的L1距离 不知道为啥要这个损失 感觉 还不如VGG</li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508211958.png" alt="" /><figcaption>image-20201230105254104</figcaption>
</figure>
<h2 id="实验结果">实验结果</h2>
<p>论文 从以下几个方面做实验：</p>
<ol type="1">
<li>和其他方法的定量对比 在 ETH数据集上对比 。</li>
<li>和其他方法做 USER STUDY实验</li>
<li>消融实验 ， 验证 三种对抗其 和 CPAM 模块的作用、</li>
<li>在 应用 上，和SLAM 检测 这两个具体任务结合 分别验证对他们带来的性能提升。</li>
</ol>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>Zero-DCE</title>
    <url>/posts/9431/</url>
    <content><![CDATA[<span id="more"></span>
<p>Zero-Reference Deep Curve Estimation for Low-Light Image Enhancement</p>
<h2 id="主要贡献">主要贡献</h2>
<ol type="1">
<li>提出了第一个不依赖于成对训练图像的低光照图像增强卷积神经网络</li>
<li>设计了一个 可以近似像素映射的 image-specific 曲线以及通过迭代方式形成的高阶曲线。这种特定于图像的曲线可以在很大的动态范围内有效地执行像素映射。</li>
<li>在没有参考图像的情况下，通过设计 特定的 任务相关的损失函数来训练深度网络 这种方法存在巨大的潜力。</li>
<li>640 x 480输入图像 500 FPS</li>
</ol>
<h2 id="主要方法">主要方法</h2>
<h3 id="光照增强曲线-le-curve">光照增强曲线 LE-curve</h3>
<p>​ 作者说受 P图软件的 曲线调整的启发，有了这个思想。希望设计一个 可以自动增强图像的曲线，其中自适应曲线参数仅依赖于输入图像。这种曲线的设计要有如下性质：</p>
<ul>
<li>增强后图像的每个像素值都应在归一化范围[0,1]内，以避免溢出截断导致的信息丢失;</li>
<li>曲线应该是单调递增的，以保持相邻像素的差异(对比度); 就是本来输入低光照图像较亮的区域输出对应也应该更亮，而不是反而变暗。</li>
<li>这种曲线可微，可以反向传播。</li>
</ul>
<p>从上述需要的三个条件可以看出，作者设计的这种曲线感觉和 图像直方图调整的那个曲线不是一回事。这个曲线就是一个对输入图像的像素经过一个非线性映射然后输出吧，类似gamma的增强方法？所以这个曲线得满足单调可谓等的性质，与gamma不同的是，这个曲线参数由CNN输出，其不同像素位置的曲线参数不同，而gamma是全局用一条曲（但是文中这么设计我觉得仅仅是曲线是单调递增得并不能保证相邻像素输出得对比度差异，因为相邻像素使用得曲线参数不一样，虽然两条曲线都是递增得，但是分别对应映射输出后得值不一定依旧保证输入之前的相对大小关系，可能这种情况通过后面的损失函数，网络训练完之后便不会出现了吧），换句话说就是不同像素位置的 映射方式不同。具体设计的曲线 如下式子：</p>
<p><span class="math display">\[L E(I(\mathbf{x}) ; \alpha)=I(\mathbf{x})+\alpha I(\mathbf{x})(1-I(\mathbf{x}))\]</span></p>
<p>​ 上式中 <span class="math inline">\(I(\mathbf{x})\)</span> 为输入图像的x位置的像素值，<span class="math inline">\(\alpha\)</span>为曲线调整的参数，由CNN输出决定，不同的<span class="math inline">\(\alpha\)</span>对应不同形状的曲线参数，具体可见下图。例如当<span class="math inline">\(\alpha\)</span>=-1时，就是一个二次曲线，输入输出的映射关系为二次关系。同理。 ​ 同时将上式迭代，可以构成更高阶的曲线。</p>
<p><span class="math display">\[L E(I(\mathbf{x}) ; \alpha)=I(\mathbf{x})+\alpha I(\mathbf{x})(1-I(\mathbf{x}))\]</span></p>
<p>​ 最后，每个像素位置的<span class="math inline">\(\alpha\)</span>参数都不同，也就是不同位置的 曲线映射方式不一样，所以CNN输出的<span class="math inline">\(\alpha\)</span>其实是和输入图像大小一样的。而由于有n次迭代，每次迭代分别对 RGB 三通道使用独立的<span class="math inline">\(\alpha\)</span> 所以最终CNN输出的feature map的尺寸应该是n x 3 x W x H大小的。如下图：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508211854.png" alt="" /><figcaption>1589469658310</figcaption>
</figure>
<p>上图 b 可以看出:</p>
<ul>
<li>对于迭代一次的曲线，当<span class="math inline">\(\alpha = -1\)</span> 为二次曲线，即输入x &gt; 输出y; 这种情况对于过曝的像素可以压缩它的像素值。</li>
<li>... 当<span class="math inline">\(\alpha = 0\)</span> 为恒等映射，输入输出不变</li>
<li>... 当<span class="math inline">\(\alpha = 1\)</span>时，曲线为凸函数，即 输入x &lt; 输出y; 这种情况可以增大像素值，对应光照增强。</li>
</ul>
<p>因此这种曲线调整的方式 不仅有可以增强低曝光区域像素的能力，还可以压缩过曝区域的像素。</p>
<h3 id="dec-net">DEC-Net</h3>
<p>​ 就是常规的CNN，主要是轻量。他的输出特征为A，通道数为迭代次数x3(RGB)，尺寸和输入图像一样。</p>
<h3 id="损失函数-non-reference-loss-functions">损失函数 Non-Reference Loss Functions</h3>
<p>​ 我觉得这就是最关键的地方吧，感觉前面说的曲线的方式 和 传统的CNN学习端到端的像素映射没什么区别，不能决定它不用参考图像来训练。</p>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
可能 增加 a 的曲线方式可以增强 CNN的非线性性？可以试试去掉后面的曲线调整部分，直接CNN输出增强后的图像，然后用这个损失函数来做看效果。</li>
</ul>
<h4 id="空间一致性损失-spatial-consistency-loss">空间一致性损失 Spatial Consistency Loss</h4>
<p><span class="math display">\[L_{s p a}=\frac{1}{K} \sum_{i=1}^{K} \sum_{j \in \Omega(i)}\left(\left|\left(Y_{i}-Y_{j}\right)\right|-\left|\left(I_{i}-I_{j}\right)\right|\right)^{2}\]</span></p>
<p>​ 作者描述的这个损失的目的是，保留输入图像和输出图像对应位置像素和相邻像素之间的差异。其中K表示局部区域像素数，<span class="math inline">\(\Omega(i)\)</span>是像素位置<span class="math inline">\(i\)</span>的上下左右四个领域位置。<span class="math inline">\(Y,I\)</span> 分别表示增强后的图像和输入图像。感觉这个式子和局部梯度相似性很像。</p>
<h4 id="曝光控制-exposure-control-loss">曝光控制 Exposure Control Loss</h4>
<p>​ 为了抑制过曝和欠曝的出现，用这个损失函数来控制图像整体曝光水平。这项就是衡量局部区域（16x16）的像素值的平均水平与 常数E例如0.6之间的差距。作者说这个E取[0.4, 0.7]差别不大。</p>
<p><span class="math display">\[L_{e x p}=\frac{1}{M} \sum_{k=1}^{M}\left|Y_{k}-E\right|\]</span></p>
<h4 id="颜色恒常损失color-constancy-loss">颜色恒常损失Color Constancy Loss</h4>
<p>​ 基于 <strong>Gray-World color constancy hypothesis</strong> 这个规则，对于一幅有着大量色彩变化的图像，R，G，B， 三个分量的平均值趋于同一灰度值。 从物理意义上讲，灰色世界法假设自然界景物对于光线的平均反射的均值在总体上是个定值，这个定值近似地为“灰色”。也就是一个正常的彩色图像，R,G,B三通道的平均值应该都相等。避免</p>
<p><span class="math display">\[L_{c o l}=\sum_{\forall(p, q) \in \varepsilon}\left(J^{p}-J^{q}\right)^{2}, \varepsilon=\{(R, G),(R, B),(G, B)\}\]</span></p>
<p>上式含义显而易见。设计了色彩恒常性损失，以纠正在增强的过程中可能出现的颜色偏差。</p>
<h4 id="光照平滑-illumination-smoothness-loss">光照平滑 Illumination Smoothness Loss</h4>
<p>这个损失就 类似 Retinex中的局部光照一致性原理。即局部区域的 a 参数应该是一样的。</p>
<h2 id="实验">实验</h2>
<p>​ 使用SICE数据集中的 2422张训练，其余的测试。 每张图resize到512x512进行训练。</p>
<h3 id="各项损失函数的作用">各项损失函数的作用</h3>
<p>​ 作者分别去掉四项损失中的一项，进行训练得到的结果如下：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508211903.png" alt="" /><figcaption>1589508112377</figcaption>
</figure>
<ul>
<li>去掉 spa损失，对比度细节下降，如空中的白云。</li>
<li>去掉 esp损失，图像暗区域的曝光度降低，没能成功增强暗区域</li>
<li>去掉 col 颜色恒常损失，可以看出图片整体颜色出现偏色</li>
<li>没有 tv 光照平滑损失，图像出现严重伪影</li>
</ul>
<h3 id="各项参数的影响">各项参数的影响</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508211909.png" alt="" /><figcaption>1589508544279</figcaption>
</figure>
<p>​ 网络深度-通道数-迭代次数。可以看出对比def三个图，可以看出 迭代一次的曲线增强能力太弱，因此需要更多次的迭代来合成高阶曲线，这样曲线具有更强的调整能力。</p>
<h3 id="训练数据的影响">训练数据的影响</h3>
<p>​ 作者 做了三类训练数据</p>
<ol type="1">
<li>原本DEC训练数据中的一部分900张 只有欠曝光的图像。DEC_low</li>
<li>DARK FACE数据集中收集的 9000张 低光照数据集，也是只有低光照数据集。DEC_large_L</li>
<li>使用数据增广的方法，包含了 过曝光和欠曝光图像，从1,2部分获得的数据集 4800张 DEC_large_LH</li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508211925.png" alt="" /><figcaption>1589509475989</figcaption>
</figure>
<p>​ 由图c,d可以看出，如果训练数据中不含有过曝光数据，最终网络会对原本光照正常的区域造成过曝光，但是如果低光照数据多，对暗区域增强的能力要强。因此</p>
<ol type="1">
<li>训练数据集中必须有 过曝光图像，防止过曝</li>
<li>低光照训练图像多的话，网络的增强能力要强。</li>
</ol>
<h3 id="最终对比结果">最终对比结果</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508211917.png" alt="" /><figcaption>1589509826164</figcaption>
</figure>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>test</title>
    <url>/posts/63534/</url>
    <content><![CDATA[<span id="more"></span>
<p><span class="math display">\[
L_{R e g i o n}=w_{L} \cdot \frac{1}{m_{L} n_{L}} \sum_{i=1}^{n_{L}} \sum_{j=1}^{m_{L}}\left(\left\|E_{L}(i, j)-G_{L}(i, j)\right\|\right)+w_{H} \cdot \frac{1}{m_{H} n_{H}} \sum_{i=1}^{n_{H}} \sum_{j=1}^{m_{H}}\left(\left\|E_{H}(i, j)-G_{H}(i, j)\right\|\right)
\]</span></p>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>UNET-GAN</title>
    <url>/posts/17245/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="unet-gan">UNET-GAN</h1>
<p>A U-Net Based Discriminator for Generative Adversarial Networks</p>
<h2 id="主要思想">主要思想</h2>
<p>文章的工作主要是针对 GAN 的判别器的改进。使用一个U-NET作为判别器，判别器的编码部分输出对图象的全局分类结果，判别器的解码部分输出对图象像素级的判别。因此这个判别器既能判别全局也能判别局部信息。同时作者结合了 最新的正则化技术 MixCup 提出了个一致性正则化损失 。</p>
<h2 id="主要内容">主要内容</h2>
<h3 id="研究背景">研究背景</h3>
<p>GAN 目前从三个研究角度进行，即大规模训练、网络结构设计和正则化技术。尽管近年来取得了很大的进展，但如何综合具有全局语义连贯、长程结构和细节准确性的图像仍然具有挑战性。对抗器的好坏会直接影响生成器的效果。在目前最先进的GAN模型中，作为分类网络的鉴别器只学习一种表示，因此它通常要么关注全局结构，要么关注局部细节。合成样本的分布随着训练过程中生成器的不断变化而变化，容易忘记之前的任务 (在判别器训练的背景下，学习语义、结构和纹理可以被认为是不同的任务) .....</p>
<h3 id="结构">结构</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210331203430.png" alt="" /><figcaption>image-20210225152057705</figcaption>
</figure>
<p>结构很简单 ，使用UNET 判别器可以同时输出去全局和局部判别。对于全局判别的标签就是和输入图像一样的 0/1的值。除此之外，还是用了MixCut正则技术</p>
<h3 id="cutmix">CutMix</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210411220658.png" alt="" /><figcaption>20210331203434</figcaption>
</figure>
<p>mixcut用在对判别器的训练。通常判别器输入要么是正样本要么是负样本。而MixCut就是复制粘贴的方式结合在一起输入网络（M就是二值掩膜）。对应的标签按照 正负样本 面积比例给的。除此之外还有 Mixup,Cutout</p>
<ul>
<li>Mixup:将随机的两张样本按比例混合，分类的结果按比例分配；</li>
<li>Cutout:随机的将样本中的部分区域cut掉，并且填充0像素值，分类的结果不变；</li>
<li>CutMix:就是将一部分区域cut掉但不填充0像素而是随机填充训练集中的其他数据的区域像素值，分类结果按一定的比例分配</li>
</ul>
<p>CutMix优点：</p>
<ol type="1">
<li>在训练过程中不会出现非信息像素，从而能够提高训练效率；</li>
<li>保留了regional dropout的优势，能够关注目标的non-discriminative parts；</li>
<li>通<strong>过要求模型从局部视图识别对象，对cut区域中添加其他样本的信息</strong>，<strong>能够进一步增强模型的定位能力</strong>；</li>
<li>不会有图像混合后不自然的情形，能够提升模型分类的表现；</li>
<li>训练和推理代价保持不变</li>
</ol>
<p>https://blog.csdn.net/weixin_38715903/article/details/103999227</p>
<h3 id="损失函数">损失函数</h3>
<p>从上述结构不难看出 生成器的损失函数 包含两项 一个是编码器的全局判别损失和解码器的像素级判别损失。而训练对抗器的损失由于加入了CutMix操作，作者又提出了一个一致性损失，更充分的利用了像素判别的优势。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210331203438.png" alt="" /><figcaption>image-20210225153426059</figcaption>
</figure>
<p>这个式子的意思是 将 真实图片 x 和 生成器生成的假的图片 fake 首先使用Mask将二者混合后 输入 判别器，解码出的像素级判别的结果 1 和 将x 和 fake 分别输入判别器得到各自的得分后再使用Mask混合得到结果2 ，这两个结果应该一致。因此最终判别器的损失：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210331203442.png" alt="" /><figcaption>image-20210225153858202</figcaption>
</figure>
<p>但是对于全局判别器的Mix 标签 这里的设置和 以往的不同 以往Mix后的全局标签设置是按照正负样本面积比例计算的一个介于0-1之间的值。而作者这里 <strong>Mix标签设置为固定的0。</strong>用于约束编码器的输出。</p>
<blockquote>
<p>In contrast to [47], the class label c ∈ {0, 1} for the new CutMix image x˜ is set to be fake, i.e. c = 0. Globally the mixed synthetic image should be recognized as fake by the encoder Denc U ,otherwise the generator can learn to introduce the CutMix augmentation into generated samples, causing undesirable artifacts.</p>
</blockquote>
<h2 id="实验">实验</h2>
<p>MixCut图象的生成概率 p 在前n个epoch是从0到0.5逐步提高的。以给生成器足够的时间学习生成较真实的图片。避免判别器过早的训练稳定。一开始生成器生成的太假 判别mix难度太小。</p>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>虹软实习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>动态场景复原</title>
    <url>/posts/50530/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="动态场景视频增强复原">动态场景、视频增强复原</h1>
<h3 id="动态场景hdr">动态场景HDR</h3>
<p>早期的算法有将所有图象像素强度大概对齐到一定水平，然后使用光流算法完成图象空间对齐，最后再融合输出, 也有使用CNN实现光流的但是本质都是在图象层面完成了空间对齐。这篇文章作者将HDR看作图象到图象的转换，认为CNN有容忍偏差的能力，不需要显式的对齐图片，因此全用一个网络完成。</p>
<blockquote>
<p>Deep HDR Reconstruction of Dynamic Scenes 这篇文章就是使用CNN在图象层面完成对齐，再使用CNN对对齐后的图象融合</p>
</blockquote>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210411220742.png" alt="" /><figcaption>20210331203224</figcaption>
</figure>
<p><strong>HDR-GAN: HDR Image Reconstruction from Multi-Exposed LDR Images with Large Motions</strong></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210331203231.png" alt="" /><figcaption>image-20210203172029335</figcaption>
</figure>
<p>感觉这个文章和上面一篇区别不大，就是引入了GAN 他还是需要参考图的（图中的L1损失）。只不过生成器结构更复杂了。使用了多尺度的结果，左边浅蓝色是下采样的过程。文章还提到 最中间那个 + 连接 是有特征对齐的作用（浅紫色块处的+连接）。</p>
<p>###　视频重建</p>
<p><strong>EDVR: Video Restoration with Enhanced Deformable Convolutional Networks</strong></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210331203234.png" alt="" /><figcaption>image-20210203152356503</figcaption>
</figure>
<p>主体结构如上图。主要流程为 -&gt;输入特征提取 --&gt; 特征对齐模块 -&gt; 特征融合模块 -&gt; 重建输出。核心是特征对齐模块和融合模块。</p>
<p>特征对齐模块的设计使用了可变性卷积 和 特征金子塔的结构。如下图。特征融合模块的一个重要的设计是 作者考虑到不同帧间即便对齐了，但是由于信息量的差异，应该有不同的权重，因此加入了注意力。</p>
<p>应该是端到端损失 据说不好训练</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210331203254.png" alt="" /><figcaption>image-20210203152951344</figcaption>
</figure>
<h3 id="动态场景去噪">动态场景去噪</h3>
<p><strong>Supervised Raw Video Denoising with a Benchmark Dataset on Dynamic Scenes</strong></p>
<p>这篇文章和上面那篇很相似。特征对准的方式几乎一样。只不过多了一个非局部模块。整个流程对去噪任务做了特定的设计。</p>
<h3 id="视频去模糊">视频去模糊</h3>
<p>Spatio-Temporal Filter Adaptive Network for Video Deblurring</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210331203244.png" alt="" /><figcaption>image-20210203154242212</figcaption>
</figure>
<p>这篇文章视频去模糊的结构分为了三个模块 特征提取模块、STFAN模块、重建模块。可以看出，这篇文章的空间对齐和去模糊操作也都是在中间的特征空间完成的。但是这个STFAN模块采用了不同与可变性卷积的特征对齐方式。不过和上面的类似，他们都是采用了隐式的空间对齐方法，即网络中集成了可以完成空间对齐的结构，但是 本质上的约束都是来自最后的端到端的监督损失。</p>
<p>作者提出了一个 FAC layer 用于完成特征对齐和去模糊的操作。具体的流程：特征提取网络对当前帧提取特征得到Et STFAN模块则使用卷积对三元组输出处理得到 两个滤波器，一个是对齐滤波器一个是去模糊滤波器（图中的Falign deblur）。将估计的对齐滤波器（包含了复杂的运动参数）和上次迭代的 Ht-1（应该就是代表上一帧的去模糊后的特征图） 通过 FAC层得到一个对齐后的特征，同理去模糊滤波器也这么用。最后将两个特征concat（concat特征包含了这一帧去模糊的结果和上一帧去模糊后的特征图经过对齐后的结果）。 使用另一个解码器得到输出，同时concat的结果会传递到下一帧的计算。</p>
<p>FAC 层</p>
<p>很直观 这个为啥可以对其特征？</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210331203249.png" alt="" /><figcaption>image-20210203160054986</figcaption>
</figure>
<p>损失函数</p>
<p>也是很简单 一个MSE 一个感知损失</p>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>虹软实习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>相似性度量</title>
    <url>/posts/60259/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="相似性度量方法">相似性度量方法</h1>
<h3 id="samise">Samise</h3>
<p>Learning to Compare Image Patches via Convolutional Neural Networks</p>
<p>这篇文章讲了使用 孪生神经网路做patch的相似性度量。但是他的输出是全连接 只有1个输出，损失了空间位置的相关性。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210331203220.png" alt="" /><figcaption>image-20210204085426652</figcaption>
</figure>
<h3 id="图像质量评价">图像质量评价</h3>
<p>Deep Neural Networks for No-Reference and Full-Reference Image Quality Assessment</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210331203217.png" alt="" /><figcaption>image-20210204092039515</figcaption>
</figure>
<p>这个文章是用来做图像质量评价的。输入两个VGG结构类似的孪生神经网络 对两个patch计算得到两个全连接特征，特征融合是将两个特征向量以及他们的插值concat 然后输入后面两个共享权重的全连接（patch weight estimate ...）。上面一个全连接输出一的是 该patch的权重，下面一个全连接输出的是 该Patch 的打分。最终的输出是所有随机采样的patch的加权平均。</p>
<h3 id="图象配置">图象配置</h3>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>虹软实习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/posts/48231/</url>
    <content><![CDATA[<span id="more"></span>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>Linux系统相关api</category>
      </categories>
  </entry>
  <entry>
    <title>Linux基础知识</title>
    <url>/posts/29244/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="linux">Linux</h1>
<p>在面试中，Linux 知识点相对于网络和操作系统等知识点而言不是那么重要，只需要重点掌握一些原理和命令即可</p>
<ul>
<li><strong>能简单使用 cat，grep，cut 等命令进行一些操作；</strong></li>
<li><strong>文件系统相关的原理，inode 和 block 等概念，数据恢复；</strong></li>
<li><strong>硬链接与软链接；</strong></li>
<li><strong>进程管理相关，僵尸进程与孤儿进程，SIGCHLD</strong></li>
</ul>
<h2 id="文件系统">文件系统</h2>
<h3 id="组成">组成</h3>
<p>最主要的几个组成部分如下：</p>
<ul>
<li>inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；</li>
<li>block：记录文件的内容，文件太大时，会占用多个 block。</li>
</ul>
<p>除此之外</p>
<ul>
<li>superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</li>
<li>block bitmap：记录 block 是否被使用的位图。</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210417213817.png" alt="" /><figcaption>image-20210417213817484</figcaption>
</figure>
<h3 id="文件读取">文件读取</h3>
<p>对于 Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来。</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210417213859.png" alt="image-20210417213859503" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210417213911.png" alt="image-20210417213911816" /><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210417213859.png" alt="image-20210417213859503" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210417213911.png" alt="image-20210417213911816" /></p>
<p>而对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号</p>
<h3 id="磁盘碎片">磁盘碎片</h3>
<p>指一个文件内容所在的 block 过于分散，导致磁盘磁头移动距离过大，从而降低磁盘读写性能</p>
<h3 id="block">block</h3>
<p>在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种，不同的大小限制了单个文件和文件系统的最大大小。一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的 block。</p>
<h3 id="inode">inode</h3>
<p>inode 具体包含以下信息：</p>
<ul>
<li>权限 (read/write/excute)；</li>
<li>拥有者与群组 (owner/group)；</li>
<li>容量；</li>
<li>建立或状态改变的时间 (ctime)；</li>
<li>最近读取时间 (atime)；</li>
<li>最近修改时间 (mtime)；</li>
<li>定义文件特性的旗标 (flag)，如 SetUID...；</li>
<li>该文件真正内容的指向 (pointer)。</li>
</ul>
<p>inode 具有以下特点：</p>
<ul>
<li>每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)；</li>
<li>每个文件都仅会占用一个 inode。</li>
</ul>
<p>inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用让 inode 记录的引用 block 块记录引用信息。</p>
<p><img src="C:/Users/10729/AppData/Roaming/Typora/typora-user-images/image-20210417214209808.png" alt="image-20210417214209808" style="zoom:67%;" /></p>
<h3 id="目录">目录</h3>
<p>建立一个目录时，会分配一个 inode 与至少一个 block。<strong>block 记录的内容是目录下所有文件的 inode 编号以及文件名</strong>。可以看到文件的 <strong>inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的写权限有关</strong>。</p>
<h3 id="挂载">挂载</h3>
<p>挂载利用目录作为文件系统的进入点，也就是说，进入目录之后就可以读取文件系统的数据。</p>
<h2 id="文件">文件</h2>
<h3 id="文件属性">文件属性</h3>
<p>用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。使用 ls 查看一个文件时，会显示一个文件的信息，例如 <code>drwxr-xr-x 3 root root 17 May 6 00:14 .config</code>，对这个信息的解释如下：</p>
<ul>
<li>drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段</li>
<li>3：链接数</li>
<li>root：文件拥有者</li>
<li>root：所属群组</li>
<li>17：文件大小</li>
<li>May 6 00:14：文件最后被修改的时间</li>
<li>.config：文件名</li>
</ul>
<p>常见的文件类型及其含义有：</p>
<ul>
<li>d：目录</li>
<li>-：文件</li>
<li>l：链接文件</li>
</ul>
<p>9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对<strong>文件拥有者、所属群组以及其它人的文件权限</strong>。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。</p>
<h3 id="链接">链接</h3>
<ul>
<li>实体链接 ： 即硬链接，在目录下创建一个条目，记录着文件名和inode编号，这个inode编号就是源文件的inode，删除源文件 这个硬链接还是存在，只是把当前文件从它在的目录下的记录抹去了，但是还有别的地方链接了它，那么这个文件的inode就不会真正删除</li>
<li>软链接：类似于windows下的快捷方式，只是记录了文件的绝对路径，如果源文件删除了 软链接就失效了。</li>
</ul>
<h2 id="常用命令">常用命令</h2>
<h3 id="chmod-修改权限">chmod 修改权限</h3>
<p>可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## chmod [-R] xyz dirname/filename</span><br></pre></td></tr></table></figure>
<p>示例：将 .bashrc 文件的权限修改为 -rwxr-xr--</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## chmod [ugoa]  [+-=] [rwx] dirname/filename</span><br><span class="line">- u：拥有者</span><br><span class="line">- g：所属群组</span><br><span class="line">- o：其他人</span><br><span class="line">- a：所有人</span><br><span class="line">- +：添加权限</span><br><span class="line">- -：移除权限</span><br><span class="line">- =：设定权限</span><br></pre></td></tr></table></figure>
<p>示例：为 .bashrc 文件的所有用户添加写权限。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">chmod a+w .bashrc</span><br></pre></td></tr></table></figure>
<h3 id="ln-创建链接">ln 创建链接</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">## ln [-sf] source_filename dist_filename</span><br><span class="line">-s ：默认是实体链接，加 -s 为符号链接</span><br><span class="line">-f ：如果目标文件存在时，先删除目标文件</span><br></pre></td></tr></table></figure>
<h3 id="ls-查看目录信息">ls 查看目录信息</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## ls [-aAdfFhilnrRSt] file|dir</span><br><span class="line">-a ：列出全部的文件</span><br><span class="line">-d ：仅列出目录本身</span><br><span class="line">-l ：以长数据串行列出，包含文件的属性与权限等等数据</span><br></pre></td></tr></table></figure>
<h3 id="touch-建立新文件">touch 建立新文件</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">更新文件时间或者建立新文件。</span><br><span class="line">## touch [-acdmt] filename</span><br><span class="line">-a ： 更新 atime</span><br><span class="line">-c ： 更新 ctime，若该文件不存在则不建立新文件</span><br><span class="line">-m ： 更新 mtime</span><br><span class="line">-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date&#x3D;&quot;日期或时间&quot;</span><br><span class="line">-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]</span><br></pre></td></tr></table></figure>
<h3 id="cp-复制">cp 复制</h3>
<p>复制文件。如果源文件有两个以上，则目的文件一定要是目录才行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp [-adfilprsu] source destination</span><br><span class="line">-a ：相当于 -dr --preserve&#x3D;all</span><br><span class="line">-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身</span><br><span class="line">-i ：若目标文件已经存在时，在覆盖前会先询问</span><br><span class="line">-p ：连同文件的属性一起复制过去</span><br><span class="line">-r ：递归复制</span><br><span class="line">-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制</span><br><span class="line">--preserve&#x3D;all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了</span><br></pre></td></tr></table></figure>
<h3 id="mv-移动">mv 移动</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## mv [-fiu] source destination</span><br><span class="line">## mv [options] source1 source2 source3 .... directory</span><br><span class="line">-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖</span><br></pre></td></tr></table></figure>
<h3 id="cat-取得文件内容">cat 取得文件内容</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## cat [-AbEnTv] filename</span><br><span class="line">-n ：打印出行号，连同空白行也会有行号，-b 不会</span><br><span class="line"></span><br><span class="line">## cat test &gt; test1   ### test 内容会覆盖test1的所有内容</span><br><span class="line">## cat test &gt;&gt; test1  ### test内容添加在 test1 内容的后面</span><br></pre></td></tr></table></figure>
<h3 id="locate-文件搜索">locate 文件搜索</h3>
<p>文件搜索。可以用关键字或者正则表达式进行搜索。locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且<strong>每天更新一次，所以无法用 locate 搜索新建的文件</strong>。可以使用 <strong>updatedb</strong> 来立即更新数据库。较快</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## locate [-ir] keyword</span><br><span class="line">-r：正则表达式</span><br><span class="line">##  locate -r &#x2F;ls$     ### 查找以&#x2F;ls结尾的文件  </span><br></pre></td></tr></table></figure>
<h3 id="find-文件搜索">find 文件搜索</h3>
<p>文件搜索。可以使用文件的属性和权限进行搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## find [basedir] [option]</span><br><span class="line">example: find . -name &quot;shadow*&quot;</span><br><span class="line"></span><br><span class="line">与时间有关的选项</span><br><span class="line"></span><br><span class="line">与文件拥有者和所属群组有关的选项</span><br><span class="line"></span><br><span class="line">与文件权限和名称有关的权限</span><br></pre></td></tr></table></figure>
<h3 id="tar-打包指令">tar 打包指令</h3>
<p>压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>fork和vfork</title>
    <url>/posts/60894/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="fork-和-vfork">fork 和 vfork</h1>
<p>https://blog.csdn.net/gatieme/article/details/51417488</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>Linux系统相关api</category>
      </categories>
  </entry>
  <entry>
    <title>malloc实现原理</title>
    <url>/posts/56154/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="malloc-和-free的实现原理解析">malloc 和 free的实现原理解析</h1>
<p>https://jacktang816.github.io/post/mallocandfree/</p>
<h2 id="进程地址空间">进程地址空间</h2>
<figure>
<img src="https://jacktang816.github.io/img/linux/linuxAddrSpace.png" alt="" /><figcaption>img</figcaption>
</figure>
<p>如上图所示在一个32位系统中，可寻址的空间大小是4G，linux系统下0-3G是用户模式，3-4G是内核模式。而在用户模式下又分为代码段、数据段、.bss段、堆、栈。</p>
<ul>
<li>代码段： 主要存放进程的可执行二进制代码，字符串字面值和只读变量（不能修改的）</li>
<li>数据段：数据段存放已经初始化且初始值非0的全局变量和局部静态变量</li>
<li>bss段：存放未初始化或初始值为0的全局变量和局部静态变量</li>
<li>堆：存放由用户动态分配内存存储的变量；</li>
<li>栈：主要存储局部变量、函数参数、返回地址等</li>
</ul>
<p>bss段、数据段和代码段是可执行程序<strong>编译时的分段</strong>，<strong>运行时还需要栈和堆</strong>。将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和bss段的加载，并在内存中为这些段分配空间。栈也由操作系统分配和管理，<strong>堆则是由程序员自己管理</strong>。</p>
<blockquote>
<p>为什么要区分 .bss段 和 数据段？ .data段存放的是已经初始化的且非0的全局或局部变量，因此这个初始化的值会保存在可执行文件中，而.bss段中是未初始化的，因此编译的时候只是记录了该段需要的空间大小，在执行额时候才会给.bss段中的数据分配内存。这样可以减少生成的可执行文件的大小。而对于字面值常量，显示是和代码一样的不可修改的常量值，所以放在代码段。</p>
</blockquote>
<p><strong>内存映射段(mmap)</strong> 内核将硬盘文件的内容直接映射到内存，任何应用程序都可通过 Linux 的 mmap() 系统调用请求这种映射。</p>
<ul>
<li><p>内存映射是一种方便高效的文件 I/O 方式， 因而被用于装载动态共享库。</p></li>
<li><p>用户也可创建匿名内存映射，<strong>该映射没有对应的文件，可用于存放程序数据</strong>。</p></li>
<li><p>mmap 映射区向下扩展，堆向上扩展，两者相对扩展，直到耗尽虚拟地址空间中的剩余区域.</p></li>
</ul>
<h2 id="进程">进程</h2>
<p>在Linux中进程由进程控制块(PCB)描述，用一个<code>task_struct</code> 数据结构表示，这个数据结构记录了所有进程信息，包括进程状态、进程调度信息、标示符、进程通信相关信息、进程连接信息、时间和定时器、文件系统信息、虚拟内存信息等.。</p>
<p>和 <code>malloc</code>密切相关的就是虚拟内存信息，定义为 <code>struct mm_struct *mm</code> 具体描述进程的地址空间。<strong><code>mm_struct</code>结构是对整个用户空间（进程空间）的描述</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///include/linux/sched.h </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap</span>;</span>  <span class="comment">/* 指向虚拟区间（VMA）链表 */</span></span><br><span class="line">  <span class="keyword">rb_root_t</span> mm_rb;               <span class="comment">/*指向red_black树*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap_cache</span>;</span>     <span class="comment">/* 指向最近找到的虚拟区间*/</span></span><br><span class="line">  <span class="keyword">pgd_t</span> * pgd;                  <span class="comment">/*指向进程的页目录*/</span></span><br><span class="line">  <span class="keyword">atomic_t</span> mm_users;                   <span class="comment">/* 用户空间中的有多少用户*/</span>                                     </span><br><span class="line">  <span class="keyword">atomic_t</span> mm_count;                   <span class="comment">/* 对&quot;struct mm_struct&quot;有多少引用*/</span>                                     </span><br><span class="line">  <span class="keyword">int</span> map_count;                       <span class="comment">/* 虚拟区间的个数*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">mmap_sem</span>;</span></span><br><span class="line">  <span class="keyword">spinlock_t</span> page_table_lock;         <span class="comment">/* 保护任务页表和 mm-&gt;rss */</span>       </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span>            <span class="comment">/*所有活动（active）mm的链表 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> start_code, end_code, start_data, end_data; <span class="comment">/* 代码段、数据段 起始地址和结束地址 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> start_brk, brk, start_stack; <span class="comment">/* 栈区 的起始地址，堆区 起始地址和结束地址 */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> arg_start, arg_end, env_start, env_end; <span class="comment">/*命令行参数 和 环境变量的 起始地址和结束地址*/</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> rss, total_vm, locked_vm;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> def_flags;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> cpu_vm_mask;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> swap_address;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> dumpable:<span class="number">1</span>;</span><br><span class="line">  <span class="comment">/* Architecture-specific MM context */</span></span><br><span class="line">  <span class="keyword">mm_context_t</span> context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>start_brk 和 brk 分别是堆的起始和终止地址。堆的大小由start_brk 和brk决定。
<ul>
<li>可以使用系统调用 sbrk() 或 brk() 增加 brk的值，达到增大堆空间的效果，但是系统调用代价太大，涉及到用户态和内核态的相互转换。所以，<strong>实际中系统分配较大的堆空间，进程通过malloc() 库函数在堆上进行空间动态分配，堆如果不够用 malloc 可以进行系统调用，增大brk的值。</strong></li>
</ul></li>
<li>start_stack是进程栈的起始地址，栈的大小是在编译时期确定的，在运行时不能改变。</li>
</ul>
<blockquote>
<p>malloc 只知道 start_brk 和brk之间连续可用的内存空间它可用任意分配，如果不够用了就向系统申请增大brk。后面一部分主要就malloc如何分配内存进行说明。</p>
</blockquote>
<blockquote>
<p>个人理解：每个进程都有一个4G的虚拟进程空间，但是其中很大一部分起始都没有映射到物理内存，比如堆区，不可能每个进程都同时把这么大的堆空间都分配物理内存。而是在动态申请后，真正使用了 才会分配。每个进程malloc管理的也是自己区域虚拟空间中的堆区，不同进程之间的malloc不存在交叉。</p>
</blockquote>
<h3 id="相关的系统调用">相关的系统调用</h3>
<h4 id="brk-和-sbrk">brk() 和 sbrk()</h4>
<p>由之前的进程地址空间结构分析可以知道，要增加一个进程实际的可用堆大小，就需要将 brk 指针向高地址移动。Linux通过<strong>brk和sbrk系统调用</strong>操作break指针。两个系统调用的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>;             <span class="comment">//将brk指针直接设置为某个地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> increment)</span></span>;  <span class="comment">//将brk指针从当前位置移动increment所指定的增量 ，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p><strong>进程所面对的虚拟内存地址空间，只有按页映射到物理内存地址，才能真正使用</strong>。受物理存储容量限制，整个堆虚拟内存空间不可能全部映射到实际的物理内存。因此每个进程有一个<strong>rlimit</strong>表示当前进程可用的资源上限。这个限制可以通过<strong>getrlimit系统调用</strong>得到。</p>
<figure>
<img src="https://jacktang816.github.io/img/linux/heapSpace.png" alt="" /><figcaption>img</figcaption>
</figure>
<h4 id="mmap">mmap</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, off\<span class="keyword">_t</span> offset)</span></span>;  <span class="comment">// 向映射区申请一块内存</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;   <span class="comment">// 用于释放内存</span></span><br></pre></td></tr></table></figure>
<p>mmap函数第一种用法是映射磁盘文件到内存中；而malloc使用的mmap函数的第二种用法，即匿名映射，匿名映射不映射磁盘文件，而是向映射区申请一块内存。</p>
<ul>
<li>分配内存 &lt; DEFAULT_MMAP_THRESHOLD （默认128K），走__brk，从内存池获取，失败的话走brk系统调用</li>
<li>分配内存 &gt; DEFAULT_MMAP_THRESHOLD，走__mmap，直接调用mmap系统调用</li>
</ul>
<p><strong>上述的只是分配了虚拟内存，还没有映射到物理内存，当访问申请的内存时，才会因为缺页异常，内核分配物理内存。</strong></p>
<h2 id="malloc实现方案">malloc实现方案</h2>
<p>直接使用系统调用分配内存存在的问题：</p>
<ol type="1">
<li>由于brk/sbrk/mmap属于系统调用，如果每次申请内存，都调用这三个函数中的一个，那么每次都要产生系统调用开销（即cpu从用户态切换到内核态的上下文切换，这里要保存用户态数据，等会还要切换回用户态），这是非常影响性能的；</li>
<li>其次，这样申请的内存容易产生碎片，因为堆是从低地址到高地址，如果低地址的内存没有被释放，高地址的内存就不能被回收。</li>
</ol>
<p>因此， <strong>malloc采用的是内存池的实现方式</strong>，malloc内存池实现方式更类似于STL分配器和memcached的内存池，先申请一大块内存，然后将内存分成不同大小的内存块，然后用户申请内存时，直接从内存池中选择一块相近的内存块即可。</p>
<p><img src="https://jacktang816.github.io/img/linux/bins.png" alt="img"  /></p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210407212613.png" alt="image-20210407212612902" style="zoom:200%;" /></p>
<p>上图左边 是隐式 空闲闲链表，和上图的堆的结构对应；右边是显式空闲链表的结构，和bins(即内存池对应)。内存池保存在bins这个长128的数组中，每个元素都是一双向个链表，每个双向链表将大小接近的空闲块连接起来。</p>
<ul>
<li>bins[0]目前没有使用</li>
<li>bins[1]的链表称为unsorted_list，用于维护free释放的chunk。</li>
<li>bins[2,63)的区间称为small_bins，用于维护＜512字节的内存块，其中每个元素对应的链表中的chunk大小相同，均为index*8。</li>
<li>bins[64,127)称为large_bins，用于维护&gt;512字节的内存块，每个元素对应的链表中的chunk大小不同，index越大，链表中chunk的内存大小相差越大，例如: 下标为64的chunk大小介于[512, 512+64)，下标为95的chunk大小介于[2k+1,2k+512)。同一条链表上的chunk，按照从小到大的顺序排列。</li>
</ul>
<p>malloc除了有unsorted bin，small bin，large bin三个bin之外，还有一个<strong>fast bin</strong>。一般的情况是，程序在运行时会经常需要申请和释放一些较小的内存空间。当分配器合并了相邻的几个小的 chunk 之后，也许马上就会有另一个小块内存的请求，这样分配器又需要从大的空闲内存中切分出一块，这样无疑是比较低效的，故而，malloc 中在分配过程中引入了 fast bins，不大于 max_fast(默认值为 64B)的 chunk 被释放后，首先会被放到 fast bins中，fast bins 中的 chunk 并不改变它的使用标志 P。这样也就无法将它们合并，当需要给用户分配的 chunk 小于或等于 max_fast 时，malloc 首先会在 fast bins 中查找相应的空闲块，然后才会去查找 bins 中的空闲 chunk。在某个特定的时候，malloc 会遍历 fast bins 中的 chunk，将相邻的空闲 chunk 进行合并，并将合并后的 chunk 加入 unsorted bin 中，然后再将 unsorted bin 里的 chunk 加入 bins 中。</p>
<p>unsorted bin 的队列使用 bins 数组的第一个，如果被用户释放的 chunk 大于 max_fast，或者 fast bins 中的空闲 chunk 合并后，这些 chunk 首先会被放到 unsorted bin 队列中，在进行 malloc 操作的时候，如果在 fast bins 中没有找到合适的 chunk，则malloc 会先在 unsorted bin 中查找合适的空闲 chunk，然后才查找 bins。如果 unsorted bin 不能满足分配要求。 malloc便会将 unsorted bin 中的 chunk 加入 bins 中。然后再从 bins 中继续进行查找和分配过程。从这个过程可以看出来，<strong>unsorted bin 可以看做是 bins 的一个缓冲区，增加它只是为了加快分配的速度。</strong></p>
<p>综上：</p>
<h3 id="malloc-内存分配流程">malloc 内存分配流程</h3>
<ol type="1">
<li>如果分配内存&lt;512字节，则通过内存大小定位到smallbins对应的index上(floor(size/8))
<ul>
<li>如果smallbins[index]为空，进入步骤3</li>
<li>如果smallbins[index]非空，直接返回第一个chunk</li>
</ul></li>
<li>如果分配内存&gt;512字节，则定位到largebins对应的index上
<ul>
<li>如果largebins[index]为空，进入步骤3</li>
<li>如果largebins[index]非空，扫描链表，找到第一个大小最合适的chunk，如size=12.5K，则使用chunk B，剩下的0.5k放入unsorted_list中</li>
</ul></li>
<li>遍历unsorted_list，查找合适size的chunk，如果找到则返回；否则，将这些chunk都归类放到smallbins和largebins里面</li>
<li>index++从更大的链表中查找，直到找到合适大小的chunk为止，找到后将chunk拆分，并将剩余的加入到unsorted_list中</li>
<li>如果还没有找到，那么使用top chunk</li>
<li>或者，内存&lt;128k，使用brk；内存&gt;128k，使用mmap获取新内存</li>
</ol>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>计算机操作系统-内存管理</title>
    <url>/posts/34672/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="内存管理">内存管理</h1>
<h2 id="虚拟内存">虚拟内存</h2>
<p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p>
<p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>
<p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，<strong>也就是说一个程序不需要全部调入内存就可以运行</strong>，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p>
<h2 id="分页系统地址映射">分页系统地址映射</h2>
<p>内存管理单元（MMU）管理着地址空间和物理内存的转换。 内存管理单元里的 页表 存储着 页（程序地址空间）和页框（物理内存空间）的映射表。</p>
<p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。 其中页面号通过 页表 转成真实 页的地址，另外，页表还有一个功能就是 标记 地址是否在内存中。具体实例如下：</p>
<figure>
<img src="https://i.loli.net/2021/04/05/rtI45BhWZqkAnP6.png" alt="" /><figcaption>image-20201214203458354</figcaption>
</figure>
<p>例如虚拟地址 0010 000000000100 前 4 位是存储页面号 2 后 12 位存储页面内偏移量 但是 这个页面号不是真实地址的页面号。需要通过页表映射。取页面号2即页表的第二个位置存储的 表项内容为（110 1）：页表项最后一位表示是否存在于内存中，1 表示存在。则这个页对应的页框的地址为 （110 000000000100）。如果不在内存中 就将<strong>外存</strong>调入内存。</p>
<blockquote>
<p>每个进程的虚拟空间地址都一样，那如果两个进程完全使用了相同的虚拟地址，页表项怎么区分呢？一个进程在执行前，操作系统要为它设置好页表寄存器，让它指向进程自己专属的页表，相当于虚拟地址 + 页表地址</p>
</blockquote>
<h2 id="页面置换算法">页面置换算法</h2>
<p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p>
<p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p>
<p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）</p>
<h3 id="fifo先进先出">FIFO先进先出</h3>
<p>FIFO, First In First Out 选择换出的页面是最先进入的页面。该算法会将那些经常被访问的页面换出，导致缺页率升高。</p>
<h3 id="lru-最近最久未使用">LRU 最近最久未使用</h3>
<p>LRU, Least Recently Used <strong>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况</strong>。LRU 将最近最久未使用的页面换出。为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p>
<p>缺点：</p>
<ol type="1">
<li>因为每次访问都需要更新链表，<strong>因此这种方式实现的 LRU 代价很高</strong>。</li>
<li>缓存颠簸，当出现类似的 (3，2，1） 满了，然后又来连续的数据 (0,1,2,3,0,1,2,3….) 每次替换的页面都是下一次即将出现的序号，循环往复每次都要替换</li>
<li>缓存污染，当出现偶然出现的数据时，它被替换到队头，需要整个队列的长度它才会被替换出去，缓存中冷数据会存放太久</li>
</ol>
<h3 id="lru-k">LRU-K</h3>
<p>最久未使用K次淘汰算法 为了缓解LRU缓存污染的缺点，只有当引用次数超过K次才会被提到对头。可以使用一个队列，一个双向链表实现。对于访问次数不超过 K 次的内存页，可以将它存放在历史访问 队列里，超过K次的元素可以放在缓存队列里。</p>
<ol type="1">
<li>当历史队列中的元素满，并且还有新增访问元素的时候，将历史缓存队列的元素 按照 FIFO 的顺序置换页面（历史缓存页里的元素被访问的次数都不超过K次）</li>
<li>当历史缓存页里的某个页 访问大于等于K次时，将它从历史队列里删除，并且添加到缓存队列里。</li>
<li>当访问的元素大于K次，那么它应该在缓存队列里，缓存队列使用的双向链表实现，因此将该元素添加到队头</li>
<li>当缓存队列里的元素需要删除的时候，删除链表尾的元素， 即<code>第k次访问距离现在最久</code>的那个页面。</li>
</ol>
<h3 id="q">2Q</h3>
<p>2Q 就 类似于 LRU-2，采用一个FIFO队列 一个LRU队列，当FIFO容量为2，访问负载为 ABCABCABC时用不到 LRU队列</p>
<h3 id="lfu最不经常访问淘汰算法">LFU（最不经常访问淘汰算法）</h3>
<p>如果数据过去被访问多次，那么将来被访问的频率也更高。每个数据块一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。每次淘汰队尾数据块。</p>
<p>缓存颠簸</p>
<h3 id="最近未使用">最近未使用</h3>
<p>NRU, Not Recently Used 每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p>
<ul>
<li>R=0，M=0</li>
<li>R=0，M=1</li>
<li>R=1，M=0</li>
<li>R=1，M=1</li>
</ul>
<p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p>
<h3 id="第二次机会算法">第二次机会算法</h3>
<p>和FIFO 一样，但是设置了第二次机会。设置一个队列保存 被置置入的 页面序号，先被置入内存的页面在队列最前面。当内存满了 需要置换页面时，fifo方法是 把队列头的 页置换出去，但是可能这个页是频繁访问的页面。第二次机会算法 是 每次访问页面是，将该页面的R位设置为 1 需要置换时，如果队列头的R位是1 就将它放放到队列最后并R位清0，再找下一个，直到队列头的页的R位为0时，将其替换掉。当每个页面都被访问过时就退化为FIFO</p>
<p>这种方法的缺点时 如果缓存中所有的页面都已经被标记 就退化为 FIFO</p>
<h3 id="时钟">时钟</h3>
<p>第二次机会算法中的队列 即 （链表）需要在链表中移动页面，降低了效率。时钟算法<strong>使用环形链表将页面连接起来</strong>，再使用一个指针指向最老的页面。 从C移动到D就相当于 把C放到了队列尾！！！！</p>
<figure>
<img src="https://i.loli.net/2021/04/05/uiTFI7CpPsqkUZl.png" alt="" /><figcaption>image-20201214205828039</figcaption>
</figure>
<h2 id="分段">分段</h2>
<p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。（代码段 …）</p>
<p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p>
<p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p>
<figure>
<img src="https://i.loli.net/2021/04/05/UzkJHWdnFwPqKhV.png" alt="" /><figcaption>image-20201214212530805</figcaption>
</figure>
<h2 id="段页式">段页式</h2>
<p>程序的地址空间划分成多个拥有独立地址空间的段 每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能</p>
<h2 id="分页与分段的比较">分页与分段的比较</h2>
<ul>
<li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li>
<li>地址空间的维度：<strong>分页是一维地址空间，分段是二维的。</strong></li>
<li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li>
<li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；<strong>分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护</strong>。</li>
</ul>
<h2 id="多级页表">多级页表</h2>
<p>一般来说，任何进程切换都会暗示着更换活动页表集。Linux内核为每一个进程维护一个task_struct结构体（即进程描述符PCB），task_struct-&gt;mm_struct结构体成员用来保存<strong>该进程的页表</strong>。在进程切换的过程中，<strong>内核把新的页表的地址写入CR3控制寄存器</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210419204602.png" alt="image-20210419204602171" style="zoom: 150%;" /></p>
<p>可以看出 多级页表的结构 是这样的 一级页表中的每一个项 指向下一级页表的地址。如果一级页表由 1K 个项，那么附属的就有 1K 个二级页表。</p>
<p>假设4G 的寻址空间，每个页大小 4K。</p>
<ul>
<li>如果只用一级页表来寻址，那么需要的一级页表的项目数为 4 G / 4 K = 1 M的容量，假设表的每个项就是4字节的数组，那么存储这个1级表需要 1M X 4B = 4M</li>
<li>如果使用二级表，并且将一级表的数量设置为 1K， 那么对应的二级表的个数也为 1K 由于寻址4G空间，那么每个二级表的大小 1M / 1K = 1K ，也就是 需要1K 个 每个大小为 1K 的二级表，那么存放所有的二级表需要 1K x 1K x 4B =4M空间，加上一级表的空间 0.004M，总共需要 4.004 M 的空间存储一级和二级表。</li>
</ul>
<p>多级页表的内存空间占用反而变大了</p>
<h3 id="为什么用多级表">为什么用多级表</h3>
<p>通过上面的计算，发现二级表占用空间反而多了。但是其实在大部分进程中，短时间内并不会真正用上 4G 的寻址空间，但是一级表由于是连续的，要加载就得全部加载进内存，尽管中间很多映射项都没用。如果使用二级表，那么一级表中只有百分之20的二级表需要存储，而没用上的二级表并不需要加载到内存，<strong>可以在使用的时候再调入</strong>。假设只用了4G寻址空间中的百分之20，二级表 需要存储的空间为 1K x 1K x 0.2 x 4B = 0.8 M 再加上一级表 1K x 4B = 0.004M 一共 使用 0.804M。即实现了分散存储 大大减少了存储页表的开支。</p>
<p>只有一级页表才需要总是在主存中；虚拟存储器系统可以在需要时创建，页面掉入或调出二级页表，这就减少了主存的压力；只有最经常使用的二级页表才需要缓存在主存中，这种离散的存储方式是非常便利的</p>
<h2 id="page-cache">page cache</h2>
<p><a href="https://zhuanlan.zhihu.com/p/68071761">参考连接</a></p>
<p><a href="https://blog.csdn.net/yang_yulei/article/details/46371975">基数树</a> 主要用于构建大范围 但是有较多公共前缀的 稀疏映射关系 例如稀疏的地址集合</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>计算机操作系统-概述</title>
    <url>/posts/30994/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="计算机操作系统---概述">计算机操作系统 - 概述</h1>
<h2 id="基本特征">基本特征</h2>
<h3 id="并发">1. 并发</h3>
<ul>
<li>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</li>
<li>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</li>
<li>操作系统通过引入进程和线程，使得程序能够并发运行</li>
</ul>
<h3 id="共享">2.共享</h3>
<p>共享是指系统中的资源可以被多个并发进程共同使用。有两种共享方式：互斥共享和同时共享。互斥共享 称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问</p>
<h3 id="虚拟">3.虚拟</h3>
<p>虚拟技术把一个物理实体转换为多个逻辑实体。主要有两种虚拟技术：<strong>时（时间）分复用技术和空（空间）分复用技术</strong>。</p>
<ul>
<li>时分复用：多个进程能在同一个处理器上<strong>并发执行</strong>使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</li>
<li>空分复用：虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中 。 <strong>它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间）</strong>，而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上使用这种技术的系统使得大型程序的编写变得更容易，对真正的<a href="https://zh.wikipedia.org/wiki/物理内存">物理内存</a>（例如<a href="https://zh.wikipedia.org/wiki/隨機存取記憶體">RAM</a>）的使用也更有效率</li>
</ul>
<h3 id="异步">4.异步</h3>
<p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进</p>
<h2 id="基本功能">基本功能</h2>
<h3 id="进程管理">进程管理</h3>
<p>进程控制、进程同步、进程通信、死锁处理、处理机调度等</p>
<h3 id="内存管理">内存管理</h3>
<p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p>
<h3 id="文件管理">文件管理</h3>
<p>文件存储空间的管理、目录管理、文件读写管理和保护等</p>
<h3 id="设备管理">设备管理</h3>
<p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。主要包括缓冲管理、设备分配、设备处理、虛拟设备等</p>
<h2 id="系统调用">系统调用</h2>
<p>Linux内核中设置了一组用于实现各种系统功能的子程序，称为系统调用。用户可以通过系统调用命令在自己的应用程序中调用它们。从某种角度来看，系统调用和普通的函数调用非常相似。区别仅仅在于，系统调用由操作系统核心提供，运行于核心态（内核态）; 而普通的函数调用由函数库或用户自己提供，运行于用户态。</p>
<p><a href="./计算机操作系统-系统调用.md">系统调用</a></p>
<p>Linux 的系统调用主要有以下这些：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Task</th>
<th>Commands</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">进程控制</td>
<td>fork(); exit(); wait();</td>
</tr>
<tr class="even">
<td style="text-align: center;">进程通信</td>
<td>pipe(); shmget(); mmap();</td>
</tr>
<tr class="odd">
<td style="text-align: center;">文件操作</td>
<td>open(); read(); write();</td>
</tr>
<tr class="even">
<td style="text-align: center;">设备操作</td>
<td>ioctl(); read(); write();</td>
</tr>
<tr class="odd">
<td style="text-align: center;">信息维护</td>
<td>getpid(); alarm(); sleep();</td>
</tr>
<tr class="even">
<td style="text-align: center;">安全</td>
<td>chmod(); umask(); chown()</td>
</tr>
</tbody>
</table>
<h2 id="宏内核和微内核">宏内核和微内核</h2>
<h3 id="宏内核">宏内核</h3>
<p>简单来说，就是把很多东西都集成进内核，例如linux内核，除了最基本的进程、线程管理、内存管理外，文件系统，驱动，网络协议等等都在内核里面。由于各模块共享信息，<strong>因此有很高的性能。缺点是稳定性差</strong>，开发过程中的bug经常会导致整个系统挂掉。做驱动开发的应该经常有按电源键强行关机的经历。</p>
<h3 id="微内核">微内核</h3>
<p>内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的。优点是超级稳定，驱动等的错误只会导致相应进程死掉，不会导致整个系统都崩溃，在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p>
<figure>
<img src="https://i.loli.net/2021/04/05/ed489OiP7okQBLV.png" alt="" /><figcaption>image-20201209214721265</figcaption>
</figure>
<h2 id="中断分类">中断分类</h2>
<h3 id="外中断">外中断</h3>
<p><strong>由 CPU 执行指令以外的事件引起</strong>，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p>
<h3 id="异常">异常</h3>
<p>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等</p>
<h3 id="陷入">陷入</h3>
<p>在用户程序中使用系统调用</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>计算机操作系统-死锁</title>
    <url>/posts/49205/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="死锁">死锁</h1>
<h2 id="必要条件">必要条件</h2>
<p>通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待的一种状态</p>
<ul>
<li>互斥（mutualexclusion），一个资源每次只能被一个进程使用</li>
<li>不可抢占（nopreemption），进程已获得的资源，在未使用完之前，不能强行剥夺</li>
<li>占有并等待（hold andwait），一个进程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>环形等待（circularwait），若干进程之间形成一种首尾相接的循环等待资源关系。</li>
</ul>
<h2 id="处理方法">处理方法</h2>
<p>主要有以下四种方法：</p>
<ul>
<li>鸵鸟策略</li>
<li>死锁检测与死锁恢复</li>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
<h2 id="鸵鸟策略">鸵鸟策略</h2>
<p>鸵鸟在遇见问题时，把头埋在沙子里，假装根本没发生问题。因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。（<strong>就是不管</strong>）</p>
<p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h2 id="死锁检测与死锁恢复">死锁检测与死锁恢复</h2>
<p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复</p>
<h3 id="每种类型一个资源的死锁检测">每种类型一个资源的死锁检测</h3>
<figure>
<img src="https://i.loli.net/2021/04/05/I9NwHWanvUqPs7V.png" alt="" /><figcaption>image-20201214195516515</figcaption>
</figure>
<p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。<strong>有环时 即发生死锁</strong> 因此 每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p>
<h3 id="每种类型多个资源的死锁检测">每种类型多个资源的死锁检测</h3>
<figure>
<img src="https://i.loli.net/2021/04/05/gnWPJ9mkNRSMTFu.png" alt="" /><figcaption>image-20201214195622770</figcaption>
</figure>
<p>这时候后 就不能用上述的环路检测法检测了，一个类型多个资源的情况如下，左图发生了死锁，而右图未死锁。这种情况的死锁检测算法如下：</p>
<figure>
<img src="https://i.loli.net/2021/04/05/GvwpKYR1V4gUxoF.png" alt="" /><figcaption>image-20201214195823456</figcaption>
</figure>
<p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p>
<ul>
<li>E 向量：资源总量</li>
<li>A 向量：资源剩余量</li>
<li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li>
<li>R 矩阵：每个进程请求的资源数量</li>
</ul>
<p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。</p>
<p>算法总结如下：每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p>
<ol type="1">
<li>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。</li>
<li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li>
<li>如果没有这样一个进程，算法终止。</li>
</ol>
<h3 id="死锁恢复">死锁恢复</h3>
<ul>
<li>利用抢占恢复 ： 剥夺陷于死锁的进程所占用的资源，但并不撤销此进程，直至死锁解除。</li>
<li>利用回滚恢复 ： 根据系统保存的检查点让所有的进程回退，直到足以解除死锁，这种措施要求系统建立保存检查点、回退及重启机制。</li>
<li>通过杀死进程恢复：撤销陷入死锁的所有进程，解除死锁，继续运行</li>
</ul>
<h2 id="死锁预防">死锁预防</h2>
<p>在程序运行之前预防发生死锁</p>
<ol type="1">
<li>破坏互斥条件</li>
<li>破坏占有和等待条件 ： 一种实现方式是规定所有进程在开始执行前请求所需要的全部资源</li>
<li>破坏不可抢占条件</li>
<li>破坏环路等待：给资源统一编号，进程只能按编号顺序来请求资源</li>
</ol>
<h2 id="死锁避免">死锁避免</h2>
<p>在程序运行时避免发生死锁。</p>
<p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p>
<h2 id="锁的实现">锁的实现</h2>
<p>Linux中有很多种锁。互斥锁，读写锁，自旋锁，RCU锁等。从底层实现来看 锁就是一个标志位，哪个线程先得到该标志位并对他置位，则代表它先获得了该锁，其他的线程无法对他操作，直到该线程自己将标志位恢复为止。</p>
<ol type="1">
<li>原子的CAS操作 （Compare and Set）</li>
</ol>
<p>标志位本身也是一个共享的变量，对他进行读写也需要保护，那么这是个无解的问题嘛？不是的，其实对这个标志位的操作由硬件支持指令级的原子的 CAS 。原子的意思是 某一系列指令在执行过程中不会被任务调度和中断给打断，在单核系统中，简单的关中断即可实现系列指令的原子执行，但是多核系统中还要借助缓存一致性，来确保不同核上的线程对同一个内存区域的变量读取的是一致的。通过上面手段就在硬件层面上实现了变量的 原子性的CAS</p>
<blockquote>
<p>CAS 原理就是，首先从内存中读取要修改的变量，将他和期望值比较，如果和期望值不同，那么就说明它被修改了就什么都不做返回false，如果相同，则对变量修改并返回true。</p>
</blockquote>
<ol start="2" type="1">
<li>根据锁是否获得，来决定执行什么策略</li>
</ol>
<p>基于上面原子的CAS操作，就可以保证锁被某个线程唯一的获得不会出现多个线程同时拿到锁的情况。然后至于 互斥锁，自旋锁，读写锁什么的都是根据锁是否获得，来决定执行什么不同的策略</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>计算机操作系统-系统调用</title>
    <url>/posts/22984/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="系统调用">系统调用</h1>
<h2 id="概述">概述</h2>
<p>系统调用就是内核提供给用户的一组接口，通过这组接口，用户可以受限地访问硬件设备或者操作系统的其他资源。通过系统调用，应用程序可以主动地从用户态 陷入 内核态，进而获得更高地权限，访问操作系统更多的资源。用户态转换为内核态的方法为：</p>
<ul>
<li>外部中断（外部输入设备中断，例如硬盘的读写）</li>
<li>异常（缺页异常，操作异常如除0）</li>
<li>系统调用 （后面会详细介绍）</li>
</ul>
<p>为了保证系统的稳定和安全性，操作系统将程序运行状态分为 用户态 和 内核态。</p>
<h3 id="内核态">内核态</h3>
<p>大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信。（特权指令：一类只能在核心态下运行而不能在用户态下运行的特殊指令）。不同的操作系统特权指令会有所差异，但是一般来说主要是和硬件相关的一些指令。</p>
<h3 id="用户态">用户态</h3>
<p>用户程序只在用户态下运行，有时需要访问系统核心功能，这时通过系统调用接口使用系统调用。应用程序有时会需要一些危险的、权限很高的指令，如果把这些权限放心地交给用户程序是很危险的(比如一个进程可能修改另一个进程的内存区，导致其不能运行)，但是又不能完全不给这些权限。</p>
<p>于是有了系统调用，危险的指令被包装成系统调用，用户程序只能调用而无权自己运行那些危险的指令。另外，计算机硬件的资源是有限的，为了更好的管理这些资源，所有的资源都由操作系统控制，进程只能向操作系统请求这些资源。操作系统是这些资源的唯一入口，这个入口就是系统调用。</p>
<h2 id="库函数">库函数</h2>
<p>系统调用是一组 api 但是他和库函数不同，系统调用是操作系统提供，不同的操作系统系统调用不同，而库函数是语言提供，例如C语言库函数，或者是系统库。语言库可以屏蔽不同操作系统的差异，封装出统一的接口，使得程序具有可移植性。</p>
<p>库函数主要由两方面提供：一是操作系统提供的；另一类是由第三方提供的（语言库函数）。</p>
<ul>
<li><p>系统提供的这些函数把系统调用进行封装或者组合，可以实现更多的功能，这样的库函数能够实现一些对于内核来说比较复杂的操作。比如read函数根据参数，直接就能读文件，而背后隐藏的文件比如在那个磁道，那个扇区，加载到那个内存，是程序员不必关心的问题。这些操作里面也包含了系统调用。比如write()这个系统函数，会调用同名的系统调用，来完成写入操作。</p></li>
<li><p>对于第三方库，其实和系统库一样，只是他直接利用系统调用的可能性要小一些，而是系统提供的 API 接口来是实现。比如printf，实际上调用了write()这个系统函数。 第三方库函数大部分是对系统函数的封装。</p></li>
<li><p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210614203714.png" alt="image-20210614203714441" style="zoom:50%;" /></p></li>
</ul>
<h2 id="系统调用号">系统调用号</h2>
<p>在 Linux 系统中每个系统调用都被赋予一个系统调用号。这样通过这个独一无二的号就可以关联到系统调用。当用户空间执行一个系统调用的时候，这个系统调用号指明到底是要执行哪个系统调用，进程不会提及系统调用的函数名称（这个在后续会用）</p>
<p>一个系统调用号相当重要，一旦确定，以后都不能更改，否则编译好的程序就会崩溃。如果一个系统调用被删除，它所占用的系统调用号也不能被回收利用，否则以前编译过的代码会调用这个系统调用而实际上它掉用的却是另一个。Linux有一个 <code>sys_ni_syscall()</code>用于作为未实现的系统调用号的默认函数，填补空缺，它只返回一个 -ENOSYS 不做任何操作。</p>
<p>内核通过 sys_call_table 记录所有已经注册过的系统调用列表。这个表为每个有效的系统调用指定了唯一的系统调用号。</p>
<h2 id="原理">原理</h2>
<p>用户空间无法直接执行内核代码，他们不能直接调用内核空间的函数，更不能直接操作内核地址空间，这都是出于系统稳定全的考虑。所以应用程序应该以某种方式告诉内核自己要执行一个系统调用，希望系统切换到内核态，这样内核就可以代替应用程序在内核空间执行系统调用。</p>
<p>通知机制是靠<strong>软中断</strong>实现的。前面说了用户态-&gt;内核态切换的三种方式，外中断 异常 和系统调用，<strong>系统调用是一种特殊的中断类型(软中断)</strong>。</p>
<p>在x86的机器中，用一个8bit的数字（0~255）来区分各种中断，这个数字被称为<strong>中断向量</strong>（vector）。其中一个中断向量，即128 （0x80），专门被用于执行系统调用。在Linux系统中，存有一个系统表，叫做Interrupt DescriptorTable （中断向量表），简称IDT。IDT表共有256项，存放了从中断向量到相应处理例程（interrupt or exceptionhandler）的映射关系。当某个中断发生时，CPU从IDT表中查找到相应的处理例程的地址来执行。而第128号中断处理程序 即 <code>system_call()</code></p>
<h3 id="确定系统调用">确定系统调用</h3>
<p>通过上述可以看出，所有的系统调用都是使用相同的方式陷入内核，即触发 128 软中断进入内核，根据中断向量表找到 system_call 函数来处理具体的系统调用。</p>
<p>但是仅仅是这不够，用户还得告诉内核调用的是那个系统调用函数，因此，还要将系统调用号写入 exa 寄存器，即通过exa寄存器告诉具体的系统调用号。<code>system_call()</code>函数通过将给定的系统调用号与 NR_syscalls 做比较检查有效性，如果有效 就通过 系统调用号 找到对应的 系统调用函数的地址。</p>
<h3 id="参数传递">参数传递</h3>
<p>找到了具体的系统调用函数，通常系统调用函数还有输入输出参数。所以，在发生陷入的时候，应该把这些参数从用户空间传给内核，简单的方法是和系统调用号一样，把这些参数也存放在寄存器中。在x84-32系统上，ebx ecx edx 和 edi 寄存器存放前五个参数，需要六个以上的参数，应该通过一个单独的寄存器存放指向所有这些参数在用户空间的地址。</p>
<p>给用户的返回值也通过寄存器传递，在x86系统上，它存放在 eax 寄存器中</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210614221021.png" alt="image-20210614221021493" style="zoom:67%;" /></p>
<h3 id="系统调用流程">系统调用流程</h3>
<p>当系统调用发生时，通过中断机制，系统调用例程system_call被调用。它的执行过程大概分为4个步骤：</p>
<ol type="1">
<li>从寄存器中取出系统调用号和输入参数，然后将这些寄存器的值压入kernel栈中。</li>
<li>根据系统调用号查找系统调用分派表（system call dispatch table），找到系统调用服务例程（一个内核函数）</li>
<li>调用查到的系统调用服务例程。</li>
<li>将系统调用服务例程的返回值出栈，重新保存在寄存器中。</li>
</ol>
<p>上面描述的系统调用例程system_call在kernel空间中执行。<strong>在执行前，系统调用号和输入参数已经存入了寄存器，这个存入过程由user空间的代码完成。实际上，如同第一节所讲，每个真正的系统调用基本上都有一个封装它的库函数，一般是在这个库函数中完成系统调用号和输入参数的保存动作</strong>。当系统调用例程system_call执行完毕后，返回值通过寄存器再传回user空间的库函数。</p>
<h2 id="新增一个系统调用">新增一个系统调用</h2>
<p>….</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>计算机操作系统-设备管理</title>
    <url>/posts/17731/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="设备管理">设备管理</h1>
<h2 id="磁盘结构">磁盘结构</h2>
<ul>
<li>盘面（Platter）：一个磁盘有多个盘面；</li>
<li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li>
<li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li>
<li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li>
<li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li>
<li>主轴（Spindle）：使整个盘面转动。</li>
</ul>
<figure>
<img src="https://i.loli.net/2021/04/05/UgN2XMLorY4yB3f.jpg" alt="" /><figcaption>img</figcaption>
</figure>
<h2 id="磁盘调度算法">磁盘调度算法</h2>
<p>读写一个磁盘块的时间的影响因素有：</p>
<ul>
<li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li>
<li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li>
<li>实际的数据传输时间</li>
</ul>
<p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短</p>
<h3 id="先来先服务">先来先服务</h3>
<p>FCFS, First Come First Served 按照磁盘请求的顺序进行调度。优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p>
<h3 id="最短寻道时间优先">最短寻道时间优先</h3>
<p>SSTF, Shortest Seek Time First 优先调度与当前磁头所在磁道距离最近的磁道。虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现<strong>饥饿现象</strong>。具体来说，<strong>两端的磁道请求更容易出现饥饿现象。</strong></p>
<figure>
<img src="https://i.loli.net/2021/04/05/TlDjAExVoS2wamz.png" alt="" /><figcaption>image-20201214213147756</figcaption>
</figure>
<h3 id="电梯算法">电梯算法</h3>
<p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p>
<figure>
<img src="https://i.loli.net/2021/04/05/P9Ta1sqvX3yKOrQ.png" alt="" /><figcaption>image-20201214213157846</figcaption>
</figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>计算机操作系统-链接</title>
    <url>/posts/20007/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="链接">链接</h1>
<h2 id="编译系统">编译系统</h2>
<p>以下是一个 hello.c 程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure>
<p>这个过程大致如下：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210416214427.png" alt="" /><figcaption>image-20201214213338460</figcaption>
</figure>
<ul>
<li>预处理阶段：处理以 # 开头的预处理命令，例如解决头文件的包含关系，宏定义替换，条件编译处理，去掉注释等；</li>
<li>编译阶段：检查函数和变量是否存在声明，检查语法是否正确，将C文件翻译成汇编文件；
<ul>
<li>编译优化 -O1 -O2 -O3（利用了cpu流水线和缓存功能等） Og</li>
</ul></li>
<li>汇编阶段：将 .s 汇编文件翻译成可重定位 .o 目标文件，二进制机器指令文件；</li>
<li>链接阶段：将所有的 .o 文件 还有库文件连接生成可执行文件。编译器将每个函数变量都使用符号表示，然后为每个目标文件提供两个符号表用于和其他文件连接。</li>
</ul>
<h2 id="链接-1">链接</h2>
<p>链接过程分为两步：重定位，符号解析</p>
<p><strong>重定位</strong>：由于多个编译单元 .o 文件的符号地址可能相同，因此重定位就是在连接时会对每个编译单元中的符号地址进行调整，具体的文件内的地址加上该文件最终在可执行文件中的偏移位置即为重定位之后的内存地址。</p>
<p><strong>符号解析</strong> 在符号解析阶段，编译器会给每个.o （编译单元）文件生成两个符号表</p>
<ul>
<li>未解决符号表：就是本单元声明但是没有定义的符号</li>
<li>导出符号表：就是本单元定义，并且可供给其他文件调用的符号表</li>
</ul>
<p>连接器会根据目标文件提供的未解决的符号表去所有的编译单元的导出符号表中查找与这个匹配的符号名，如果找到就将这个符号地址填到未解决的符号的地址处。</p>
<p>最后把所有的目标文件的内容写在各自的位置上，就生成一个可执行文件。</p>
<h3 id="静态链接">静态链接</h3>
<p>静态链接在编译阶段就将库文件的所有代码加到可执行文件中，因此生成的程序体积更大，其后缀名一般为 .a</p>
<p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210526222804.png" alt="" /><figcaption>image-20201214213743892</figcaption>
</figure>
<h3 id="动态链接">动态链接</h3>
<p>静态库有以下两个问题：</p>
<ul>
<li>当静态库更新时那么整个程序都要重新进行链接；</li>
<li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li>
</ul>
<p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。动态链接在编译链接时并不会把库文件的代码加到可执行文件中，而是在运行时加载所需的动态库，后缀名一般为 .so</p>
<ul>
<li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li>
<li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210526222816.png" alt="" /><figcaption>image-20201214213832838</figcaption>
</figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>应用层-HTTP</title>
    <url>/posts/23632/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="http">HTTP</h2>
<h3 id="请求和响应报文">请求和响应报文</h3>
<p>客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。</p>
<p>请求报文结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET http:&#x2F;&#x2F;www.example.com&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Host: www.example.com</span><br><span class="line">If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line">If-None-Match: &quot;3147526947+gzip&quot;</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 xxx</span><br><span class="line"></span><br><span class="line">param1&#x3D;1&amp;param2&#x3D;2</span><br></pre></td></tr></table></figure>
<ul>
<li>第一行是包含了请求方法、URL、协议版本；</li>
<li>接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。 ( ： 的形式)</li>
<li>一个空行用来分隔首部和内容主体 Body</li>
<li>最后是请求的内容主体</li>
</ul>
<p>响应报文结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Age: 529651</span><br><span class="line">Cache-Control: max-age&#x3D;604800</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 648</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;UTF-8</span><br><span class="line">Date: Mon, 02 Nov 2020 17:53:39 GMT</span><br><span class="line">Etag: &quot;3147526947+ident+gzip&quot;</span><br><span class="line">Expires: Mon, 09 Nov 2020 17:53:39 GMT</span><br><span class="line">Keep-Alive: timeout&#x3D;4</span><br><span class="line">Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line">Server: ECS (sjc&#x2F;16DF)</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Cache: HIT</span><br><span class="line"></span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Example Domain&lt;&#x2F;title&gt;</span><br><span class="line">	&#x2F;&#x2F; 省略... </span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了</li>
<li>接下来多行也是首部内容</li>
<li>一个空行分隔首部和内容主体</li>
<li>最后是响应的内容主体</li>
</ul>
<h3 id="url">URL</h3>
<p>HTTP 使用 URL（ <strong>U</strong> niform <strong>R</strong>esource <strong>L</strong>ocator，统一资源定位符）来定位资源，它是 URI（<strong>U</strong>niform <strong>R</strong>esource <strong>I</strong>dentifier，统一资源标识符）的子集，URL 在 URI 的基础上增加了定位能力。URI 除了包含 URL，还包含 URN（Uniform Resource Name，统一资源名称），它只是用来定义一个资源的名称，并不具备定位该资源的能力。例如 urn:isbn:0451450523 用来定义一个书籍名称，但是却没有表示怎么找到这本书。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406092218.png" alt="" /><figcaption>image-20201208195001747</figcaption>
</figure>
<blockquote>
<h4 id="httpwww.aspxfans.com8080newsindex.aspboardid5id24618page1name"><a href="https://link.jianshu.com/?t=http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a></h4>
</blockquote>
<p>从上面的URL可以看出，一个完整的URL包括以下几部分：</p>
<ol type="1">
<li>协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在"HTTP"后面的“//”为分隔符</li>
<li>域名部分：该URL的域名部分为“<a href="https://link.jianshu.com/?t=http://www.aspxfans.com">www.aspxfans.com</a>”。一个URL中，也可以使用IP地址作为域名使用</li>
<li>端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</li>
<li>虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</li>
<li>文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</li>
<li>锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</li>
<li>参数部分 从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</li>
</ol>
<h3 id="http-方法">HTTP 方法</h3>
<p>客户端发送的 <strong>请求报文</strong> 第一行为请求行，包含了方法字段</p>
<h4 id="get">GET</h4>
<p>获取资源 当前网络请求中，绝大部分使用的是 GET 方法</p>
<h4 id="head">HEAD</h4>
<p>获取报文首部 和 GET 方法类似，但是不返回报文实体主体部分。主要用于确认 URL 的有效性以及资源更新的日期时间等。</p>
<h4 id="post">POST</h4>
<p>传输实体主体 POST 主要用来传输数据，而 GET 主要用来获取资源. 更多 POST 与 GET 的比较请见第九章</p>
<h4 id="put">PUT</h4>
<p>上传文件 由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;new.html HTTP&#x2F;1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-type: text&#x2F;html</span><br><span class="line">Content-length: 16</span><br><span class="line"></span><br><span class="line">&lt;p&gt;New File&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<h4 id="patch">PATCH</h4>
<p>对资源进行部分修改 PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PATCH &#x2F;file.txt HTTP&#x2F;1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application&#x2F;example</span><br><span class="line">If-Match: &quot;e0023aa4e&quot;</span><br><span class="line">Content-Length: 100</span><br><span class="line"></span><br><span class="line">[description of changes]</span><br></pre></td></tr></table></figure>
<h4 id="delete">DELETE</h4>
<p>删除文件 与 PUT 功能相反，并且同样不带验证机制。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">DELETE /file.html HTTP/1.1</span><br></pre></td></tr></table></figure>
<h4 id="options">OPTIONS</h4>
<p>查询支持的方法 查询指定的 URL 能够支持的方法。 会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容</p>
<h4 id="connect">CONNECT</h4>
<p>要求在与代理服务器通信时建立隧道 使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。<a href="https://joji.me/zh-cn/blog/the-http-connect-tunnel/">代理</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">CONNECT www.example.com:443 HTTP/1.1</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210520155917.png" alt="" /><figcaption>image-20201208195826753</figcaption>
</figure>
<h4 id="trace">TRACE</h4>
<p>追踪路径 服务器会将通信路径返回给客户端。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p>
<h3 id="http-状态码">HTTP 状态码</h3>
<p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">状态码</th>
<th style="text-align: center;">类别</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1XX</td>
<td style="text-align: center;">Informational（信息性状态码）</td>
<td style="text-align: center;">接收的请求正在处理</td>
</tr>
<tr class="even">
<td style="text-align: center;">2XX</td>
<td style="text-align: center;">Success（成功状态码）</td>
<td style="text-align: center;">请求正常处理完毕</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3XX</td>
<td style="text-align: center;">Redirection（重定向状态码）</td>
<td style="text-align: center;">需要进行附加操作以完成请求</td>
</tr>
<tr class="even">
<td style="text-align: center;">4XX</td>
<td style="text-align: center;">Client Error（客户端错误状态码）</td>
<td style="text-align: center;">服务器无法处理请求</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5XX</td>
<td style="text-align: center;">Server Error（服务器错误状态码）</td>
<td style="text-align: center;">服务器处理请求出错</td>
</tr>
</tbody>
</table>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">200</span> OK                        <span class="comment">//客户端请求成功</span></span><br><span class="line"><span class="number">400</span> Bad Request               <span class="comment">//客户端请求有语法错误，不能被服务器所理解</span></span><br><span class="line"><span class="number">401</span> Unauthorized              <span class="comment">//请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </span></span><br><span class="line"><span class="number">403</span> Forbidden                 <span class="comment">//服务器收到请求，但是拒绝提供服务</span></span><br><span class="line"><span class="number">404</span> Not Found                 <span class="comment">//请求资源不存在，eg：输入了错误的URL</span></span><br><span class="line"><span class="number">500</span> Internal Server <span class="built_in">Error</span>     <span class="comment">//服务器发生不可预期的错误</span></span><br><span class="line"><span class="number">503</span> Server Unavailable        <span class="comment">//服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span></span><br></pre></td></tr></table></figure>
<h3 id="http-首部">HTTP 首部</h3>
<p>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP-应用</title>
    <url>/posts/24375/</url>
    <content><![CDATA[<p>HTTP相关的应用</p>
<span id="more"></span>
<h1 id="http具体应用">HTTP具体应用</h1>
<h2 id="连接管理">连接管理</h2>
<h3 id="短连接与长连接">短连接与长连接</h3>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210520163234.png" alt="image-20210520163234892" style="zoom:50%;" /></p>
<p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信</p>
<ul>
<li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li>
<li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code></li>
</ul>
<h3 id="流水线">流水线</h3>
<p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。<strong>流水线是在同一条长连接上连续发出请求</strong>，而不用等待响应返回，这样可以减少延迟。</p>
<h2 id="cookie">Cookie</h2>
<p><strong>HTTP 协议是无状态的</strong>，<strong>主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务</strong>。HTTP/1.1 引入 Cookie 来保存状态信息。Cookie 是一些数据, 存储于你电脑上的文本文件中。当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。</p>
<p>Cookie 的作用就是用于解决 "如何记录客户端的用户信息"。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p>
<h3 id="用途">用途</h3>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）记录用户信息</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）浏览历史信息</li>
</ul>
<h3 id="创建过程">创建过程</h3>
<p>服务器发送的响应报文包含 <strong>Set-Cookie</strong> 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure>
<p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">GET /sample_page.html HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure>
<h3 id="分类">分类</h3>
<ul>
<li><p>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</p></li>
<li><p>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</p></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></table></figure>
<h3 id="作用域">作用域</h3>
<h3 id="javascript">JavaScript</h3>
<h3 id="httponly">HttpOnly</h3>
<p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: id&#x3D;a3fWa; Expires&#x3D;Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure>
<h3 id="secure">Secure</h3>
<p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p>
<h3 id="session">Session</h3>
<p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以<strong>利用 Session 存储在服务器端</strong>，<strong>存储在服务器端的信息更加安全</strong>。</p>
<p>使用 Session 维护用户登录状态的过程如下：</p>
<ul>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li>
</ul>
<p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p>
<h3 id="浏览器禁用cookie">浏览器禁用Cookie</h3>
<p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递</p>
<h3 id="cookie与session选择">Cookie与Session选择</h3>
<ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li>
<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li>
</ul>
<h2 id="缓存">缓存</h2>
<h3 id="优点">优点</h3>
<ul>
<li>缓解服务器压力；</li>
<li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存</li>
</ul>
<h3 id="实现方法">实现方法</h3>
<ul>
<li>让代理服务器进行缓存；</li>
<li>让客户端浏览器进行缓存</li>
</ul>
<h3 id="cache-control">Cache-Control</h3>
<p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</p>
<p>禁止进行缓存：no-store 指令规定不能对请求或响应的任何一部分进行缓存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure>
<p>强制确认缓存：no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure>
<p>私有缓存和公共缓存：private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-Control: private</span><br><span class="line">Cache-Control: public</span><br></pre></td></tr></table></figure>
<p>缓存过期机制：Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p>
<ul>
<li>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</li>
<li>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-Control: max-age&#x3D;31536000</span><br><span class="line"></span><br><span class="line">Expires: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure>
<ul>
<li>在 HTTP/1.1 中，会优先处理 max-age 指令；</li>
<li>在 HTTP/1.0 中，max-age 指令会被忽略掉。</li>
</ul>
<h3 id="缓存验证">缓存验证</h3>
<p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <code>http://www.google.com/</code> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ETag: &quot;82e22293907ce725faf67773957acd12&quot;</span><br></pre></td></tr></table></figure>
<p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If-None-Match: &quot;82e22293907ce725faf67773957acd12&quot;</span><br></pre></td></tr></table></figure>
<p>Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT</span><br><span class="line"></span><br><span class="line">If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>
<h2 id="通信数据转发">通信数据转发</h2>
<h3 id="代理">代理</h3>
<p>代理服务器接受客户端的请求，并且转发给其它服务器。使用代理的主要目的是：</p>
<ul>
<li>缓存</li>
<li>负载均衡</li>
<li>网络访问控制</li>
<li>访问日志记录</li>
</ul>
<p>代理服务器分为正向代理和反向代理两种：</p>
<ul>
<li>用户察觉得到正向代理的存在</li>
<li>而反向代理一般位于内部网络中，用户察觉不到</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210520170133.png" alt="" /><figcaption>image-20210520170133457</figcaption>
</figure>
<h3 id="网关">网关</h3>
<p>与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务</p>
<h3 id="隧道">隧道</h3>
<p>使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。</p>
<h2 id="section"></h2>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>Socket</title>
    <url>/posts/34204/</url>
    <content><![CDATA[<p>socket 的诞生是为了应用程序能够更方便的将数据经由传输层来传输，所以它本质上就是对 TCP/IP 的运用进行了一层封装，然后应用程序直接调用 socket API 即可进行通信。</p>
<span id="more"></span>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210520173058.png" alt="" /><figcaption>image-20201208214109784</figcaption>
</figure>
<h2 id="io-模型">I/O 模型</h2>
<p>一个输入操作通常包括两个阶段：</p>
<ul>
<li>等待数据准备好</li>
<li>从内核向进程复制数据</li>
</ul>
<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>
<p>Unix 有五种 I/O 模型：</p>
<ul>
<li>阻塞式 I/O</li>
<li>非阻塞式 I/O</li>
<li>I/O 复用（select 和 poll）</li>
<li>信号驱动式 I/O（SIGIO）</li>
<li>异步 I/O（AIO）</li>
</ul>
<h3 id="阻塞式-io">阻塞式 I/O</h3>
<p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。应该注意到，在阻塞的过程中，<strong>其它应用进程还可以执行</strong>，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。</p>
<p>重点在于 这个进程就休眠了 等数据从内核缓冲区复制到进程缓冲区返回后 才接着干别的事儿（不影响别的进程）</p>
<h3 id="非阻塞式-io">非阻塞式 I/O</h3>
<p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。</p>
<p>和阻塞式的区别 是当前进程没休眠，询问过后，又去干别的，然后过一会再询问下好不好，再干别的，再询问 就是轮询。这种不断询问就做了无用功</p>
<h3 id="io-复用">I/O 复用</h3>
<p>使用 <strong>select 或者 epoll</strong> 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即<strong>事件驱动 I/O。</strong></p>
<p>阻塞式I/O中如果要侦听多个事件，那么就需要多个进程分别负责一个事件，因为它会阻塞当前事件。而多路复用就是在当前进程中把所有要关注的事件都注册进epoll 然后就等（阻塞），一旦有一个事件有动静就会调用recvfrom 复制数据。所以本质是这个进程还是阻塞了，只能用于侦听事件，只不过相对纯阻塞式I/O的可以多路同时侦听</p>
<p>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。</p>
<h3 id="信号驱动-io">信号驱动 I/O</h3>
<p>应用进程使用 <strong>sigaction</strong> <strong>系统调用</strong>，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>
<p>相<strong>比于阻塞式I/O 这个方法没阻塞当前进程，相对非阻塞式I/O它也可以接着干其他事儿 还不用轮询效率更高</strong>。<strong>类似中断吧。</strong>但是在唤醒recvfrom 系统调用后 复制数据的过程还是阻塞的</p>
<h3 id="异步-io">异步 I/O</h3>
<p><strong>相对 信号驱动I/O 是数据接收到并且复制到 应用程序缓存后 才告知</strong></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210526223103.png" alt="" /><figcaption>image-20201208220653357</figcaption>
</figure>
<h2 id="io复用">I/O复用</h2>
<p>select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p>
<h3 id="select">select</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I/O 操作。</p>
<h3 id="poll">poll</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="比较">比较</h3>
<ol type="1">
<li>功能：select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。
<ul>
<li>select 会修改描述符，而 poll 不会；</li>
<li>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；</li>
<li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。</li>
<li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定</li>
</ul></li>
<li>速度: select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区</li>
<li>可移植性：几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</li>
</ol>
<h3 id="epoll">epoll</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。</p>
<p>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。</p>
<p>epoll 仅适用于 Linux OS。</p>
<p>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p>
<p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。</p>
<h3 id="工作模式">工作模式</h3>
<p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）</p>
<h4 id="lt-模式">1. LT 模式</h4>
<p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p>
<h4 id="et-模式">2. ET 模式</h4>
<p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h3 id="应用场景">应用场景</h3>
<p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p>
<h4 id="select-应用场景">1. select 应用场景</h4>
<p>select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。select 可移植性更好，几乎被所有主流平台所支持</p>
<h4 id="poll-应用场景">2. poll 应用场景</h4>
<p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select</p>
<h4 id="epoll-应用场景">3. epoll 应用场景</h4>
<p>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>HTTPS</title>
    <url>/posts/54221/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="https">HTTPS</h1>
<p><a href="https://juejin.cn/post/6850418120629485582">参考链接</a></p>
<p><a href="https://www.cnblogs.com/cxuanBlog/p/12490862.html">参考链接</a></p>
<p>HTTP 有以下安全性问题：</p>
<ul>
<li>使用明文进行通信，内容可能会被窃听；</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li>
<li>无法证明报文的完整性，报文有可能遭篡改</li>
</ul>
<p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 <strong>HTTPS 使用了隧道进行通信</strong>。通过使用 SSL，HTTPS 具有了<strong>加密（防窃听）、认证（防伪装）和完整性保护（防篡改）</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210520171309.png" alt="image-20210520171309580" style="zoom:67%;" /></p>
<p>HTTPS 有以下三个要点</p>
<ul>
<li>加密</li>
<li>数据完整性</li>
<li>身份验证：通过认证实现</li>
</ul>
<p>流程如下图：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/2021030410034421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjI2MjU3,size_16,color_FFFFFF,t_70#pic_center" alt="" /><figcaption>img</figcaption>
</figure>
<h2 id="加密">加密</h2>
<h3 id="对称加密">对称加密</h3>
<p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p>
<ul>
<li>优点：运算速度快；</li>
<li>缺点：无法安全地将密钥传输给通信方。</li>
</ul>
<p>例如 AES加密算法，加密就是 将 明文和密钥 通过一个加密函数映射得到密文。解密就是函数的逆映射。AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。</p>
<h3 id="非对称加密">非对称加密</h3>
<p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p>
<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p>
<ul>
<li>优点：可以更安全地将公开密钥传输给通信发送方；</li>
<li>缺点：运算速度慢。</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210520162855.png" alt="" /><figcaption>image-20201208203759099</figcaption>
</figure>
<p>例如 RSA算法，它的安全性基于 <code>整数分解</code>，使用两个超大素数的乘积作为生成密钥的材料</p>
<h3 id="https-采用的加密方式">HTTPS 采用的加密方式</h3>
<p>上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案：</p>
<ul>
<li>使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;</li>
<li>获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key）</li>
</ul>
<h2 id="完整性保护">完整性保护</h2>
<p>SSL 提供报文摘要功能来进行完整性保护。</p>
<ul>
<li>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</li>
<li>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</li>
</ul>
<p>MD5 全程 密码哈希算法(cryptographic hash algorithm)，MD5 可用于从任意长度的字符串创建 128 位字符串值，MD5 最常用于<code>验证文件</code>的完整性。除了MD5加密算法外，TLS 里用的是 SHA-2</p>
<h2 id="认证">认证</h2>
<p>通过使用 <strong>证书</strong> 来对通信方进行认证。数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p>
<p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p>
<p>签名的过程可以理解为 CA 机构使用私钥对签名进加密，同时对签名的明文使用 数据摘要算法（散列算法）将签名压缩为一个固定的长度的数据，这个就是上面所说的完整性保护中用的方法。客户端收到证书后，需要使用 公钥CA的公钥对 签名解密然后使用同样的散列函数对 解密后的签名进行压缩 再和 给定的进行对比，如果一致 说明签名在加密后没有被篡改过，是合法的。</p>
<h2 id="https-的安全性">HTTPS 的安全性</h2>
<p>不是绝对安全的，可以通过中间人攻击。</p>
<h3 id="什么是中间人攻击">什么是中间人攻击</h3>
<p>中间人攻击是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。</p>
<p>HTTPS 使用了 SSL 加密协议，是一种非常安全的机制，目前并没有方法直接对这个协议进行攻击，一般都是在建立 SSL 连接时，拦截客户端的请求，利用中间人获取到 CA证书、非对称加密的公钥、对称加密的密钥；有了这些条件，就可以对请求和响应进行拦截和篡改。</p>
<figure>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3215994d16b543fd81285341833fc808~tplv-k3u1fbpfcp-zoom-1.image" alt="" /><figcaption>image.png</figcaption>
</figure>
<h3 id="https-是如何防止中间人攻击的">https 是如何防止中间人攻击的</h3>
<p>https 无法防止中间人攻击，只有做证书固定ssl-pinning 或者 apk中预置证书做自签名验证可以防中间人攻击。具体的可以看这一篇文章。</p>
<h2 id="https的缺点">HTTPS的缺点</h2>
<ul>
<li>因为需要进行加密解密等过程，因此速度会更慢；</li>
<li>需要支付证书授权的高额费用。</li>
</ul>
<h2 id="get-和-post-比较">GET 和 POST 比较</h2>
<h4 id="作用">作用</h4>
<p>GET 用于获取资源，而 POST 用于传输实体主体。</p>
<h4 id="参数">参数</h4>
<p>GET 和 POST 的请求都能使用额外的参数，但是 <strong>GET 的参数是以查询字符串出现在 URL 中</strong>，而 <strong>POST 的参数存储在实体主体中</strong>。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p>
<p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">POST /test/demo_form.asp HTTP/1.1</span><br><span class="line">Host: w3schools.com</span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure>
<h4 id="安全">安全</h4>
<p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p>
<p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p>
<p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p>
<h4 id="幂等性">幂等性</h4>
<p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p>
<p>所有的安全方法也都是幂等的。</p>
<p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p>
<p>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">GET /pageX HTTP/1.1</span><br><span class="line">GET /pageX HTTP/1.1</span><br><span class="line">GET /pageX HTTP/1.1</span><br><span class="line">GET /pageX HTTP/1.1</span><br></pre></td></tr></table></figure>
<p>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 1nd row</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 2nd row</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 3rd row</span><br></pre></td></tr></table></figure>
<h4 id="可缓存">可缓存</h4>
<p>如果要对响应进行缓存，需要满足以下条件：</p>
<ul>
<li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li>
<li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li>
<li>响应报文的 Cache-Control 首部字段没有指定不进行缓存</li>
</ul>
<h4 id="xmlhttprequest">XMLHttpRequest</h4>
<p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p>
<blockquote>
<p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p>
</blockquote>
<ul>
<li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</li>
<li>而 GET 方法 Header 和 Data 会一起发送</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络-传输层</title>
    <url>/posts/37553/</url>
    <content><![CDATA[<p>网络层只把分组发送到目的主机，但是<strong>真正通信的并不是主机而是主机中的进程</strong>。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p>
<span id="more"></span>
<h2 id="传输层">传输层</h2>
<h3 id="udptcp特点">UDP/TCP特点</h3>
<ul>
<li>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），<strong>支持一对一、一对多、多对一和多对多的交互通信</strong>。</li>
<li>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的<strong>（一对一）。</strong></li>
</ul>
<h3 id="udptcp-首部格式">UDP/TCP 首部格式</h3>
<figure>
<img src="https://i.loli.net/2021/04/05/oqmREA9cFxWiZt3.png" alt="" /><figcaption>image-20201207200213483</figcaption>
</figure>
<p>UDP首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p>
<p>TCP 首部：</p>
<ul>
<li><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li>
<li><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li>
<li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li>
<li><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li>
<li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</li>
<li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li>
<li><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li>
</ul>
<h3 id="tcp-的三次握手">TCP 的三次握手</h3>
<figure>
<img src="https://i.loli.net/2021/04/05/9isQeZEN8VRupmv.png" alt="" /><figcaption>image-20201207200623727</figcaption>
</figure>
<p>假设 A 为客户端，B 为服务器端。</p>
<ul>
<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li>
<li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li>
<li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li>
<li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li>
<li>B 收到 A 的确认后，连接建立。</li>
</ul>
<p><strong>三次握手的原因</strong></p>
<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
<h3 id="tcp-四次挥手">TCP 四次挥手</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406091652.png" alt="" /><figcaption>image-20201207201452127</figcaption>
</figure>
<ul>
<li>A 发送连接释放报文，FIN=1。</li>
<li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li>
<li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li>
<li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li>
<li>B 收到 A 的确认后释放连接。</li>
</ul>
<p><strong>四次挥手的原因</strong></p>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 TIME_WAIT ， 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ul>
<li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li>
<li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li>
</ul>
<h3 id="tcp-可靠传输">TCP 可靠传输</h3>
<p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。其中 RTTd 为偏差的加权平均值。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406091711.png" alt="" /><figcaption>image-20201207202638734</figcaption>
</figure>
<h3 id="tcp-的滑动窗口">TCP 的滑动窗口</h3>
<p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，滑动窗口协议是<strong>传输层进行流控</strong>的一种措施，<strong>接收方通过通告发送方自己的窗口大小</strong>，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。</p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<p>对ACK的再认识，ack通常被理解为收到数据后给出的一个确认ACK，ACK包含两个非常重要的信息： <strong>一是期望接收到的下一字节的序号n，该n代表接收方已经接收到了前n-1字节数据，此时如果接收方收到第n+1字节数据而不是第n字节数据，接收方是不会发送序号为n+2的ACK的。</strong>举个例子，假如接收端收到1-1024字节，它会发送一个确认号为1025的ACK,但是接下来收到的是2049-3072，它是不会发送确认号为3072的ACK,而依旧发送1025的ACK。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406091720.png" alt="" /><figcaption>image-20201207203211039</figcaption>
</figure>
<h3 id="tcp-流量控制">TCP 流量控制</h3>
<p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h3 id="tcp-拥塞控制">TCP 拥塞控制</h3>
<p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p>
<p>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p>
<p><strong>发送方</strong>需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p>
<p>为了便于讨论，做如下假设：</p>
<ul>
<li><p>接收方有足够大的接收缓存，因此不会发生流量控制；</p></li>
<li><p>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406091731.png" alt="" /><figcaption>image-20201207211202040</figcaption>
</figure></li>
</ul>
<ol type="1">
<li><h3 id="慢开始与拥塞避免">慢开始与拥塞避免</h3>
<p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；（开始拥塞窗口是1时，发一个数据包等ACK回来 , 后面可以发送两个包,发送间隔几乎没有, 对方回的ACK到达发送方几乎是同时到达的.）当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...</p>
<p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>
<p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始</p></li>
<li><h3 id="快重传与快恢复">快重传与快恢复</h3>
<ul>
<li><strong>快重传</strong>：快重传算法首先要求<strong>接收方每收到一个失序的报文段就立即发出重复确认</strong> 快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待为其设置的重传计时器到期。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认，在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。在这种情况下，<strong>只是丢失个别报文段，而不是网络拥塞。</strong>因此执行快恢复**</li>
<li><strong>快恢复</strong>：当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限减半。这是为了预防网络发生拥塞，<strong>但不执行慢开始算法。</strong>由于发送方现在认为网络很可能没有发生拥塞 （如果网络发生了严重拥塞，就不会一连有好几个报文段连续到达接收方，也就不会导致接收方连续发送重复确认）。因此与慢开始不同之处就是现在不执行慢开始算法（<strong>即拥塞窗口现在不设置为1）而是把拥塞窗口的值设置为慢开始门限减半后的值，然后开始执行拥塞避免算法（“加法增大”）</strong>，使拥塞窗口缓慢地线性增大。</li>
</ul></li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406091741.png" alt="" /><figcaption>image-20201207210545841</figcaption>
</figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络-应用层</title>
    <url>/posts/63069/</url>
    <content><![CDATA[<p>位于计算机网络体系结构的最上层，前面四层做的所有事情就是为了他服务，他也是设计和建立计算机网络的最终目的，通俗的讲，就是我们开发的应用软件，就处于这一层。比如，QQ，浏览器访问网页，等等你看得到的应用软件都要使用这一层协议中的某一种，随着信息往下走，会逐渐在数据帧中增加其他层的协议。</p>
<span id="more"></span>
<h2 id="应用层">应用层</h2>
<p>　应用层协议定义了运行在不同端系统上的应用进程如何相互传递报文 应用层协议会定义</p>
<ul>
<li>交换的报文类型，如请求报文和响应报文；</li>
<li>各种报文类型的语法，如报文中的各个字段公共详细描述;</li>
<li>字段的语义，即包含在字段中信息的含义；</li>
<li>进程何时、如何发送报文及对报文进行响应</li>
</ul>
<p>应用层的应用软件分为两种 客户/服务 和 P2P</p>
<p>应用层协议的分类：</p>
<ul>
<li><code>域名系统(Domain Name System, DNS)</code>：用于实现网络设备名字到 IP 地址映射的网络服务</li>
<li><code>文件传输协议(File Transfer Protocol，FTP)</code>：用于实现交互式文件传输功能</li>
<li><code>邮件传送协议(Simple Mail Transfer Protocol, SMTP)</code>：用于实现电子邮箱传送功能</li>
<li><code>超文本传输协议(HyperText Transfer Protocol，HTTP)</code>：用于实现 Web 服务</li>
<li><code>远程登录协议(Telnet)</code>：用于实现远程登录功能</li>
</ul>
<h3 id="域名dns系统">域名(DNS)系统</h3>
<p>用户在与互联网上的主机通信时，必须知道对方的 IP 地址。但是每个 IP 地址都是由 32 位的二进制组成，即使是十进制的 IP 地址表示形式 ，不好记。所以域名的目的就是将互联网上不好记的主机的IP地址 转化为方便记忆的 域名。互联网中的域名系统 DNS 被设计成一个<strong>层次树状结构的联机分布式数据库系统</strong> ，并<strong>且采取的是客户服务器的方式</strong>。DNS 使大多数名字都在本地进行解析，只有少量的解析需要在互联网通信，因此效率很高。采取分布式的一个好处是，即使单个计算机出了故障，也不会妨碍 DNS 系统的正常运行。</p>
<p>域名到 IP 地址的解析是通过许多分布在互联网上的域名服务器完成的。解析的主要过程如下：当一个主机中的进程需要把域名解析为 IP 地址时，该进程就会调用解析程序，并成为 DNS 的 一个客户，把待解析的域名放在 DNS 的请求报中，以 <strong>UDP 用户数据报</strong>方式发送给<strong>本地域名服务器</strong>。本地域名服务器在查找域名后，把对应的 IP 地址放在回答报文中返回。获得 IP 地址的后主机即可进行通信。</p>
<h4 id="传输方式">传输方式</h4>
<p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：</p>
<ul>
<li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li>
<li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）</li>
</ul>
<h4 id="域名结构">域名结构</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406092125.png" alt="" /><figcaption>image-20201202204435339</figcaption>
</figure>
<p><code>www.baidu.com/</code> 为例，<code>www</code> 是三级域名，<code>baidu</code> 是二级域名，<code>com</code> 是顶级域名 各级域名之间通过 <code>.</code> 相连。每个<strong>互联网上的主机域名</strong>都对应一个 IP 地址，并且这个<strong>域名在互联网中是唯一的</strong></p>
<h4 id="域名服务器">域名服务器</h4>
<p>世界各地很多主机，不可能把所有的 域名-&gt;ip地址的映射方式都记录在本地主机。所以需要DNS服务根据域名去获取IP地址。根据域名服务器所起到的作用，可以把域名服务器分为四种不同的类型。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406092131.png" alt="" /><figcaption>img</figcaption>
</figure>
<ul>
<li>根域名服务器： 是最高层次的域名服务器，也是最重要的域名服务器，全球共设有 13 个根域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。当其他的域名服务器无法解析域名时，会首先求助于根域名服务器。假如所有的根域名服务器都挂了，那么整个互联网的 DNS 系统就无法工作了，因为采取的分布式结构，所以只要有一台能够正常工作，互联网的 DNS 系统就不会受到影响。</li>
<li>顶级域名服务器</li>
<li>权限域名服务器</li>
<li>本地域名服务器 ： 本地域名服务器(local name server)并不属于上面图示的服务器层次结构，但是它在域名服务系统却发挥着至关重要的作用。当一台主机发出 DNS 查询请求时，这个查询请求报文就会发送给本地域名服务器。每一个互联网提供者，或者一个大学，甚至小到一个学院，都可以拥有一台本地域名服务器，这种域名服务器也被称为默认域名服务器。我们本地网络服务连接的域名服务器指的就是本地域名服务器</li>
</ul>
<h4 id="域名解析过程">域名解析过程</h4>
<ul>
<li>迭代查询： 本地域名服务器向根域名服务器的查询方式通常采取迭代查询</li>
<li>递归查询：主机向本地域名服务器的查询一般都采用递归查询</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406092137.png" alt="" /><figcaption>image-20201202205206528</figcaption>
</figure>
<h4 id="dns缓存记录">DNS缓存记录</h4>
<p>为了提高 DNS 的查询效率，减轻根域名服务器的负荷和 DNS 数据报的查询数量，在域名服务器中广泛地使用了高速缓存。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。不仅在本地域名服务器中有高速缓存，在主机中也有。很多主机在启动的时候从本地域名服务器下载名字和地址的全部数据库，维护存放自己使用的域名的高速缓存，只有在缓存中找不到名字时才使用域名服务器。</p>
<h3 id="文件传送协议">文件传送协议</h3>
<p>FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：</p>
<ul>
<li>数据连接：用来传送一个文件数据。</li>
</ul>
<p>根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</p>
<ul>
<li>主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</li>
<li>被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406092142.png" alt="" /><figcaption>image-20201207212239959</figcaption>
</figure>
<p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p>
<h3 id="动态主机配置协议">动态主机配置协议</h3>
<p>当某组织获得一块地址后，就可以为本组织内的主机或者路由器分配IP地址。这个分配工作可以由系统管理员手动通过网络管理工具来完成。也可以由动态主机配置协议（Dynamic Host Congfiguration,DHCP）来完成。现在，主机通常是使用DHCP自动获取IP地址。</p>
<p>DHCP 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。当有一台主机加入时，DHCP服务器从其当前可用的地址池中分配一个任意地址给它；当一台主机离开时，其地址便被收回到这个池中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210517155901.png" alt="image-20210517155844106" style="zoom:50%;" /></p>
<p>DHCP 工作过程如下：</p>
<ol type="1">
<li><strong>客户端发送 Discover 报文</strong>，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68（因为此时新接入的主机还没有被分配IP地址）被放入 <strong>UDP</strong> 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。（中继代理通常是路由器）</li>
<li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端择优选择。</li>
<li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li>
<li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406092150.png" alt="" /><figcaption>image-20201207212830445</figcaption>
</figure>
<h3 id="远程登录协议">远程登录协议</h3>
<p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p>
<h3 id="电子邮件协议">电子邮件协议</h3>
<p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406092155.png" alt="" /><figcaption>image-20201207212959016</figcaption>
</figure>
<ol type="1">
<li><p>SMTP SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p></li>
<li><p>POP3 POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件</p></li>
<li><p>IMAP IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p></li>
</ol>
<h3 id="常用端口">常用端口</h3>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">应用</td>
<td style="text-align: center;">应用层协议</td>
<td style="text-align: center;">端口号</td>
<td style="text-align: center;">传输层协议</td>
<td style="text-align: center;">备注</td>
</tr>
<tr class="even">
<td style="text-align: center;">域名解析</td>
<td style="text-align: center;">DNS</td>
<td style="text-align: center;">53</td>
<td style="text-align: center;">UDP/TCP</td>
<td style="text-align: center;">长度超过 512 字节时使用 TCP</td>
</tr>
<tr class="odd">
<td style="text-align: center;">动态主机配置协议</td>
<td style="text-align: center;">DHCP</td>
<td style="text-align: center;">67/68</td>
<td style="text-align: center;">UDP</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">简单网络管理协议</td>
<td style="text-align: center;">SNMP</td>
<td style="text-align: center;">161/162</td>
<td style="text-align: center;">UDP</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">文件传送协议</td>
<td style="text-align: center;">FTP</td>
<td style="text-align: center;">20/21</td>
<td style="text-align: center;">TCP</td>
<td style="text-align: center;">控制连接 21，数据连接 20</td>
</tr>
<tr class="even">
<td style="text-align: center;">远程终端协议</td>
<td style="text-align: center;">TELNET</td>
<td style="text-align: center;">23</td>
<td style="text-align: center;">TCP</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">超文本传送协议</td>
<td style="text-align: center;">HTTP</td>
<td style="text-align: center;">80</td>
<td style="text-align: center;">TCP</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">简单邮件传送协议</td>
<td style="text-align: center;">SMTP</td>
<td style="text-align: center;">25</td>
<td style="text-align: center;">TCP</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">邮件读取协议</td>
<td style="text-align: center;">POP3</td>
<td style="text-align: center;">110</td>
<td style="text-align: center;">TCP</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">网际报文存取协议</td>
<td style="text-align: center;">IMAP</td>
<td style="text-align: center;">143</td>
<td style="text-align: center;">TCP</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h3 id="web-页面请求过程">Web 页面请求过程</h3>
<h4 id="dhcp-配置主机信息">1. DHCP 配置主机信息</h4>
<p>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取</p>
<ul>
<li>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中 ；（传输层 UDP）</li>
<li>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。（网络层 IP）</li>
<li>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。(数据链路层)</li>
<li>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</li>
<li>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 <strong>MAC 地址到其转发接口的交换表项</strong>，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</li>
<li>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</li>
</ul>
<h4 id="arp-解析-mac-地址">2. ARP 解析 MAC 地址</h4>
<p>此时 主机要知道网站域名和IP的对应 就得使用 DNS 协议获取 域名的 IP 地址，本地没有记录时就要用过DNS向外部的DNS服务器获取IP，所以此时要 先 将DNS 报文 通过网关路由器发往外网的DNS服务器，但是 在传输层只知道 网关路由器的 IP 地址，内网中发送报文还需要数据链路层的 MAC地址，DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</p>
<p><strong>在以太网环境下，同一个网段的主机之间需要知道对方的MAC地址，才能进行通信</strong></p>
<ul>
<li>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</li>
<li>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</li>
</ul>
<h4 id="dns-解析域名">3.DNS 解析域名</h4>
<p>知道了网关路由器的 MAC 地址之后，就可以开始 DNS 的解析过程了。</p>
<ul>
<li>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</li>
<li>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</li>
<li>通过上一步，此时ARP可以直接根据网关路由器地址解析出器MAC地址 ，该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。此时交换机 直接把 该数据包 转给和网关路由器连接的端口。</li>
<li>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</li>
<li>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</li>
<li>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</li>
<li>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过<strong>以太网交</strong>换机到达主机。</li>
</ul>
<h4 id="http请求页面">4.HTTP请求页面</h4>
<p>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</p>
<ul>
<li>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</li>
<li>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</li>
<li>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</li>
<li>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</li>
<li>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络-概述</title>
    <url>/posts/57351/</url>
    <content><![CDATA[<p>来自 <a href="http://www.cyc2018.xyz/">www.cyc2018.xyz</a> 的内容</p>
<span id="more"></span>
<h2 id="概述">概述</h2>
<h3 id="网络的网络">网络的网络</h3>
<p>计算网络是由若干结点和连接这些结点的链路组成。网络中的结点可以是计算机，集线器，交换机或路由器等</p>
<p>网络把主机连接起来，而互联网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。而互联网（Internet）是全球范围的互连网。</p>
<figure>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/network-of-networks.gif" alt="" /><figcaption>img</figcaption>
</figure>
<h3 id="isp">ISP</h3>
<p>ISP(internet service provider)译为互联网服务提供商，类似中国电信，中国移动，中国联通就是国内有名的ISP。ISP可以从互联网管理机构申请到很多IP地址，然后一些机构和个人从某个ISP获取IP地址的使用权，并可通过该ISP连接到互联网。三层ISP结构分为 主干ISP，地区ISP，本地ISP</p>
<p>从原理上讲。只要每一个本地ISP都安装了路由器连接到某个地区ISP，而每一个地区ISP也有路由器连接到主干ISP，那么在这些相互连接的ISP的共同作用下，就可以完成互联网中的所有的分组转发任务。</p>
<figure>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/3be42601-9d33-4d29-8358-a9d16453af93.png" alt="" /><figcaption>img</figcaption>
</figure>
<p><strong>互联网交换点(IXP)：为了更快地转发分组，IXP允许两个网络直接连接并交换分组，而不需要通过第三个网络来转发分组。</strong>例如上图中，主机A和主机B通过2个地区ISP连接起来了，就不必经过最上层的的主干ISP来转发分组。<strong>典型的IXP由一个或多个网络交换机组成</strong>。</p>
<h3 id="主机之间的通信方式">主机之间的通信方式</h3>
<h4 id="客户-服务器cs">客户-服务器（C/S）</h4>
<p>客户是服务的请求方，服务器是服务的提供方。客户端之间不能直接交流。</p>
<h4 id="对等p2p">对等（P2P）</h4>
<p>不区分客户和服务器。</p>
<h3 id="电路交换与分组交换">电路交换与分组交换</h3>
<h4 id="电路交换">电路交换</h4>
<p>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%</p>
<h4 id="分组交换">分组交换</h4>
<p>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程</p>
<h3 id="时延">时延</h3>
<p>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</p>
<h4 id="排队时延">排队时延</h4>
<p>分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</p>
<h4 id="处理时延">处理时延</h4>
<p>主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</p>
<h4 id="传输时延">传输时延</h4>
<p>主机或路由器传输数据帧所需要的时间。一帧数据有长度 delay = l / v(bit/s) 其中 l 表示数据帧的长度，v 表示传输速率</p>
<h4 id="传播时延">传播时延</h4>
<p>电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速</p>
<hr />
<h3 id="计算机网络体系结构">计算机网络体系结构</h3>
<figure>
<img src="https://images2017.cnblogs.com/blog/999804/201709/999804-20170929150555778-1593038196.png" alt="" /><figcaption>img</figcaption>
</figure>
<h4 id="五层协议">五层协议</h4>
<ul>
<li><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</li>
<li><strong>传输层</strong> ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li>
<li><strong>网络层</strong> ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li>
<li><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li>
<li><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li>
</ul>
<h4 id="osi">OSI</h4>
<p>其中表示层和会话层用途如下：</p>
<ul>
<li><strong>表示层</strong> ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li>
<li><strong>会话层</strong> ：建立及管理会话。</li>
</ul>
<p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理</p>
<h4 id="tcpip-协议">TCP/IP 协议</h4>
<p>它只有四层，数据链路层和物理层合并为网路接口层。并且 TCP/IP协议中，应用程序可以直接使用网络层或者网络接口层的，不严格遵守OSI分层的概念。</p>
<h3 id="数据在各层的传递">数据在各层的传递</h3>
<figure>
<img src="https://pic1.zhimg.com/v2-cc40c9010862820c3ffd457021d885d0_r.jpg" alt="" /><figcaption>preview</figcaption>
</figure>
<p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p>
<p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p>
<h2 id="物理层">物理层</h2>
<h3 id="通信方式">通信方式</h3>
<p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p>
<ul>
<li>单工通信：单向传输</li>
<li>半双工通信：双向交替传输</li>
<li>全双工通信：双向同时传输</li>
</ul>
<h3 id="带通调制">带通调制</h3>
<p>带通调制 就是用 根据 要传输的信号，去调制载波。将规则周期变化的载波（例如正弦波）调制为我们期待的信号。为什么要调制呢？因为按照通信中的理论，<strong>无线通信的条线长度和波长是有对应的关系的，而我们要传输的信号通常不固定或者频率很低，所以为了灵活应对不同的传输信号，使用固定的合适的频率去做载波做无线传输。</strong></p>
<p>模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络-链路层</title>
    <url>/posts/2693/</url>
    <content><![CDATA[<p>个人理解的 首先数据链路层的作用是：物理层比特流在介质上传输肯定有错误，因此依靠链路层通过 <code>CRC</code>等方法进行差错检验，然后配合滑窗的方法（这个TCP中也有）进行错误重传和流量控制等，向网络层提高高质量的数据传输服务。从应用场景上看，每个主机<code>ISP</code>过独立网线连接，这就是点对点通信，通常使用<code>PPP</code>协议控制。</p>
<span id="more"></span>
<p>局域网属于典型的广播通信，所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 <code>CSMA/CD</code> 协议。</p>
<p>点对点通信： 一条网线独立连接</p>
<ul>
<li><code>PPP</code>协议</li>
</ul>
<p>广播通信：总线接入，存在碰撞问题</p>
<ul>
<li>分时/分频/波分/码分复用，这种规则很死，对带宽利用率低（比如时分复用就规定了某个主机只能在特定时间片使用宽带，那我不想用呢？不久浪费了）</li>
<li><code>CSMA.CD</code>协议控制：通过碰撞检测的协议规则来控制，比较灵活，宽带利用率高。</li>
</ul>
<h3 id="链路层的意义">链路层的意义</h3>
<p>物理层的线路有传输介质与通信设备组成，比特流在传输介质上传输时肯定会存在误差的。这样就引入了数据链路层在物理层之上，采用差错检测、差错控制和流量控制等方法，向网络层提供高质量的数据传输服务。对于网络层，由于链路层的存在，而不需要关心物理层具体采用了那种传输介质和通信设备。</p>
<ol type="1">
<li>链路管理，帧同步</li>
<li>流量控制，差错控制</li>
<li>数据和控制信息分开</li>
<li>透明传输和<strong>寻址</strong></li>
</ol>
<h3 id="基本问题">基本问题</h3>
<h4 id="封装成帧">封装成帧</h4>
<p>就是将网络层传下来的分组添加 首部和尾部 用于标记帧的开始和结束 如下图 首部 <code>SOH</code>尾部 <code>EOT</code>。</p>
<h4 id="透明传输">透明传输</h4>
<p>透明表示一个实际存在的事物看起来好像不存在一样 。帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。<strong>这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在</strong>。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406091812.png" alt="" /><figcaption>image-20201202210820341</figcaption>
</figure>
<h4 id="差错检测">差错检测</h4>
<p>差错是不可避免的。而且不同的传输介质的差错程度也是不同的。链路层的任务就是分析差错产生的原因，检查差错，然后纠正差错。 目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。使用滑窗协议来解决出现差错（有两种），大概是发一帧，受到之后CRC校验没问题应带ACK 再发下一帧，否则重发这一帧….</p>
<h3 id="信道分类">信道分类</h3>
<h4 id="广播信道">广播信道</h4>
<p>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。 所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。主要有两种控制方法进行协调，一个是使用<strong>信道复用技术</strong>，一是使用 <strong>CSMA/CD</strong> 协议。</p>
<h4 id="点对点信道">点对点信道</h4>
<p>一对一通信。因为不会发生碰撞，因此也比较简单，使用 <strong>PPP 协议</strong>进行控制。</p>
<h3 id="信道复用技术">信道复用技术</h3>
<p>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。</p>
<ul>
<li><p>频分复用 ：频分复用的所有主机在相同的时间占用不同的频率带宽资源</p></li>
<li><p>时分复用 ： 时分复用的所有主机在不同的时间占用相同的频率带宽资源。</p></li>
<li><p>统计时分复用：是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送</p></li>
<li><p>波分复用：光的频分复用。在同一根光纤中同时传输两个或众多不同波长光信号的技术，称为波分复用</p></li>
<li><p>码分复用：为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片<span class="math inline">\(\vec{S}\)</span> 和 $ $ 有 <span class="math inline">\(\frac{1}{m} \vec{S} \cdot \vec{T}=0\)</span> 为了讨论方便，取 m=8，设码片 <span class="math inline">\(\vec{S}\)</span> 为 0 0011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406091820.png" alt="" /><figcaption>image-20201202222641379</figcaption>
</figure>
<p>利用上面的式子我们知道，当接收端使用码片 <span class="math inline">\(\vec{S}\)</span> 对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。<strong>码分复用需要发送的数据量为原先的 m 倍。</strong> 例如 A 的 码片是 1 1 -1 -1</p>
<p>B 的码片是 -1 1 -1 1 那么 A B 的内积为 0 ；如果要发送A的0bit 就发送 A码片否则发送A的反码。从这里看出，如果要两个码片正交，那么码片的位数一定得是偶数位，并且对应位乘积后，正负1对半开，这样就正交了，这个和数学上的正交坐标系思想一样但是实现方式不太一样，主要是数学上一下子就容易想到 （0, 1, 0） (1,0,0)这种正交，但是这种没法用两种状态来表示，至少需要 0 1 -1</p></li>
</ul>
<h3 id="csmacd-协议">CSMA/CD 协议</h3>
<p>CSMA/CD 表示载波监听多点接入 / 碰撞检测</p>
<ul>
<li><strong>多点接入</strong> ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li>
<li><strong>载波监听</strong> ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li>
<li><strong>碰撞检测</strong> ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li>
</ul>
<p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 <strong>争用期</strong> 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 <strong>截断二进制指数退避算法</strong> 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p>
<h3 id="ppp协议">PPP协议</h3>
<p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议</p>
<p>PPP 的帧格式：</p>
<ul>
<li>F 字段为帧的定界符</li>
<li>A 和 C 字段暂时没有意义</li>
<li>FCS 字段是使用 CRC 的检验序列</li>
<li>信息部分的长度不超过 1500</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406091829.png" alt="" /><figcaption>image-20201202225254343</figcaption>
</figure>
<h3 id="mac地址">MAC地址</h3>
<p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p>
<h3 id="局域网">局域网</h3>
<p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406091836.png" alt="" /><figcaption>image-20201202225413801</figcaption>
</figure>
<h4 id="以太网">以太网</h4>
<p>是一种局域网</p>
<p>以太网是一种星型拓扑结构局域网。目前以太网使用交换机替代了集线器，<strong>交换机是一种链路层设备</strong>，它不会发生碰撞，能根据 MAC 地址进行存储转发。以太网帧格式：</p>
<ul>
<li><strong>类型</strong> ：标记上层使用的协议；</li>
<li><strong>数据</strong> ：长度在 46-1500 之间，如果太小则需要填充；</li>
<li><strong>FCS</strong> ：帧检验序列，使用的是 CRC 检验方法；</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406091856.png" alt="" /><figcaption>image-20201202225529512</figcaption>
</figure>
<h3 id="交换机">交换机</h3>
<p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</p>
<p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406091906.png" alt="" /><figcaption>image-20201202225650091</figcaption>
</figure>
<h3 id="虚拟局域网">虚拟局域网</h3>
<p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406091916.png" alt="" /><figcaption>image-20201202225733826</figcaption>
</figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>相关的编程题汇总-图</title>
    <url>/posts/13636/</url>
    <content><![CDATA[<p>汇总了刷题中遇到的 图 相关的题目，例如拓扑排序，最短路径等</p>
<span id="more"></span>
<h2 id="图">图</h2>
<h3 id="拓扑排序类">拓扑排序类</h3>
<h4 id="leecode课程表-ii">leecode:课程表 II</h4>
<p>现在你总共有 n 门课 <code>0 ~ n-1</code>。想要学习课程 0，要先完成课程 1，用 <code>[0,1]</code> 表示。给定课程总量以及它们的先决条件，返回学完所有课程的顺序（返回一种即可），如果不可能完成所有课程，返回空数组。</p>
<p>这道题是一个典型的拓扑排序的问题，或者说 ：</p>
<ul>
<li>能拓扑排序 的图，一定是有向无环图</li>
<li>有向无环图，一定能拓扑排序</li>
</ul>
<blockquote>
<p>AOV网（Activity On Vertex Network)：将一个工程分为多个小的活动（Activity)，在有向无环图中，用顶点表示活动，用弧（有向边）表示活动的先后关系，简称为AOV网。</p>
</blockquote>
<p>此题还可以使用 深度优先遍历，遍历所有节点，若节点未被访问则从该节点开始深度遍历。并将该节点状态设置为正在遍历中 1；当他的所有邻接子节点遍历完成后，再次回溯到这个节点时，将状态设置为 2 并将该节点入栈。 代表访问完成。而当该节点状态为 正在遍历中 并再次访问到它时 代表有环 直接退出，无拓扑排序。 最后输出时将 栈 反序输出即可。这么做可以成立的原因是，因为 节点入栈实在回溯的时候完成的 因此对于有出度的节点 它入栈的顺序一定晚于 由该节点输出的子节点，符合拓扑排序的要求。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 存储每个节点的入度</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; indeg;</span><br><span class="line">    <span class="comment">// 存储答案</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        indeg.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="comment">// 将所有入度为 0 的节点放入队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 从队首取出一个节点</span></span><br><span class="line">            <span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 放入答案中</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(u);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v: edges[u]) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="comment">// 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span></span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() != numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="最短路径类">最短路径类</h3>
<p>实例：LeeCode 743题</p>
<h4 id="leecode-k-站中转内最便宜的航班">leecode: <a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/">K 站中转内最便宜的航班</a></h4>
<p>这个题从无向图的最短路径衍生而来。但是区别是这里有转机次数限制条件。因此如果没有跳转次数限制，存储起点到各节点的数组一维就够了，如果是有跳转次数限制，则最短距离数组为两维，新增的第二维为跳转次数：即从起点到节点 j 且跳转次数为 k 的最短距离。因为：如下情况 从A 出发到 节点 C 的最短路径是A-&gt;B-&gt;C 但是转了一次，如果从C 往后还有节点，但是只设置了一维最短距离数组，那么当取出{ C, 5, 0} 时由于 d[5] = 4 &lt; 0 + 5 = 5（d[5] 被 A-&gt;B-&gt;C这个选项先更新为4了），就不会把 {C, 5, 0} (A-&gt;C) 路径加入优先队列，导致后面可能经过C到达节点N的最短路径且满足转机次数要求的路径 是A-&gt;C-&gt;… 这种情况被忽略。所以这个题加入了 转机次数的限制，最短路径就要为 两维数组，保存在转折次数相同时到达节点N的最短距离。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328202842.png" alt="" /><figcaption>image-20210104223320648</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迪杰斯特拉算法实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; a, vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n, INT_MAX));  <span class="comment">// 用邻接矩阵存储图</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n)</span></span>;  <span class="comment">// 目标顶点到 其他各点的距离  一维数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flights.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            map[flights[i][<span class="number">0</span>]][flights[i][<span class="number">1</span>]] = flights[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;vector&lt;<span class="keyword">int</span>&gt;, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;, cmp&gt; edges;  </span><br><span class="line">        <span class="comment">// 优先队列： 节点p  起点到节点p的距离  起点到p需要中转的次数，如果只是求最短距离，这项没用</span></span><br><span class="line">        edges.<span class="built_in">push</span>(&#123;src, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	   <span class="comment">//  起始 起点到起点的距离0  转的次数0  （这里的转的次数和题目里的定义K不完全一样 差1）</span></span><br><span class="line">        <span class="keyword">while</span>(!edges.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; edge = edges.<span class="built_in">top</span>();</span><br><span class="line">            edges.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 取出节点到起点最近的  一个节点</span></span><br><span class="line">            <span class="keyword">int</span> p = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> dis_tmp = edge[<span class="number">1</span>]; </span><br><span class="line">            <span class="keyword">int</span> trans = edge[<span class="number">2</span>];</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 如果正好是目的结点，可以退出得到最近距离</span></span><br><span class="line">            <span class="keyword">if</span>(p == dst)   <span class="keyword">return</span> dis_tmp;</span><br><span class="line">		   <span class="comment">// 以距离起点最近的节点 p  	</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> ed = <span class="number">0</span>; ed &lt; n; ed++)&#123;</span><br><span class="line">                <span class="comment">// 如果 节点 p 和 ed 相邻  并且 结果点p到达节点ed的距离比原本 ed 的距离近  就更新到ed的最短距离 并加入队列以后访问  </span></span><br><span class="line">                <span class="keyword">if</span>(map[p][ed] == INT_MAX || d[ed] &lt;= map[p][ed] + dis_tmp) <span class="keyword">continue</span>;      </span><br><span class="line">                d[ed] = <span class="built_in">min</span>(d[ed], map[p][ed] + dis_tmp);</span><br><span class="line">                edges.<span class="built_in">push</span>(&#123;ed, d[ed], trans+<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="并查集">并查集</h3>
<p>​ 主要用途是 （参考链接：https://blog.csdn.net/liujian20150808/article/details/50848646）</p>
<ul>
<li><p>求联通分量：依次对每个边的两个顶点进行并查集合并，可以使得每个连通分量的root相同，从而得出每个连通分量。</p></li>
<li><p>查找环： 合并过程中，如果发现一条边的两个顶点已经合并过，说明这两个顶点之前已经通过其他路径合并，再加上这条边，图中就出现了环。<strong>合并节点 a , b 时 发现它两是一个祖先，是无向图，这样再加上边a-b就构成了环</strong>。(leecode 684 冗余连接)</p></li>
<li><p>求最小生成树： 贪心思想，从小到大排序所有边，使用并查集依次合并，并跳过形成环的边，即可得到最小生成树。</p>
<p>基本用方法 （详情 ）：</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="keyword">int</span> set_cnt;  <span class="comment">//  统计联通数 初始所有元素各自为一类，然后依次读入数据 不断合并 合并过程中 该变量递减 </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = i;</span><br><span class="line">        <span class="keyword">while</span>(parent[p] != p)</span><br><span class="line">            p = parent[p];</span><br><span class="line">        parent[i] = p;   <span class="comment">//这里的路劲 压缩写的不全  具体百度  思想就是 ，将所有子节点 都直接连接到根节点下，这样查找祖先时一部到位 速度快</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unio</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP == rootQ)  <span class="comment">// 联通的冗余边  当发现q p 已经连接时 ， 又传进p q代表此时成环了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        set_cnt--;       <span class="comment">// 联通数减一  这里可以加上启发式合并，每次合并保证将小的祖先族添加到大的祖先族下，免得一个方向的深度太深， 查找的慢 3-&gt;2-&gt;1    4-&gt;5  =》 3-&gt;2-&gt; 1 &lt;-5&lt;-4 优于 3-&gt;2-&gt;1-&gt; 4-&gt;5</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        set_cnt = N;</span><br><span class="line">        parent.<span class="built_in">resize</span>(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>(edges.<span class="built_in">size</span>()+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt; edg : edges)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">unio</span>(edg[<span class="number">0</span>], edg[<span class="number">1</span>]) == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span> edg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="最小生成树">最小生成树</h3>
<p>是 一副连通加权无向图中一颗权值最小的生成树。</p>
<h4 id="kruskal-克鲁斯卡算法">Kruskal 克鲁斯卡算法</h4>
<p>Kruskal 算法是一种<strong>贪心算法</strong>，将图中的每个edge按照权重大小进行排序，每次从边集中取出权重最小且两个顶点都不在同一个集合的边加入生成树中！<strong>注意：如果这两个顶点都在同一集合内，说明已经通过其他边相连，因此如果将这个边添加到生成树中，那么就会形成环！</strong>这样反复做，直到所有的节点都连接成功！这里可以用前面的并查集实现，复杂度NlogN</p>
<p><img src="https://picb.zhimg.com/v2-584bc7761471fd9835cde91b303935ac_r.jpg" alt="preview" style="zoom:67%;" /></p>
<h4 id="leecode-找到最小生成树里的关键边和伪关键边">leecode: 找到最小生成树里的关键边和伪关键边</h4>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328202902.png" alt="1599203012347" style="zoom:67%;" /></p>
<p>较简单的暴力思想。首先使用 kruskal算法+并查集的方法 求得最小生成树的 最小权值。然后再遍历判断每个边是否为 关键边。例如对于边 i 。判断它是关键边的方法就是在 使用 kruskal 时 跳过该边。如果最后生成的树的权值比开始计算的大 或者 不连通，说明它是关键边。伪关键边只会出现在 权值相同的多个边中，因此在生成树的时候优先以 待判断的边去选择，再对比最后生成树的权值是否最小。</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>基本数据结构</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>相关的编程题汇总-树</title>
    <url>/posts/55782/</url>
    <content><![CDATA[<p>汇总了刷题中遇到的 树 相关的题目，例如二叉树的遍历，公共祖先问题等</p>
<span id="more"></span>
<h3 id="二叉树">二叉树</h3>
<h4 id="特定深度节点链表">特定深度节点链表</h4>
<p>​ <img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328202809.png" alt="1598931882407" /></p>
<p>这个题 使用 层序遍历的 即可简单完成。类似于广度优先搜索的策略。只不过这里为了体现层的 特点，不是直接将 节点 传入队列 遍历，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;ListNode*&gt; <span class="title">listOfDepth</span><span class="params">(TreeNode* tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree==<span class="literal">nullptr</span>)<span class="keyword">return</span> vector&lt;ListNode*&gt;();</span><br><span class="line">        vector&lt;ListNode*&gt; v;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(tree);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            ListNode *h = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            ListNode *k=h;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=q.<span class="built_in">size</span>(); i&gt;<span class="number">0</span>; i--)&#123;    <span class="comment">/// 这里 先把size 赋给 i 即便for循环内改变了 队列的大小，最终也只是for遍历了原先的元素 ，所有可以记录 遍历的深度</span></span><br><span class="line">                TreeNode *p = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                k-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p-&gt;val);</span><br><span class="line">                k = k-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left)q.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right)q.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            v.<span class="built_in">push_back</span>(h-&gt;next); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="合法二叉搜索树">合法二叉搜索树</h4>
<p>最简单的思路就是 中序遍历 打印出二叉树所有的值，然后判断是不是递增的就可。必须是中序遍历才能将标准的搜索树递增的顺序打印出来。</p>
<h4 id="树的子结构">树的子结构</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">NULL</span> || B == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> B == <span class="literal">NULL</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (A-&gt;val != B-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="built_in">helper</span>(A-&gt;right, B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">NULL</span> || B == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(A, B) || <span class="built_in">isSubStructure</span>(A-&gt;left, B) || <span class="built_in">isSubStructure</span>(A-&gt;right, B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​ 这道题的思路是，双递归。首先 isSubStructure 第一个递归用来对A树递归，在A中搜索和B树的根节点 相同的 子节点 即return 中的 helper(A, B) 若该节点不满足则递归A 分别搜索A 的左右子节点是否满足。 而help函数的递归是在 第一个输入子节点A,B val值相同时，才开启递归，A和B分别往左右 递归去判断后面的节点是否相同。也就是此时二者的递归是同步的。注意helper中 若B是NULL 那位对应位置的A可以是任意值，所以直接返回True。</p>
<h4 id="翻转二叉树以匹配先序遍历"><a href="https://leetcode-cn.com/problems/flip-binary-tree-to-match-preorder-traversal/">翻转二叉树以匹配先序遍历</a></h4>
<p>​ 这道题容易理解错。题目的翻转的意思不是交换左右子节点的位置，它的反转是交换先序遍历中 左右子节点的访问顺序，之后能否匹配上给定的行程。因此解题思路是 首先 还是先序遍历，如果当前节点值 和 期待的行程值不一样直接返回false；接着先序遍历会递归访问左子节点 再右子节点。但是，这里在访问左子节点时要先判断下如果左子节点非空 且 值等于期待的行程的值 那么再递归的访问左右子节点，否则看右子节点值与期待的是否一样，<strong>若是，则先递归右子节点再左子节点</strong>，这就是所谓的交换子节点了。</p>
<h4 id="收集树上所有苹果"><a href="https://leetcode-cn.com/problems/minimum-time-to-collect-all-apples-in-a-tree/">收集树上所有苹果</a></h4>
<p>​ 这道题主要思路 是 从苹果往它上方通往根节点0的方向回退，并将总路程+2(该节点到父节点的往返) 这样对于有公共父节点的苹果，只用计算父节点到 根节点0的距离 和 各个苹果到该节点的距离。 首先利用并查集里的方法 构建一个 parent 的一维数组，parent[0] = 0代表起始的根节点，后面paent[1] = 0 表示节点1 的父节点是0，类似的 每个节点与它直系的可以通往 节点 0 的父节点相接。这个parent数组的初始化方法是：在并查集合并节点时，首先判断两个节点p,q的迭代到最后的根节点是不是0，若节点p的根节点不是0，q是，则 parent [p] = q 。初始化完了之后，将有苹果的节点加入队列，挨个访问，除了根节点之外 其余的在总路径上加2 表示往返 若他的父节点 没被访问过，则将它的父节点加入队列。</p>
<h4 id="输出二叉树"><a href="https://leetcode-cn.com/problems/print-binary-tree/">输出二叉树</a></h4>
<p>​ 这道题的主要思路是 首先深度优先搜索确定 树的最大深度。这样就可以直到 最终输出数组的宽度和长度，然后再用递归写一个深度优先搜索来，来依次填数。而这里的填充方法 用二分法定位每个节点子节点在数组中的位置比较方便。</p>
<h4 id="二叉树减树枝"><a href="https://leetcode-cn.com/problems/binary-tree-pruning/submissions/">二叉树减树枝</a></h4>
<p>​ 这道题思路很简单。写一个 dfs 后续遍历，如果递归左边和右边输出的树指针为NULL 且 当前节点 值为0 则返回NULL指针，否则直接返回 输入的结点。</p>
<h4 id="二叉树右视图"><a href="https://www.cnblogs.com/liuzhen1995/p/11921771.html">二叉树右视图</a></h4>
<p>​ 使用层次遍历，较简单。每次先把右子节点加入队列，每次输出只输出第一个节点的值。即可</p>
<h4 id="重建二叉树"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">重建二叉树</a></h4>
<p>​ 这类题目有 从前序和中序遍历的结果生成二叉树，或者从前序和后续遍历的结果生成二叉树，中序后序遍历的结果生成二叉树。要根据 不同遍历的 特点来构造递归。</p>
<ul>
<li><p>前序遍历：根节点 + 左子树所有节点 + 右子树所有节点的值</p></li>
<li><p>中序遍历：左子树的所有节点 + 根节点 + 右子树所有节点的值</p></li>
<li><p>后续遍历：左子树的所有节点 + 右子树所有节点的值 + 根节点</p>
<p>有了上述的规律，考虑 已知前序 和 后序遍历时，首先根节点 确定，然后根据前序遍历的 左子树序列的第一个值，即左子树的根节点值，在后续遍历序列中确定 左子树的范围。因为 前序和后续的同一颗子树的根节点 必然一个在最开始 一个在最结尾。这样递归的划分子树，构建即可。为了加快速度，使用<strong>Hash表</strong>构建 值-&gt;位置的索引，快速划分子树。</p></li>
</ul>
<h4 id="二叉树最近公共祖先"><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树最近公共祖先</a></h4>
<p>​ 这道题目的思想 在于 在一颗子树下的两个 待寻找的节点，找到最上面那个节点后 直接返回该节点，不用再往下递归搜索啦。因为如果深度往下搜的时候已经找到了 那么另一个要么 在它之下，要么在另一颗子树，这两种情况 最后最近的公共节点都是 这个返回的值。</p>
<h4 id="二叉树中的最大路径和"><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">二叉树中的最大路径和</a></h4>
<p>思路比较简单，但是是个困难的题目</p>
<h4 id="完全二叉树的节点个数"><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">完全二叉树的节点个数</a></h4>
<p>这个利用了 满二叉树的 性质。对于满二叉树 它的叶子节点的编号和路径是有规律的 。因此 先找到最左边的叶子节点，那么最底层的叶子节点的个数就是个范围，然后用二分搜索去确定最下面的叶子节点的具体编号。</p>
<h4 id="字典序的第k小数字"><a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/">字典序的第K小数字</a></h4>
<p>完全十叉树，和满二叉树类似。主要是要熟悉完全二叉树的性质。</p>
<h3 id="堆">堆</h3>
<h4 id="无序数组的topk小元素">无序数组的topK小元素</h4>
<p>​ 可以使用优先队（大根堆），c++ 中的数据结构为<strong>priority_queue</strong>。思路是，首先对数组前K个元素建大根堆，然后依次读取数组后面的元素，若该元素大于 堆顶的元素，则丢弃不管，若小于堆顶元素，则将它入堆，并pop掉原本的根节点的数据。遍历完数组后，最后堆中剩下的就是TopK小的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">vec</span>(k, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> vec; <span class="comment">// 排除 0 的情况</span></span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt;Q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) Q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; (<span class="keyword">int</span>)arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Q.<span class="built_in">top</span>() &gt; arr[i]) &#123;</span><br><span class="line">                Q.<span class="built_in">pop</span>();</span><br><span class="line">                Q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            vec[i] = Q.<span class="built_in">top</span>();</span><br><span class="line">            Q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="数据流的中位数"><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/">数据流的中位数</a></h4>
<p>使用大小堆解决。一个大顶堆一个小顶堆。每次先把数据从小顶堆输入，输出到大顶堆。这样就保证了 小顶堆中的数始终大于等于大顶堆的数。（因为大顶堆的数是从小顶堆过来的，小顶堆弹出的一定是最堆中最小的，而大顶堆堆定数最大 ）最后每次维持小顶堆的数据量大于或等大顶堆中的数据量即可（如果大顶堆数量大于小顶堆数量，就反过来将大顶堆数据弹出一个给小顶堆，这样两堆元素数量就相等了）。这样当数据量为偶数时就是两个堆定元素平均，否则就是小顶堆的堆顶元素。</p>
<h4 id="重构字符串"><a href="https://leetcode-cn.com/problems/reorganize-string/">重构字符串</a></h4>
<p>这个题很容易能想到用堆做</p>
<h4 id="接雨水-ii"><a href="https://leetcode-cn.com/problems/trapping-rain-water-ii/">接雨水 II</a></h4>
<p>同类题 一维的接雨水 （<a href="https://leetcode-cn.com/problems/trapping-rain-water/">接雨水</a>），这个是二维的 太变态了。但是基本原理都是用短板效应。每次找最短的板。 对于一维的接雨水，想象从上往下倒水，水只能从两边流出，因此取两边中的短边作为短板，然后不断往中间搜索，如果中间的比两边的短，那么这个就可以和短板构成一个接水槽，如果它比短板高，那么它不能作为接水槽，因为会往外流，但是可以更新边界的高度。使用双指针就可以完成整个逻辑。但是一维接雨水最好想的思路是，计算每个位置的板左边和右边最大的高度即可，但是这个最大高度其实不用每次都暴力搜索，只需要两次遍历，即可找到每个位置左边和右边的最大值。</p>
<p>同理对于二维的接雨水问题，中间能接多少水，取决于四周板最短的一块，但是不能暴力搜索最短的啊，直接使用小顶堆来动态维护最短边界。具体的思路。<a href="https://leetcode-cn.com/problems/trapping-rain-water-ii/solution/javajie-yu-shui-de-xin-lu-li-cheng-zhao-n4cpz/">解题</a></p>
<p>比如说外围一圈，那个最短的地方肯定能结算它四周的位置，因为雨下的足够大，你不可能会低于这个短板，高于这个短板又会溢出，所以这个结算肯定是正确的。欸，这样的话，我每次都找外围的短板，然后结算它四周的位置，不断的缩小这个外围不就能把水量算出来了嘛！！！等等，短板用一次就丢好么？如果这个短板比中间所有的位置都要高，那你这圈就是再咋缩短板也不能变呀。所以短板得有个淘汰机制，什么情况下短板就没用了，那肯定你此时结算的圈的短板比之前的短板要高的时候了，我当前圈的短板更高，那我这个圈里的水都给我hold住了，不可能从之前的短板里溜出去了。</p>
<p>1.外围不断在变化，咋样能快速知道每次的短板是哪个呢？很明显用小根堆可以解决。 2.如何确保一个位置不被重复结算？用set？反正肯定最后所有位置都被结算一次，直接用个boolean数组就好了 3.然后再整个变量存一下此时短板的高度 4.堆里存的是当前外圈的板子，那么需要存那些信息呢？我要知道你多高，height跑不掉，我需要结算你四周的水量，所以你的位置也得知道，所以加上(row,col)</p>
<h2 id="其他树">其他树</h2>
<h4 id="最多-k-次交换相邻数位后得到的最小整数"><a href="https://leetcode-cn.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/">最多 K 次交换相邻数位后得到的最小整数</a></h4>
<p>树状数组解决</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>基本数据结构</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>相关的编程题汇总-表</title>
    <url>/posts/38982/</url>
    <content><![CDATA[<p>汇总了刷题中遇到的 表 相关的题目，例如栈，哈希表，数组字符串相关的题目</p>
<span id="more"></span>
<h2 id="数组字符串">数组/字符串</h2>
<h4 id="旋转图像"><a href="https://leetcode-cn.com/problems/rotate-image/">旋转图像</a></h4>
<p>要做到不占用额外空间</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210426192915.gif" alt="" /><figcaption>rotate.gif</figcaption>
</figure>
<p>方法一：需要用 暂存一个值 然后 循环交换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">                matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">                matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">                matrix[j][n - i - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：先水平镜像 后竖直镜像</p>
<h4 id="计算器"><a href="https://leetcode-cn.com/problems/calculator-lcci/">计算器</a></h4>
<p>方法一：递归的方法 很好理解。用递归 实际上也是 遍历了一边确定没有乘除之后 再遍历一圈计算加减</p>
<p>定义函数计算 cal(string &amp;s, int l, int r) 字符串s在区间[l,r]的结果</p>
<ol type="1">
<li>由于是递归所以优先级低的+-先判断进入递归</li>
<li>因为同等优先级是从左往右 所以递归是从右往左开始扫</li>
<li>如果没有符号则说明这个区间里是一个数字 使用 stoi 返回数字即可</li>
</ol>
<p>方法二：使用堆栈 只遍历一次。遇到乘除直接计算值，遇到加减，将数字放入堆栈（带符号的放入），最后计算堆栈中所有数字的和</p>
<h4 id="验证ip地址"><a href="https://leetcode-cn.com/problems/validate-ip-address/">验证IP地址</a></h4>
<p>这个题 很恶性 主要就是各种边界条件的判定。有三种方法：</p>
<ol type="1">
<li>不使用任何库函数 就纯c++手写循环。使用状态机的思路 构建了状态表 逻辑比较清晰 不会乱</li>
<li>使用 <code>stringstream</code> 来分割字符串</li>
<li>使用 正则表达式 这种方法最慢，但是代码最简介。</li>
</ol>
<h4 id="移除无效的括号"><a href="https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/">移除无效的括号</a></h4>
<h4 id="寻找两个正序数组的中位数"><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></h4>
<p>这个题要求实现 log(m+n)的时间复杂度。首先想到的是使用 归并的方式从头到尾寻找中位数。但是这样复杂度是O(m+n)。不符合要求。看到log(m+n)首要想打就是 二分法。问题是这个怎么用二分法呢。</p>
<p>首先找中位数 就是找第k个数，那么我就上下 各找前 (k-1)/2个数，然后比较两个数组这个位置数字大小，因为数组是有序的，一旦比较大小比出结果，就可以排除一大部分数字。再在后面的区间中找.</p>
<h4 id="重复的子字符串"><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">重复的子字符串</a></h4>
<p>一开始想到的是 暴力枚举 子字符串的个数，从2，3，4…. 字符串长度如果不能整除可以跳过。然后怎么判断 字符串是否是3个子串重复的呢？例如 a = a1 + a2 + a3 如果要判断a是三个重复的组成就要判断 a1 == a2 a2 == a3 都成立，这样写麻烦，直接把 比较（a2 + a3 + a1 ）== (a1 + a2 + a3) 是否相等即可，代码写着比较简便。</p>
<p>但是更好的方法是 双倍长度法 构建新的双倍长度的字符串 s == a + a 然后 从 s 的第1个元素开始查找 和 a 匹配的位置，如果a 没有重复字符串组成 那么 找到的位置一定是从 a.size() 开始，即只能找到后面那个 a。</p>
<h4 id="下一个排列"><a href="https://leetcode-cn.com/problems/next-permutation/">下一个排列</a></h4>
<p>这个题主要要想清楚下一个大排列的规律。 参考连接：https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/</p>
<h4 id="旋转数组"><a href="https://leetcode-cn.com/problems/rotate-array/">旋转数组</a></h4>
<p>这个题很经典。要求不使用 额外的 空间将 数组平移。方法1是使用三次翻折法，比较好想。方法二是循环移位法，原理假如下：</p>
<p>假设现在有 A 、B 、C、 D、 E 五名同学，今天考试完，老师要求换座位，每个同学向后移动3个座位。于是就从 A 同学开始换座位了... A同学 非常自觉，看了看自己座位号（0），根据老师要求，他走到了3 号位置，即 D 同学的位置，同时他把D 同学赶到了角落，自己坐在了 3 号位置，第一个完成任务真爽！D同学 一看，不行啊，我咋能呆在角落，于是D同学也按要求理直气壮来到了1号位置，同样把B同学赶到了角落，猛男落泪...B同学 当然也不干，气汹汹走到了4号位置，"E同学，麻烦起来一下，角落给你收拾好了：)",于是 E同学来到角落..E同学 一想：不行呀，我这么帅，必须有座位！站起来跑到了2号位置，二话不说，赶走了C….</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210426110441.png" alt="image-20210426110441307" style="zoom:67%;" /></p>
<p>同样，对于循环移位类的问题，可以这样理解，移动后的位置 i = (k + i) % len；但是移动的时候，可能还没遍历完所有的元素，就回到了起点。也可能从起点0开始，往后寻找，到下一轮回到了1位置，这时候再循环，可以到2位置….最终肯定能够再回到起点位置。也可能是从起点开始，到下一轮刚好又回到起点。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210426113941.png" alt="" /><figcaption>image-20210426113941474</figcaption>
</figure>
<h2 id="链表">链表</h2>
<h4 id="相交链表"><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">相交链表</a></h4>
<p>双指针，走 m + n + c n + m + c 相遇</p>
<h4 id="lru-缓存机制"><a href="https://leetcode-cn.com/problems/lru-cache/">LRU 缓存机制</a></h4>
<h4 id="lfu-缓存"><a href="https://leetcode-cn.com/problems/lfu-cache/">LFU 缓存</a></h4>
<p>这个题和上面的区别在于，LRU的题意是，删除最久没使用过的元素，所以通过一个链表即可完成。而这个题要求删除使用最少的元素，所以就需要记录每个元素的使用次数。但是这个最小使用次数有一个规律，使用一个 变量 记录最小使用的次数，每次插入元素</p>
<ul>
<li>若该元素A在缓存中存在，且A的使用次数大于最少使用次数，那么该次插入对最小使用次数不影响</li>
<li>若该元素A在缓存中存在，且A不是唯一一个使用次数最少的元素，那么将它的使用次数加1之后，还是不影响系统的最下使用次数</li>
<li>若该元素A在缓存中存在，且正好A就是唯一的一个最少使用次数的元素，那么系统的最少使用次数 + 1 并将改元素移动到 使用频率为 min+1 的缓存池中</li>
<li>若该元素A是个新元素，那么删除缓存中的最少使用频率的元素后，系统使用次数最少频率 就 是 1</li>
</ul>
<p>综上，在这个操作逻辑下 想要维护系统最小使用次数这个变量，其实逻辑不复杂，不需要排序。因此优化上述的数据结构，可以很容易O(1) 实现所有功能</p>
<p>但是，如果想不到 上述 O(1) 的方法，想到要取出 频率最小的元素，其实就应该 想到 堆 二叉搜索树 等数据结构，但是 用堆，当插入的元素不是堆顶的元素的是偶，从堆中搜索其他元素，O(n) 所以，考虑使用 红黑树，来维护 使用频率的有效性。c++中 set 底层是 红黑树，自定义数据结构后对 &lt; 重载，就可以保证插入到集合中的元素是有序的，每次取出集合起始的元素即可。（但是 要注意，自定义数据结构中，仅仅以 频率作为排序依据实不行的，因为不同元素使用频率可能一样，而集合要求每个元素不同，另外题目也要求 使用频率一样的 删除最近没使用的变量，所以新增一个 time（时间戳） 变量来标记每个元素，当有新的操作增加时，对应被操作的元素time更新时间戳，当使用频率相同时使用time的大小做为排序依据）。这种使用红黑树的方法，每次插入元素复杂度为 O(log N)</p>
<h4 id="全-o1-的数据结构"><a href="https://leetcode-cn.com/problems/all-oone-data-structure/">全 O(1) 的数据结构</a></h4>
<p>和 LFU 类似。这种 O(1) 一般都是要用Hash表，自己想的是以频率作为键来存储每个频率中的元素，但是当极端情况下 频率出现较大断层的 情况 {1: [“dsd“]， 55：[“sdsd”]} 这种情况，吧“dsd”删除后 寻找最小频率的复杂度就很高了，要向上搜索到55 所以更好的方法是 使用双向链表来 记录顺序，因为每次频率 只能是 +1 -1的操作，所以频率节点每次只会像周围移动一次，但是为了避免寻找特定 key 的节点，需要用 Hash表存储 key-&gt;Node的映射。</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210614154224.png" alt="image-20210614154217494" style="zoom:50%;" /></p>
<h4 id="回文链表"><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">回文链表</a></h4>
<p>基本的方法是 遍历链表 把 每个节点缓存到数组里 然后使用双指针判断是不是 回文链表。空间复杂度O(1) 的方法是 先使用快慢指针找到链表的中点，然后将链表后半部分反转，再和前半部分比较，这样没有缓存任何东西，空间复杂度O(1) 时间复杂度O(N)</p>
<h4 id="排序链表"><a href="https://leetcode-cn.com/problems/sort-list/">排序链表</a></h4>
<p>很容易想到归并排序，但是在实现过程中 很容易出现 无线递归的情况。这样考虑 一个节点的时候 中点节点回是哪个，两个节点的时候中点节点会是哪个，基本四个以上的节点就不会出问题了 主要是节点少的时候容易无限递归。</p>
<h4 id="合并k个升序链表"><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">合并K个升序链表</a></h4>
<p>首先合并两个，然后再和第三个合并，再和第四个合并…. 这样时间复杂度为 O(KxKxN) 可以使用归并优化 降低时间复杂度</p>
<h2 id="hash表">Hash表</h2>
<h4 id="o1-时间插入删除和获取随机元素"><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1/">O(1) 时间插入、删除和获取随机元素</a></h4>
<p><strong>vector 的尾部插入删除时间复杂度为O(1)</strong> 但是随机插入和删除的时间复杂度为O(N) 所以要解决随机删除复杂度的问题 可以记录 将要删除的某个元素在vector 中的位置然后将他和最后一个元素交换，然后把最后一个元素删了即可</p>
<h4 id="缺失的第一个正数"><a href="https://leetcode-cn.com/problems/first-missing-positive/">缺失的第一个正数</a></h4>
<p>这个题 有点意思 要时间复杂度 O(N) 常数的空间复杂度。首先一个隐含条件需要看出来，那就是缺失的最小正整数一定是[1, N+1]其中N为数组长度。所以要实现时间复杂度O(N)很容易，直接枚举N个数。用hash表判断每个枚举的数在不在表中即可。</p>
<p>但是要空间复杂度为O(N) 那就不能额外新建hash表了。但是题目给定的数组可以修改啊，于是乎 怎样在修改数组中数的前提下，害不修改数组的值呢？那就是用正负号标记喽。只对原数组中的数做 正负 处理，如果某个元素存在就将该元素对应的下标上的数 用负标记。（由于数组中可能会存在 0或这负数，而这些数肯定不是 要找的最小正整数，所以将他们预先设置为N+1，不影响负号的标记即刻）。最后再遍历，最先出现正数的位置（即每被标记过） 即为 最小的正数。</p>
<p>综上 遍历三次 第一次 将负数和0设置为 N+1，第二次遍历标记出现过的数对应的下标的值标为 负数，第三次遍历找第一次为正数的下标</p>
<h4 id="最长连续序列"><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">最长连续序列</a></h4>
<p>这个题不难实现，但是关键是先能想到的使用暴力的方法 求解的逻辑，然后再使用 Hash 去优化，最后再进行剪枝，最终实现 O(n)。</p>
<h4 id="和为k的子数组"><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">和为K的子数组</a></h4>
<p>这个题还可以变化一下 和 大于 K 的最短子数组 就是另一个题目了</p>
<h4 id="连续数组"><a href="https://leetcode-cn.com/problems/contiguous-array/">连续数组</a></h4>
<p>这类 连续数组 和 &gt;&gt; 前缀后 &gt;&gt; 数组中两数差/两数和 &gt;&gt; Hash</p>
<h2 id="单调栈">单调栈</h2>
<h4 id="下一个更大元素-ii"><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">下一个更大元素 II</a></h4>
<p>这是一个典型的单调栈的题目 。 就是栈中元素,按递增顺序或者递减顺序排列。</p>
<h4 id="接雨水"><a href="https://leetcode-cn.com/problems/trapping-rain-water/">接雨水</a></h4>
<p>单调递减栈。这个题，关键点 是没想到 怎么计算雨水的容量，一开始想的是 宽度x短边长，但是如果这里面还有其他矮的柱子，还得减去矮柱子的面积，想到了使用栈的方式，但是没想到使用栈的第推计算面积的方式，计算面积可以通过高度差的方式 累计面积。</p>
<p>其实这个题最好想的思路 不是用单调栈。按照题目意思，对于当前位置能存水的量是 min(左边最大高度, 右边最大高度) 那么问题就转换为 求每个位置左边最大高度，和右边最大高度。这就和 下面这个题有点类似，下面这个题最终就是要找每个位置 左边第一个右边第一个小于当前高度的柱子。但是后者用单调栈分别左右遍历可以求得，而前者使用最大值遍历即可求得。都需要两个方向遍历。</p>
<h4 id="柱状图中最大的矩形"><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a></h4>
<h4 id="不同字符的最小子序列"><a href="https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters/">不同字符的最小子序列</a></h4>
<p>相对简单的单调栈有更多限制，但是基本思想还是一样的。</p>
<h4 id="和至少为-k-的最短子数组"><a href="https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/">和至少为 K 的最短子数组</a></h4>
<h4 id="分割数组"><a href="https://leetcode-cn.com/problems/partition-array-into-disjoint-intervals/">分割数组</a></h4>
<p>构建单调数组，基本的方法是两趟遍历分别寻找数组左边和右边的最大值，最小值。我一开始想的，因为从最左边到最右边滑动，相当于一个数据流，左边的数据不断增多，右边的数据逐渐减少，相当于两个数据流，通过堆的方式获取左边和右边的最大最小值。但是明显，在数组数据固定的时候可以通过O(N) 的方式求到每个位置得最大最小值，而用堆，复杂度至少O(NlogN)</p>
<h2 id="栈">栈</h2>
<h4 id="字符串解码"><a href="https://leetcode-cn.com/problems/decode-string/">字符串解码</a></h4>
<h4 id="section"></h4>
<p>难度困难1400</p>
<h2 id="队列">队列</h2>
<h4 id="滑动窗口最大值"><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">滑动窗口最大值</a></h4>
<p>这个题 和 最大栈/单调栈 类似。只不过那个是用来记录栈数据中的最大值，因此需要一个额外的最大栈。这种题目中 最大值都是和元素的增加顺序有关，因为滑动窗口很像 双端队列的逻辑，所以使用一个双端队列来记录最大值。具体的 窗口前端增加数据时，首先队列前端所有比他小的元素，然后再将改元素从前端入队，同时窗口可能还要收缩一个单位，如果待收缩的元素不是队列尾端的，就不管，若是就从尾端弹出。最后窗口最大的元素就是队列末尾的元素了。o(N)</p>
<p>但是这个题也可以用优先队列做。首先优先队列中存放K个数，顶端的肯定是最大的，但是不一定在窗口中，因此每次去顶端元素时，要先保证它在窗口中（同时记录每个元素的大小 和 其在数组中的索引位置）即索引位置在窗口以外，就弹出，直到顶端元素在窗口中，那么顶端元素就是窗口的最大值。这个方法复杂度 O(log(N))</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>基本数据结构</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-图</title>
    <url>/posts/41634/</url>
    <content><![CDATA[<p>数据结构之图，记录了图有关的定义和常规操作</p>
<span id="more"></span>
<h1 id="图">图</h1>
<h2 id="几个重要的概念">几个重要的概念</h2>
<ul>
<li>有向图 / 无向图 / 混合图：每个边都是有向边，个边都是无向边，…</li>
<li>度：顶点相邻边的数目，常用 <code>deg(V)</code>, <code>d(v)</code> 表示。有向图中 以该顶点为终点的边的数目 <strong>入度</strong>； 以该顶点为起点的边的数目 <strong>出度</strong> ； 顶点的度 = 入度 + 出度。</li>
<li>连通的 / 连通图 / 连通分量 / 极大连通子图：从顶点 u 有路径到达 v ，则 <code>u,v</code> 是连通的；任意两点连通；H是G的连通子图，且不存在连通图F，使得 <code>H ⊊ F ⊆ G</code>，则H是G的连通分量。
<ul>
<li>连通图只有一个连通分量，即图自身</li>
<li>非连通图有多个连通分量。</li>
</ul></li>
</ul>
<h2 id="图的表示">图的表示</h2>
<p><strong>直接存边</strong>：使用一个数组来存边，数组中的每个元素都包含一条边的起点、终点和边权（带边权的图），或者使用多个数组分别存起点、终点和边权。</p>
<figure>
<img src="https://i.loli.net/2021/03/28/BNKUo93ncTrgdWY.png" alt="" /><figcaption>1598969422109</figcaption>
</figure>
<p><strong>邻接矩阵 Adjacency Matrix</strong>二维数组 <code>adj[][]</code>，<code>adj[u][v]</code> 为 1 表示存在 u 到 v 的边，为 0 表示不存在。如果是带边权的图，可以在 <code>adj[u][v]</code> 中存储 u 到 v 的边的边权。</p>
<p><strong>邻接表 Adjacency Table</strong>：使用一个支持动态增加元素的数据结构构成的数组，例如c++中的 vector<int></p>
<ul>
<li><p>领接表：中 <code>adj[u]</code> 存储的是点 u 所有出边的信息（终点、边权等）</p></li>
<li><p>逆邻接表：中 <code>adj[u]</code> 存储的是点 u 所有入边的信息（起点、边权等）</p>
<p>​</p></li>
</ul>
<h2 id="图的遍历">图的遍历</h2>
<ul>
<li>深度优先搜索 (Depth-First Search, DFS)</li>
<li>广度优先搜索 (Breadth-First Search, BFS)</li>
</ul>
<h2 id="拓扑排序">拓扑排序</h2>
<p>根据依赖关系输入 排序结果，要将被依赖的步骤放在前面执行，没有依赖关系的步骤先后顺序无所谓。对于有环的图，构成了循环依赖的关系，因此这个环上的所有元素无法输出。所以 <strong>拓扑排序可以用来判断图是否有环</strong></p>
<h3 id="思路">思路</h3>
<h4 id="广度优先">广度优先</h4>
<p>首先入度为0的节点，它一定不依赖任何节点，所以它可以最先输出。因此首先遍历所有节点并统计每个节点的 入度；一开始将所有入度为0的节点之间放入队列。按照广度优先遍历的套路，不断从队列中取节点，取出的节点代表它执行完毕，可以被输出，同时将它指向的节点的入度减1，如果减到了0那么就代表它所有的依赖都执行了，因此可以放入队列中等待执行（输出）。</p>
<h4 id="深度优先">深度优先</h4>
<p>遍历所有节点，若节点未被访问则从该节点开始深度遍历。并将该节点状态设置为正在遍历中 1；当他的所有邻接子节点遍历完成后，再次回溯到这个节点时，将状态设置为 2 并将该节点入栈。 代表访问完成。而当该节点状态为 正在遍历中 并再次访问到它时 代表有环 直接退出，无拓扑排序。最后输出时将 栈 反序输出即可。这么做可以成立的原因是，因为 节点入栈实在回溯的时候完成的 因此对于有出度的节点 它入栈的顺序一定晚于 由该节点输出的子节点，符合拓扑排序的要求。</p>
<h2 id="最短路径">最短路径</h2>
<h3 id="深度广度优先遍历">深度/广度优先遍历</h3>
<p>这种方法耗时较长。初始 到其他节点的延时为无穷大。首先从初始节点出发，开始广度/深度优先遍历。判断是否将新的节点加入队列的方法是 <strong>当前延时小，则将该节点加入访问队列（递归节点）</strong>。这样可以防止有环的情况下 出现死循环。对于广度优先遍历的方法，注意不能用 入度数 是否递减到 0 来判断 是否停止 将其加入遍历，例如 4-&gt;1-&gt;2-&gt;3 4-&gt;2-&gt;3 若第一个路劲 为最短 ，但是 若用入度数递减为0判断是否加入遍历的条件，路径一会先到达3这样导致 2-&gt;3提前失效，就无法找到最短的路径一。</p>
<h3 id="迪杰斯特拉算法-dijkstra">迪杰斯特拉算法 Dijkstra</h3>
<p>特点： （参考链接: https://blog.csdn.net/qq_35644234/article/details/60870719）</p>
<ul>
<li>求<strong>单源最短路径</strong>，即求从一个点出发 到其他所有点的最短距离</li>
<li>只适用于非负权图</li>
<li>时间复杂度优秀</li>
<li>使用了贪心思想</li>
</ul>
<p>步骤：</p>
<ol type="1">
<li>初始化两个集合，一个已确定最短路径的节点为集合P， 未确定最短路的节点为集合Q。保存源节点 K 到每个节点的距离，若源节点和它无直接连接，初始化时距离为无穷大。将源节点K放入 P。</li>
<li>从Q中找一个 到 K 距离最短的节点 u, 因为距离权值都是正，而这个又最短，其他的无论怎么从 K 走到 u 都不如这个 K直接到 u 的近。因此将它放入P，代表已经确定。 （贪心思想）</li>
<li>上一步已经确定一个新的 最短路径的节点，这一步就要 确定 以 u 为出的 边所指向的 节点 v，是否能通过 u 缩短 K到v的距离。这一步叫松弛。此时 v 节点还是在Q中。</li>
<li>循环 2 开始 找新的 最短距离 节点 然后再用新的最短边 来松弛 节点。直到 Q 空。</li>
</ol>
<p><strong>核心思想</strong>：基于贪心的原则。每次取出从起点到某节点最短的距离，然后再以该节点为中心 区松弛更新起点到所有节点的距离。是一个 贪心+广度优先搜索的策略</p>
<p><strong>时间复杂度</strong>： O(E + NlogN) 使用优先队列优化后， 朝队列中插入复杂度为 O(N) N为节点数目。然后遍历所有节点最多 N log N , 但是其实还访问了一遍所有的边，所以加 E 为边的数量 访问边–&gt;取点-&gt;插入优先队列</p>
<h3 id="bellman-ford-算法">Bellman-Ford 算法</h3>
<p>Dijkstra算法要求边权为正数，但是这个方法不要求，并且可以用来判断负环路，就是如果图中成环且总和为负，那么在没有中转数限制下转的圈越多就越小到负无穷</p>
<p>该方法 基本思想是 遍历每个边 e(i, j) 如果 dist(st, j) = min( dist(st, i) + w(i, j) , dist(st, i)) 。根据连接情况初始化 dist , 第一次遍历所有边，完成之后，此时的最短距离其实其中的最短距离是 中转节点不超过 1 个 时的最短距离 （也可能没中转，取决于上述 min 表达式有没有松弛成功）。那么一共有 N个节点，所以最多需要要遍历所有边 N-1 次 即可求得确定的单源到所有节点的最短距离（不是负环图时）。</p>
<p>当然，图是稀疏连接的，那么不可能经过每个点都中转一次才能得到最短距离。因此在每次遍历完所有边之后如果此时的最短路径没有更新边可以退出了。</p>
<p>同理，借助这个原理，如果他是负环图，那么即便遍历N-1次后，最短距离依然可以更低。</p>
<p><strong>核心思想</strong>： 遍历所有的边，用边松弛当前最短距离。遍历的论数代表当前可能中转的最多节点数</p>
<p><strong>复杂度</strong>：O(NxE) N 为节点数，E为边的数目。</p>
<p><strong>如何记录最短距离对应的路径</strong>： 通过path数组来记录路径，path[i]=j表明节点 i 取得最小路径时，其最后一段走的是节点 j 到节点 i 。知道终点后，反向查找即可。例如求起点是 0 到 终点 5 的最短路径。path[ 5 ] = k 就是起点到5取最短路劲时 最后一段是 k -&gt;5 即 0 -&gt; k -&gt; 5 …..</p>
<h3 id="floyd算法">Floyd算法</h3>
<p>用于求任意两个节点之间的最短距离。</p>
<p>将上述两种算法套个循环即可完成所有点之间的最短距离</p>
<p>但是这里记录一下 dp 的思路 复杂度其实和 B-F算法加个循环一样</p>
<p>设 dp[k] [i] [j] 代表最多只能经过前 k 个节点中转时的最短路径 （就是可以经过 1,2,…k节点中的一个或者多个中转） dp[k] [i] [j] = min( dp[k-1] [i] [k] + dp[k-1] [k] [j] + w(i, j) , dp[k-1] [i] [j]) 从这个 转移方程可以看出，第一项就是 正好 以 节点 k 中转时的最短路径 ，后一项就是 k 节点能中转但是我不在这儿转的最短距离。因此如果 min 选择了前者，那么就代表在 k 节点中转，没选择，k节点就没中转。</p>
<p>所以最外层 依旧要遍历所有节点 复杂度和上面方法套个循环一样</p>
<h2 id="并查集">并查集</h2>
<h3 id="思想">思想</h3>
<p>并查集的重要思想在于，<strong>用集合中的一个元素代表集合</strong>。我曾看过一个有趣的比喻，把集合比喻成<strong>帮派</strong>，而代表元素则是<strong>帮主</strong>。接下来我们利用这个比喻，看看并查集是如何运作的。</p>
<p>对于一个给定的图 它有很多节点，但是部分节点是联通的，部分是不连通的。如何判断该图中有多少个联通区域呢。</p>
<ol type="1">
<li>初始每个节点自成一派，自己是自己的祖先 ，初始联通个数为节点数目</li>
<li>给定图中的一个边，首先判断该边的两个端点是否在一个集合中
<ul>
<li>如果不在一个集合中 说明 该边的存在会将 这两个端点合并成一个集合，因此联通个数-1，并将两个集合合并，合并的思路很简单，将他们附属在同一个祖先下即可</li>
<li>如果在一个集合中 返回false 说明这个边的存在不影响当前联通的个数</li>
</ul></li>
<li>这样遍历所有的边 最后就可以计算出联通图的个数</li>
</ol>
<h3 id="作用">作用</h3>
<p>并查集 简单来说有两个功能</p>
<ol type="1">
<li>查询两个集合是否相交<br />
</li>
<li>合并两个不相交的集合 需要合并所有节点</li>
</ol>
<p>他的查询和合并时间复杂度是相互约束的。如果所有相连的节点都挂在同一个祖先下，即树的深度只有1，那么查询的复杂度为1，但是合并的复杂度就为O(N)，（因为要将一个集合的所有节点的祖先重新设置）。也可以在合并时适当控制树的深度来平衡查询和合并的复杂度。</p>
<blockquote>
<p><strong>题目背景</strong> 若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。 <strong>题目描述</strong> 规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind1</span> <span class="title">implements</span> <span class="title">UF</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind1</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unionElements</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pID = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="keyword">int</span> qID = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="comment">//如果本身就是相连的</span></span><br><span class="line">        <span class="keyword">if</span> (qID == pID) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] == pID) &#123;</span><br><span class="line">                array[i] = qID;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小生成树">最小生成树</h3>
<p>最小生成树就是 一个图中，使它可以完全联通的最小边的权重和。这是并查集的一个典型应用</p>
<p><strong>思路</strong></p>
<ol type="1">
<li>将所有的边权从小到大排序</li>
<li>从小到达取边 首先判断边的两个端点是否属于同一个集合
<ul>
<li>如果是就不能使用该边，因为它的加入不会使联通数量减少，说明加入之后会使当已经加入的连接成环</li>
<li>如果不是，那么要合并这两个点对应的集合。同时这个边也是最小生成树中的一个边</li>
</ul></li>
<li>遍历</li>
</ol>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>基本数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-表</title>
    <url>/posts/4000/</url>
    <content><![CDATA[<p>数据结构之表，例如数组，哈希表，链表</p>
<span id="more"></span>
<h1 id="表">表</h1>
<h2 id="hash-表">hash 表</h2>
<p>数组+链表（通过映射函数将key值映射为不同的整数，之后存入该整数对应的链表）</p>
<p>数组的特点： <strong>寻址容易，插入和删除困难</strong></p>
<p>链表的特点： <strong>寻址困难，插入和删除容易</strong></p>
<h3 id="构造哈希">构造哈希</h3>
<ol type="1">
<li>直接地址法</li>
<li>平方取中法</li>
<li>除留余数法（根据余数将该hash键值存入对应的数组中, JVM中桶的大小位 2 的 幂次，用 按位与 来快速计算取模）</li>
</ol>
<h3 id="hash冲突">hash冲突</h3>
<p>关键字值不同的元素可能会映象到哈希表的同一地址上</p>
<ol type="1">
<li><strong>开放定址法</strong>（当发生地址冲突时，根据再寻址的方法（探查序列--线性探查 不断+1，伪随机探测--随机数法），去寻找下一个地址，若发生冲突再去寻找，直至找到一个为空的地址为止） 所有关键字都在位桶里</li>
<li><strong>再哈希法--再散列</strong>（当发生哈希冲突时使用另一个哈希函数计算地址值，直到冲突不再发生。这种方法<strong>不易产生聚集</strong>，但是<strong>增加计算时间</strong>，同时<strong>需要准备许多哈希函数</strong>）</li>
<li><strong>链地址法（</strong>将<strong>所有哈希值相同的Key通过链表存储，</strong>key 按顺序插入到链表中<strong>）</strong>冲突的关键字在位桶外的链表里</li>
<li><strong>建立公共溢出区</strong>等方法（采用一个溢出表处理产生冲突的关键字，在溢出表中再用其他方法处理冲突）SGL 版本使用链地址法，使用一个链表保持相同散列值的元素。虽然链地址法并不要求哈希桶长度必须为质数，但SGI STL 仍然以质数来设计哈希桶长度，并且将28 个质数（逐渐呈现大约两倍的关系）计算好，以备随时访问，同时提供一个函数，用来查询在这28 个质数之中，“最接近某数并大于某数”的质数。</li>
</ol>
<p>考点：哈希表 负载因子 rehash</p>
<p>C++的hash 表中有一个<strong>负载因子loadFactor</strong>，当<strong>loadFactor&lt;=1</strong> 时，hash 表查找的<strong>期望复杂度为O(1)</strong>. 因此，每次往hash 表中添加元素时，我们必须保证是在loadFactor &lt;1 的情况下，才能够添加。</p>
<p>因此，当Hash 表中loadFactor==1 时，Hash 就需要进行rehash。rehash 过程中，会模仿C++的vector 扩容方式，Hash 表中每次发现loadFactor ==1 时，就开辟一个原来桶数组的两倍空间，称为新桶数组，然后把原来的桶数组中元素全部重新哈希到新的桶数组中。</p>
<h2 id="deque">Deque</h2>
<p>是一种优化了的、对序列两端元素进行添加和删除操作的基本序列容器。它允许较为快速地随机访问，但它不像vector 把所有的对象保存在一块连续的内存块，而是采用多个连续的存储块，并且在一个映射结构中保存对这些块及其顺序的跟踪。</p>
<p>两端插入、删除为o(1)，遍历最差为o(N)</p>
<p>在 deque 中，随机存取任何元素都能在常数时间内完成（但速度慢于vector）。它相比于 vector 的优点是，vector 在头部删除或添加元素的速度很慢，在尾部添加元素的性能较好，而 deque 在头尾增删元素都具有较好的性能（大多数情况下都能在常数时间内完成）。</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>基本数据结构</category>
      </categories>
      <tags>
        <tag>表</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法思想汇总</title>
    <url>/posts/29875/</url>
    <content><![CDATA[<p>汇总了编程中常用的编程思想的原理，例如DFS，动态规划，回朔等</p>
<span id="more"></span>
<h1 id="算法思想汇总">算法思想汇总</h1>
<h2 id="广度深度优先搜索-bfsdfs">广度/深度优先搜索 BFS/DFS</h2>
<p>​ 广度优先搜索 是<a href="http://baike.baidu.com/view/3148644.htm">连通图</a>的一种<a href="http://baike.baidu.com/view/549585.htm">遍历</a>策略。因为它的思想是从一个顶点V0开始，辐射状地优先遍历其周围较广的区域 BFS同样属于盲目搜索。一般用队列数据结构来辅助实现BFS算法。</p>
<ol type="1">
<li>首先将根节点放入队列中。</li>
<li>从队列中取出第一个节点，并检验它是否为目标。如果找到目标，则结束搜寻并回传结果。否则将它所有尚未检验过的直接子节点加入队列中。</li>
<li>若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。</li>
<li>重复步骤2。</li>
</ol>
<figure>
<img src="https://i.loli.net/2021/03/28/mJ4GI6aciKLot9F.png" alt="" /><figcaption>1598357141189</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 广度优先搜索</span></span><br><span class="line"><span class="comment"> * @param Vs 起点</span></span><br><span class="line"><span class="comment"> * @param Vd 终点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(Node&amp; Vs, Node&amp; Vd)</span></span>&#123;</span><br><span class="line">	queue&lt;Node&gt; Q;</span><br><span class="line">	Node Vn, Vw;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//初始状态将起点放进队列Q</span></span><br><span class="line">	Q.<span class="built_in">push</span>(Vs);</span><br><span class="line">	<span class="built_in">hash</span>(Vw) = <span class="literal">true</span>;<span class="comment">//设置节点已经访问过了！</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())&#123;<span class="comment">//队列不为空，继续搜索！</span></span><br><span class="line">		<span class="comment">//取出队列的头Vn</span></span><br><span class="line">		Vn = Q.<span class="built_in">front</span>();</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//从队列中移除</span></span><br><span class="line">		Q.<span class="built_in">pop</span>();</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">while</span>(Vw = Vn通过某规则能够到达的节点)&#123;</span><br><span class="line">			<span class="keyword">if</span> (Vw == Vd)&#123;<span class="comment">//找到终点了！</span></span><br><span class="line">				<span class="comment">//把路径记录，这里没给出解法</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回</span></span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">isValid</span>(Vw) &amp;&amp; !visit[Vw])&#123;</span><br><span class="line">				<span class="comment">//Vw是一个合法的节点并且为白色节点</span></span><br><span class="line">				Q.<span class="built_in">push</span>(Vw);<span class="comment">//加入队列Q</span></span><br><span class="line">				<span class="built_in">hash</span>(Vw) = <span class="literal">true</span>;<span class="comment">//设置节点颜色</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//无解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​</p>
<h2 id="回溯">回溯</h2>
<h3 id="简介">简介</h3>
<p>Backtracking（回溯）属于 DFS</p>
<ul>
<li>回溯算法就是按照深度优先的顺序，穷举所有可能性的算法，但是回溯算法比暴力穷举法更高明的地方就是回溯算法可以随时判断当前状态是否符合问题的条件。一旦不符合条件，那么就退回到上一个状态，省去了继续往下探索的时间</li>
<li>优化剪枝策略，就是判断当前的分支树是否符合问题的条件，如果当前分支树不符合条件，那么就不再遍历这个分支里的所有路径。</li>
<li>启发式搜索策略指的是，给回溯法搜索子节点的顺序设定一个优先级，从该子节点往下遍历更有可能找到问题的解。</li>
<li>普通 DFS 主要用在 <strong>可达性问题</strong> ，这种问题只需要执行到特点的位置然后返回即可。</li>
<li>而 Backtracking 主要用于求解 <strong>排列组合</strong> 问题，例如有 { 'a','b','c' } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。</li>
</ul>
<p>​ 该页中 平洋大西洋水流问题 中解释中的，将他看作从四周到中间可达问题比较简单，但是自己第一次做的时候其实是用的回溯的思想做的，比较复杂。 因为 Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：</p>
<h3 id="步骤">步骤</h3>
<p>​ 回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。用回溯算法解决问题的一般步骤：</p>
<ol type="1">
<li><p>在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；</p></li>
<li><p>但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。</p></li>
</ol>
<h2 id="贪心算法">贪心算法</h2>
<p>​ 贪心算法，又名贪婪法，是寻找<strong>最优解问题</strong>的常用方法，这种方法模式一般将求解过程分成<strong>若干个步骤</strong>，但每个步骤都应用贪心原则，选取当前状态下<strong>最好/最优的选择</strong>（局部最有利的选择），并以此希望最后堆叠出的结果也是最好/最优的解。</p>
<ol type="1">
<li>从某个初始解出发；</li>
<li>采用迭代的过程，当可以向目标前进一步时，就根据局部最优策略，得到一部分解，缩小问题规模；</li>
<li>将所有解综合起来。</li>
</ol>
<h2 id="双指针">双指针</h2>
<p>​ 双指针 有 <strong>快慢指针</strong> 和 <strong>左右指针</strong> 。双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。</p>
<p><strong>快慢指针</strong> ： 般都初始化指向链表的头结点 head ，前进时快指针 fast 在前，慢指针 slow 在后。</p>
<ul>
<li>判定链表中是否含有环。从head出发， 快指针每次移动慢指针两倍的距离，二者相遇则有环，快指针先结束无环。</li>
<li>返回环的长度。相遇后，固定一个指针不懂，移动另一个到再次相遇 记录走过的步长 即为环的长度</li>
<li>返回环的起点。在刚才相遇的B点，将一个指针回归到起点，另一个还是在B点，然后二者以相同的速度移动，二者再次相遇的 点即为换的起点。具体证明可画图 理解。</li>
<li>返回链表的中点。类似上面的思路，让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。</li>
<li>寻找链表的倒数第 k 个元素。让快指针先走 k 步，然后快慢指针开始同速前进。当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点。</li>
</ul>
<p><strong>左右指针</strong>： 左右指针在数组中实际是指两个索引值，一般初始化为 left = 0, right = nums.length - 1。当数组提到有序时就应该想到双指针。</p>
<ul>
<li>二分查找，反转数组，两数之和…</li>
<li>滑动窗口算法 。滑窗的关键在于判断什么时候座指针收缩窗口，何时更新数据，合理的收缩窗口的方法可以大大简化代码。</li>
</ul>
<h3 id="二分查找">二分查找</h3>
<p>​ 二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法<strong>时间复杂度为 O(logN)</strong>。</p>
<p>​ <strong>m 计算</strong>： m = l + (h - l) / 2 ​ <strong>未成功查找的返回值</strong>：循环退出时如果仍然没有查找到 key，那么表示查找失败。可以有两种返回值。-1：以一个错误码表示没有查找到 key；l：将 key 插入到 nums 中的正确位置。 ​ <strong>变种</strong>：二分查找可以有很多变种，实现变种要注意边界值的判断。例如<strong>在一个有重复元素的数组中查找 key 的最左位置</strong>的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] &gt;= key) &#123;</span><br><span class="line">            h = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分治算法">分治算法</h2>
<p>​ 分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p>
<p>​ 适用的情况：</p>
<ol type="1">
<li>该问题的规模缩小到一定的程度就可以容易地解决</li>
<li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</li>
<li>利用该问题分解出的子问题的解可以合并为该问题的解；</li>
<li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</li>
</ol>
<p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，<strong>如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法</strong>。第四条特征涉及到分治法的效率，如果各子问题<strong>是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好</strong>。</p>
<p>​ 分治法在每一层递归上都有三个步骤：</p>
<ol type="1">
<li>分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</li>
<li>解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</li>
<li>合并：将各个子问题的解合并为原问题的解</li>
</ol>
<p>常见的例如 二分搜索，汉诺塔问题，归并排序，快速排序等都是使用分治的思想。</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>算法思想</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer</title>
    <url>/posts/26732/</url>
    <content><![CDATA[<p>记录了剑指offer中的题目，不会写的都在后面加了思路注释，重点复习不会写的就行</p>
<span id="more"></span>
<h2 id="数组与矩阵">数组与矩阵</h2>
<ul>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/3.%20数组中重复的数字.html">3. 数组中重复的数字</a><br />
</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/4.%20二维数组中的查找.html">4. 二维数组中的查找</a></li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/5.%20替换空格.html">5. 替换空格</a></li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/29.%20顺时针打印矩阵.html">29. 顺时针打印矩阵</a></li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/50.%20第一个只出现一次的字符位置.html">50. 第一个只出现一次的字符位置</a></li>
</ul>
<h2 id="栈队列堆">栈队列堆</h2>
<ul>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/9.%20用两个栈实现队列.html">9. 用两个栈实现队列</a><br />
</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/30.%20包含%20min%20函数的栈.html">30. 包含 min 函数的栈</a> no 栈的数据进出顺序逻辑的应用 例如 在栈低的较大的数一定后出，那么最大栈的顶端一定得是它</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/31.%20栈的压入、弹出序列.html">31. 栈的压入、弹出序列</a> no 模拟栈的push pop流程 重点在如何代码简化这个逻辑</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/40.%20最小的%20K%20个数.html">40. 最小的 K 个数</a> no 堆</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/41.1%20数据流中的中位数.html">41.1 数据流中的中位数</a> no 中位数 只关心中间大的那个数，因此只需要中位数左边序列最大的右边序列最小的即可，两个堆</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/41.2%20字符流中第一个不重复的字符.html">41.2 字符流中第一个不重复的字符</a><br />
</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/59.%20滑动窗口的最大值.html">59. 滑动窗口的最大值</a> no 和min函数栈很类似。同样从数据进出先后顺序的逻辑下手存储数据流中的最大值</li>
</ul>
<h2 id="双指针">双指针</h2>
<ul>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/57.1%20和为%20S%20的两个数字.html">57.1 和为 S 的两个数字</a></li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/57.2%20和为%20S%20的连续正数序列.html">57.2 和为 S 的连续正数序列</a> no 先想到暴力枚举，再想双指针优化</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/58.1%20翻转单词顺序列.html">58.1 翻转单词顺序列</a> no 面试不能用 split 那么就倒序用双指针确定每个单词的边界</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/58.2%20左旋转字符串.html">58.2 左旋转字符串</a></li>
</ul>
<h2 id="链表">链表</h2>
<ul>
<li><p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/6.%20从尾到头打印链表.html">6. 从尾到头打印链表</a></p></li>
<li><p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/18.1%20在%20O(1)%20时间内删除链表节点.html">18.1 在 O(1) 时间内删除链表节点</a></p></li>
<li><p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/18.2%20删除链表中重复的结点.html">18.2 删除链表中重复的结点</a></p></li>
<li><p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/22.%20链表中倒数第%20K%20个结点.html">22. 链表中倒数第 K 个结点</a> 快慢指针</p></li>
<li><p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/23.%20链表中环的入口结点.html">23. 链表中环的入口结点</a></p></li>
<li><p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/24.%20反转链表.html">24. 反转链表</a> 用递归做的关键思路是 清楚递归函数的意义。此题递归函数 输入为链表头，输出为反转后的新的链表头。</p>
<p>1-&gt;2-&gt;3-&gt;4 例如从 2 开始递归 那么 把2递归完毕后 1-&gt;2 null&lt;-3&lt;-4 并且返回的要是节点4；而2-&gt;3依然存在因此在递归完2以后需要把2接上3后面，然后把之前的递归的节点返。</p></li>
<li><p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/25.%20合并两个排序的链表.html">25. 合并两个排序的链表</a></p></li>
<li><p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/35.%20复杂链表的复制.html">35. 复杂链表的复制</a></p></li>
<li><p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/52.%20两个链表的第一个公共结点.html">52. 两个链表的第一个公共结点</a> a-&gt;b c-&gt;b b-&gt;d 的距离分别为 a,b,c 则 a+c+b = b+c+a 相遇即为公共节点。</p></li>
</ul>
<h2 id="树">树</h2>
<ul>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/7.%20重建二叉树.html">7. 重建二叉树</a></li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/8.%20二叉树的下一个结点.html">8. 二叉树的下一个结点</a> 按照中序遍历的规则 分情况讨论</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/26.%20树的子结构.html">26. 树的子结构</a> 递归</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/27.%20二叉树的镜像.html">27. 二叉树的镜像</a></li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/28.%20对称的二叉树.html">28. 对称的二叉树</a></li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/32.1%20从上往下打印二叉树.html">32.1 从上往下打印二叉树</a> 层序遍历 （BFS）</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/32.2%20把二叉树打印成多行.html">32.2 把二叉树打印成多行</a></li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/32.3%20按之字形顺序打印二叉树.html">32.3 按之字形顺序打印二叉树</a></li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/33.%20二叉搜索树的后序遍历序列.html">33. 二叉搜索树的后序遍历序列</a> 按照比较大小的方法递归 判断左右子树是否合法</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/34.%20二叉树中和为某一值的路径.html">34. 二叉树中和为某一值的路径</a></li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/36.%20二叉搜索树与双向链表.html">36. 二叉搜索树与双向链表</a> 官方的方法是 中序遍历一定是按照大小顺序遍历到搜索树的每个节点的 因此设置一个 pre cur指针来迭代的更改指向即可。还可以分支的思想 递归左子树 和右子树 分别得到左右两个循环链表 再加上中间节点重组成一个新的双向链表 但是这种方法逻辑比较复杂。</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/37.%20序列化二叉树.html">37. 序列化二叉树</a> 主要是 字符转分割操作 怎么用 stringstream</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/54.%20二叉查找树的第%20K%20个结点.html">54. 二叉查找树的第 K 个结点</a></li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/55.1%20二叉树的深度.html">55.1 二叉树的深度</a></li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/55.2%20平衡二叉树.html">55.2 平衡二叉树</a> 递归 要注意所有节点的左右子树高度差都得满足</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/68.%20树中两个节点的最低公共祖先.html">68. 树中两个节点的最低公共祖先</a> 这个题也是递归 但是套用递归的思路很巧妙。</li>
</ul>
<h2 id="贪心思想">贪心思想</h2>
<ul>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/14.%20剪绳子.html">14. 剪绳子</a> 贪心思想。</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/63.%20股票的最大利润.html">63. 股票的最大利润</a> 记录最低的买入价格，并尝试以当前价减去前面最低的买入价得到利润。遍历求最大利润即可。</li>
</ul>
<h2 id="二分查找">二分查找</h2>
<ul>
<li><p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/11.%20旋转数组的最小数字.html">11. 旋转数组的最小数字</a></p></li>
<li><p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/53.%20数字在排序数组中出现的次数.html">53. 数字在排序数组中出现的次数</a></p></li>
</ul>
<h2 id="分治">分治</h2>
<ul>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/16.%20数值的整数次方.html">16. 数值的整数次方</a> 递归</li>
</ul>
<h2 id="搜索">搜索</h2>
<ul>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/12.%20矩阵中的路径.html">12. 矩阵中的路径</a> DFS</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/13.%20机器人的运动范围.html">13. 机器人的运动范围</a> DFS BFS都可</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/38.%20字符串的排列.html">38. 字符串的排列</a> DFS 将每个字母轮换放在首位 然后递归剩下的字符串 注意相同字母去重</li>
</ul>
<h2 id="排序">排序</h2>
<ul>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/21.%20调整数组顺序使奇数位于偶数前面.html">21. 调整数组顺序使奇数位于偶数前面</a> 快慢指针 or 首尾对象指针</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/45.%20把数组排成最小的数.html">45. 把数组排成最小的数</a> 这道题关键是知道 字符串比较的 性质 例如 1991 &gt; 1199 是默认按照从高到底字符顺序比较的。那么在自己自定义 cmp 函数的时候 使用这个性质来快速 比较 两个字符串谁放前面。看谁放前面组合成新的字符串哪个小。或者自己写快排</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/51.%20数组中的逆序对.html">51. 数组中的逆序对</a> 归并排序 稍加改进即可 因为归并排序递归到最后就是比较两个数的大小，同时又由于 归并的时候左右两边的都是有序的 所以比较次数少。</li>
</ul>
<h2 id="动态规划">动态规划</h2>
<ul>
<li><p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/10.1%20斐波那契数列.html">10.1 斐波那契数列</a></p></li>
<li><p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/10.2%20矩形覆盖.html">10.2 矩形覆盖</a></p></li>
<li><p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/10.3%20跳台阶.html">10.3 跳台阶</a></p></li>
<li><p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/10.4%20变态跳台阶.html">10.4 变态跳台阶</a></p></li>
<li><p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/42.%20连续子数组的最大和.html">42. 连续子数组的最大和</a></p></li>
<li><p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/47.%20礼物的最大价值.html">47. 礼物的最大价值</a></p></li>
<li><p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/48.%20最长不含重复字符的子字符串.html">48. 最长不含重复字符的子字符串</a> 动态规划 or 双指针 动态规划 ！！！ 注意连续 这就和 子数组最大和设置dp的出发点相同了</p></li>
<li><p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/49.%20丑数.html">49. 丑数</a> 不能 试图 按着判断某个整数是不是丑数，会超时。因此要从递推的角度思考，第n个丑数 和 第 n-1个丑数的关系。第n个大的丑数一定是由 第n-1个丑数 x 2/3/5得来的 至于是乘的哪个 那肯定是选最小的喽。但是不是 dp[n] x 2/3/5 可能是 dp[i] x 2 dp[j] x3 … 以2/3/5，所以就要设置三个指针分别 记录。有点像 三个迈的步子分别为 1/3/5的三个人从同一个1的起点开始走。走的距离最短的人优先跳步…..</p></li>
<li><p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/60.%20n%20个骰子的点数.html">60. n 个骰子的点数</a> 状态转移方程很好想 n个筛子 点数 由 n-1个筛子时的点数 + 1 +2 … + 6 (注意判断边界)</p></li>
<li><p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/62.%20圆圈中最后剩下的数.html">62. 圆圈中最后剩下的数</a> 思考子问题 不要关注中间 怎么数 只关注 起始 和 结束</p></li>
</ul>
<h2 id="数学">数学</h2>
<ul>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/39.%20数组中出现次数超过一半的数字.html">39. 数组中出现次数超过一半的数字</a> 空间复杂度O(1) 时间复杂度O(N) 的方法 摩尔投票法</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/66.%20构建乘积数组.html">66. 构建乘积数组</a> 数学问题</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/43.%20从%201%20到%20n%20整数中%201%20出现的次数.html">43. 从 1 到 n 整数中 1 出现的次数</a> 题目别理解错了 是 所以的数字中 所有的1的个数，不是说统计含有1的数字的个数。因此思路就是分别统计个位/十位/…分别为1的个数，最后求和</li>
</ul>
<h2 id="位运算">位运算</h2>
<ul>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/15.%20二进制中%201%20的个数.html">15. 二进制中 1 的个数</a><br />
</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/56.%20数组中只出现一次的数字.html">56. 数组中只出现一次的数字</a> 异或的性质</li>
</ul>
<h2 id="其它">其它</h2>
<ul>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/17.%20打印从%201%20到最大的%20n%20位数.html">17. 打印从 1 到最大的 n 位数</a> 要考虑 越界 因此本质是全排列问题</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/19.%20正则表达式匹配.html">19. 正则表达式匹配</a> 太难了 待定</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/20.%20表示数值的字符串.html">20. 表示数值的字符串</a> 状态机 通过状态表实现 就是情况很多</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/44.%20数字序列中的某一位数字.html">44. 数字序列中的某一位数字</a> 找规律</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/46.%20把数字翻译成字符串.html">46. 把数字翻译成字符串</a> 动态规划</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/61.%20扑克牌顺子.html">61. 扑克牌顺子</a> 找规律</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/64.%20求%201+2+3+...+n.html">64. 求 1+2+3+...+n</a> 用 &amp;&amp; 代替 条件判断 （(true) &amp;&amp; (a+=b)）这种条件判断里也能使用+=</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/65.%20不用加减乘除做加法.html">65. 不用加减乘除做加法</a> 二进制加法 不进位和 = 异或 进位 = 与左移 另外要注意c++负数左移低位默认补1 所以要强转为无符号。</li>
<li><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/67.%20把字符串转换成整数.html">67. 把字符串转换成整数</a></li>
</ul>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>d. 智力题</title>
    <url>/posts/21718/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="有一个无限小数小数点后前两位是a和ba和b均不为0从第三位起是前两位之和取模10-这个小数是无限循环还是不循环还是不一定">有一个无限小数，小数点后前两位是a和b，a和b均不为0，从第三位起，是前两位之和取模10 这个小数是无限循环，还是不循环，还是不一定</h3>
<p>由于当前位数只由前两位决定，因此如果 第一次出现了 ab 然后后面又出现了ab 那么必然就循环了。而要对10取模，因此a b 的范围都0~9 两个连续字取值就10 x 10种情况，所以一定会循环。</p>
<h3 id="n中所有的数里面1出现的次数">1- n中所有的数里面1出现的次数</h3>
<p><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">剑指 Offer 43. 1～n 整数中 1 出现的次数</a></p>
<h3 id="个石子每次只能取1-8个问第一次取多少个能保证自己必赢">100个石子，每次只能取1-8个。问第一次取多少个能保证自己必赢</h3>
<p>将两个人取的总数看作一轮，每一轮先手最多拿走8个，因此后手总是可以保证这一轮两个人一共拿走9个。所以这样如果有99个石子，99/9=11个回合后，后手正好拿完所有的式子，因此先手拿一个一定可以赢</p>
<h3 id="斗地主中地主拿到王炸的概率是多少">斗地主中，地主拿到王炸的概率是多少</h3>
<p>这个就是很简单的排列组合问题。54张牌，可以考虑这种分配模型，将54张牌放一排，前17张农民1的，后17张农名2的，最后20张地主的，然后就是算大小王都在后20张的概率，可以看作把大小王放到 54 个位置中的两个，大小王不同，有序，所以A54/2 同理 A20/2</p>
<h3 id="如何精确测量计算不规则物体的表面积">如何精确测量（计算）不规则物体的表面积？</h3>
<p>热缩膜覆盖后撕开铺在格子纸上数格子</p>
<h3 id="海盗分金">海盗分金</h3>
<p>经济学上有个“海盗分金”模型,是说5个海盗抢得100枚金币,他们按抽签的顺序依次提方案：首先由1号提出分配方案,然后5人表决,超过半数同意方案才被通过,否则他将被扔入大海喂鲨鱼,依此类推. 假定“每人海盗都是绝顶聪明且很理智”,那么“第一个海盗提出怎样的分配方案才能够使自己的收益最大化?”</p>
<p>1，2，3，4，5 从后往前推，如果1-3号都死了，只有4，5号，那么5号一定不会给4号投票让4号也死这样自己就能占有所有硬币。因此4号直到5号的想法就会杜绝这种情况发生，因此它要无条件支持3号，避免只剩4，5两人的情况。3号也直到4号会无条件支持他，因此它只用 100 0 0 即可。2号也知道3号这么想的，所以3号必定不会支持2二号，因此它必须讨好2号让他俩同意它的方法，所以就 98 0 1 1 这样根据2号给出的方案4号5号都能拿到1块，比把2号淘汰后3的方案好，所以这样4和5号就会接受2号的方案。同理1号又知道2号这么想的，所以应该放弃2号，并且给3号4号和5号更多的利益，首先3号如果不投1号，到2号手里就只能得到0个硬币，所以1号只需给3号1个硬币即可让3号支持它，而4和5号如果让1号死了他们最多从中获得1个硬币，因此给他们两个硬币比之前多就可以。由于1号只需3 4 5 中取两个拿到票即可，因此4号和五号挑一个给两个硬币拉拢即可。</p>
<p>综上 一号的方案 97 0 1 2 0 或 97 0 1 0 2</p>
<h3 id="机器人挖矿问题">机器人挖矿问题</h3>
<p>一个机器人每天可以挖到8个硬币； 50个硬币可以换得一个机器人； 问：给您5个机器人，50个硬币，10天后，最多拥有多少硬币？</p>
<p><a href="https://blog.csdn.net/midi666/article/details/105230879">参考链接</a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法思想</category>
      </categories>
  </entry>
  <entry>
    <title>相关的编程题汇总-DFS/BFS</title>
    <url>/posts/13264/</url>
    <content><![CDATA[<p>记录了DFS/BFS相关的题目</p>
<span id="more"></span>
<h4 id="被围绕的区域">被围绕的区域</h4>
<figure>
<img src="https://i.loli.net/2021/03/28/4Fv9EmPOSTH1Bu7.png" alt="" /><figcaption>1598364256416</figcaption>
</figure>
<p>​ 这个题直接找被围绕的区域可能会超时，因为如果测试的矩阵很大，那么中间的元素很多。而直接从四周寻找和边界联通的点，那么可以减少计算量。可以使用广度优先搜索方法 从边界开始的 ‘O’开始 寻找与其联通的其他‘O’并将其一并标记为‘A’</p>
<h4 id="单词接龙"><a href="https://leetcode-cn.com/problems/word-ladder/">单词接龙</a></h4>
<p>​ 这个题思路不难，很容易想到要用广度优先遍历，寻找起点和终点的最短路径。但是，需要提前建图，再对图用广度优先遍历的方法去寻找起点到终点的最短路径。图以 邻接表的形式保存。但是这种方法有优化的空间。字符串传递 引用的形式传入，否则时间不够</p>
<h4 id="朋友圈"><a href="https://leetcode-cn.com/problems/friend-circles/">朋友圈</a></h4>
<p>​ 这个题 和上面不一样，<strong>朋友圈的模型 给定的就是一个图的邻接矩阵</strong>，然后要求这个图中的连通图的个数。这个题一种方法是并查集做 一种是 深度/广度优先遍历，每次遍历与当前节点连接的节点并标记。</p>
<h4 id="太平洋大西洋水流问题"><a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">太平洋大西洋水流问题</a></h4>
<p>​ 这个题 有两个关键点。<strong>一是 想到 从边缘向内部深度优先遍历，标记和边缘相连的点。二是 想到分步完成</strong>，记录两个表，分别表示和左上边缘（太平洋） 和 右下边缘（大西洋）相连的点。最后两个表都标记为1 的位置即为 既可以流向大西洋也可以流向太平洋的位置。 ​ 自己在做的时候 不仅没想到 应该从边缘 向内遍历的 方法，也没想到 先判断大西洋连接再判断太平洋连接的操作。直接把两种状态放在一起遍历，考虑得情况很多，很难理清，因为对于一个点向四个方向 分别由遍历得到的四种结果 连接大西洋/太平洋/都不连接/两个都连接。四种结果综合才能确定 当前点的状态，最后想到一个用两位数表示的方法 二进制 11 01 10 00 四个遍历方向 按位 或 == 11则表示该点同时连接 两个洋。虽然此法行得通，但是 每次遍历的状态 只有 11 的情况可以用来剪枝。这种想法其实 和 回溯比较类似。</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>DFS/BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>leecode_位运算</title>
    <url>/posts/39222/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="位运算类题目">位运算类题目</h2>
<p>位运算的题目，常规的思路就是异或为0的规律做。</p>
<h4 id="剑指-offer-56---ii.-数组中数字出现的次数-ii"><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h4>
<p>这个题很巧妙。一个数组中一个数字出现了 N 次，只有一个出现了1次，找出这个出现一次的数，可以知道，出现N次那么对应的位的和一定为N的倍数。对于所有元素的某一位，可能是 0 2N 3N 4N… 或着 1 2N+1 3N+1 …</p>
<h4 id="矩阵置零"><a href="https://leetcode-cn.com/problems/set-matrix-zeroes/">矩阵置零</a></h4>
<p>O(m+n) 的方法很好实现。主要是 O(1) 的方法。O(m+n) 的方法思路是设置一个标记数组，用于标记哪些行和列需要被置0，现在要求空间复杂度为O(1) 用到了原地标注的方法，如果数组中某个位置的元素为0，那么这一行列的数全要置0，因此反正都要设置为0的，可以将该行列标号先记下来，用作标记数组，即<strong>原地标记</strong>，最后其他的行列0都置完了 再对这行列清0。这个思想在 O(1) 的hash 方法中见过，题目给定的数组中元素都是正数，那么就可以用负数来作为标记，从而使得空间复杂度为O(1)</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>相关的编程题汇总-分治</title>
    <url>/posts/49674/</url>
    <content><![CDATA[<p>记录了分治算法类的题目，最常见的 快排，归并排序中都使用了分治的思想</p>
<span id="more"></span>
<h1 id="分治算法">分治算法</h1>
<h2 id="快速排序">快速排序</h2>
<p><strong>快速排序</strong>的核心思想是在待排序数组中选取一个 基准数据（原则上要尽量保证 基准数据正好是中位数，这里以常用的第一个元素作为基准数据，基准数据选的不好 算法的复杂度会达到O(n^2)，但是平均复杂度趋近O(N)）。首先以数组第一个元素为基准a，将大于a的元素都放在a的右边，小于的放在左边。再递归的在左右区间使用这种策略直至排序完成。具体的伪代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">randomPartition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">        <span class="built_in">swap</span>(a[i], a[r]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">partition</span>(a, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//双指针 划分 数组</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = a[r], i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt; r; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt;= x) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[++i], a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(a[i + <span class="number">1</span>], a[r]);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="求无序数组的第k大">求无序数组的第K大</h4>
<p>这个题 可以暴力的将数组先 排序 完后取出。但是不是最好方法，可以使用快速排序 （分治）的方法，取基准数 按照与基准数的大小关系将数组划分左右，后判断 基准数左边有几个大于它的元素，再分别选择对左边 或者右边 数组进行再一次的 快排，直到 正好找到第K个。 ​ 求K大问题除了使用快排之外，还可以使用 堆的 方法。</p>
<h4 id="颜色分类"><a href="https://leetcode-cn.com/problems/sort-colors/">颜色分类</a></h4>
<p>这个题 数组中其实 只有 0，1， 2 三种元素。不能使用额外的空间。最直观的想法是，先使用 基准元素 1 将数组划分为 左边的 0/1 右边的2，再设置基准为0前半部分 将0，1分开。这就是最朴素的 快排的思想。但是，因为只有三种元素，可以考虑 使用三个指针，一个指针移动负责遍历所有元素，一个左指针寻找0的最右边边界，一个右指针寻找2的最左边边界。当前指向的元素等于0就和左指针交换元素，并且滑动一个位置，同理。这就和快排中 将数组中元素根据 与基准数据的大小关系分堆类似。</p>
<h4 id="为运算表达式设计优先级"><a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/">为运算表达式设计优先级</a></h4>
<p>这个题很典型的分治 算法。将 运算符 看作 分隔点，每次计算运算符左边的 字符串表达的等式的值 和 右边的字符串表达的算式的值，最后 使用该运算符计算二者的 和/差/积 即为最终的一种结果。但是注意 左边字符串算出的 值 可能有多个 使用 vector 保存 右边的也是。所以计算的时候需要两个for循环。</p>
<h4 id="不同的二叉搜索树-ii"><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">不同的二叉搜索树 II</a></h4>
<p>首先 这个题 二叉搜索树的特点是 中序遍历输出的为有序 数组。所以 要将1~n的 数组还原为二叉搜索树，就是 选定根节点，然后 按照中序遍历的特点 分别递归的构建左右子树，也是分治的思想。要注意递归的停止边界条件。</p>
<h2 id="归并排序">归并排序</h2>
<h4 id="数组中的逆序对"><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">数组中的逆序对</a></h4>
<p>根据逆序对的定义，会想到 这个比较过程 可以通过归并排序的过程等效转换，因为归并过程中存在前半部分 和 后半部分比较的过程，且前半部分和后半部分都是有序的，因此速度快。</p>
<h4 id="小和问题"><a href="https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469?tpId=101&amp;tqId=33089&amp;tPage=1&amp;rp=1&amp;ru=%2Fta%2Fprogrammer-code-interview-guide&amp;tab=answerKey">小和问题</a></h4>
<h4 id="计算右侧小于当前元素的个数"><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">计算右侧小于当前元素的个数</a></h4>
<p>这个和逆序数问题很像，所以直接用归并排序的思路求解即可。</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>相关的编程题汇总-双指针</title>
    <url>/posts/58115/</url>
    <content><![CDATA[<p>记录了解题中双指针方法典型的题目，例如二分法中的首位指针，图的环判定中的快慢指针，滑窗方法等</p>
<span id="more"></span>
<h1 id="双指针">双指针</h1>
<h2 id="二分查找">二分查找</h2>
<p>二分查找问题中，有的问题可以很明显套用二分查找的思路，例如有序数组等。但是有的问题比较隐晦，例如<a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">在 D 天内送达包裹的能力</a> 最好的思路就是先按照暴力的方法找思路，如果了暴力可以做，再考虑是否可以二分优化，这种题的有序性就隐藏在了题的情景中，直接很难想到二分的思路。</p>
<h4 id="旋转数组的最小数字"><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">旋转数组的最小数字</a></h4>
<p><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">在 D 天内送达包裹的能力</a></p>
<p>这个题有点意思。看题目很难朝二分查找上想。但<strong>凡是能用二分查找的就能用暴力</strong>。所以这个题如果先用暴力想到就可以简单的换成二分法。可以想到的是 船的运载量越大，越可能完成运载任务，题目要求可以完成运载任务的最小运载量。如果已经给定一个运载量，那么可以很容易地判断在这个运载量下能否完成运输。贪心地思想，每趟尽可能的多运，如果最后一天还运不玩 那说明这个运载量少了，需要增加运载量。于是暴力搜索运载量的方法就产生了。那么如何转换成二分呢。<strong>起始运载量越大越可能完成这个隐藏条件就是二分查找有序的条件</strong>。最后就是确定二分查找的边界。很明显当运载量为总重时是 右边界，运载量还得大于单个货物的重量。</p>
<p><a href="https://mp.weixin.qq.com/s/o-1VJO2TQZjC5ROmV7CReA">切木头</a></p>
<p>这个题目和上面的题极为类似</p>
<h4 id="分割数组的最大值"><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">分割数组的最大值</a></h4>
<p>同上</p>
<h4 id="乘法表中第k小的数"><a href="https://leetcode-cn.com/problems/kth-smallest-number-in-multiplication-table/">乘法表中第k小的数</a></h4>
<p>这个题套路和上面的题一样。但是这个难想一点，题目要求是求 K 大的元素，直观的想法是从1 … k 统计 乘法表中1的元素数量，2的元素数量，3的元素数量，然后就想着找规律了，然后没找出来。实际换个思路，可以很容易计算出 表中 小于等于 x 的个数，为什么呢？只需遍历所有的行，对于第 i 行 [1i， 2xi, 3xi，4xi…nxi]，是个递增的，所以很容易知道该行小于 x 的元素个数 Min[x//i , n]。然后遍历所有行累加即可。知道了这个就可以 从 1 … nxm 遍历，判断表中 小于等于 x 的元素个数。x越大，表中小于他的元素就越多，由此可知 可以二分 。一共要搜索 log(mn)次，每次遍历表 m 行 时间复杂度为 O(mlogmn)</p>
<p><a href="https://leetcode-cn.com/problems/minimum-limit-of-balls-in-a-bag/">袋子里最少数目的球</a></p>
<p>和上面那个题一样的思路。但是在判断查找结果能否满足要求时 不能遍历。</p>
<h4 id="元素和小于等于阈值的正方形的最大边长"><a href="https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/">元素和小于等于阈值的正方形的最大边长</a></h4>
<p>和上面的思路也是一样 只不过要用到前缀和 加速计算任意矩形面积元素和</p>
<p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></p>
<p>直接能想到 根据归并中的思路，挨个合并。但是这样时间复杂度为 O(m + n) 题目要求复杂度为 O(log(m + n )) 这很明显要用二分搜索。有序的问题一般都能通过二分搜索解决。</p>
<h4 id="有序数组中的单一元素"><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">有序数组中的单一元素</a></h4>
<pre><code>    这个题要求时间复杂度为 O(logn) 则必须使用二分查找。这个题很有意思，给定数组中按照升序排列，找出单一的元素。这个题使用二分的关键在于 两个相同的元素相邻，根据 二分之后索引的奇数偶数来确定向前还是向后搜索。</code></pre>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328203040.png" alt="" /><figcaption>image-20200930204059711</figcaption>
</figure>
<h4 id="寻找旋转排序数组中的最小值"><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">寻找旋转排序数组中的最小值</a></h4>
<p>​ 二分法。这个题关键是找对比较对象，否则 特殊情况 不好处理。关键是 计算中值后都与右边的数比较 如果 mid &gt; right 说明需要调整左区间++ 如果 mid &lt; right 说明 mid 在右边，但是此时可能mid就是 最小值，所以 r = c; 而不减一。</p>
<h4 id="在排序数组中查找元素的第一个和最后一个位置"><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></h4>
<h4 id="寻找峰值"><a href="https://leetcode-cn.com/problems/find-peak-element/">寻找峰值</a></h4>
<p>第一个难点在于如何将该问题转化为 二分查找的方法去做，另一个难点在 怎么用代码实现二分查找，写的不对的话 边界情况很麻烦，但是框架写对了，就不需要处理边界情况</p>
<h2 id="滑动窗口">滑动窗口</h2>
<p><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">最长重复子数组</a></p>
<p><img src="https://pic.leetcode-cn.com/9ed48b9b51214a8bafffcad17356d438b4c969b4999623247278d23f1e43977f-%E9%94%99%E5%BC%80%E6%AF%94%E8%BE%83.gif" alt="错开比较.gif" style="zoom:50%;" /></p>
<p>这个题 用 动态规划做复杂度 O(M x N)。滑动窗口解法复杂度 O((M + N) x min(M, N))</p>
<h4 id="最小覆盖子串"><a href="https://leetcode-cn.com/problems/minimum-window-substring/">最小覆盖子串</a></h4>
<p>这是个 很典型的 用滑动窗口的方法。右指针增加用于 扩大 窗口，当窗口中覆盖了需要的所有字符后，左指针不断收缩窗口。</p>
<h4 id="找到字符串中所有字母异位词"><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a></h4>
<p>这道题典型的使用双指针的方法来实现滑动窗口。初始两个指针都在起点，然后右指针滑动向右，和左指针构成一个滑窗。</p>
<h2 id="首尾指针">首尾指针</h2>
<p>和二分查找相同的是，这种题目也是根据有序的条件收缩 首位指针，去掉无用的搜索。因此对于简单的题目，可能题中有明显的有序的条件。但是有的比较隐晦。</p>
<h4 id="盛最多水的容器"><a href="https://leetcode-cn.com/problems/container-with-most-water/">盛最多水的容器</a></h4>
<p>这是典型的双指针的题目。和二分法类似，但是二分查找有明显的排序条件在其中，总之都是根据一定的条件收缩指针。</p>
<h2 id="其他">其他</h2>
<h4 id="递增的三元子序列"><a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/">递增的三元子序列</a></h4>
<h4 id="有效三角形的个数"><a href="https://leetcode-cn.com/problems/valid-triangle-number/">有效三角形的个数</a></h4>
<p>同样的 暴力 N^3 超时。因此可以通过手动排序的方法降低复杂度。排序一下子就想到了 但是没想到优化，排序后自然而然就要想到双指针优化，使得复杂度降低为 N^2 ，固定一个最大的边，然后使用双指针去搜索另外两个小的边</p>
<h4 id="最小区间"><a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/">最小区间</a></h4>
<p>这个题可以看作一个典型的多指针解决的问题。有多个递增的序列 首先就应该想到双指针 二分之类的思路。我当时就是想到了二分法，以一个数组为基准遍历里面的每个元素，然后去其他数组中搜索离它最近的元素，这样每个数组都能找到一个最近的，将这几个最近的合并成完整的区间即可。但是这样是错的，因为最近的元素可能会有左右两个 例如 4 9 中搜索5，离他最近的是4，但是就一定是选4嘛？不一定，因为还要看其他区间，也有可能选9，所以要考虑左右相邻的合并问题，没有想到很好的解决方法</p>
<p>标准答案是 使用多指针。由于需要在每个数组中都找一个对应的，那么就都取数组的第一个，一共K个元素使用小顶堆维护，并找到最大值，最小值到最大值即为一个区间。然后就是指针的移动条件，每次移动小顶堆中最小的那个指针。即一个区间头指针一个尾指针，数组递增，移动头指针肯定越移动区间长度越大，所以只能移动尾指针。如此动态更新。</p>
<p>另一个解法应该想到的。换个思路，将数组中的元素看作 a b c…. 的编号，然后将所有数组依序合并成一个新的递增序列 然后使用滑窗 保证窗中至少覆盖一个 a b c 即可。就转换为最小覆盖子串的问题了。</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>双指针</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>相关的编程题汇总-回朔</title>
    <url>/posts/56789/</url>
    <content><![CDATA[<p>记录了回朔类的题目，常见的 八皇后问题，排列组合等</p>
<span id="more"></span>
<h4 id="复原ip地址"><a href="https://leetcode-cn.com/problems/restore-ip-addresses/">复原IP地址</a></h4>
<h4 id="全排列-ii"><a href="https://leetcode-cn.com/problems/permutations-ii/">全排列 II</a></h4>
<p>​ 使用 swap 的方法全排列 去重的关键在于两点 一是和首元素相同的 不再swap 而是swap过的元素不再swap</p>
<h4 id="组合总和"><a href="https://leetcode-cn.com/problems/combination-sum/">组合总和</a></h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; re;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, vector&lt;<span class="keyword">int</span>&gt;&amp; se, <span class="keyword">int</span> tg, <span class="keyword">int</span> sel)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tg == <span class="number">0</span>)&#123;</span><br><span class="line">            re.<span class="built_in">push_back</span>(se);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sel; i &lt; candidates.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tg &lt; candidates[i])  <span class="keyword">continue</span>;</span><br><span class="line">            se.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, se, tg - candidates[i], i);   <span class="comment">////  i  关键  第一次 取 i 了之后  后面取的第二个 第三个...数 都只能从 第i 以及 i 之后开始取  比如 第一次取得第 2个数  那么第二次 就只能在 第二个 以及 第二个之后的数中取，因为 第二次再取第一个数的话 ，就 和 第一次取的第一个的情况重复</span></span><br><span class="line">            se.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, tmp, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="组合总和-ii"><a href="https://leetcode-cn.com/problems/combination-sum-ii/">组合总和 II</a></h4>
<p>​ 相对上一个题 去重的关键是 要 先 排序 相同的元素在一起 ，才方便去重。</p>
<h4 id="划分为k个相等的子集"><a href="https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/">划分为k个相等的子集</a></h4>
<p>暴力回朔，问题在于要 先排序 并且将大的放前面才不会超时。</p>
<h4 id="子集"><a href="https://leetcode-cn.com/problems/subsets/">子集</a></h4>
<p>思路：对于每个位置的元素 由选和不选两种情况，选的话，就 push_back到缓存数组中，然后从下一个元素递归。如果不选当前元素，就要pop出来，再对从下一个元素递归。同理下一个元素也有选和不选两种状态。最终结束的标志就是 遍历完整个数组长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; re;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> sel, vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">int</span>&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sel &gt;= nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            re.<span class="built_in">push_back</span>(ans);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">               </span><br><span class="line">        ans.<span class="built_in">push_back</span>(nums[sel]);</span><br><span class="line">        <span class="built_in">dfs</span>(sel+<span class="number">1</span>, nums, ans);</span><br><span class="line">        ans.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(sel+<span class="number">1</span>, nums, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, nums, ans);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="括号生成"><a href="https://leetcode-cn.com/problems/generate-parentheses/">括号生成</a></h4>
<p>和上面的题很类似，就通过回朔的方法，枚举当前位置是 左括号 or 右括号，分别进行递归。但是要满足有效的条件，就额外增加条件约束，即 只有左括号数量大于右括号的数量的时候才能再添加右括号，当左括号数量大于整体数量一半的时候 不能再添加左括号。</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>回朔</tag>
      </tags>
  </entry>
  <entry>
    <title>相关的编程题汇总-数学思想</title>
    <url>/posts/18579/</url>
    <content><![CDATA[<p>记录了解题中需要用数学思想的题目，这类题目规律最多样。</p>
<span id="more"></span>
<h2 id="数学">数学</h2>
<h4 id="用-rand7-实现-rand10"><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/">用 Rand7() 实现 Rand10()</a></h4>
<p>这个题有意思。第一次做很容易想到 rand 用两次然后相加得到1-14范围…这种操作就不是均匀分布了，类似扔筛子。这道题的解法是，将 执行两次 rand7 得到x y 坐标。然后映射。类似 如果 x 坐标和 y坐标是均匀分布，那么x,y构成的格点都是均匀分布的，这样就能得到7*7=49个格点，我们只要ran10 因此可以只用前40个 （对10取余即可）如果不是前40个点，则再投一次坐标（<strong>拒绝采样</strong>）。当然可以优化，剩下多的8个点其实可以看做 rand8 然后 和 rand7 再组成一个坐标网格….以此重复，使得丢弃的数少，运行效率就高。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328203006.png" alt="" /><figcaption>image-20210315221237407</figcaption>
</figure>
<p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/39.%20数组中出现次数超过一半的数字.html">39. 数组中出现次数超过一半的数字</a></p>
<p><a href="http://www.cyc2018.xyz/算法/剑指%20Offer%20题解/66.%20构建乘积数组.html">66. 构建乘积数组</a></p>
<h4 id="打乱数组"><a href="https://leetcode-cn.com/problems/shuffle-an-array/">打乱数组</a></h4>
<p>这个题 主要的思路是 如何用 一定的操作规则 模拟 打乱的情景。数组的排列有n!种 那么如何保证等概率的输出一种排序呢？就相当于把数组所有元素放进盒子里，然后无放回抽取出，按抽出的先后顺序即为….</p>
<h4 id="阶乘后的零"><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/">阶乘后的零</a></h4>
<p>这个题 要找规律。首先 阶乘后的0的个数，阶乘后的0能怎么来呢？ 例如 1x2x3x4x5x6… 这时候组合一下 1x3x4x6x(2x5) 很明显 10=2x5 所以 就是找结成中有多少个 2x5 的组合 即可。而 2 是每两次至少出现一次 5 大一些 显然出现的次数少 所以就是找有多少个5 像 但是 25 可以算 5x5 75=15x5=3x5x5 可以算有两个5 所以简单的 5 等间隔取肯定是不够的</p>
<p>1 2 3 4 5x1 6 7 8 9 5x2 11 12 13 14 5x3 …. n n/5 之后相当于 获得了 (5x1 5x2 5x3…. 5x5 5x6… 5xn/5) / 5 = 1 2 3 4 … n/5 所以说 n/5之后 又变成了 求 n/5前面有多少个5的问题了。</p>
<h4 id="字符串相乘"><a href="https://leetcode-cn.com/problems/multiply-strings/">字符串相乘</a></h4>
<p>使用 字符串 模拟 竖式乘法 呗；类似的还有 字符串加法的题目….</p>
<h4 id="灯泡开关"><a href="https://leetcode-cn.com/problems/bulb-switcher/">灯泡开关</a></h4>
<p>这个题 以看 测试的 n 10^9 的级别，就肯定是数学找规律的问题。通过归纳总结也能找到规律吧。但是理性分析的话 也是很容易得出结论的。对于第 n 个灯泡的状态，能改变它的只有它的只有 它的 因数轮，例如 36 能被 1 2 3 4 6 | 6 9 12 18 36 注意除了中间的 6 只有一个，其他的都是成对出现了，这就说明 如果 n 恰好能被完全开平方，那么状态切换一定是奇数次，然后第 n 个状态就是亮的，否则如果不能被完全开平方，例如 24 = 1 2 3 8 12 24 因数一定是偶数个，最后第24个状态就是灭的状态，同时24轮及其以后都碰不到它了。所以….</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>典型算法-KMP算法</title>
    <url>/posts/24455/</url>
    <content><![CDATA[<p>详细记录了 KMP 算法的原理，KPM算法是一种字符串匹配算法，可以在 O(n+m) 的时间复杂度内实现两个字符串的匹配。</p>
<span id="more"></span>
<h1 id="kmp-算法">KMP 算法</h1>
<p>KMP算法是一种<strong>字符串匹配</strong>算法，可以在 O(n+m) 的时间复杂度内实现两个字符串的匹配。如下图所示，字符串匹配就是从主串中搜索是否存在模式串。字符串匹配是一个非常频繁的任务。例如，今有一份名单，你急切地想知道自己在不在名单上；又如，假设你拿到了一份文献，你希望快速地找到某个关键字（keyword）所在的章节……凡此种种，不胜枚举。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328211045.png" alt="" /><figcaption>image-20210328211045841</figcaption>
</figure>
<h2 id="暴力-brute-force">暴力 Brute-Force</h2>
<p>首先想到的就是 暴力搜索，从最开始对齐比较 如果不相同，将模式串往后移动一位再去和主串对应位置的子串比较….直到找到。但是显然这样比较的复杂度为O(n*(m-n+1)) n 为主串的长度，m为子串的长度。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328212909.png" alt="" /><figcaption>image-20210328212909725</figcaption>
</figure>
<p>暴力的方法很慢，那么有没有优化的方法了。暴力方法中每次 没匹配上 都是往后移动一格，然后接着比较，这样比较的趟数很多，完全没有用到上一次比较失败的教训。<strong>尽可能利用残余的信息，是KMP算法的思想所在</strong>。上面的例子中在匹配 algor 全对上了，但是最后一个a没有匹配上，按照暴力的逻辑 可能就往后滑动一个 再接着配。但是我们可以明显看出 algor 这几个字母如果错位，就不可能再配上，所以完全可以从 i 去比较，可以直接跳过主串中algor这几个字母。再例如下面的例子：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328213445.png" alt="" /><figcaption>image-20210328213445574</figcaption>
</figure>
<p>还是在 最后一个 d 处对不上，但是已经比较了 abcab 这一段，这一段模式串和主串是对的上的，根据这个已知信息 按照直觉逻辑，这次可以跳到ab试试，因为可以保证 模式串中已经比较过的 ab 和 主串中的部分对的上，而且 比较过的这一段中 存在首ab 和 尾ab相同。一句话总结 <strong>我们在已经比较并确定对齐的模式串的主串abcab后，我们移动的准则是 从abcab中 找到 模式串的首ab 和主串的尾ab对齐的位置，再往后就是主串之前没比过的位置就接着比</strong> 。这是KMP算法的核心了。</p>
<h2 id="kmp原理">KMP原理</h2>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328215038.png" alt="" /><figcaption>image-20210328215038322</figcaption>
</figure>
<p>如上图所示，绿色部分是成功匹配，失配于红色部分。深绿色手绘线条标出了相等的前缀和后缀，<strong>其长度为next[右端]</strong>. 由于手绘线条部分的字符是一样的，所以直接把前面那条移到后面那条的位置。因此说，<strong>next数组为我们如何移动标尺提供了依据</strong>。</p>
<h2 id="pmt表">PMT表</h2>
<p>上述 ab … ab 这样首位相同的结构，叫做前缀和后缀。（也叫 next 数组 即 PMT表）</p>
<p>如果字符串A和B，存在A=BS，其中S是任意的非空字符串，那就称B为A的前缀。例如，”Harry”的前缀包括{”H”, ”Ha”, ”Har”, ”Harr”}，我们把所有前缀组成的集合，称为字符串的前缀集合。同样可以定义后缀A=SB， 其中S是任意的非空字符串，那就称B为A的后缀，例如，”Potter”的后缀包括{”otter”, ”tter”, ”ter”, ”er”, ”r”}，然后把所有后缀组成的集合，称为字符串的后缀集合。要注意的是，字符串本身并不是自己的后缀。</p>
<p>如果一个字符串长度为N 那么PMT表的长度就为N 定义为：<strong>PMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度</strong>。例如 对于字符串”ababa”，它的前缀集合为{”a”, ”ab”, ”aba”, ”abab”}，它的后缀集合为{”baba”, ”aba”, ”ba”, ”a”}， 两个集合的交集为{”a”, ”aba”}，其中最长的元素为”aba”，长度为3。</p>
<h2 id="构建next数组">构建next数组</h2>
<p>next数组是 针对模式串的。next数组的定义：</p>
<ul>
<li>定义 “k-前缀” 为一个字符串的前 k 个字符； “k-后缀” 为一个字符串的后 k 个字符。k 必须小于字符串长度。</li>
<li>next[x] 定义为： P[0]~P[x] 这一段字符串，使得<strong>k-前缀恰等于k-后缀</strong>的最大的k.</li>
</ul>
<p>用动态规划的思路思考，如果已知 next[0] next[1] next[2] … next[x] 要求 next[x+1]呢？首先，已经知道了 next[x-1]（以下记为now）。</p>
<ol type="1">
<li>如果 P[x] 与 P[now] 一样 (图中的是不相等的情况) 最长相等前后缀的长度就可以扩展一位，很明显 next[x] = now + 1。</li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328220456.png" alt="" /><figcaption>image-20210328220458845</figcaption>
</figure>
<ol start="2" type="1">
<li>P[x] 与 P[now] 不一样 。如上图 不能直接+1，因此，我们应该<strong>缩短这个now</strong>。 但是还是可以知道字串A == 字串B（这是由next[x]确定已知的），后面要新增一个 c 所以这个 c 肯定要用上，那么我们希望从 字串 B 的尾巴（后缀集合）中找一段 假设为 C ， 和字串A 的前缀中找一段 假设为 E 满足 C + ‘c’ == E，把 E 拆开为 E1 + 字符n ，又字串A == 字串B，这不就等于在子串 A 中 找相等的最大前缀C和后缀E （回到了next的定义 即为next[now - 1] ），然后再判断‘c’ 是否等于字符n。综上：
<ul>
<li>now = next[ now - 1]</li>
<li>再判断 p[x] == p[now] 是否成立，成立就是 next[now - 1] + 1 否则循环</li>
</ul></li>
</ol>
<h2 id="代码">代码</h2>
<figure>
<img src="https://pic1.zhimg.com/v2-010a582b0c92a92044c43a2a2ea88928_r.jpg?source=1940ef5c" alt="" /><figcaption>preview</figcaption>
</figure>
<figure>
<img src="https://pic2.zhimg.com/80/v2-a6bd81af7cf9bbda32b2cfb0e4858276_1440w.jpg?source=1940ef5c" alt="" /><figcaption>img</figcaption>
</figure>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>经典算法</category>
      </categories>
      <tags>
        <tag>典型算法</tag>
        <tag>KMP算法</tag>
      </tags>
  </entry>
  <entry>
    <title>相关的编程题汇总-贪心算法</title>
    <url>/posts/54399/</url>
    <content><![CDATA[<p>记录了解题中需要用贪心思路的题目。</p>
<span id="more"></span>
<h1 id="贪心思想">贪心思想</h1>
<p>这类题目往往都 有 排序？</p>
<h4 id="根据身高重建队列"><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">根据身高重建队列</a></h4>
<p>这道题的关键是 先对队列按照高到低的顺序排序，当高度相同时，多的在后面。这样从前往后挨个调整得时候，前面元素得移动只可能是往前诺，不会对后面的产生影响。后面的元素插入前面 也不会对已经插入过的影响，因为后面的身高低。</p>
<h4 id="加油站"><a href="https://leetcode-cn.com/problems/gas-station/">加油站</a></h4>
<p>这道题使用 两个for循环遍历 也不会超时 时间复杂度是 O(N^2) 但是这样并不好。首先选一个 起点0运行 通过累加 油量 和 损耗量，到第 N 站如果 油量 &gt; 损耗 说明无法到达，<strong>将起点修改为第N+1站作为新的开始</strong> 这里不是从0到1挨个 作为起点测试。因为，如果在第N站 油不够了 而前N站都够，那么油量&gt;=消耗量，那么在这之中选择一个起点 油量=消耗=0 必然到第N站还是不够，所以起点直接选 N+1开始新的测试。</p>
<h4 id="最低加油次数"><a href="https://leetcode-cn.com/problems/minimum-number-of-refueling-stops/">最低加油次数</a></h4>
<p>当时看到这个题后 觉得和跳台阶有点像，但是其实底层逻辑完全不一样。跳台阶是 每个位置的数字代表能像前跳的最大步数，但是上一次的最大步数如果没用完，不能累加使用，可以在当前位置展望跳到下一个位置能够到达的最远距离。但是这个题目的油是可以累计的，因此再按照上面的贪心逻辑就不对了。</p>
<h4 id="无重叠区间"><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">无重叠区间</a></h4>
<p>​ <img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328203056.png" alt="image-20200926211802074" /></p>
<p>​ 这个题和 <a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">用最少数量的箭引爆气球</a> 题目类似。 ​ 首先 对区间的end位置 升序排列，如图所示，从上往下 依次寻找找没有交集且最邻近的 区间，直至结束。那么总数就是可以剩下的最大区间数。为何 这么做就是对的呢？考虑以下 例如从上往下 扫面的过程中， 第0个只和 第1，2 相交，那么 1，2相互也必定重叠。这三个必删掉 两个，删掉哪两个呢？若保留1或者2，那么不能保证 1或者2下面没有区间和它相交，但是保留1，则可以保证就没有其他的再可能与1相交。所以 应该删掉1，2.这也是一种贪心的思想。从上往下扫描，删掉与其相交的 区间。 ​ 但是按照上面思路去写代码 正确性有保证，但是并没有完全利用到里面的规律 会有冗余的 循环。 ​ 再接着 想，从上往下扫面，如果 遇到一个与其相交的 就跳过（代表删除了）再接着往下扫描直到遇到以一个与当前区间不相交的区间，此时将该区间的尾部坐标更新，再接着往下扫面。每次遇到不相交的区间计数加一 统计 总共不相交的区间数量即可。这样取第0个区间的时候 并没有依次遍历完下面所有与第0个区间相交的区间，但是任然可行。因为如果 x(0)(1) &lt; x(3)(0) 即第0，3区间不相交 而 若 x(0)(1) &gt; x(n)(0) 即 第 0 n区间也相交。那么x(3)(1) &gt; x(3)(0) &gt; x(n)(0) 即第3，n区间也必然相交。这样 即便在第0个区间的时候没扫描并删除第n个区间，但是在 切换到第三个区间并往下扫描的时候 也可以将n 删除。</p>
<h4 id="划分字母区间"><a href="https://leetcode-cn.com/problems/partition-labels/">划分字母区间</a></h4>
<p>这个题的 关键就是 寻找 字母结束的最大位置，当 遍历到 第 i 个 字母时 i == end 则可以作为一个分割点</p>
<h4 id="最大交换"><a href="https://leetcode-cn.com/problems/maximum-swap/">最大交换</a></h4>
<p>在做题的时候 要首先理解清楚题目的意思，然后尽可能用简单的模型来描述 完成题目要求，而不是在边界情况都还想不清楚的时候，就下手用可能的方法解题。例如本题 一读题目就 感觉应该可以用单调栈写。其实本质就是求 高位 左边最大<strong>且 靠后</strong> 的数交换。用单调栈很难一下想到 且靠后 这种边界情况。</p>
<p>对于查找某个位置 一侧比他大的最大的最远/最近的数，像数字和字符，找它某一侧最大的数字的位置，可以不用</p>
<h4 id="有效的括号字符串"><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/">有效的括号字符串</a></h4>
<p>这个题也可以使用两个栈做。但是贪心的方法更简单。对于不含有 星号 的问题，只需要累计左右括号的相对数量，如果始终是左括号数大于等于右括号数，并且最终左括号数等于右括号数，那么代表有效。如果有星号，当星号作为左括号时，左括号数可以为 x+1, 当它为右括号时，左括号数可以为 x - 1，所以当前位置的左括号数量累计为一个区间 [l_down, l_up] ，每次遇到 星号，l_down–，r_up++，当 l_down == 0 时，代表前面的左括号数最少为0个，此时再遇到星号，星号就不能再作为右括号了，因此 l_down 限制为0；当 左括号的最大上限 &lt; 0 时，代表即便前面所有的星号都用做左括号，也无法保证左括号数大于等于右括号数。</p>
<p>最终如果最少的左括号数大于0，表明星号即便全作为右括号，也不够抵消所有的左括号，返回 false</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Rabin-Karp算法</title>
    <url>/posts/53181/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="子字符串查找-rabin-karp算法">子字符串查找 ——Rabin-Karp算法</h1>
<p>求字符串的连续子串，如果传统的散列法复杂度很高。而Rabin-Karp算法的思路是 将字符串每个 字符 a~z 看作 0~25 组成的 26 进制的数。并且在计算 每个位置长度 为 n 的连续子串的散列值时 可以使用 除留余法 方式 将散列的复杂度降低为 O(1)</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210711114504.png" alt="" /><figcaption>image-20210711114457000</figcaption>
</figure>
<h3 id="例题">例题</h3>
<h4 id="最长重复子串"><a href="https://leetcode-cn.com/problems/longest-duplicate-substring/">最长重复子串</a></h4>
<p>这个题也可以用 动态规划做，dp 设置为 字符串1 前 i 个 和 字符串2 前 j 个的子串的最长后缀长度。通过 两层遍历即可完成。</p>
<p>但是使用 二分查找 + hash 法 复杂度会更低（前提是 hash 使用Rabin-Karp算法散列，保证散列的复杂度为O(1)）</p>
<p><a href="https://www.jianshu.com/p/24895aca0459">参考链接</a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>经典算法</category>
      </categories>
  </entry>
  <entry>
    <title>二分匹配</title>
    <url>/posts/53642/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="二分匹配">二分匹配</h1>
<h2 id="匈牙利算法">匈牙利算法</h2>
<p><a href="https://zhuanlan.zhihu.com/p/96229700">参考链接</a></p>
<p>主要就是 能划分为 二分图，集合0中的元素之间不会有匹配关系，它只会和集合1中的元素有匹配关系，可能一对一一对多。同理集合2中的元素也是</p>
<p>常用的套路是 按照 奇偶 位置划分二分集合。</p>
<h3 id="算法思路">算法思路</h3>
<p>首先 依次从左边集合中选出一个元素 和 右边集合中的元素匹配。如果右边集合中某个元素已经被占用了，那么根据它指向的左边集合中的元素号，递归的去调整它，以给当前元素腾位置。如果能腾出来，那么成功。否则返回false 算法实现的关键在于 一个记录 右边 到左边 的数组序号的映射关系，和 右边序号的访问情况。</p>
<p>算法时间复杂度，O(ExV) V为左边集合顶点的数目，E为图中的边数。每次去左边的一个顶点去和右边集合的顶点匹配，最坏情况就是把图中所有的边都遍历一遍才能找到可以匹配的结果。</p>
<p><a href="https://www.nowcoder.com/practice/b9eae162e02f4f928eac37d7699b352e?tpId=37&amp;&amp;tqId=21251&amp;rp=1&amp;ru=/ta/huawei&amp;qru=/ta/huawei/question-ranking">例题</a></p>
<h3 id="代码">代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> M, N;            <span class="comment">//M, N分别表示左、右侧集合的元素数量</span></span><br><span class="line"><span class="keyword">int</span> Map[MAXM][MAXN]; <span class="comment">//邻接矩阵存图</span></span><br><span class="line"><span class="keyword">int</span> p[MAXN];         <span class="comment">//记录当前右侧元素所对应的左侧元素</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];      <span class="comment">//记录右侧元素是否已被访问过</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">        <span class="keyword">if</span> (Map[i][j] &amp;&amp; !vis[j]) <span class="comment">//有边且未访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            vis[j] = <span class="literal">true</span>;                 <span class="comment">//记录状态为访问过</span></span><br><span class="line">            <span class="keyword">if</span> (p[j] == <span class="number">0</span> || <span class="built_in">match</span>(p[j])) <span class="comment">//如果暂无匹配，或者原来匹配的左侧元素可以找到新的匹配</span></span><br><span class="line">            &#123;</span><br><span class="line">                p[j] = i;    <span class="comment">//当前左侧元素成为当前右侧元素的新匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//返回匹配成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//循环结束，仍未找到匹配，返回匹配失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hungarian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis)); <span class="comment">//重置vis数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">match</span>(i))</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="km算法">KM算法</h2>
<p>KM 算法是解决带权值的 二分匹配问题</p>
<p><a href="https://blog.csdn.net/sixdaycoder/article/details/47720471">参考链接</a></p>
<h3 id="算法实现原理">算法实现原理</h3>
<p>基本原理也是依靠匈牙利算法，但是每个边都带了权重，因此思想是 取当前的最大子图 然后按照匈牙利算法去寻找完美匹配，如果无法实现完备匹配 就需要扩充最大子图。</p>
<p>通俗的算法原理：集合A中的1个元素都可以和B中的多个元素匹配，但是由于只能择其一，所以就选和B中匹配得分最大的边 联通，同理所有A中的点都这样筛选边，这样如果 A中的所有元素都和B中的有匹配（即实现完备匹配），那么此时图的匹配权重一定是最大。此时这就可以转化为匈牙利算法去搜索有无完备匹配。</p>
<p>如果没有实现完备匹配，那一定是有 n 个点 n-1 个边之间出现冲突。所以直观的应该放宽选取可匹配边的权重标准 让新的权重较小的边也加入图中，再尝试是否可以完备匹配，如果此时可以完备匹配 那么起始最终匹配的权重和相对初始的最大子图的完备匹配后的权重和（但是无法实现） 是 略微缩小的。KM算法就是通过一定的策略完成 扩充子图 -&gt; 完备匹配 这个循环的，并保证 子图的权重 一定是 从初始最大 -&gt; 小递减的 中间没有跳跃，所以最后匹配的权重和最大</p>
<ul>
<li>寻找相等子图的完备匹配</li>
</ul>
<h3 id="实现步骤">实现步骤</h3>
<ol type="1">
<li>初始化可行顶标的值 (设定lx,ly的初始值)</li>
<li>用匈牙利算法寻找相等子图的完备匹配</li>
<li>若未找到增广路则修改可行顶标的值</li>
<li>重复(2)(3)直到找到相等子图的完备匹配为止</li>
</ol>
<p>实现子图扩充最优 要 按照两个原则来实现：</p>
<ul>
<li>可行顶标</li>
<li>可行边，顶点的定标和 等于 边的权重 为一个可行边 可以加入相等子图中</li>
</ul>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>经典算法</category>
      </categories>
  </entry>
  <entry>
    <title>典型算法-排序算法</title>
    <url>/posts/10121/</url>
    <content><![CDATA[<p>整理、对比了常用的排序算法，插入排序，快速排序….</p>
<span id="more"></span>
<h1 id="排序算法">排序算法</h1>
<h2 id="各种排序算法概述">各种排序算法概述</h2>
<figure>
<img src="https://i.loli.net/2021/03/28/2TKAQ1MtRfIrZSh.png" alt="" /><figcaption>image-20201116223456289</figcaption>
</figure>
<p>https://www.cnblogs.com/onepixel/articles/7674659.html</p>
<ul>
<li>插入排序：平均时间复杂度O(n^2) 两层循环，外循环从第二个数开始，起始认为第一个元素是有序的，每个外循环就是将当前指向的元素插入到前面已排好序的序列中。因此还需要一个内循环来完成当前外循环指向的待插入元素与前面已排好序的每个元素逐一比较寻找插入点。每次寻找插入点的过程是这样实现空间O(1)的： 待插入元素和它卡面相邻的比较，比他还大就不用比了，他就在这儿不动，如果比他小，和他交换位置，再接着往前比，直到遇到比它小的元素为止。因此整个插入过程是不断和相邻位置交换的。</li>
<li>选择排序：就是每次循环遍历序列，记录当前序列中最小的元素，将其放到序列首；再从剩余序列中寻找最小的放第二个…. 因此两个循环 。在数组实现中，空间O(n) ，不稳定 例如 5 3 5 2 第一趟选择出最小的2 和 首元素 5 交换，破坏了两个5原本的顺序，所以是不稳定排序。如果用链表就是稳定排序。</li>
<li>冒泡排序：从第一个元开始比较和他右边相邻的元素的大小，前大后小就交换，否则不动，接着第二个和第三个比，交换….直到最后一个。这样第一趟中，一定会把序列中最大的元素交换到最后。第二次冒泡就只用比较到倒数第二个元素就结束。即序列后面是拍好序的。循环执行，直到所有有序。由于每次都是相邻比较交换，所以是稳定排序。两层循环 O(n^2)</li>
<li>希尔排序：第一个时间复杂度突破O(n^2)的算法。思想是，先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序。每趟排序，根据对应的增量ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序（按照增量大小，间隔增量的元素划分为一个组）。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。这么设计算法的原因是，考虑到原始的插入排序中，当最小的元素在最后时，往前插入，要从尾比到头，循环一轮，很浪费时间。这样分组，起始组间间隔较大，可以大步长的将较小的元素调换到靠前的位置。因此 不是相邻交换元素了，是不稳定排序，时间复杂度 O(n^1.3)</li>
<li>堆排序：利用了小顶堆这个数据结构。堆是完全二叉树，因此用数组存储，首先将数组所有元素堆化（构造大顶堆），这样数组第一个元素是序列中最大的。然后将数组首元素和最后一个元素交换（即将最大的元素放到了数组最后面），因为交换了顺序，此时不满足堆的性质了，因此接着将前n-1个元素堆化，再将首元素和倒数第二个交换….循环直到堆里只剩一个元素。时间复杂度O(nlogn)，涉及到首位交换元素，不稳定排序，空间复杂度O(1)</li>
<li>快速排序：快速排序的思想是，每次从序列中选择一个基准数据，然后将比他小的数放他左边，大的放右边。这样再递归的对它左边子序列和右边子序列执行上述过程的快排。分组的过程是这样的，使用双指针，默认每次选取序列第一个元素为基准元素，初始数据遍历指针和数据存储指针都指向基准后的元素，遍历其后每个元素，如果小于基准数据，就和数据存储指针指向的数据交换，在将数据存储指针自增，每时刻，数据滑动指针总在存储指针之后的。由于这个分组过程也不是相邻元素互换了，所以是不稳定排序。空间复杂度是因为递归需要额外数据保留空间 O(nlogn)</li>
<li>归并排序：和快排一样也是用了分治的思想。递归函数作用是将数组指定区间变为有序。因此函数中，先对左半部分递归归并，使得左半部分序列有序，再对右半部分递归，使得右半部分有序，最后归并，将两部分有序的序列合并，使用双指针的方法，合并时需要一个辅助数组，因此空间复杂度O(N)，涉及到二分法所以时间复杂度O(NlogN) 同时 归并递归到最底层就是相邻两个元素的比较，所以是稳定排序。</li>
<li>计数排序：计数排序只能对正整数排序。首先要确定数组中最大最小元素，来确定分配多大的内存。然后遍历一次数组，每个数据放到其对应下标的备用数组中。遍历完后，再遍历备用数组的每个位置，将对应位置的元素一次输出，即可。所有都是O(n+k)</li>
<li>桶排序：首先根据一定的函数映射关系，例如均匀映射，将数组中 的元素分配到N个桶中，再对桶中元素执行插入排序，最后将桶所有元素拼接。这个和计数排序类似，只不过计数排序的分桶映射方式是 数据 和 数组下标直接对应，因此计数排序只能应用于数据分布范围小的整数，而桶排序不限于此。</li>
<li>基数排序：基数排序的思想是，对整数的每个位 逐位排序。先找出最大元素的位数，循环，先根据个位数的值对所有元素排序，拍完之后对于只有一位的元素，就完成排序；接着根据元素十位的值对剩下元素进行计数排序，对于只有两位数的元素也排序完成…..O(N*k) K为位数。每一位的排序是一个计数排序 为 N。</li>
</ul>
<h2 id="快排">快排</h2>
<ul>
<li>快排相对 堆排序 而言 局部性更好，因为快排比较的都是相邻的元素，更方便利用缓存，而堆排序比较的两个元素之间可能距离很远，局部性不好。</li>
<li>快排相对归并排序空间复杂度更低，归并Nlog(N) 快排 log(N)</li>
</ul>
<p>所以快排实际用的最多</p>
<p><strong>快速排序</strong>的核心思想是在待排序数组中选取一个 基准数据（原则上要尽量保证 基准数据正好是中位数，这里以常用的第一个元素作为基准数据，基准数据选的不好 算法的复杂度会达到O(n^2)，但是平均复杂度趋近O(N)）。首先以数组第一个元素为基准a，将大于a的元素都放在a的右边，小于的放在左边。再递归的在左右区间使用这种策略直至排序完成。具体的伪代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lf, <span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lf &gt;= rt || rt &lt; <span class="number">0</span>)    <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> base = nums[lf];</span><br><span class="line">        <span class="keyword">int</span> pl = lf+<span class="number">1</span>, pr = lf+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pr &lt;= rt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[pr] &lt; base)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[pr], nums[pl++]);</span><br><span class="line">            &#125;</span><br><span class="line">            pr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[lf], nums[pl<span class="number">-1</span>]);  <span class="comment">// 这一步很关键 要将比较的基准数字最后切换到中间，然后再递归它的左边和右边部分</span></span><br><span class="line">        <span class="built_in">partition</span>(nums, lf, pl<span class="number">-2</span>);</span><br><span class="line">        <span class="built_in">partition</span>(nums, pl, rt);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">partition</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序">堆排序</h2>
<p>堆排序的要点</p>
<ul>
<li>连续数组存储，对于每个节点 i 它的 左 / 右 节点的下标 2 x i + 1 / 2 x i + 2</li>
<li>建立堆的时候，每次从最底下非叶子节点开始 向上判断 节点是否大于子节点的值，若不是 和较大的节点交换值，然后再递归的调整叶子节点。因此可以看作是两个循环</li>
<li>构建好大堆之后，每次将堆顶的元素和最后一个元素交换，然后将堆顶元素下沉淀，然后将数组长度减一接着交换…</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/// 从 节点 i 开始调整，调整完毕后 （调整的数组长度为 i） 可以保证 i 节点及其以下的部分是 满足要求的堆</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjMaxHeap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> len, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>((i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span> &lt; len)&#123;</span><br><span class="line">            <span class="keyword">int</span> lf = (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rt = lf + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> max_idx = i;  <span class="comment">// 当前节点，左右子节点，取值较大的点的序号</span></span><br><span class="line">            <span class="keyword">if</span>(lf &lt; len &amp;&amp; nums[lf] &gt; nums[max_idx])  max_idx = lf;</span><br><span class="line">            <span class="keyword">if</span>(rt &lt; len &amp;&amp; nums[rt] &gt; nums[max_idx])  max_idx = rt;</span><br><span class="line">		  </span><br><span class="line">            <span class="built_in">swap</span>(nums[max_idx], nums[i]);</span><br><span class="line">			</span><br><span class="line">            <span class="keyword">if</span>(max_idx == i)  <span class="comment">//如果未在该节点处未发生调整，可以直接推出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span>             <span class="comment">//如果未在该节点处发生调整，还要往下递归的调整</span></span><br><span class="line">                i = max_idx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 构建堆，第一次构建大堆时，要从最底层的节点开始向上 不断调用 adjMaxHeap 调整 </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="built_in">adjMaxHeap</span>(nums, len, i);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; nums[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 对于已经构建好的大堆，每次将堆顶的最大元素 调换到素组后端，然后将堆顶元素重新下沉，因为只修改了堆顶元素，所以直接从堆顶开始不断向下调整即可。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortMaxHeap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="built_in">buildMaxHeap</span>(nums);</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = len<span class="number">-1</span>; l &gt; <span class="number">0</span>; l--)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[l], nums[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">adjMaxHeap</span>(nums, l, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">sortMaxHeap</span>(nums);</span><br><span class="line">       <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="桶排序">桶排序</h2>
<p>桶排序的原理是，设置 m 个桶，桶是有序的，首先将 n 个待排序数分别放到对应的桶里，然后再分别对桶里的元素进行排序。假设桶内的元素使用 快排，复杂度是 O(nlogn)，那么桶排序的复杂度为 O(N + M X (N / M) X log(N/M)) = O(N + Nlog(N / M))，当桶的数量接近于数组的长度时，复杂度接近O(N)，因此对于数据分布均匀的数组，采用桶排序效果较好。桶排序的缺点是空间复杂度高，且实际数据并不是接近均匀的情况，因此效果一般。</p>
<h3 id="典型的例题">典型的例题</h3>
<h4 id="最大间距"><a href="https://leetcode-cn.com/problems/maximum-gap/">最大间距</a></h4>
<p>自己一开始做的时候，想到了用桶排序，但是把题目要求的空间复杂度看成常数的空间复杂度，感觉桶排序不满足。那如果是要求线性空间复杂度为啥不找出最大最小值，然后用Hash标记一下某个元素是否存在，然后枚举呢。当时也是没一下子想到桶排序的抽屉原理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minVal = *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> maxVal = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> d = <span class="built_in">max</span>(<span class="number">1</span>, (maxVal - minVal) / (n - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> bucketSize = (maxVal - minVal) / d + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">bucket</span>(bucketSize, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;);  <span class="comment">// 存储 (桶内最小值，桶内最大值) 对，(-1, -1) 表示该桶是空的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = (nums[i] - minVal) / d;</span><br><span class="line">            <span class="keyword">if</span> (bucket[idx].first == <span class="number">-1</span>) &#123;</span><br><span class="line">                bucket[idx].first = bucket[idx].second = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bucket[idx].first = <span class="built_in">min</span>(bucket[idx].first, nums[i]);</span><br><span class="line">                bucket[idx].second = <span class="built_in">max</span>(bucket[idx].second, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket[i].first == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="number">-1</span>) &#123;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, bucket[i].first - bucket[prev].second);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="存在重复元素-iii"><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/">存在重复元素 III</a></h4>
<p>涉及到 区间 的问题，都可以考虑使用桶排序 加速计算。首先看到这个题能想到暴力的解法。遍历数组每个元素，判断它和它前 面K个数的差的绝对值，如果小于等于t 则找到满足要求的数，返回true，否则继续。但是这样的时间复杂度为 O(kN)。如何优化呢，可以将这个题抽象为：</p>
<p>对某个数 x ，如何快速的在它前 k 个窗口数组中 找到 存在一个在 [x-t, x+t] 区间的数。</p>
<p>如果在和前K个元素比较大小的时候，前K个元素的时有序的，那么我们就能通过二分查找的方式快读确定理K最近的数。那么时间复杂度就能降低到 O(NlogK) 。这个不难实现，通过有序集合即可，有序集合的底层是红黑数，它的插入和删除时间复杂度都为 logN 维护一个滑窗。考虑 通过 有序集合的二分查找通过函数 <code>lower_bound</code>来获取其中第一个大于等于 x 的元素，但是我们题目的要求是找到 x - t ~x + t 的元素， 如果没找到，只能代表有序数组中的所有数都小于 x 但是不一定小于 x - t 所以还得从有序数组的最后往前遍历寻找，这样还是间接遍历了。所以应该松弛的去查找，当我们希望判断滑动窗口中是否存在某个数 y 落在区间[x−t,x+t] 中，只需要判断滑动窗口中所有大于等于 x−t 的元素中的最小元素是否小于等于 x + t 即可。</p>
<p>还是刚才的思路，我们用有序的数据结构降低了区间查找的 时间复杂度，涉及到区间查找的问题，我们很容易想到桶排序的抽屉原理，如果 一个桶的尺寸是 t+1 那么同一个桶里的元素一定满足上面的要求，如果不在一个桶里，那么可能在相邻的桶里，但是这个不一定，一定满足，所以需要提出相邻桶的元素单独计算二者的差值。因为这个题是滑窗问题，数组的元素数量是有限的，就算数据大小是无穷大，我们也不必创建一个巨大的数组，用 桶号做哈希表的键值即可，这样桶就是稀疏的。这个题的另一个难点是，如何将 正负都有的元素，分桶，对于负数的桶号计算要加小心。<a href="https://leetcode-cn.com/problems/contains-duplicate-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-dlnv/">这个文章对桶id计算解释的比较好</a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>经典算法</category>
      </categories>
      <tags>
        <tag>典型算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>多缓冲多线程代码阅读笔记</title>
    <url>/posts/33505/</url>
    <content><![CDATA[<p>详细阅读了别人项目中的图像预处理pip line 的工程实现，使用到了多缓冲，多线程等知识点。</p>
<span id="more"></span>
<p>注意： 代码中所有的 拷贝构造和 赋值构造都没实现，因此应该避免使用它的场合。例如多线程类，不能使用值传递的方式 (重载 () 的方法)。</p>
<p><code>algorithm.h</code> 文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ALGORITH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALGORITH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////预处理方法////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">预处理方法使用 工厂模式，当要新增预处理方法时，</span></span><br><span class="line"><span class="comment">    1. 需要 继承 AbstractAlgorithm 类，并实现 run 函数，</span></span><br><span class="line"><span class="comment">    2. 在 AlgorithmFactory 中新增算法 id 和 实例化代码</span></span><br><span class="line"><span class="comment">图像预处理的算法参数在 创建对应算法类对象的时候传入类，由 param 保存</span></span><br><span class="line"><span class="comment">模板 T 代表 图像数据类型 例如 cv::Mat 测试的时候使用简单的 string 测试的。 </span></span><br><span class="line"><span class="comment">P 为算法参数的类型 默认 void* 指针。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> P&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractAlgorithm</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="built_in">AbstractAlgorithm</span>(): <span class="built_in">time</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">AbstractAlgorithm</span>(P p): <span class="built_in">param</span>(p), <span class="built_in">time</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">AbstractAlgorithm</span>(P p, <span class="keyword">int</span> t): <span class="built_in">param</span>(p), <span class="built_in">time</span>(t)&#123;&#125;;</span><br><span class="line">        <span class="built_in">AbstractAlgorithm</span>(<span class="keyword">const</span> AbstractAlgorithm&amp; alg) = <span class="keyword">delete</span>;</span><br><span class="line">        AbstractAlgorithm&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> AbstractAlgorithm&amp; alg) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getRunTime</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> time;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> T <span class="title">run</span><span class="params">(T&amp; input)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Delay</span><span class="params">()</span></span>&#123; </span><br><span class="line">            <span class="keyword">clock_t</span> now = <span class="built_in">clock</span>(); </span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">clock</span>()-now &lt; time); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> time;</span><br><span class="line">        P param;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> P&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqReadAlgorithm</span>:</span> <span class="keyword">public</span> AbstractAlgorithm&lt;T, P&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> frame_cnt = <span class="number">0</span>;</span><br><span class="line">        vector&lt;T&gt; data_buff;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">SeqReadAlgorithm</span>(P p): AbstractAlgorithm&lt;T, P&gt;(p, <span class="number">5</span>)&#123;</span><br><span class="line">            frame_cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++)</span><br><span class="line">                data_buff.<span class="built_in">push_back</span>(<span class="string">&quot;frame: &quot;</span> + std::<span class="built_in">to_string</span>(i) + <span class="string">&quot; param: &quot;</span> + (<span class="keyword">char</span>*)<span class="keyword">this</span>-&gt;param);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function">T <span class="title">run</span><span class="params">(T&amp; input)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(frame_cnt &gt;= <span class="number">500</span>)  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">Delay</span>();</span><br><span class="line">            T ans = data_buff[frame_cnt++];</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> P&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnhanceAlgorithm</span>:</span> <span class="keyword">public</span> AbstractAlgorithm&lt;T,P&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">EnhanceAlgorithm</span>(P p): AbstractAlgorithm&lt;T,P&gt;(p, <span class="number">5</span>)&#123;&#125;;</span><br><span class="line">        <span class="function">T <span class="title">run</span><span class="params">(T&amp; input)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">Delay</span>();</span><br><span class="line">            T ans = input + <span class="string">&quot; Enhancement&quot;</span> + <span class="string">&quot; param: &quot;</span> + <span class="built_in">to_string</span>(*(<span class="keyword">int</span>*)<span class="keyword">this</span>-&gt;param);</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> P&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DenoiseAlgorithm</span>:</span> <span class="keyword">public</span> AbstractAlgorithm&lt;T,P&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">DenoiseAlgorithm</span>(P p): AbstractAlgorithm&lt;T,P&gt;(p,<span class="number">5</span>)&#123;&#125;;</span><br><span class="line">        <span class="function">T <span class="title">run</span><span class="params">(T&amp; input)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">Delay</span>();</span><br><span class="line">            T ans = input + <span class="string">&quot; Denoise&quot;</span> + <span class="string">&quot; param: &quot;</span> + <span class="built_in">to_string</span>(*(<span class="keyword">float</span>*)<span class="keyword">this</span>-&gt;param);</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> P&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlgorithmFactory</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">AlgorithmFactory</span>()&#123;&#125;;</span><br><span class="line">        AbstractAlgorithm&lt;T, P&gt;* createAlgorim(int type, P parma)&#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (type)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SeqReadAlgorithm&lt;T,P&gt;(parma);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> EnhanceAlgorithm&lt;T,P&gt;(parma);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> DenoiseAlgorithm&lt;T,P&gt;(parma);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>safeQueue.h</code> 文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SAFE_QUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAFE_QUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// ////////////////////////// 线程安全的数据队列 /////////////////////////////</span></span><br><span class="line"><span class="comment">// 只是简单的实现了线程安全的队列，可以优化的地方很多  例如缓冲区数据满后 自动休眠，取数据空后自动休眠</span></span><br><span class="line"><span class="comment">// T 是队列数据类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeMatList</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SafeMatList</span>(<span class="keyword">int</span> sz): <span class="built_in">max_sz</span>(sz)&#123;&#125;;</span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>; </span><br><span class="line">        T ans = m_queue.<span class="built_in">front</span>();</span><br><span class="line">        m_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushItem</span><span class="params">(T&amp; data)</span></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>; </span><br><span class="line">        m_queue.<span class="built_in">push</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>; </span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>() &gt;= max_sz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>; </span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>() &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> max_sz;</span><br><span class="line">    std::queue&lt;T&gt; m_queue;</span><br><span class="line">    std::mutex mtx_; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>prepocessThread.h</code> 文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PREPOCESS_THREAD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREPOCESS_THREAD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;safeQueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;algorithm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////使用多线程类对预处理算法包装////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将多个图像预处理算法封装在一个线程类中，按照穿行的方式执行这些算法。新增算法也无须修改该类的代码</span></span><br><span class="line"><span class="comment">类中有三个主要的数据结构，一个是 封装的预处理算法 基类指针 数组，一个是待处理图像队列，另一个是处理就绪的队列指针；</span></span><br><span class="line"><span class="comment">在 run 函数中首先从 待处理队列中获取一个图像，然后串行调用预处理算法，将最后一个算法生成的结果保存在就绪队列中。</span></span><br><span class="line"><span class="comment">由于一个系统中可能有多个多种预处理算法，例如图像去噪，增强，矫正等，每种算法耗时不同，如果每个算法一个线程，对于耗时很短的算法，</span></span><br><span class="line"><span class="comment">会常常在休眠和运行态切换，带来不必要的系统开销，因此我们采用分组多线的形式，即使用一个线程类包装一个或多个算法，尽可能使得每个</span></span><br><span class="line"><span class="comment">线程组的算法运行总耗时接近。</span></span><br><span class="line"><span class="comment">由于线程类对象的构建采用一个单例的生成器构建，使用这个单例生成器首先将算法id列表划分为多个算法组，并实例化线程类，每个线程类包装</span></span><br><span class="line"><span class="comment">一个算法组，实例化的所有线程类都由这个生成器统一管理。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> P&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstrctThreadAlg</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vector&lt;AbstractAlgorithm&lt;T, P&gt;*&gt; list_algs;</span><br><span class="line">        SafeMatList&lt;T&gt;* m_pFinishQueue;</span><br><span class="line">        <span class="comment">// 构造函数 给数据缓冲区分分配内存</span></span><br><span class="line">        <span class="built_in">AbstrctThreadAlg</span>(<span class="keyword">int</span> sz, SafeMatList&lt;T&gt;* pre_queue): <span class="built_in">m_pReadyQueue</span>(pre_queue)&#123;</span><br><span class="line">            m_pFinishQueue = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(sz &gt; <span class="number">0</span>)</span><br><span class="line">                m_pFinishQueue = <span class="keyword">new</span> SafeMatList&lt;T&gt;(sz);</span><br><span class="line">        &#125; </span><br><span class="line">        ~<span class="built_in">AbstrctThreadAlg</span>()&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list_algs.<span class="built_in">size</span>(); i++) <span class="keyword">delete</span> list_algs[i];</span><br><span class="line">            <span class="keyword">if</span>(m_pFinishQueue != <span class="literal">nullptr</span>)   <span class="keyword">delete</span> m_pFinishQueue;</span><br><span class="line">            m_pFinishQueue = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">AbstrctThreadAlg</span>(<span class="keyword">const</span> AbstrctThreadAlg&amp; threadAlg) = <span class="keyword">delete</span>;</span><br><span class="line">        AbstrctThreadAlg&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> AbstrctThreadAlg&amp; threadAlg) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果 输入数据缓冲队列指针为 空，则不读数据，这就需要列表的第一个 alg 为读图的程序</span></span><br><span class="line">            <span class="keyword">if</span>(!m_pReadyQueue)  cout &lt;&lt; <span class="string">&quot;This thread does&#x27;t have input data queue!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// 如果 输出数据缓冲队列指针为 空，则不往缓冲区中存储数据</span></span><br><span class="line">            <span class="keyword">if</span>(!m_pFinishQueue)  cout &lt;&lt; <span class="string">&quot;This thread does&#x27;t have out data queue!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                T input_data;</span><br><span class="line">                <span class="comment">// 输入缓冲区数据空，就等待，直到取出数据</span></span><br><span class="line">                <span class="keyword">if</span>(m_pReadyQueue)&#123;  </span><br><span class="line">                    <span class="keyword">while</span>(m_pReadyQueue-&gt;<span class="built_in">empty</span>());</span><br><span class="line">                    input_data = std::<span class="built_in">move</span>(m_pReadyQueue-&gt;<span class="built_in">getItem</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 串行执行该线程中的算法</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it : list_algs)</span><br><span class="line">                    input_data = std::<span class="built_in">move</span>(it-&gt;<span class="built_in">run</span>(input_data));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 输出缓冲区数据满了 就等待，直到有存储的位置</span></span><br><span class="line">                <span class="keyword">if</span>(m_pFinishQueue)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(m_pFinishQueue-&gt;<span class="built_in">full</span>());</span><br><span class="line">                    m_pFinishQueue-&gt;<span class="built_in">pushItem</span>(input_data);</span><br><span class="line">                &#125;        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        SafeMatList&lt;T&gt;* m_pReadyQueue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程类的生成器  新增算法时 不需要修改该部分代码，不过可以考虑。这个类默认的算法参数是  void* 类型，以下方面可以优化</span></span><br><span class="line"><span class="comment">1. 优化build函数，使用均衡分组方法，保证每个线程上的任务耗时接近</span></span><br><span class="line"><span class="comment">2. 优化 模板类 使得 算法参数类型 不一定非得是 void* 类型  （现在的做法是在 算法函数中 将 void* 指针强转）</span></span><br><span class="line"><span class="comment">3. ...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrepocessTaskSingleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    ~<span class="built_in">PrepocessTaskSingleton</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;alg : m_pThreadAlgs)    <span class="keyword">delete</span> alg;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/* 增加  用到的预处理算法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_Algorm</span><span class="params">(<span class="keyword">int</span> alg_id, <span class="keyword">void</span>* p)</span></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        alg_pairs.<span class="built_in">push_back</span>(&#123;alg_id, (<span class="keyword">void</span>*)(p)&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/* 设置 某个线程的队列大小 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDataSize</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= thread_num) <span class="keyword">return</span>;</span><br><span class="line">        data_size[i] = n;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/* 获取 某个线程的队列大小 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDataSize</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= thread_num) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> data_size[i];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/* 获取 某个线程的结果队列地址 */</span></span><br><span class="line">    <span class="function">SafeMatList&lt;T&gt;* <span class="title">getResultQueue</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m_pThreadAlgs.<span class="built_in">size</span>())   <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> m_pThreadAlgs[i];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/*构建多线程对象 默认第一个线程的读取数据队列指针为 nullptr, 该线程的第一个算法需要是读取序列图像类似的算法</span></span><br><span class="line"><span class="comment">      也可以设置 输入数据缓冲队列地址。采用等数量划分算法组的方法， 不好 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(SafeMatList&lt;T&gt;* q_in = <span class="literal">nullptr</span>)</span></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">        SafeMatList&lt;T&gt;* pQueue = q_in;  </span><br><span class="line">        <span class="keyword">int</span> N = alg_pairs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> per = N / thread_num + (N%thread_num ? <span class="number">1</span> :<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thread_num; i++)&#123;</span><br><span class="line">            vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">void</span>*&gt;&gt; p;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i*per; j &lt; <span class="built_in">min</span>((i+<span class="number">1</span>)*per, N); j++)</span><br><span class="line">                p.<span class="built_in">push_back</span>(alg_pairs[j]);</span><br><span class="line"></span><br><span class="line">            pQueue = <span class="built_in">per_threadContrust</span>(p, pQueue, data_size[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/* 开启多线程 运行*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        vector&lt;std::thread&gt; tasks;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; algs : m_pThreadAlgs)</span><br><span class="line">            tasks.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(AbstrctThreadAlg&lt;T, <span class="keyword">void</span>*&gt;::run, algs));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t : tasks)</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/*获取 构造器*/</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> PrepocessTaskSingleton&lt;T&gt;* <span class="title">getPrepocessBuilder</span><span class="params">(<span class="keyword">int</span> nth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleBuilder != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> singleBuilder;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(singleBuilder == <span class="literal">nullptr</span>)</span><br><span class="line">            singleBuilder = <span class="keyword">new</span> PrepocessTaskSingleton&lt;T&gt;(nth);</span><br><span class="line">        <span class="keyword">return</span> singleBuilder;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">PrepocessTaskSingleton</span>(<span class="keyword">int</span> n): <span class="built_in">thread_num</span>(n) &#123;</span><br><span class="line">        <span class="comment">/* 初始化的时候 默认 每个线程的数据缓冲队列大小为 3 最后一个线程的缓冲队列大小为 0，大小为 0 表明不存储生成的结果*/</span> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; thread_num<span class="number">-1</span>; i++)</span><br><span class="line">            data_size.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">        data_size.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">SafeMatList&lt;T&gt;* <span class="title">per_threadContrust</span><span class="params">(vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">void</span>*&gt;&gt;&amp; aps, SafeMatList&lt;T&gt;* data_queu, <span class="keyword">int</span> sz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> AbstrctThreadAlg&lt;T, <span class="keyword">void</span>*&gt;(sz, data_queu);</span><br><span class="line">        m_pThreadAlgs.<span class="built_in">push_back</span>(p);</span><br><span class="line">        AlgorithmFactory&lt;T, <span class="keyword">void</span>*&gt; algorithm_creator;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ap : aps)</span><br><span class="line">            p-&gt;list_algs.<span class="built_in">push_back</span>(algorithm_creator.<span class="built_in">createAlgorim</span>(ap.first, ap.second));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p-&gt;m_pFinishQueue;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> std::mutex mtx_;  <span class="comment">// 保证线程安全</span></span><br><span class="line">    <span class="keyword">static</span> PrepocessTaskSingleton&lt;T&gt;* singleBuilder;   <span class="comment">// 单例模式 返回实例化的对象 </span></span><br><span class="line">    vector&lt;AbstrctThreadAlg&lt;T, <span class="keyword">void</span>*&gt;*&gt; m_pThreadAlgs; <span class="comment">// 用于管理 实例化的所有线程类</span></span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">void</span>*&gt;&gt; alg_pairs;                <span class="comment">// 用于存储输入的算法 id 和 对应的参数地址</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; data_size;                             <span class="comment">// 用于存储 每个线程 的缓冲数据队列的 大小</span></span><br><span class="line">    <span class="keyword">int</span> thread_num;                                    <span class="comment">// 生成的线程数量 </span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>main.cpp</code> 测试文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;algorithm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;prepocessThread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员变量 这个初始化 必须有，因为静态成员变量在初始化的时候分配内存</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">PrepocessTaskSingleton&lt;T&gt;* PrepocessTaskSingleton&lt;T&gt;::singleBuilder = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::mutex PrepocessTaskSingleton&lt;T&gt;::mtx_;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> builder= PrepocessTaskSingleton&lt;string&gt;::<span class="built_in">getPrepocessBuilder</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* alg0_param = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="string">&quot;dir&quot;</span>);</span><br><span class="line">    builder-&gt;<span class="built_in">add_Algorm</span>(<span class="number">0</span>, alg0_param);   <span class="comment">//增加一个 预处理方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> alg1_param = <span class="number">0</span>;</span><br><span class="line">    builder-&gt;<span class="built_in">add_Algorm</span>(<span class="number">1</span>, &amp;alg1_param);  <span class="comment">//增加一个 预处理方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> alg2_param = <span class="number">2.1</span>;</span><br><span class="line">    builder-&gt;<span class="built_in">add_Algorm</span>(<span class="number">2</span>, &amp;alg2_param);  <span class="comment">//增加一个 预处理方法</span></span><br><span class="line"></span><br><span class="line">    builder-&gt;<span class="built_in">build</span>();  <span class="comment">// 构建  算法分组，并使用多个线程类包装  </span></span><br><span class="line">    builder-&gt;<span class="built_in">run</span>();    <span class="comment">// 运行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其他笔记</category>
        <category>个人小项目</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>应用</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池代码解析</title>
    <url>/posts/43376/</url>
    <content><![CDATA[<p>网上大佬用 C++11 写的线程池代码，和自己的阅读笔记</p>
<span id="more"></span>
<p>代码中有很多<code>c11</code>新增的高级操作， <a href="../../C++/库函数/bind_function.md">配合笔记</a> 一起理解</p>
<p><code>ThreadPool</code>.h 头文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 版的 线程池</span></span><br><span class="line"><span class="keyword">namespace</span> zl</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadsGuard</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">ThreadsGuard</span>(std::vector&lt;std::thread&gt;&amp; v)</span><br><span class="line">            : <span class="built_in">threads_</span>(v)</span><br><span class="line">        &#123;      </span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">ThreadsGuard</span>()</span><br><span class="line">        &#123;   <span class="comment">// join 需要等到所有线程运行完毕，才能退出析构函数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != threads_.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (threads_[i].<span class="built_in">joinable</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    threads_[i].<span class="built_in">join</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">ThreadsGuard</span>(ThreadsGuard&amp;&amp; tg) = <span class="keyword">delete</span>;</span><br><span class="line">        ThreadsGuard&amp; <span class="keyword">operator</span> = (ThreadsGuard&amp;&amp; tg) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ThreadsGuard</span>(<span class="keyword">const</span> ThreadsGuard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        ThreadsGuard&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> ThreadsGuard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::vector&lt;std::thread&gt;&amp; threads_;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; task_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> n = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">ThreadPool</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stop</span>();</span><br><span class="line">            cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">            stop_.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Function</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">        std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="built_in">Function</span>(Args...)&gt;::type&gt; <span class="built_in">add</span>(Function&amp;&amp;, Args&amp;&amp;...);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">ThreadPool</span>(ThreadPool&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        ThreadPool&amp; <span class="keyword">operator</span> = (ThreadPool&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        <span class="built_in">ThreadPool</span>(<span class="keyword">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        ThreadPool&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::atomic&lt;<span class="keyword">bool</span>&gt; stop_;       <span class="comment">// 将值做了一遍封装，使得这个值的访问不会导致数据竞争</span></span><br><span class="line">        std::mutex mtx_;               <span class="comment">// 互斥锁用于对任务队列互斥访问</span></span><br><span class="line">        std::condition_variable cond_; <span class="comment">// 条件变量 在测试条件的时候要先加锁 确保完全进入 wait 状态后再释放锁，然后再安心接收条件，免得还没wait呢，发了一个唤醒信号，就丢了。</span></span><br><span class="line"></span><br><span class="line">        std::queue&lt;task_type&gt; tasks_;</span><br><span class="line">        std::vector&lt;std::thread&gt; threads_;</span><br><span class="line">        zl::ThreadsGuard tg_;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">        : stop_(false)</span></span><br><span class="line"><span class="function">        , tg_(threads_)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> nthreads = n;</span><br><span class="line">        <span class="keyword">if</span> (nthreads &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nthreads = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">            nthreads = (nthreads == <span class="number">0</span> ? <span class="number">2</span> : nthreads);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 1. 构造函数，n 设置线程池中的线程数目。构造函数中，首先开启了n个线程，线程池其实就是 std::vector&lt;std::thread&gt; 的一个数组，每个线程的函数都在干同一件事：等待条件，如果条件成立，就从任务队列中取出一个任务执行。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != nthreads; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            threads_.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>([<span class="keyword">this</span>]&#123;</span><br><span class="line">                <span class="keyword">while</span> (!stop_.<span class="built_in">load</span>(std::memory_order_acquire))</span><br><span class="line">                &#123;</span><br><span class="line">                    task_type task;</span><br><span class="line">                    &#123;   <span class="comment">// 这个 大括号至关重要，表明这是一个 操作临界区的部分代码，因为使用了 unique_lock，当退出这个临界区代码，unique_lock 会自动调用析构函数解锁。然后接着执行 task 任务，在执行task 任务期间并不需要上锁，只有从队列取出任务的过程需要上锁</span></span><br><span class="line">                        <span class="comment">// 使用 unique_lock 对互斥锁进行封装，有自动上锁和解锁的功能，析构函数中解锁。 task() 退出函数后自动解锁</span></span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; <span class="built_in">ulk</span>(<span class="keyword">this</span>-&gt;mtx_);</span><br><span class="line">                        <span class="comment">// 当任务队列为空的时候的等待  或者不是stop_模式的时候等待，如果是stop模式，不等待直接退出</span></span><br><span class="line">                        <span class="keyword">this</span>-&gt;cond_.<span class="built_in">wait</span>(ulk, [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> stop_.<span class="built_in">load</span>(std::memory_order_acquire) || !<span class="keyword">this</span>-&gt;tasks_.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">                        <span class="keyword">if</span> (stop_.<span class="built_in">load</span>(std::memory_order_acquire))</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        <span class="comment">// 函数的返回值是一个临时右值，使用 move 直接高效的转移给 task  （当调用的函数返回的是引用的时候，实际返回的是左值，当值返回时，返回的是右值。这里使用的move 无论 front() 返回的是左值还是右值都被转换成了右值）</span></span><br><span class="line">                        task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks_.<span class="built_in">front</span>());</span><br><span class="line">                        <span class="keyword">this</span>-&gt;tasks_.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 2. 增加任务的函数，任务队列 tasks_ 实际是一个 function 类型的队列。result_of 用于获取输入函数fcn的返回类型</span></span><br><span class="line"><span class="comment">// 3. future 是 创建packge_task后的返回值，用于异步获取调用结果 </span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Function</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">    std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="built_in">Function</span>(Args...)&gt;::type&gt;</span><br><span class="line">        ThreadPool::<span class="built_in">add</span>(Function&amp;&amp; fcn, Args&amp;&amp;... args)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 4. std::result_of&lt;Function(Args...)&gt;::type 中的 type 实际是类的一个成员，前面的 typename 告诉编译器将这个成员当作类型名称。所以 最终 return_type 就是一个类型名称。</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">Function</span>(Args...)&gt;::type return_type;</span><br><span class="line"><span class="comment">// 5. 加入 return_type 是 int 型 那么这句话相当于申明了一个  std::packaged_task&lt;int()&gt; 型的类，他就可以包装 返回值为 int 的可调用对象。进而使用它的返回值 future 实现异步读取执行结果的功能</span></span><br><span class="line">        <span class="keyword">typedef</span> std::packaged_task&lt;<span class="built_in">return_type</span>()&gt; task;</span><br><span class="line"><span class="comment">// 6. 由于前面申明的只是一个 int() 型的 package_task 类型，但是输入函数还有参数，因此先用 bind 绑定可执行对象和参数，形成一个不带输入参数的新的可调用对象，这里只是用智能指针管理。</span></span><br><span class="line">        <span class="comment">// 将可调用函数 fcn 和 对应的参数 args 绑定成一个仿函数。会隐式的转换成函数指针  std::forward用于完美转发</span></span><br><span class="line">        <span class="comment">// 将该函数指针用 share_ptr 智能指针管理 </span></span><br><span class="line">        <span class="keyword">auto</span> t = std::make_shared&lt;task&gt;(std::<span class="built_in">bind</span>(std::forward&lt;Function&gt;(fcn), std::forward&lt;Args&gt;(args)...));</span><br><span class="line"><span class="comment">// 7. 获取package_task的返回值，是 future对象 </span></span><br><span class="line">        <span class="keyword">auto</span> ret = t-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">// 8. 要向任务队列中添加任务的时候先上锁，这里用 lock_guard 来管理 互斥锁 在退出大括号的作用域后，可以自动解锁</span></span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (stop_.<span class="built_in">load</span>(std::memory_order_acquire))</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;thread pool has stopped&quot;</span>);</span><br><span class="line"><span class="comment">// 9. 这里之所以还要用 lambad函数封一层，是因为 t 是 package_task 类型的对象，可以执行，但是  不同的 输入fcn 可能有不同的 返回值类型，例如按照前面假设的这里就是 package_task&lt;int()&gt; 类型。因此 为了更通用，这里用 lambda 函数封一遍 统一都是 function&lt;void(void)&gt;类型了。但是这里不用 package_task封了，因为 这里的 lambda 没返回值，不用future来异步获取结果。   </span></span><br><span class="line">            tasks_.<span class="built_in">emplace</span>([t]&#123;(*t)(); &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">/* THREAD_POOL_H */</span></span></span><br></pre></td></tr></table></figure>
<p><code>main</code>文件使用例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ThreadPool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        zl::ThreadPool tp;</span><br><span class="line">        std::vector&lt;std::future&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">        std::vector&lt;std::future&lt;<span class="keyword">void</span>&gt;&gt; v1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> ans = tp.<span class="built_in">add</span>([](<span class="keyword">int</span> answer) &#123; <span class="keyword">return</span> answer; &#125;, i);</span><br><span class="line">            v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(ans));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">auto</span> ans = tp.<span class="built_in">add</span>([&amp;mtx](<span class="keyword">const</span> std::string&amp; str1, <span class="keyword">const</span> std::string&amp; str2)</span><br><span class="line">            &#123;</span><br><span class="line">                std::lock_guard&lt;std::mutex&gt; <span class="built_in">lg</span>(mtx);</span><br><span class="line">                std::cout &lt;&lt; (str1 + str2) &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;, <span class="string">&quot;hello &quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">            v1.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(ans));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cout &lt;&lt; v[i].<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            v1[i].<span class="built_in">get</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (std::exception&amp; e)&#123;</span><br><span class="line">        std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其他笔记</category>
        <category>个人小项目</category>
      </categories>
      <tags>
        <tag>应用</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记管理软件</title>
    <url>/posts/33362/</url>
    <content><![CDATA[<p>平常在本地使用 typoral 写markdown 笔记，通过git管理本地的笔记文件，定时上传github，使用hexo环境编译笔记并同步到github主页，但是由于 typoral 只是一个文档编辑器，每次要插入笔记引用和笔记yaml头等操作时很麻烦。</p>
<span id="more"></span>
<h2 id="动机">动机</h2>
<p>一方面，本地 typoral + hexo + github 管理笔记的模式在创建笔记连接的时候不方便 另一方面，熟悉一下 c++ 编程，所以编写了一个简单的插件辅助管理本地的笔记</p>
<h2 id="开发环境">开发环境</h2>
<p>windows / QT 5.12 / C++</p>
<h2 id="开发流程">开发流程</h2>
<ol type="1">
<li>qt crator 编写代码，本地调试</li>
<li>使用 <code>windeployqt main_window.exe</code> 将exe运行需要的依赖文件都自动拷贝到一个文件夹下</li>
<li>使用 Inno setup 打包出安装文件，生成安装包，可以在任何电脑上运行 （使用方法 <a href="https://blog.csdn.net/hebbely/article/details/78168071">Inno使用方法</a>）</li>
</ol>
<h2 id="软件使用方法">软件使用方法</h2>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210514172857.png" alt="image-20210514172857737" style="zoom:67%;" /></p>
<p>第一次使用的时候，通过参数设置页面，设置本地笔记的根目录，然后退出重启，即可。</p>
<h3 id="软件功能">软件功能</h3>
<ul>
<li>生成笔记连接：第一次单击需要插入引用的 笔记，选择添加笔记引用功能，第二次单击它要引用的笔记文件；然后会自动将引用写入系统粘贴板，粘贴至笔记中即可</li>
<li>生成笔记yaml头信息：同样，单击，选择添加笔记功头选项。即可在对应文件的开头插入 yaml 信息，这个在 hexo 编译的时候用的上</li>
<li>更新文件中的引用和头信息：当本地笔记文件目录或者名字改变时，通过最上面的更新引用功能，即可自动修正相关的引用（实现原理是 将每个文件的创建时间作为 标识，通过缓存文件来记录每个文件的历史路径）</li>
<li>一键同步上传本地笔记：使用 <code>system</code>函数调用cmd，因此可以在参数设置页面中设置 hexo 编译和 git 上传的命令，每一行为一条命令，最后一行没有换行符。设置完后，就可以使用一键上传功能</li>
</ul>
<h2 id="开发记录">开发记录</h2>
<h3 id="实现原理">实现原理</h3>
<p>首先 需要一个本地缓存，首次运行遍历 当前目录下的所有 md 文件，查找文件中的 插入的超链接 和它连接到的文件；使用一个 类 来管理。</p>
<ol type="1">
<li>扫描文件夹，建立缓冲文件，即预先存储所有的 笔记连接映射，还有一些配置参数</li>
<li>将缓存文件读入内存，以键值对的形式保存。</li>
<li>当单个文件名和路径修改时，需要找到原始的文件名，然后替换。（如果不是通过软件修改，怎么识别变动？）
<ul>
<li>通过唯一的文件创建时间来建立 映射，初始遍历所有文件，如果有重复的创建时间，需要去重，并修改id，然后建立 文件名和创建时间的映射。然后将这个映射写进 缓存文件。</li>
<li>后续如果有文件修改，找出这个最近修改了的文件名和唯一标识符。首先遍历所有 md 文件，和历史缓存的信息对比
<ul>
<li>唯一标志符存在，且和本地记录的文件名一致，说明只是文件内容修改了，这种情况不用操作</li>
<li>唯一标志符存在，对应的文件路径不一致，说明要么是移动了路径，要么是修改了文件名。找到引用它的所有文件，以及它自己引用的所有文件 （因为引用的插入都是相对路径的形式）， 修改笔记中的引用，如果它有 yaml 头信息，还要将 <code>categories</code>信息修正。这一步调整的都是 md 文件</li>
<li>唯一标志符不存在，说明是新建立的文件，这中情况也不用操作</li>
</ul></li>
</ul></li>
<li>完成上述操作后，重新扫描一遍文件夹，在内存中重新建立缓存，并写入本地 cathe.json文件中。</li>
</ol>
<p>上述的逻辑可能不是最优的，因为要扫描两遍，比较耗时。不过本地文件较少，目前没用多线程去扫描，这个判断逻辑应该可以优化吧。</p>
<h3 id="问题">问题</h3>
<p>c++ 的 ifstream 这种功能很奇怪，当路径为中文并且使用 UTF-8 编码的格式，就打不开。因为md文件默认编码都是 utf8 qt编辑器默认也是 utf8 而使用 c++ 的 ifstream 以及 文件遍历的函数都只能支持 gbk 编码的中文路径。很无解，所以在代码中有频繁的 utf8 转 gbk 的地方，用的很混乱。</p>
<p>管理 mrkdown 的类使用的 纯c++ 没有使用 qt ，感觉还是用 qt 做目录遍历，文件读写啥的会方便很多，不用考虑编码格式问题吧</p>
<p>qt 的 <code>QFileSystemModel</code>看起来很牛皮，实现文件浏览只用一行代码。但是居然只提供了 文件 rename 的信号，如果是文件移动就不能实时给出信号。所以本来想增加一个文件监视的共能，如果有一个文件变动，就只修改这一项，不用再遍历所有文件对比了。但是没找到qt 的这个接口，倒是有个 <code>QFileSystemWatcher</code>但是这个用于监控一个文件还好，如果是很多文件夹，好像就不太好。</p>
<p>对 Qt 不熟悉，界面功能实现上走了好多弯路。</p>
<h2 id="本地笔记管理流程">本地笔记管理流程</h2>
<p>使用typoral+github / 图床云笔记 <a href="../工具软件使用/typoral云笔记搭建.md">typoral云笔记搭建.</a>，在本地通过 typoral编写笔记，使用git同步到云端</p>
<p>使用hexo+github 制作个人主页 <a href="../工具软件使用/hexo的使用.md">hexo的使用.</a>，方便在网页中浏览笔记</p>
<p>最后使用该软件辅助，作为 typoral 的补充</p>
<h2 id="需要完善">需要完善</h2>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
hexo 不支持 markdown 中的 <code>[]()</code> 笔记文件引用 ！！！ 后续有时间再添加上这个功能吧</li>
</ul>
]]></content>
      <categories>
        <category>其他笔记</category>
        <category>个人小项目</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>项目总结</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/posts/48230/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="linux-环境设置问题">Linux 环境设置问题</h2>
<h3 id="找不到动态库的问题">找不到动态库的问题</h3>
<p>在编译或者运行的时候提示 找不到 xx.so库</p>
<ul>
<li>LD_LIBRARY_PATH 设置运行时查找动态库的路径</li>
<li>LIBRARY_PATH 设置编译时查找动态库的路径</li>
</ul>
<p>首先查找.so文件的位置 sudo find / -name libxx.so；将查找到的.so路径添加到 LD_LIBRARY_PATH 或者 LIBRARY_PATH 环境变量中即可。</p>
<p>永久的设置，可以在 home目录下的 .bashrc中 增加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LIBRARY_PATH&#x3D;&#x2F;mnt&#x2F;Softwares&#x2F;fftw-3.3.8&#x2F;build&#x2F;lib</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;opencv2&#x2F;lib:&#x2F;mnt&#x2F;Softwares&#x2F;fftw-3.3.8&#x2F;build&#x2F;lib</span><br><span class="line"></span><br><span class="line">source .bashrc  </span><br></pre></td></tr></table></figure>
<h3 id="linux文件编码转换">Linux文件编码转换</h3>
<ol start="3" type="1">
<li>将当前目录下所有的 cpp 文件转化为utf-8 编码 enca -x utf-8 *.cpp （linux 以及qt默认的编码是utf8）</li>
<li>将某路径下所有文件由 GBK 转码为 UTF-8 find $PWD -type f -exec sh -c "iconv -f GBK -t UTF-8 {} &gt; ~/temp" ; -exec mv ~/temp {} ;</li>
</ol>
<h3 id="linux进程操作">Linux进程操作</h3>
<p>清除用户所有进程 pkill -u changruowang</p>
<h3 id="tensorflow可视化">tensorflow可视化</h3>
<p>在本地主机查看远程服务器的tensorboard</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -L 16013:127.0.0.1:6013 changruowang@115.156.213.131   (115.156.213.131为远程服务器ip)</span><br></pre></td></tr></table></figure>
<p>linux下直接使用python启动tensorboard</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m tensorboard.main --logdir  /mnt2/changruowang/image_enhance/myKinD/log_dir</span><br></pre></td></tr></table></figure>
<p>查看tensorflow是否安装成功 import tensorflow as tf tf.Session()</p>
<h3 id="conda-相关操作">conda 相关操作</h3>
<ol type="1">
<li>创建新环境 conda create -n name python=3.7</li>
<li>激活环境 source activate name</li>
<li>退回到base环境 conda deactivate</li>
<li>清除环境 conda remove -n name --all</li>
<li>查看所有的虚拟环境 conda info --env</li>
<li>查看当前环境下所有的包 conda list</li>
<li>清除缓存 conda clean -t / conda clean -p / ....</li>
<li>在用户home路径下的 .bashrc 中 添加conda安装的环境变量，以及CUDA的路径</li>
</ol>
<h3 id="其他命令">其他命令</h3>
<p>查看gpu占用 nvidia -smi</p>
<p>查看CUDA版本 nvcc -V</p>
<p>查看文件具体信息 ll</p>
<p>将qt-designer的 .ui文件转为py</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyuic5 -o mainwindow_.py mainwindow.ui    (.ui为qt设计师的文件)</span><br></pre></td></tr></table></figure>
<p>markdown转word</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pandoc -f markdown -t docx .&#x2F;其他.md -o test.docx</span><br></pre></td></tr></table></figure>
<h2 id="git-hub-使用">git hub 使用</h2>
<ol type="1">
<li><p>首先在远程创建一个工程，按照工程下的提示在本地该工程的文件夹下打开git bash按顺序输入(其中有和远程库关联的步骤，必须输入)</p></li>
<li><p>git init 在当前文件夹下创建一个git 仓库管理该文件夹下的工程</p></li>
<li><p>git add . 表示将所有文件提交到监控区域 则有文件改动都会被记录</p></li>
<li><p>git commit -m "inform" 提交当前改动</p></li>
<li><p>git push 将代码提交到git hub 远程仓库 <strong>不要在浏览器上随意删除已经提交了的文件，否则本地的记录和云端的记录不一致再次提交会报错，所有对文件的修改最好只在本地修改让后上传云端</strong></p>
<p><strong>空文件夹不会被add添加 只有里面有文件才会被add .gitignore文件可以选择push时忽略的文件</strong></p></li>
<li><p>在新的机子上生成 公钥 ssh-keygen -C“ changruowang@qq.com” 然后在用户目录下 把生成的id_rsa.pub文件中的东西粘贴添加到 网页版github账户的列表中 这样本地可以访问远程github仓库了</p></li>
<li><p>使用 git clone https… 形式的连接，提示错误，要将 http / https 代理关闭</p>
<blockquote>
<p>fatal: unable to access 'https://github.com/hexojs/hexo-starter.git/': Failed to connect to 127.0.0.1 port 1080: Connection refused</p>
<p>git config --global --unset http.proxy</p>
<p>git config --global --unset https.proxy</p>
</blockquote></li>
</ol>
<h2 id="latex-语法">Latex 语法</h2>
<p> 引用作者 xx at al  只显示序号 \part 新的段落  引用图片</p>
<h2 id="麒麟系统环境配置">麒麟系统环境配置</h2>
<ol type="1">
<li>源码安装 cmake g++</li>
<li>.run<br />
</li>
<li>dus https://blog.csdn.net/u010168781/article/details/89681674 https://blog.csdn.net/weixin_41910427/article/details/82733265</li>
<li>运行编译 提示 找不到GL库 https://blog.csdn.net/qq_27278957/article/details/100054043<br />
sudo ln -s /usr/lib64/libGL.so.1 /usr/lib/libGL.so</li>
</ol>
<p>yum install libX11-devel --nogpg</p>
<p>libX11-devel libXext-devel， libXtst-devel</p>
<p>sudo yum install freetype-devel fontconfig-devel</p>
<p>./configure - fontconfig // 支持自定义tff字体</p>
<p>make &amp;&amp; sudo make install</p>
<h2 id="qt相关">qt相关</h2>
<p>解决打包的问题</p>
<p>https://blog.csdn.net/weijifen000/article/details/102537640</p>
]]></content>
      <categories>
        <category>其他笔记</category>
        <category>工具软件使用</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch扩展C</title>
    <url>/posts/29752/</url>
    <content><![CDATA[<h3 id="c测试文件">c++测试文件：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include &lt;torch/script.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;torch/extension.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">torch::Tensor <span class="title">extend_gray</span><span class="params">(torch::Tensor image, torch::Tensor warp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BEGIN image_mat</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">image_mat</span><span class="params">(<span class="comment">/*rows=*/</span>image.size(<span class="number">0</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="comment">/*cols=*/</span>image.size(<span class="number">1</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="comment">/*type=*/</span>CV_32FC1,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="comment">/*data=*/</span>image.data_ptr&lt;<span class="keyword">float</span>&gt;())</span></span>;</span><br><span class="line">    <span class="comment">// END image_mat</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BEGIN warp_mat</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">warp_mat</span><span class="params">(<span class="comment">/*rows=*/</span>warp.size(<span class="number">0</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="comment">/*cols=*/</span>warp.size(<span class="number">1</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="comment">/*type=*/</span>CV_32FC1,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="comment">/*data=*/</span>warp.data_ptr&lt;<span class="keyword">float</span>&gt;())</span></span>;</span><br><span class="line">    <span class="comment">// END warp_mat</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BEGIN output_mat</span></span><br><span class="line">    cv::Mat output_mat;</span><br><span class="line">    cv::<span class="built_in">warpPerspective</span>(image_mat, output_mat, warp_mat, <span class="comment">/*dsize=*/</span>&#123;<span class="number">8</span>, <span class="number">8</span>&#125;);</span><br><span class="line">    <span class="comment">// END output_mat</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BEGIN output_tensor</span></span><br><span class="line">    torch::Tensor output = torch::<span class="built_in">from_blob</span>(output_mat.ptr&lt;<span class="keyword">float</span>&gt;(), <span class="comment">/*sizes=*/</span>&#123;<span class="number">8</span>, <span class="number">8</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> output.<span class="built_in">clone</span>();</span><br><span class="line">    <span class="comment">// END output_tensor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pybind11 绑定</span></span><br><span class="line"><span class="built_in">PYBIND11_MODULE</span>(TORCH_EXTENSION_NAME, m) &#123;</span><br><span class="line">    m.<span class="built_in">def</span>(<span class="string">&quot;extend_gray&quot;</span>, &amp;extend_gray, <span class="string">&quot;extend gray&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同目录下的-setup.py文件">同目录下的 setup.py文件</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">from</span> torch.utils.cpp_extension <span class="keyword">import</span> BuildExtension, CppExtension</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件目录</span></span><br><span class="line">include_dirs = os.path.dirname(os.path.abspath(__file__))  <span class="comment">## 头文件路径</span></span><br><span class="line"><span class="comment"># 源代码目录</span></span><br><span class="line">source_cpu = glob.glob(os.path.join(include_dirs, <span class="string">&#x27;*.cpp&#x27;</span>))  <span class="comment">## cpp文件列表 [&#x27;&#x27;, &#x27;&#x27;]</span></span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">&#x27;extend_gray&#x27;</span>,  <span class="comment"># 模块名称，需要在python中调用  </span></span><br><span class="line">    version=<span class="string">&quot;0.1&quot;</span>,</span><br><span class="line">    ext_modules=[</span><br><span class="line">        CppExtension(<span class="string">&#x27;extend_gray&#x27;</span>, </span><br><span class="line">        sources=source_cpu,   </span><br><span class="line">        library_dirs=[<span class="string">&#x27;/usr/local/lib&#x27;</span>], <span class="comment"># &#x27;/usr/local/lib&#x27;为opencv的动态库路径 -L/usr/...</span></span><br><span class="line">        include_dirs=[include_dirs, <span class="string">&#x27;/usr/local/include/opencv&#x27;</span>, <span class="string">&#x27;/usr/local/include&#x27;</span>], <span class="comment">## 头文件路径后两个为 opencv的</span></span><br><span class="line">        libraries=[<span class="string">&quot;opencv_core&quot;</span>, <span class="string">&quot;opencv_imgproc&quot;</span>, <span class="string">&quot;opencv_imgcodecs&quot;</span>, <span class="string">&quot;opencv_highgui&quot;</span>]),</span><br><span class="line">        <span class="comment">## 相当于g++ 编译的 -lopencv_core 一定要写全, 否则不写全编译不会报错但是运行会出错，必要时可以直接g++编译测试看用到哪些动态库</span></span><br><span class="line">    ],</span><br><span class="line">    cmdclass=&#123;</span><br><span class="line">        <span class="string">&#x27;build_ext&#x27;</span>: BuildExtension.with_options(no_python_abi_suffix=<span class="literal">True</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="测试文件">测试文件</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> extend_gray</span><br><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(extend_gray.extend_gray(torch.randn(<span class="number">32</span>, <span class="number">32</span>), torch.rand(<span class="number">3</span>, <span class="number">3</span>)))</span><br></pre></td></tr></table></figure>
<p>​ 遇到提示 .so 库找不到 使用 find 命令在环境中搜，然后 添加到 LD_LIBRARY_PATH 变量中 写入 .bashrc 文件后面</p>
]]></content>
      <categories>
        <category>其他笔记</category>
        <category>工具软件使用</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>typoral个人云笔记设置</title>
    <url>/posts/16194/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="7159743a9bfb0ea115d11e4c298f9525d43e26f2627096e4e74ddf527e0fda38">995e50c340763ee1a325e8c3b289bb94042f5aabaa770bc0112db74bfe3b3d8bcf0171a02d8c4b6eedae4b4b26a86161ac4e8b5b6d09a7617f0c472693d46bdcc2527fe7eedbc86db8ebd905e1ed774f42f2fe105959bf45ba0c9240629075501b64ce076c6913085d490df52dac01e6349026d33c254cbb8dcf763258d3e5608edf71eb2802b7112dba4c2e0fc7b5bd082fadec8c4d8b3ee0dca2cacb9d676e06b7b10a77ec2d78311ebab03718bd8c54ed280a3789b529f6653a5b3fc421257842d221da076678fec9b1d98bf02d4c34e08d04dd1ee3c0ee22bbe876e6b8ee22668be5e64b554e52ad097eeabf4b2154e12fefb5dcb264aaa1d3e94112d50725978ca34db1677b8a5507009a2fdfee1faa8a2fbea07ced5f20987826c74bcf10f98cbb80283a0b47c55749121b8ba10583e40d72d8dd2737f4af81cb6e5d456e66643a2a1fcbf35031216cfddf2535a817c824023979bd4e614a3b673fbabe848a54c9703bf934b9072f20742eec12c61a1a50e13da5456f19da04e01aba32cc4e7af79ad9d769049668fd14159b7c6696c8014aa6a16cf66498fc03bd89240f143bbee6fa5fc88a241a7c9f9e8cda28a4b6a9d77295a71ff1e833ec04b2e2f084201819fbeeddd23c5b8512a80ca514287090db47768a5e65768cc309e165bf6e0e8f446cfbce05e081a08391c79e1829de2c19d9b5a053407bf1a5b392efe62c032453b2622c8ecbf22b7870840b2b08a8da7df1672a891694e541b4ec223379b3b123cf51430fb89c14740af16d3a747068ca61239e39647b4eeec54ea6bf480a00d044a7ef391f3144b295a50c05f67b370a4e4975c0506ae2eca110cabcc6989ce5f41155284b778aa614617438534970a96655f34d77cd0bf957bd2062d4d96e7fa52bbeb98ea0793681acde1335ebfc04b3801b0e4b00fb4d9b4394ceaa38b821bfc591d77fc3ff36db5caef82e950b3dcacaeea379184f8183dbea45f4992ff32fbe0e193a2641d3db1181b53dfaf72b52eb559cae9bd464fe7b0d04fdd8221860418d6e92f32e422002a1b2c379aa91465b8dd8854ea421ccc19a702b142ea23e5040317f984bae1682f05edb8fddae195eaa90683b62b6617df36991f5eccb6ab99639aa1681fce04e0cd031cbb29b39c36124597f7f720b002b2f508d25b9952f03a60b578ece8cacd9302a8f1ed8b17b91315e93181a9af35d0f46c4599aa8f19807e5028d15787a9702ba95912b1f62535396981b2221aec9aad32ec561bcaa4556bd1555face77a721e27d4dd147d4bb428f6607ee0392971f26fa06420251bfe98d57cbbb4bd6dddb4f4a78d7c11dd98b3897968101b3aff3b9c2074e93f1c296b900e01793a64c0355b4ebe31322497f4c9c2b89326671f6395ff0b4716592fe6f2011685d59a59d378d66365d0c940e75f7e1b3467edbca17c4b4c3c82d7d151adaed17b6796b92e5f32a8a43ecc830d9ff9d852fd9dc211d0c86b36d542d8815b942ff9270da7ad238064d9944b5be6f3c7b4463d7f631ad936f5057f8e39d6da6c79f4d5b65237e7491a42e53d70e9941944aba2c946bdd7064248d7ed273869bc9d6e53c14919eb3659dbdc51cae8b12d8f1bc3051a7281b1348ab5a6d6ccd57213c6eab5934f20938fdad6ca311212c5b344c8a2de40f20645daff967362969f28123c7380e2a3f9d7e0d4e55b26657a0760cea000d6d84415d6436913b9811e053cfd334dd7503a348202f026228e4d66c601ed92db4e1b8f0b45ab6a4ceb93462597fab6542729e3505964a38cf547d080390315033190fe359ab58033177f2ea8402518feffbea1a1d4b712219029df58497ea6ad637037bc4711c20e5f4a320eba493745436a114827857e6a9e60e46e4d73deb4f496050a9d3c8de9aad6caecded1fba6c99b9dbb20261a781f6665343847878412bccc255c88eae471981a59a2a4a16edbcfcccb6375225e0792e63dc947cb09ad5c33a5e4a90fd45275f9f8230612573c07dd76804aca996d13bd0a9df3b941ff53db7b7147e63ba6850ec20920f2ac31fdce8c2f23e2e1454ed8da29bdce9f231ba1b6ea791ad9c3f2a72dbcf619cb0ca9a67ab9fb43f6c1255347c3261e6311eb01ed97caa26eac9bb45ed038fe15df0d799248caad8b1b715ce320cb09c871a3c9ad45b4cc0ca7167ae18113262b2e9ca1289e3ce2142ade6591ad19bb91b5e4f8c5aef8dbc2dfc533d28af6aeddb7f1fa19188085264f3bc26374aaadd0cffcad4213aa33253c3468ef39ab1a59e884ccc1409493e21d338cac273a1a77c2b1e735183d9cec73950a33e9090893db63bad18b012cd1285e0cb3fa4bfd137a304d1a61c86d63ec27107ca13a6c937514d6017ce5dc7b289fe1a3c2d39f7b66b6888045eefe7f604d5b2a2a1498911dda4c943b02d456d2dbc235c14726afae67a77b441222b11c27d33d4d10da8f431d4fae066c5bdd9ccea115feb367fa55afbfab04b371a6ef5ef22bd57e813e917bd813643f8fdb16068489e6bdb1561689484ceb403462c2333dd72a7cd9dc3bfacd9b3e26af25bd3afc0b4f6b3febfdc64499d11c95256dca7f99ec2822e9027f3b0efaee92ce5c3ecbeadeceef7bf4222c31c73374831766eba5e7c99b111728512503e01793c6ff71313a62935cdfa142500c72b49bb2db5e3ca00d2a9c97d3e544cbb8a91c39d8d5773c57bb07ae2c399dfde4f16dce09cb06150f34c03304fec835c01af815c602688ff27398b342f34ecae2637a45c6103f5e41a329e5a8d11966ae2a46f67fca46556be99fe97c6f4890a08a192d1cb7bac152d</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>其他笔记</category>
        <category>工具软件使用</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>加密内容</tag>
      </tags>
  </entry>
  <entry>
    <title>个人conda配置</title>
    <url>/posts/59306/</url>
    <content><![CDATA[<span id="more"></span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 添加conda环境变量</span><br><span class="line">  sudo gedit ~&#x2F;.bashrc</span><br><span class="line"></span><br><span class="line">在文件中添加如下配置：</span><br><span class="line"># &gt;&gt;&gt; conda initialize &gt;&gt;&gt;</span><br><span class="line"># !! Contents within this block are managed by &#39;conda init&#39; !!</span><br><span class="line">__conda_setup&#x3D;&quot;$(&#39;&#x2F;home&#x2F;hust1008&#x2F;anaconda3&#x2F;bin&#x2F;conda&#39; &#39;shell.bash&#39; &#39;hook&#39; 2&gt; &#x2F;dev&#x2F;null)&quot;</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">    eval &quot;$__conda_setup&quot;</span><br><span class="line">else</span><br><span class="line">    if [ -f &quot;&#x2F;home&#x2F;hust1008&#x2F;anaconda3&#x2F;etc&#x2F;profile.d&#x2F;conda.sh&quot; ]; then</span><br><span class="line">        . &quot;&#x2F;home&#x2F;hust1008&#x2F;anaconda3&#x2F;etc&#x2F;profile.d&#x2F;conda.sh&quot;</span><br><span class="line">    else</span><br><span class="line">        export PATH&#x3D;&quot;&#x2F;home&#x2F;hust1008&#x2F;anaconda3&#x2F;bin:$PATH&quot;</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line">unset __conda_setup</span><br><span class="line"># &lt;&lt;&lt; conda initialize &lt;&lt;&lt;</span><br><span class="line"># export PYTHONPATH&#x3D;&#x2F;mnt2&#x2F;zhangjinpu&#x2F;CODE&#x2F;CenSiam:$PYTHONPATH</span><br><span class="line"></span><br><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda&#x2F;bin$&#123;PATH:+:$&#123;PATH&#125;&#125;</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda&#x2F;lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;</span><br><span class="line"></span><br><span class="line">2. 修改conda环境保存路径  换源</span><br><span class="line">sudo gedit ~&#x2F;.condarc</span><br><span class="line"></span><br><span class="line">添加：</span><br><span class="line">channels:</span><br><span class="line"></span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: true</span><br><span class="line">default_channels:</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;main</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;r</span><br><span class="line">custom_channels:</span><br><span class="line">    conda-forge: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud</span><br><span class="line">    msys2: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud</span><br><span class="line">    bioconda: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud</span><br><span class="line">    menpo: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud</span><br><span class="line">    pytorch: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud</span><br><span class="line">    simpleitk: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud</span><br><span class="line">envs_dirs:</span><br><span class="line">  - &#x2F;home&#x2F;changruowang&#x2F;.conda&#x2F;envs</span><br><span class="line">pkgs_dirs:</span><br><span class="line">  - &#x2F;home&#x2F;changruowang&#x2F;.conda&#x2F;pkgs</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其他笔记</category>
        <category>工具软件使用</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>办公软件</title>
    <url>/posts/63450/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="word">Word</h2>
<p><a href="https://zhuanlan.zhihu.com/p/38300903">公式快速编号</a></p>
]]></content>
      <categories>
        <category>其他笔记</category>
        <category>工具软件使用</category>
      </categories>
  </entry>
  <entry>
    <title>C++_bind_function_package_task</title>
    <url>/posts/29308/</url>
    <content><![CDATA[<p>该笔记作为理解通用线程池代码的基础。包含了异步编程的方法，函数绑定的方法等…</p>
<span id="more"></span>
<p>参考链接：</p>
<p>http://cpp11.bitfoc.us/#title-6 https://cloud.tencent.com/developer/article/1584075 https://www.jianshu.com/p/f191e88dcc80</p>
<h2 id="function类">function类</h2>
<p>通过std::function 对 C++中各种可调用实体（普通函数、Lambda表达式、函数指针、以及其它函数对象等）的封装，形成一个新的可调用的std::function对象，只要被包装的可调用类型的函数符合相应的函数调用签名（即 返回值类型，输入参数列表类型相同的函数）；让我们不再纠结那么多的可调用实体。std::function对象最大的用处就是在<strong>实现函数回调 (延迟调用)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码出自链接：http://www.jellythink.com/archives/771</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::function&lt; <span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; Functional;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestFunc</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> lambda = [](<span class="keyword">int</span> a)-&gt;<span class="keyword">int</span>&#123; <span class="keyword">return</span> a; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数(functor)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Functor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.类成员函数</span></span><br><span class="line"><span class="comment">// 2.类静态函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ClassMember</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">StaticMember</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 普通函数</span></span><br><span class="line">    Functional = TestFunc;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">Functional</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;普通函数：&quot;</span>&lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda表达式</span></span><br><span class="line">    Functional = lambda;</span><br><span class="line">    result = <span class="built_in">Functional</span>(<span class="number">20</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Lambda表达式：&quot;</span>&lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仿函数</span></span><br><span class="line">    Functor testFunctor;</span><br><span class="line">    Functional = testFunctor;</span><br><span class="line">    result = <span class="built_in">Functional</span>(<span class="number">30</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;仿函数：&quot;</span>&lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类成员函数</span></span><br><span class="line">    TestClass testObj;</span><br><span class="line">    Functional = std::<span class="built_in">bind</span>(&amp;TestClass::ClassMember, testObj, std::placeholders::_1);</span><br><span class="line">    result = <span class="built_in">Functional</span>(<span class="number">40</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;类成员函数：&quot;</span>&lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类静态函数</span></span><br><span class="line">    Functional = TestClass::StaticMember;</span><br><span class="line">    result = <span class="built_in">Functional</span>(<span class="number">50</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;类静态函数：&quot;</span>&lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现技巧">实现技巧</h3>
<p>首先 function 的底层实现其实是一个模板类，他使用了函数签名的模板特化形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认的模板没实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">function</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现有返回值类型和 2 个参数类型的偏特化  根据模板特化的原则可以知道，虽然原本的模板只有一个参数T，而这里偏特化却有三个参数，其实不是这样的，这里也还是一个参数。 &lt; Ret(Arg0, Arg1) &gt; 中等价于一个模板参数，是一个整体</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ret, <span class="keyword">typename</span> Arg0, <span class="keyword">typename</span> Arg1&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">function</span>&lt;</span><span class="built_in">Ret</span>(Arg0, Arg1)&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先通过上面的 函数签名，就可以匹配到特定类型的函数调用，例如都是 <code>int(int)</code>返回值类型为 int 输入参数为int，只不过调用形式不同，可能是 函数指针，可能是 函数，lambda函数，拟函数等等。因此 function 类内部要对不同的调用对象做一步统一封装。</p>
<ol type="1">
<li><p>首先封装出来的类需要 可执行，因此需要重载 () 操作符</p></li>
<li><p>考虑无论什么调用对象，它都可以归结到一个函数指针，但是不知道函数指针的具体类型，因此 需要增加一个 (void*) p 类型的函数指针，指向输入的可调用对象。</p></li>
<li><p>我们希望 把 所有可调用对象都执行 一次 封装，封装成 这种形式：</p></li>
<li><p>当function&lt;int(int)&gt;( f ) 执行构造函数时，此时有了 f 具体的可调用对象，那么我们可以将构造函数加上 Functor 的模板，进而编译器可以根据 实例 f 自动推断 Functor 的具体类型。</p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>* p = f;                           <span class="comment">//  f 是实际输入的可调用对象  类型是 Functor 的函数指针</span></span><br><span class="line"><span class="function">R <span class="title">invoke_functor</span><span class="params">(<span class="keyword">void</span>*p, <span class="keyword">int</span> args)</span></span>&#123;	   <span class="comment">//  我们希望将 f 统一包装成  统一的  invoke_functor() 函数，第一个参数是可调用对象的函数指针，后面的是函数的输入参数，统一都在  call_able 函数中首先 将可调用对象的类型转换为 它原本的 Functor类型然后调用。</span></span><br><span class="line">	<span class="keyword">return</span>  <span class="keyword">static_cast</span>&lt;Functor&gt;(p)(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>有了上面的 Functor 类型，我们可以将 不同的调用对象都封装成上述的 call_able 的形式来完成调用。多以就有如下更完整的代码</p></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">function</span>&lt;</span><span class="built_in">R</span>(Args...)&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>* functor_ptr; <span class="comment">// 由于无法确定函数对象的具体类型, 就用 void* 保存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并利用以下模板函数转换类型</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Functor&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Functor&amp; <span class="title">get_functor</span><span class="params">(<span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">static_cast</span>&lt;Functor*&gt;(p);                            <span class="comment">// (c)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个函数指针, 当需要调用函数对象时, 从此函数指针上调用</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">invoke_fn_t</span> = <span class="built_in">R</span>(*)(<span class="keyword">void</span>*, Args&amp;&amp;...);</span><br><span class="line">    <span class="keyword">invoke_fn_t</span> invoke_f;</span><br><span class="line">    <span class="comment">// 它将以下面这个函数的特化作为有效值</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Functor&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> R <span class="title">invoke_functor</span><span class="params">(<span class="keyword">void</span>* p, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get_functor&lt;Functor&gt;(p)(std::forward&lt;Args&gt;(args)...); <span class="comment">// (b)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 对外暴露的函数调用算符重载</span></span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 检查是否为空, 并在为空时抛出异常</span></span><br><span class="line">        <span class="comment">// if (!this-&gt;invoke_f) throw bad_function_call(&quot;function is null&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">invoke_f</span>(<span class="keyword">this</span>-&gt;functor_ptr, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从函数对象构造</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Functor&gt;</span><br><span class="line">    <span class="built_in">function</span>(Functor f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;invoke_f = invoke_functor&lt;Functor&gt;;                    <span class="comment">// (a)</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;functor_ptr = <span class="keyword">new</span> <span class="built_in">Functor</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许隐式从 nullptr 转换构造, 此构造函数没有 explicit</span></span><br><span class="line">    <span class="built_in">function</span>(std::<span class="keyword">nullptr_t</span> = <span class="literal">nullptr</span>)</span><br><span class="line">        : <span class="built_in">invoke_f</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol type="a">
<li><p>首先看 构造函数中的 (a) 部分，根据传入构造函数中的 实际调用对象 Functor，来构造一个通用的 函数指针 。单独看 <code>invoke_functor</code> 函数，是个模板函数，将这个模板函数实例化后成为一个实例化后的函数指针，实例化出的函数指针也是前面说的要封装出的通用调用方式，即第一个参数为 可调用对象的指针，后面是输入参数，在函数中完成函数调用。所以 <code>invoke_f</code> 定义的也是一个<code>R(*)(void*, Args&amp;&amp;...);</code>类型的通用函数指针。然后 再 new 一个指向可调用对象的函数指针，并把它存为 void* 类型，做为后面调<code>invoke_functor</code>的第一个参数。</p></li>
<li><ol start="2" type="a">
<li>部分就是 通用函数中需要干的事儿了，首先将 指向可调用对象的 void* 类型的指针 转化为 其原本的 Functor 类型，这一步是通过<code>get_functor</code> 函数 (c) 部分中使用 static_cast 完成的类型转换。</li>
</ol></li>
<li><ol start="3" type="a">
<li>部分即为 一个强制类型转换</li>
</ol></li>
</ol>
<p>最终在 重载的 () 函数中，完成函数调用。</p>
<h3 id="总结">总结</h3>
<p>总结一下实现的流程：</p>
<ol type="1">
<li>当我们只是声明一个 <code>Function&lt;int(int)&gt;</code> 类型时，还不知道具体的需要管理的 可调用对象的类型，因此内部只能先new一个 void* 指针用来指向将来需要指向的可调用对象。</li>
<li>当我们将 一个可调用对象赋值给 <code>Func</code>传入拷贝或者赋值构造函数时，通过该函数的模板实参推导可以得到 该实例的类型为 Functor</li>
<li>在拷贝构造/赋值构造函数中，使用<code>Functor</code>实例化一个 通用函数指针，即前面说的 第一个参数为 void 函数指针，后面为输入参数…Functor 目的是作为 通用函数中 <code>static_cast</code>转换的依据</li>
<li>将一个void指针指向 可调用对象</li>
<li>当要运行的时候，首先将 void* 指针传入通用函数，在函数中，根据<code>Functor</code>类型完成 <code>void*</code>指针到 Functor类型的类型转换，然后执行 该函数并返回计算结果。</li>
</ol>
<h2 id="bind函数">bind函数</h2>
<p>首先，std::bind 是标准库中新增的一个<strong>函数</strong>，std::function是一个类 ，package_task 也是一个类。可将std::bind函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。std::bind将可调用对象与其参数一起进行绑定，绑定后的结果可以使用std::function保存。std::bind主要有以下两个作用：</p>
<ul>
<li>将可调用对象和其参数绑定成一个防函数；</li>
<li>只绑定部分参数，减少可调用对象传入的参数。</li>
</ul>
<h3 id="占位符">占位符</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">my_divide</span> <span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;<span class="keyword">return</span> x/y;&#125;  </span><br><span class="line"><span class="keyword">auto</span> fn_half = std::<span class="built_in">bind</span> (my_divide,_1,<span class="number">2</span>);   <span class="comment">//bind的第一个参数是函数名，普通函数做实参时，会隐式转换成函数指针。因此std::bind (my_divide,_1,2)等价于std::bind (&amp;my_divide,_1,2)；_1表示占位符，位于&lt;functional&gt;中，std::placeholders::_1；</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">fn_half</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;                        <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h3 id="普通成员函数的绑定">普通成员函数的绑定</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_sum</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span></span>&#123;       </span><br><span class="line">        std::cout &lt;&lt; n1+n2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(&amp;Foo::print_sum, &amp;foo, <span class="number">95</span>, std::placeholders::_1);  <span class="comment">//因为普通的成员函数 有 this指针，必须传入一个对象才行。如果是静态成员函数，不需要这样。</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">5</span>); <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这是因为 类的成员函数指针的调用方法为 ： </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;f(&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;value &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;g(&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;value &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Foo* foo1, Foo* foo2, <span class="keyword">void</span> (Foo::*fun)())</span> </span>&#123;</span><br><span class="line">    (foo1-&gt;*fun)();  <span class="comment">// call fun on the object foo1</span></span><br><span class="line">    (foo2-&gt;*fun)();  <span class="comment">// call fun on the object foo2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo foo1&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    Foo foo2&#123;<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">apply</span>(&amp;foo1, &amp;foo2, &amp;Foo::f);   <span class="comment">// 使用类的成员函数，传入两个不同的实例对象，该函数指针可以访问对象1中的数据和2的数据</span></span><br><span class="line">    <span class="built_in">apply</span>(&amp;foo1, &amp;foo2, &amp;Foo::g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>bind绑定类成员函数时，第一个参数表示对象的成员函数的指针，第二个参数表示对象的地址。</li>
<li>必须显示的指定&amp;Foo::print_sum，因为编译器不会将对象的成员函数隐式转换成函数指针，<strong>所以必须在Foo::print_sum前添加&amp;；</strong></li>
<li>使用对象成员函数的指针时，必须要知道该指针属于哪个对象，因此第二个参数为对象的地址 &amp;foo；</li>
</ul>
<h3 id="被绑定的参数为引用参数">被绑定的参数为引用参数</h3>
<p>默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。但是，与lambda类似，有时对有些绑定的参数希望以引用的方式传递，或是要绑定参数的类型无法拷贝。<strong>使用 标准库 ref 函数转化为 引用</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream &amp; <span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> string&amp; s, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; words&#123;<span class="string">&quot;helo&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;this&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;C++11&quot;</span>&#125;;</span><br><span class="line">    ostringstream os;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), </span><br><span class="line">                   [&amp;os, c](<span class="keyword">const</span> string &amp; s)&#123;os &lt;&lt; s &lt;&lt; c;&#125; );</span><br><span class="line">    cout &lt;&lt; os.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ostringstream os1;</span><br><span class="line">    <span class="comment">// ostream不能拷贝，若希望传递给bind一个对象，</span></span><br><span class="line">    <span class="comment">// 而不拷贝它，就必须使用标准库提供的 ref 函数</span></span><br><span class="line">    for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">                   <span class="built_in">bind</span>(print, <span class="built_in">ref</span>(os1), _1, c));</span><br><span class="line">    cout &lt;&lt; os1.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="package_task">package_task</h2>
<p>std::packaged_task 包装一个可调用的对象，并且允许异步获取该可调用对象产生的结果，从包装可调用对象意义上来讲，std::packaged_task 与 std::function 类似，只不过 std::packaged_task 将其包装的可调用对象的执行结果传递给一个 std::future 对象（该对象通常在另外一个线程中获取 std::packaged_task 任务的执行结果）。</p>
<p>因此，和 function的区别</p>
<ul>
<li>功能上都可以包装可调用对象，实现都是一个类</li>
<li>但是pack_task 可以实现异步获取对象返回结果的功能，就是在一个线程中执行可调用对象，在另一个线程中 获取该对象的执行结果，达到异步访问的目的。而 function 不行</li>
</ul>
<h3 id="用法">用法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span>       <span class="comment">// std::packaged_task, std::future</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span>       <span class="comment">// std::chrono::seconds</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span>       <span class="comment">// std::thread, std::this_thread::sleep_for</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// count down taking a second for each value:</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countdown</span> <span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=from; i!=to; --i) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Finished!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> from - to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span>&gt; <span class="title">task</span><span class="params">(countdown)</span></span>; <span class="comment">// 设置 packaged_task</span></span><br><span class="line">    std::future&lt;<span class="keyword">int</span>&gt; ret = task.<span class="built_in">get_future</span>(); <span class="comment">// 获得与 packaged_task 共享状态相关联的 future 对象.</span></span><br><span class="line">    <span class="function">std::thread <span class="title">th</span><span class="params">(std::move(task), <span class="number">10</span>, <span class="number">0</span>)</span></span>;   <span class="comment">//创建一个新线程完成计数任务.  10  0  为函数的输入参数</span></span><br><span class="line">    <span class="keyword">int</span> value = ret.<span class="built_in">get</span>();                    <span class="comment">// 等待任务完成并获取结果.    </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The countdown lasted for &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; seconds.\n&quot;</span>;</span><br><span class="line">    th.<span class="built_in">join</span>();                                <span class="comment">// 要么 join 要么 detach 子线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="stdpackaged_task-构造函数">std::packaged_task 构造函数</h3>
<p>std::packaged_task 构造函数共有 5 中形式，不过拷贝构造已经被禁用了。下面简单地介绍一下上述几种构造函数的语义：</p>
<ol type="1">
<li>默认构造函数，初始化一个空的共享状态，并且该 packaged_task 对象无包装任务。</li>
<li>初始化一个共享状态，并且被包装任务由参数 fn 指定。</li>
<li>带自定义内存分配器的构造函数，与默认构造函数类似，但是使用自定义分配器来分配共享状态。</li>
<li><strong>拷贝构造函数，被禁用</strong>。</li>
<li>移动构造函数。 move 调用的</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span>      <span class="comment">// std::move</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span>       <span class="comment">// std::packaged_task, std::future</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span>       <span class="comment">// std::thread</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::packaged_task&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; foo; <span class="comment">// 默认构造函数.</span></span><br><span class="line">    <span class="comment">// 使用 lambda 表达式初始化一个 packaged_task 对象.</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">bar</span><span class="params">([](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> x*<span class="number">2</span>;&#125;)</span></span>;</span><br><span class="line">    foo = std::<span class="built_in">move</span>(bar); <span class="comment">// move-赋值操作，也是 C++11 中的新特性.</span></span><br><span class="line">    <span class="comment">// 获取与 packaged_task 共享状态相关联的 future 对象.</span></span><br><span class="line">    std::future&lt;<span class="keyword">int</span>&gt; ret = foo.<span class="built_in">get_future</span>();</span><br><span class="line">    std::<span class="built_in">thread</span>(std::<span class="built_in">move</span>(foo), <span class="number">10</span>).<span class="built_in">detach</span>(); <span class="comment">// 产生线程，调用被包装的任务.</span></span><br><span class="line">    <span class="keyword">int</span> value = ret.<span class="built_in">get</span>(); <span class="comment">// 等待任务完成并获取结果.</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The double of 10 is &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stdfuture">std::future</h2>
<p>std::future 可以用来获取异步任务的结果，因此可以把它当成一种<strong>简单的线程间同步的手段</strong>。std::future 通常由某个 Provider 创建，你可以把 Provider 想象成一个异步任务的提供者，Provider 在某个线程中设置共享状态的值，与该共享状态相关联的 std::future 对象调用 get（通常在另外一个线程中） 获取该值，如果共享状态的标志不为 ready，则调用 std::future::get 会阻塞当前的调用者，直到 Provider 设置了共享状态的值（此时共享状态的标志变为 ready），std::future::get 返回异步任务的值或异常（如果发生了异常）。</p>
<p>一个有效(valid)的 std::future 对象通常由以下三种 Provider 创建，并和某个共享状态相关联，Provider 可以是函数或者类，他们分别是：</p>
<ul>
<li><p>std::async 函数</p></li>
<li><p>std::packaged_task::get_future，此时 get_future为 packaged_task 的成员函数，返回即为 std::future 类</p></li>
<li><p>std::promise::get_future，get_future 为 promise 类的成员函数</p></li>
<li><p><input type="checkbox" disabled="" />
Future更详细的用法…</p></li>
</ul>
<h2 id="c11异步编程">C++11异步编程</h2>
<p>主要有三个， <strong>std::async</strong>， <strong>std::packaged_task</strong>， <strong>std::promise</strong></p>
<p>C++11中提供的异步任务高级抽象，包含在 &lt; future&gt;头文件中，它能让我们方便的实现异步地执行一个耗时任务，并在需要的时候获取其结果。例如：</p>
<ol type="1">
<li>批量拷贝/下载文件；</li>
<li>进行一个复杂的计算；</li>
<li>执行多个嵌套的SQL查询语句；</li>
</ol>
<h3 id="stdpromise">std::promise</h3>
<p>std::promise是一个<strong>类模板</strong>，它的作用是在不同的线程中实现数据的同步，与future结合使用，也间接实现了<code>future</code>在不同线程间的同步。下面的例子可以看出， <code>promise + future</code> 等同于 <code>package_task</code>，无需用户自己设置future值。相当于后者对前者进行了封装。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x, std::promise&lt;<span class="keyword">int</span>&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">	x++;</span><br><span class="line">	x *= <span class="number">10</span>;</span><br><span class="line">	p.<span class="built_in">set_value</span>(x);</span><br><span class="line">	std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::promise&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">	std::future&lt;<span class="keyword">int</span>&gt; fu = p.<span class="built_in">get_future</span>();        <span class="comment">// 并将结果返回给future</span></span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(fun, <span class="number">1</span>, std::ref(p))</span></span>;</span><br><span class="line">	std::cout &lt;&lt; fu.<span class="built_in">get</span>() &lt;&lt; std::endl;          <span class="comment">// 当promise还没有值的时候在此等待</span></span><br><span class="line">	std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="stdpackage_task">std::package_task</h3>
<p>前面已经介绍，是个<strong>类模板</strong>，用来打包可调用对象的。相对 promise 有着更高级的封装吧</p>
<h3 id="stdasync">std::async</h3>
<p><strong>这个函数是对上面的对象的一个整合</strong>，<code>async</code>先将可调用对象封装起来，然后将其运行结果返回到<code>promise</code>中，这个过程就是一个面向future的一个过程，最终通过<code>future.get()</code>来得到结果。它的实现方法有两种，一种是<code>std::launch::async</code>，这个是直接创建线程，另一种是std::launch::deferred，这个是延迟创建线程(当遇到<code>future.get</code>或者<code>future.wait</code>的时候才会创建线程)，这两个参数是<code>std::async</code>的第一个参数，如果没有使用这个两个参数，也就是第一个参数为空的话，那么第一个参数默认为<code>std::launch::async | std::launch::deferred</code>，这个就不可控了，由操作系统根据当时的运行环境来确定是当前创建线程还是延迟创建线程。那么<code>std::async</code>的第二个参数就是可调用对象的名称，第三个参数就是可调用对象的参数。</p>
<p>这个函数 直接封装 了 中间对象打包过程和线程创建过程，因此封装度更高，操作的灵活性更低。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	x++;</span><br><span class="line">	x *= <span class="number">10</span>;</span><br><span class="line">	std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// std::launch::deferred 当执行到fu.get才开始创建线程</span></span><br><span class="line">	std::future&lt;<span class="keyword">int</span>&gt; fu = std::<span class="built_in">async</span>(std::launch::deferred, fun, <span class="number">1</span>);</span><br><span class="line">	std::cout &lt;&lt; fu.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>库函数</category>
      </categories>
      <tags>
        <tag>STL库</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title>面经C++基础知识1</title>
    <url>/posts/25550/</url>
    <content><![CDATA[<p>面经 C++ 基础知识</p>
<span id="more"></span>
<h2 id="c基础知识">C++基础知识</h2>
<h3 id="static-关键字的作用">static 关键字的作用</h3>
<ol type="1">
<li><p>修饰变量</p>
<ul>
<li>局部静态变量：存放在静态存储区，不随函数的退出而销毁，默认初始化为 0</li>
<li>全局静态变量：作用域是 定义该变量位置开始到文件结尾，而常规的全局变量其他cpp文件可以通过 extern引用</li>
</ul></li>
<li><p>修饰函数</p>
<p>​ 加上static 修饰函数之后，该函数只能被当前文件调用，不会被外部同名函数影响。</p></li>
<li><p>类中使用</p>
<ul>
<li>类中的静态变量：该类实例化的所有对象的静态变量 公用一个存储区，即公用一个变量，使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。</li>
<li>类中的静态函数：同样也是所有对象公用的函数，成员调用函数不需要 加上对象引用，直接调用。静态函数中可以直接调用类中申明的静态函数，但是想要调用 类中非静态函数，需要 以 <em><类名>::<静态成员函数名>(<参数表>)</em> 的格式。</li>
</ul></li>
</ol>
<h3 id="怎么理解面向对象">怎么理解面向对象</h3>
<p>和面向过程一样，面向对象也是一种编程思想。面向过程是将问题一个复杂的问题分解为多个子过程逐步解决。理论上任何复杂的系统都可以用面向过程的方法解决。但是随着系统的复杂，各个过程之间一定存在相似性和耦合性，面向过程的方法效率就很低。而面向对象的思想更加适合处理一个系统性的问题，着眼于整个面，总结同类事物的共性。使用多态的方法定义和其他类别对象沟通的统一接口；使用封装的特性将数据 和 方法封装为一个整体，简化外部调用的复杂度，并保护内部的私有数据；使用继承的方法实现同类事物的代码复用和特性扩展。</p>
<h3 id="cc区别">C/C++区别</h3>
<ul>
<li><p>设计思想上 C 是面向过程的结构化编程语言，而C++是面向对象的语言，因此C++具有 额外的 封装，继承，多态三大特征</p></li>
<li><p>C++ 增加类型安全的操作，例如 强制类型转换</p></li>
<li><p>C++ 支持范式编程，例如 模板类 和 函数模板</p></li>
</ul>
<h3 id="c四种cast转换的区别">C++四种cast转换的区别</h3>
<p><code>const_cast&lt;T&gt;(expression);</code></p>
<ul>
<li>reinterpret_cast 重解释转换 : 和 c 语言的强制转换中的部分功能—数据的二进制形式重新解释，但是不改变其值 。 如指针转int这种，灵活度高。</li>
<li>const_cast : 用于去掉/增加<strong>指针/引用</strong>的 const 属性 （分为两种，一个是全局的const，它在编译时会被放在只读数据区，通过地址尝试修改只读数据区会产生运行错误。而函数局部const变量 存在栈上，可以通过指针修改变量的值）</li>
<li>static_cast :
<ol type="1">
<li>和 c 语言中的强制类型转换 的功能一样 如 float -&gt; int 但是这种会对数据做二进制的修改（丢失小数点的精度），这点 和 重解释转换不一样。</li>
<li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换，可以上行转换，下行转换由于没有动态类型检查，运行会异常。</li>
<li>不能去掉 变量const, volite关键字</li>
</ol></li>
<li>dynamic_cast : 类层次间类指针或引用的转换，运行时会检查转换的可行性，这点与static 不同的是，下行转换 会返回 null （通过type_info 来判断）因此更安全。（指针空 引用异常）</li>
</ul>
<h3 id="c指针和引用的区别">C++指针和引用的区别</h3>
<ol type="1">
<li><p>指针是一个变量，占内存，而引用是一个变量的别称，不占内存。</p>
<ul>
<li>sizeof(指针) 和 sizeof(引用) 不同</li>
<li>指针有const 而 引用没有</li>
</ul></li>
<li><p>指针可以更改指向的对象，而引用一旦确定，就和所引用的对象绑定了，不能更改</p></li>
<li><p>指针需要 被解引用 才能对对象操作，而引用直接就是对对象的操作</p></li>
<li><p>指针可以多级 引用只能一级。</p></li>
<li><p>如果返回动态分配的内存 只能用指针。</p></li>
</ol>
<h3 id="关于引用">关于引用</h3>
<p>左值引用和右值引用…..</p>
<p>引用不能 绑定 临时变量，右值，例如常量就是一个右值。只有const 引用可以同时接收 左值 和 临时右值。右值说白了就是给零时变量起了个新名字 从而延续了临时变量的生命周期。</p>
<p>右值引用 语义移动，move 可以将左值强制转换为一个右值，原理就是使用static_cast 将左值强制转化为右值引用，而完美转发的原理是 将 根据模板去推断 static_cast&lt;T&amp;&amp;&gt;的类型，原理是引用折叠。</p>
<h3 id="关于运算符的重载">关于运算符的重载</h3>
<p>分为类内重载 和 全局范围重载（并不是所有运算符都能重载 也不是所有运算符都能全局重载 -&gt;）</p>
<p>最基本的重载运算符不能改变原有运算符的优先级 用法，操作数数量（在类中重载二元操作数数量少一个 因为类自身算法一个）…</p>
<p>全局范围重载 通常需要访问操作对象的私有变量，所以想要全局重载则要使用友元函数。同时在全局范围重载的运算符形参必须有一个是自定义类，这是为了防止程序员修改操作符原本的属性例如 int 变量的加法改为减法。</p>
<h3 id="c智能指针">C++智能指针</h3>
<p>auto_ptr&lt; &gt; , unique_ptr&lt; &gt; , share_ptr&lt; &gt;, weak_ptr&lt; &gt; 。当 new 了 一个指针后，必须手动delet，否则会内存泄漏，为了解决这个缺点，c++中增加了 智能指针，智能指针实际上是一个类，对new出来的指针用 类 进行了一层封装，超出类的作用域的时候会自动调用析构函数释放指针指向的内存，并在类中 对 () -&gt; 等操作符进行了重载。<strong>智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏</strong></p>
<ol type="1">
<li>auto_ptr : 是 c++98里的东西，在 c++11已经被弃用，但是后面三个的基本用法还是类似的。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt; string&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;I reigned lonely as a cloud.”));</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">auto_ptr&lt;string&gt; p2;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">p2 = p1; //auto_ptr不会报错.  这时 p2 剥夺了 p1 的所有权，但是调用 p1 的时候还是会内存崩溃，因为此时p1指向的其实是空地址</span></span></span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>unique_ptr : 独占的意思，就是某个指针，只能被一个智能指针独占，当试图使用赋值运算符去复制指针时，编译器会报错，解决了auto_ptr中潜在的问题。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span> <span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;auto&quot;</span>))</span></span>;   <span class="comment">//#4</span></span><br><span class="line">unique_ptr&lt;string&gt; p4；                       <span class="comment">//#5</span></span><br><span class="line">p4 = p3;   <span class="comment">//此时编译会报错！！</span></span><br><span class="line"><span class="comment">//但是 如果是临时右值  可以赋值，因为 临时右值执行完之后就被析构了  不存在风险</span></span><br><span class="line">unique_ptr&lt;string&gt; pu3;</span><br><span class="line">pu3 = unique_ptr&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;You&quot;</span>));   <span class="comment">// #2 允许</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是想要重用这个指针  可以使用 便准库中带的  move</span></span><br><span class="line"><span class="function">unique_ptr&lt;Test&gt; <span class="title">ptest</span><span class="params">(<span class="keyword">new</span> Test(<span class="string">&quot;123&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;Test&gt; <span class="title">ptest2</span><span class="params">(<span class="keyword">new</span> Test(<span class="string">&quot;456&quot;</span>))</span></span>;</span><br><span class="line">ptest-&gt;<span class="built_in">print</span>();</span><br><span class="line">ptest2 = std::<span class="built_in">move</span>(ptest);<span class="comment">//不能直接ptest2 = ptest</span></span><br><span class="line"><span class="keyword">if</span>(ptest == <span class="literal">NULL</span>)  cout&lt;&lt;<span class="string">&quot;ptest = NULL\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>share_ptr : 上面的 unique_ptr虽然很安全，但是不方便，不能赋值要求太死了。share_ptr 使用计数机制来表明资源被几个指针共享。当计数值为0 就释放资源。调用 reset 放弃内部对象，会使引用对象计数值减一。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;Test&gt; <span class="title">ptest</span><span class="params">(<span class="keyword">new</span> Test(<span class="string">&quot;123&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;Test&gt; <span class="title">ptest2</span><span class="params">(<span class="keyword">new</span> Test(<span class="string">&quot;456&quot;</span>))</span></span>;</span><br><span class="line">cout&lt;&lt;ptest2-&gt;<span class="built_in">getStr</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;ptest2.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">ptest = ptest2;<span class="comment">//&quot;456&quot;引用次数加1，“123”销毁</span></span><br><span class="line">ptest-&gt;<span class="built_in">print</span>();</span><br><span class="line">cout&lt;&lt;ptest2.<span class="built_in">use_count</span>()&lt;&lt;endl;<span class="comment">//2</span></span><br><span class="line">cout&lt;&lt;ptest.<span class="built_in">use_count</span>()&lt;&lt;endl;<span class="comment">//2</span></span><br><span class="line">ptest.<span class="built_in">reset</span>();</span><br><span class="line">ptest2.<span class="built_in">reset</span>();<span class="comment">//此时“456”销毁</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;done !\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>weak_ptr : 上述的 <strong>共享指针在相互引用时 会出现 锁死的情况，导致内存泄漏</strong>，就是 计数值永远减不到0的情况。而weak_ptr 指针就可以弥补这个缺点。weak_ptr 指向一个 shared_ptr 管理的对象，它不控制对象的生命周期，进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造，它的构造和析构不会引起引用记数的增加或减少。</li>
</ol>
<h3 id="给定三角形三顶点-判断点是否在三角形里">给定三角形三顶点 判断点是否在三角形里</h3>
<p>ABC 即判断 面积 OAB + OAC + OBC = ABC 是否成立即可。计算面积使用海伦公式 S = ( x1 y1 1 x2 y2 1 x3 y3 1 ) 构成的3x3行列式的值的一般即为 面积。</p>
<h3 id="c多态">C++多态</h3>
<p>多态性可以简单地概括为 “一个接口，多种方法”，它是面向对象编程领域的核心概念。</p>
<p>多态的目的：封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了“接口重用”。也即，不论传递过来的究竟是类的哪个对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。</p>
<p>c++多态的两种形式：</p>
<ol type="1">
<li><p>编译时多态：通过函数重载，函数模板 实现</p></li>
<li><p>运行时多态性（动态多态）：通过虚函数实现，重写 （一般函数子类和基类函数同名时对基类函数屏蔽的作用不叫 多态）</p></li>
</ol>
<p>虚函数是实现多态的机制。其核心理念就是通过基类访问派生类定义的函数。多态性使得程序调用的函数是在运行时动态确定的，而不是在编译时静态确定的。</p>
<p>虚函数实现的过程是：<strong>通过对象内存中的虚函数指针vptr找到虚函数表vtbl，再通过vtbl中的函数指针找到对应虚函数的实现区域并进行调用</strong></p>
<ul>
<li>虚函数： 在类成员方法的声明（不是定义）语句前加“virtual”, 如 virtual void func()。子类可以不重写虚函数。子类如果不提供虚函数的实现，将会自动调用基类的缺省虚函数实现，作为备选方案；</li>
<li>纯虚函数，在虚函数后加“=0”，如 virtual void func()=0。子类必须对纯虚函数实现，否则编译报错。（纯虚函数在基类中的实现跟多态性无关，它只是提供了一种语法上的便利，在变化多端的应用场景中留有后路）</li>
</ul>
<h3 id="为什么c默认的析构函数是不是虚函数为什么析构函数最好是虚函数">为什么C++默认的析构函数是不是虚函数，为什么析构函数最好是虚函数</h3>
<p>为什么要是 虚函数：因为当使用基类指针指向 new 出来的子类对象时，如果子类中分配了新的内存，此时如果析构函数不是虚函数，会调用基类的析构函数 无法释放子类新定义的变量造成内存泄漏。 为什么c++默认不是虚函数：当不使用基类指针指向子类对象时，就不会出现上述内存泄漏的情况，而定义虚函数 会多分配一个虚函数指针，占内存。</p>
<h3 id="关键字volatile">关键字volatile</h3>
<p><strong>表示一个变量也许会被后台程序改变</strong>，关键字 volatile 是与 const 绝对对立的。它指示一个变量也许会被某种方式修改，这种方式按照正常程序流程分析是无法预知的（例如，<strong>一个变量也许会被一个中断服务程序所修改</strong>。</p>
<p>变量如果加了 volatile 修饰，则会从内存重新装载内容<strong>，而不是直接从寄存器拷贝内容。 volatile 的作用是作为指令关键字，</strong>确保本条指令不会因编译器的优化而省略，且要求每次直接读值。volatile应用比较多的场合，在中断服务程序和cpu相关寄存器的定义。</p>
<p>当某个线程只负责读，某个线程只负责写时 volatile 修饰的变量是线程安全的</p>
<h3 id="简述函数指针">简述函数指针</h3>
<p>函数指针就是一个指针变量，只不过它指向的是函数的入口地址，可以使用定义的函数指针去调用它指向的函数。概念上和指向变量的指针相似。 作用：可以用函数指针做回调函数 或者 函数的入口参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fun</span><span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;  &#125;</span><br><span class="line"><span class="keyword">char</span> * (*pfun)(<span class="keyword">char</span> *);  <span class="comment">//函数指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* (*pfun_ty)(<span class="keyword">char</span>*);</span><br><span class="line"></span><br><span class="line">pfun_ty pfun2 = fun;</span><br><span class="line">pfun = fun;</span><br></pre></td></tr></table></figure>
<h3 id="c中析构函数的作用">c++中析构函数的作用</h3>
<p>析构函数与构造函数对应，当其生命周期结束的时候，系统会自动调用析构函数，用户在类中使用了动态内存分配，就需要在析构函数中释放内存。如果用户没有显示的写析构函数，系统编译会自动生成一个析构函数。 顺序：<strong>子类本身的析构函数，子类对象成员的析构函数，基类的析构函数。</strong></p>
<h3 id="重载和覆盖的区别">重载和覆盖的区别</h3>
<p>重载：是相同的函数名，不同的参数列表（返回值没要求），程序编译时会根据调用的参数的类型选择对应的函数。编译时多态 重写： 子类继承父类，子类对父类的虚函数重写，在运行过程中确定是调用子类还是父类的函数。</p>
<h3 id="请你说一说strcpy和strlen">请你说一说strcpy和strlen</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;  <span class="comment">//strcpy是字符串拷贝函数</span></span><br><span class="line"><span class="comment">//从src逐字节拷贝到dest，直到遇到&#x27;\0&#x27;结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。</span></span><br><span class="line"><span class="comment">//strlen函数是计算字符串长度的函数，返回从开始到&#x27;\0&#x27;之间的字符个数。</span></span><br></pre></td></tr></table></figure>
<h3 id="请你说一说你理解的虚函数和多态">请你说一说你理解的虚函数和多态</h3>
<p>多态：多态分为静态多态和动态多态，前者是重载实现，在编译的时候就确定了，而后者主要通过虚函数实现，是程序运行过程中动态确定要执行那个函数。例如 父类中含有一个虚函数，子类中重写了虚函数，当new一个子类对象并使用基类指针指向它时，此时指针调用虚函数调用的其实是子类中重写的函数，这就实现了一个接口复用的功能。 虚函数的实现：虚函数通过虚函数指针和虚函数表实现。当类种某个函数申明为虚函数的时候，这个类会多一个看不见的 虚函数指针，这个指针指向虚函数表，表中放了虚函数的地址（实际虚函数在代码段）。<strong>当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</strong></p>
<h3 id="i-和-i-的-区别-以及他们的实现">++i 和 i++ 的 区别， 以及他们的实现</h3>
<p>记住 i++ 重载要使用 int 占位；而 ++i 不用；再根据作用 i++ 是先返回再自增，就是需要备份再自增，然后返回备份的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">int</span>::operate++(<span class="keyword">int</span>)&#123;   <span class="comment">// i++  先返回 再自增  使用一个int占位 和 i++ 区分</span></span><br><span class="line">	<span class="keyword">int</span> tmp = (*<span class="keyword">this</span>);</span><br><span class="line">    (*<span class="keyword">this</span>)++;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">int</span>::operate++()&#123;  <span class="comment">// ++i  先自增 再返回</span></span><br><span class="line">    (*<span class="keyword">this</span>)++;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="请你来写个函数在main函数执行前先运行">请你来写个函数在main函数执行前先运行</h3>
<p>在main函数之前运行的 有以下几个思路：</p>
<ol type="1">
<li>全局变量在 main 开始之前就初始化了 ，因此可以定义一个全局 的 类 在 这个类的构造函数 和析构函数即为 main 之前之后调用的</li>
<li>attribute 关键字</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__attribute((constructor)) <span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; start &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="智能指针shared_ptr的实现">智能指针shared_ptr的实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  关键点 ：</span></span><br><span class="line"><span class="comment">//  1. tmplate &lt;typename T&gt;  模板</span></span><br><span class="line"><span class="comment">//  2. 需要管理的指针变量设置为 T* ptr, 计数值也设置为 int * 指针，在构造函数时给 计数变量分配 内存并初始化为1</span></span><br><span class="line"><span class="comment">//  3. 除了构造函数中重新分配内存外，重载的 = 运算符  和  拷贝构造函数 都是公用计数变量 和 公用 管理的区域</span></span><br><span class="line"><span class="comment">//  4. 在拷贝构造函数中，需要先释放等号左值管理的内存区，再将其指针（计数指针和管理的指针）指向等号右边智能指针管理的地方</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPointer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">SmartPointer</span>(T* p=<span class="number">0</span>): _ptr(p), _reference_count(<span class="keyword">new</span> <span class="keyword">size_t</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p)</span><br><span class="line">			*_reference_count = <span class="number">1</span>; </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			*_reference_count = <span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">SmartPointer</span>(<span class="keyword">const</span> SmartPointer&amp; src) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;src) &#123;</span><br><span class="line">			_ptr = src._ptr;</span><br><span class="line">			_reference_count = src._reference_count;</span><br><span class="line">			(*_reference_count)++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载赋值操作符</span></span><br><span class="line">	SmartPointer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPointer&amp; src) &#123;</span><br><span class="line">		<span class="keyword">if</span>(_ptr==src._ptr) &#123;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">releaseCount</span>();</span><br><span class="line">		_ptr = src._ptr;</span><br><span class="line">		_reference_count = src._reference_count;</span><br><span class="line">		(*_reference_count)++;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载操作符</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">		<span class="keyword">if</span>(ptr) &#123;</span><br><span class="line">			<span class="keyword">return</span> *_ptr;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//throw exception</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载操作符</span></span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">		<span class="keyword">if</span>(ptr) &#123;</span><br><span class="line">			<span class="keyword">return</span> _ptr;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//throw exception</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">SmartPointer</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (--(*_reference_count) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">            <span class="keyword">delete</span> _reference_count;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T *_ptr;</span><br><span class="line">        <span class="keyword">size_t</span> *_reference_count;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">releaseCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(_ptr) &#123;</span><br><span class="line">			(*_reference_count)--;</span><br><span class="line">    			<span class="keyword">if</span>((*_reference_count)==<span class="number">0</span>) &#123;</span><br><span class="line">    				<span class="keyword">delete</span> _ptr;</span><br><span class="line">    				<span class="keyword">delete</span> _reference_count;</span><br><span class="line">    			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">SmartPointer&lt;<span class="keyword">char</span>&gt; <span class="title">cp1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">char</span>(<span class="string">&#x27;a&#x27;</span>))</span></span>;</span><br><span class="line">    <span class="function">SmartPointer&lt;<span class="keyword">char</span>&gt; <span class="title">cp2</span><span class="params">(cp1)</span></span>;</span><br><span class="line">    SmartPointer&lt;<span class="keyword">char</span>&gt; cp3;</span><br><span class="line">    cp3 = cp2;</span><br><span class="line">    cp3 = cp1;</span><br><span class="line">    cp3 = cp3;</span><br><span class="line">    <span class="function">SmartPointer&lt;<span class="keyword">char</span>&gt; <span class="title">cp4</span><span class="params">(<span class="keyword">new</span> <span class="keyword">char</span>(<span class="string">&#x27;b&#x27;</span>))</span></span>;</span><br><span class="line">    cp3 = cp4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组和字符串区别">数组和字符串区别</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * arr = <span class="string">&quot;123&quot;</span>; <span class="comment">// 存放在常量区，不能修改值</span></span><br><span class="line"><span class="keyword">char</span> * brr = <span class="string">&quot;123&quot;</span>;       <span class="comment">//和上面那个一样 也是存放在常量存储区  因为字符串默认就存储在常量存储区 不可修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> crr[] = <span class="string">&quot;123&quot;</span>; <span class="comment">//数组 应该存在 栈区域 但是加了 const 编译器会将他优化，存到常量区 不可修改</span></span><br><span class="line"><span class="keyword">char</span> drr[] = <span class="string">&quot;123&quot;</span>;	      <span class="comment">// 存放在栈区域</span></span><br></pre></td></tr></table></figure>
<h3 id="c里是怎么定义常量的常量存放在内存的哪个位置">C++里是怎么定义常量的？常量存放在内存的哪个位置？</h3>
<p>局部常量 存储在栈区，全局常量 存在全局存储区，字面值常量如字符串 存在常量区</p>
<h3 id="const-修饰成员函数的目的">const 修饰成员函数的目的</h3>
<p>在函数尾部加上 const</p>
<ol type="1">
<li>const 修饰的成员函数表明函数调用不会对对象数据成员做出任何更改</li>
<li>也不能调用该类中的没有用const修饰的成员函数</li>
<li>const对象是不可以调用类中的非const成员函数</li>
</ol>
<p>因此，如果确认不会对对象做更改，就应该为函数加上const限定。必须在成员函数的<strong>声明和定义</strong>处同时加上 const 关键字。</p>
<h3 id="c隐式类型转换">c++隐式类型转换</h3>
<ul>
<li>对于内置类型，低精度的变量给高精度变量赋值会发生隐式类型转换</li>
<li>对于只含一个参数的构造函数的对象来说，函数调用可以直接传入该类型的参数，编译器会使用该参数调<strong>用构造函数生成临时对象</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BOOK</span>  //定义了一个书类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        string _bookISBN ;  <span class="comment">//书的ISBN号</span></span><br><span class="line">        <span class="keyword">float</span> _price ;    <span class="comment">//书的价格</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//定义了一个成员函数，这个函数即是那个“期待一个实参为类类型的函数”</span></span><br><span class="line">        <span class="comment">//这个函数用于比较两本书的ISBN号是否相同</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isSameISBN</span><span class="params">(<span class="keyword">const</span> BOOK &amp; other )</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> other._bookISBN==_bookISBN;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//类的构造函数，即那个“能够用一个参数进行调用的构造函数”（虽然它有两个形参，但其中一个有默认实参，只用一个参数也能进行调用）</span></span><br><span class="line">        <span class="built_in">BOOK</span>(string ISBN,<span class="keyword">float</span> price=<span class="number">0.0f</span>):_bookISBN(ISBN),_price(price)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BOOK <span class="title">A</span><span class="params">(<span class="string">&quot;A-A-A&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">BOOK <span class="title">B</span><span class="params">(<span class="string">&quot;B-B-B&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;A.<span class="built_in">isSameISBN</span>(B)&lt;&lt;endl;   <span class="comment">//正经地进行比较，无需发生转换</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;A.<span class="built_in">isSameISBN</span>(<span class="built_in">string</span>(<span class="string">&quot;A-A-A&quot;</span>))&lt;&lt;endl; <span class="comment">//此处即发生一个隐式转换：string类型--&gt;BOOK类型，借助BOOK的构造函数进行转换，以满足isSameISBN函数的参数期待。</span></span><br><span class="line">    cout&lt;&lt;A.<span class="built_in">isSameISBN</span>(<span class="built_in">BOOK</span>(<span class="string">&quot;A-A-A&quot;</span>))&lt;&lt;endl;    <span class="comment">//显式创建临时对象，也即是编译器干的事情。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="c函数栈空间的最大值">C++函数栈空间的最大值</h3>
<p>1M 可调整</p>
<h3 id="externc">extern“C”</h3>
<p>C++ 调用 C 函数 需要 extern c 因为c语言 没有函数重载</p>
<h3 id="newdelete与mallocfree的区别是什么">new/delete与malloc/free的区别是什么</h3>
<ol type="1">
<li>前者是 C++ 的关键字，后者是C语言的库函数</li>
<li>前者不需要设置分配的空间大小，会根据对象的大小自动分配内存，并且会自动调用对象的构造函数</li>
<li>前者直接返回对象的指针，而后者返回void指针</li>
<li>前者分配失败会抛异常，后者返回空指针</li>
<li>后者分配的堆上的内存，前者默认是调用后者分配，但是在c++中称为自由存储区，即可以自己重定义分配内存的方式</li>
</ol>
<p>在默认情况下，new操作的自由存储区和堆等价，<strong>但是可以通过重载操作符，改用其他内存来实现自由存储</strong>，例如全局变量做的对象池，这时自由存储区就区别于堆了。</p>
<p>前者 c++ 的 关键字 后者 c 的内存分配的库函数，后者使用必须指明申请内存空间的大小。对于类类型的对象，后者不会调用构造函数和析构函数。</p>
<h3 id="new申请的内存可以由free释放吗">new申请的内存可以由free释放吗？</h3>
<p>简单数据类型可以，int、float这种数组没问题，但对类中动态分配内存且要在析构函数中释放的则不行、会造成内存泄露，编译不会报错—运行有可能会内存泄露</p>
<p>因为new本质上先调用operator new() 先分配内存（malloc根据不同大小在不同区域（小于的，大于128字节文件映射区）申请内存），之后再调用构造函数，delete先调用析构函数，然后再调用free释放内存。Free传入参数是void指针，所以编译不会报错</p>
<h3 id="用new申请一个数组delete怎么知道释放多少">用new申请一个数组delete怎么知道释放多少</h3>
<p>new 申请数组时 会多申请四个字节的空间用于保存大小，这四个字节位置在申请的空间的起始四个字节。</p>
<h3 id="怎样使类的实例只能使用new来生成">怎样使类的实例只能使用new来生成</h3>
<p>在栈上分配内存是 静态建立，我们定义一个变量的时候，默认在栈上分配，而new默认在堆上分配。因为是在栈上分配的内存，变量出栈会自动调用析构函数，所以编译器再看到定义的变量的时候会首先检查它的析构函数有没有，没有的话就会报错。因此可以将析构函数设置为 private 性质的 或者 protect 性质的，这样就不能静态定义变量。然后自己重新写一个 成员函数用来析构对象。</p>
<p>（重载 new 关键字并将它设置为 delete 就可以使类<strong>只能在栈上分配</strong>）</p>
<p>在栈上分配就是定义函数局部变量嘛 这时候编译器会自动检测该变量是否有构造函数和析构函数， 如果没有 你就不能定义；但是new 分配内存时它就只管你是否有构造函数 所以 将析构函数设置为 private 即可 使得只能 new 构造 但是需要自己重新实现一个 析构函数</p>
<p>如果不想让他 new 构造 那就 重载 new 函数并把它设置为 delete</p>
<h3 id="rtti">RTTI</h3>
<p>实现原理就是在 虚表的 -1 项存储类型信息，在编译器打开RTTI选项后 就可以使用 typeid 方法在运行过程中获取类别信息 dynamic_cast就是通过这个原理实现的</p>
<h3 id="c语言怎么进行函数调用的">c语言怎么进行函数调用的</h3>
<p>每个函数在栈上都有一个栈帧。当调用函数时，首先要将调用方的 栈底指针ebp，返回地址即下一条将要执行的指针，还有其他cpu的关键寄存器值存入当前函数栈的栈帧，此步骤即保存现场，接着为调用函数分配新的栈帧，即将当前esp指针作为新函数栈的ebp，PC指针设置为调用函数的地址从而实现程序跳转，如果有参数，将函数入口参数从右往左压入新的栈帧。函数调用结束后释放当前函数栈帧，并按序恢复调用前的现场。</p>
<p>ESP指针 栈指针 EBP 栈底指针 PC 程序计数器 EXA乘加运算的临时值</p>
<p>会分配函数栈，在栈内进行函数执行，先将返回地址地址压栈，再把当前函数的esp指针压栈</p>
<h3 id="c语言参数压栈顺序">C语言参数压栈顺序</h3>
<p>从右往左</p>
<h3 id="c如何处理返回值">c++如何处理返回值</h3>
<p>如果反之值可以使用 eax 等寄存器存储，直接用cpu寄存器传递。 如果需要的空间较大 创建临时变量，将临时变量的引用作为函数参数输入函数</p>
<h3 id="c拷贝构造函数能否值传递">c++拷贝构造函数能否值传递</h3>
<p>不能，会无限循环</p>
<h3 id="fork-函数">fork 函数</h3>
<p>pid_t fork(void); 成功调用 fork函数后，fork会创建出一个新进程，他几乎和调用fork的进程一模一样，不同的是，父进程中，fork返回的是 子进程的pid , 子进程中fork返回的是 0 ；可以根据这两个来区分是子进程还是父进程 这样来并行的执行两个任务。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>面经C++汇总</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>HDR+</title>
    <url>/posts/51754/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="hdr">HDR+</h1>
<p>Burst photography for high dynamic range and low-light imaging on mobile cameras</p>
<p><a href="https://blog.csdn.net/zbwgycm/article/details/82458240">参考链接</a></p>
<h2 id="主要思想">主要思想</h2>
<ol type="1">
<li>不使用多曝光。而是使用一个固定的较低的曝光时间和增益采集多帧图像。将这个曝光设置的足够低以比避免过曝溢出</li>
<li>直接对bayer格式的数据处理，而不是RGB。一方面采集多帧如果都用RGB格式那每张都要经过ISP，另一方面ISP会对RAW图像做个非线性化，使得去噪变得困难</li>
<li>使用了基于 FFT 的快速对齐算法</li>
</ol>
<p>主要思想是，首先使用多帧低照度的 raw 格式的图像做去噪融合成一张（这是一个常用多帧去噪手段），然后使用一个自适应的曝光算法将该图像扩展到长短曝光后融合，最后将处理后的 RAW 数据 经过ISP流程得到结果。</p>
<h2 id="主要内容">主要内容</h2>
<ol type="1">
<li>故意曝光不足避免过曝而不可逆</li>
<li>采集多帧用于抑制暗区域噪声</li>
<li>使用自动曝光算法 设置长短曝光参数，短曝光参数用于调整相机硬件参数来采集固定曝光的图像，长曝光参数用于对短曝光图像做tone map合成长曝光图</li>
<li>使用 像素级的 曝光融合方法 融合长短曝光图像</li>
<li>色调映射（tone map）压缩动态范围</li>
</ol>
<h3 id="自动曝光">自动曝光</h3>
<p>这一步其实是在多帧去噪融合之后使用的，按照原文顺序先介绍了。</p>
<p>现在的 ISP 中都集成了 自动对焦 自动曝光 自动白平衡算法（3A），理论上我们可以直接使用ISP中自带的自动曝光算法根据场景自动设置相机曝光参数，然后再沿用这个参数采集多帧固定曝光的图像用于后续的融合去噪。但是，对于高动态范围的场景，拍摄的图像可能包含无法通过后期 HDR 色调映射恢复的高光或曝光不足的区域。（个人感觉主要是过曝不可逆，所以要避免）</p>
<p>因此其实最终是对 两张gamma矫正后的图像做融合，其中一个是多帧去噪后的欠曝光图，另一张是对欠曝光后的图使用数字曝光补偿后的图。因此自动曝光算法可以 表述 为两个曝光水平：</p>
<ul>
<li><strong>合成长曝光</strong>：由短曝光图合成的长曝光图，在色调映射中用于恢复阴影区域</li>
<li><strong>短曝光</strong>：用于捕捉场景中亮的区域</li>
</ul>
<p><em>动态范围</em>： 图像能捕捉的场景中的光亮度的范围。自然场景中的动态场景通常特别高，人眼能看到的范围也很大。而通常相机能表示的范围只有256中。即便相机能采集到大动态范围的图像，但是一般的显示器能显示的亮度等级也有限，一方面为了弥补相机自生的动态感知范围不足的问题常常采用多曝光融合的方式来合成高动态的图像（场景亮暗细节都能保留），另一方面还要通过tone map色调映射技术将HDR图像压缩为，转换成可以在显示器上显示出更符合人眼视觉的LDR图像。<a href="https://zhuanlan.zhihu.com/p/90093872">动态范围</a></p>
<p>虽然说要尽量先使用低曝光的图像去采集多帧图像，从而避免饱和。但是曝光太低意味着噪声太强，需要融合更多帧来抑制噪声，这需要付出计算代价。同时如果过分的压缩动态范围（我理解为这是 Tone map 这一步的压缩动态范围，将合成的高动态图使用色调映射手段压缩为显示器可以显示的范围）会出现卡通效应（就是阴影部分被过度提亮了）<strong>文章中设置的压缩比为8（即最亮：最暗大约8比1）</strong></p>
<h4 id="基于实例的自动曝光">基于实例的自动曝光</h4>
<p>构建了一个包含5000个场景的数据集，并手动给每张图片标注 短曝光参数 和 长曝光参数，前者用于采集图像的曝光参数，后者用于后面 tone map 的参数。给定一帧raw的输入图像，提取他的特征描述符并在数据库中寻找与他对应的候选样例，然后将所有候选样例手动标注的两个参数分别做一个简单的加权融合。</p>
<ul>
<li>用于计算特征描述符的图像保证是白平衡的</li>
<li>是在大幅下采样的版本上计算特征描述符，用于量化场景亮度分布</li>
<li>四组64纬的特征，其中两组在两个不同的尺度空间上提取的，其中两组提取自图像 max(R,G,B) 和 avg(R,G,B)；前者用于代表频率空间的曝光，后两组用于关注颜色削波 <font color=red>（color clipping ？？？？？不懂）</font></li>
<li>带注意力的特征提取手段，通常情况下计算特征时都是给与图像中心更多的权重，当选择中人脸时也可以给与选定区域较大的权重。</li>
<li>选取候选实例中亮度在当前场景亮度8倍的实例，以防止昼夜颠倒的不真实情况</li>
</ul>
<h4 id="曝光参数分解">曝光参数分解</h4>
<p>通过前面可以计算出 长短曝光参数。那么这一步就是要将从实例中查询计算的短曝光参数 分解为 真实的相机参数（相机曝光时间和曝光增益）然后修改相机参数再去采集图像。这一步使用一个固定的策略来 平衡噪声 和 运动模糊（如果曝光时间长就会有运动模糊）之间的关系</p>
<ul>
<li>对于亮的场景，曝光增益设置到最低，而曝光时间提高到8ms</li>
<li>当场景变得暗时，曝光时间固定8ms不变，曝光增益x4</li>
<li>最后曝光时间和曝光增益一起成比例的提高，曝光时间上限100ms 曝光增益上限96x 为了尽可能提高采集图像的信噪比，尽可能提高曝光增益</li>
</ul>
<p><font color=red>（这个过程不是很理解 为何要这么做 以及前面的短曝光参数在这一步做何用？）</font></p>
<h4 id="图像数量burst-size">图像数量(burst size)</h4>
<p>在较亮的场景 使用1~2张图即可，因为噪声不多，虽然多一点图也可以抑制运动模糊啥的。在低光照环境下 或者 高动态场景下，通常要将低亮度的区域亮度拉升，会有噪声，因此需要较多帧去噪，提高信噪比。</p>
<p>通常作者 会限制 图像数量才 2~8 张</p>
<h4 id="图像流采集">图像流采集</h4>
<p>自动曝光算法运行在ISP之前。每四帧图像做一次 自动曝光的参数 计算，计算一次大概10ms，没必要每次都计算因为场景不会急速变化，但是也不能太久计算一次参数，免得场景切换时显示有延迟。</p>
<p>另一个问题就是，高动态场景中如果包含大量过曝的像素，对估计 低曝光参数 有影响，因此作者通过 忽略 部分过曝像素来计算 匹配参数能较好地匹配样例中相似的低光照场景 <font color=red>（？）</font></p>
<h3 id="帧对齐">帧对齐</h3>
<p>常用的对齐方法是光流对齐，这种方法可以对齐非刚体形变，但是计算复杂度很高。出于速度、内存和性能（毕竟是移动端）的折衷考虑，作者提出了一个简单的对齐的方法，虽然这种方法无法应对非刚性形变并且误差比较大，但是后续的多帧融合算法对这个误差比较鲁棒，所以即便是使用这个简单快速的对齐方法，整体效果也可以接受。</p>
<h4 id="选参考帧">选参考帧</h4>
<p>参考帧选择尽可能清晰的帧。根据基于原始输入绿色通道中梯度的简单度量，选择参考帧作为突发子集中最清晰的帧。同时为了最大限度地减少快门延迟，按下快门后连拍并从前 3 帧中选择参考帧。</p>
<h4 id="处理raw图像">处理raw图像</h4>
<p>raw数据格式实际是一整张 RGGB 排列的图像，包含了四个颜色平面。作者直接使用 2X2 的平均池化 得到 下采样的灰度图，对该灰度图像做配准。（我觉得这里不必拘泥于是不是 严格的灰度，因为最后对齐的损失函数使用像素差异来做的，即便不是标准的 RGB-&gt;gray也不太影响对齐性能）</p>
<h4 id="分层配准">分层配准</h4>
<p>作者采用了一个由粗到细的配准策略。具体的是构建一个高斯金字塔的结构，先从顶层配（粗）， 将上层的配准结果作为下一层的固定偏移。每层配准的表达式</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210628093708.png" alt="" /><figcaption>image-20210628093708522</figcaption>
</figure>
<p>其中 u0 v0 为上一层配准的偏移结果，p 可能是 L1/L2距离，n 是计算相似度窗口的大小。u v 即为要求的 偏移；因此求u v 即为优化D的最小值。关于窗口的大小 和 采用的损失类型会在后面讨论。另外这里没有采用归一化互相关系数类似NCC中的东西对光照对比度做归一化是因为作者认为采集的几帧图像都是在相同曝光才采集的亮度一致。</p>
<p><font color=red> 边界情况怎么处理？</font></p>
<p>根据不同的尺度层，采用了不同的超参数。在粗尺度下，使用L2损失和大搜索半径来做对齐（这里的较大搜索半径如何理解？理解为偏移吧），以提高初始对齐的准确率；在底层，使用L1损失和较小的搜索半径。按照文中的说明：</p>
<ul>
<li>最底层，使用+-1的搜索半径，L1损失，图像块为16X16</li>
<li>接着，对上层做二倍下采样，+-4搜索半径，L2损失</li>
<li>接着，对上层做四倍下采样，+-4搜索半径，L2损失</li>
<li>…</li>
</ul>
<p>个人理解，最底层的L1损失精度最高，但是计算比较耗时。高层的L2损失可以做加速，优化的计算方法中这个搜索半径其实就是一个限幅的作用，并不会实际对每组偏移都计算然后选一个最优，而是最小化二次式的最优估计的方式，因此这里添加的搜索半径其实就是个限度，并不会实际影响计算速度，而这里的限度估计也是怕高层估计误差太大跑偏太远使得当前层无法对上一层的偏差纠正。由于在高层有了粗略偏移估计，所以在最低层使用+-1的搜索半径就行。</p>
<p>如果不采用尺度金子塔的策略，最底层就要 做一个搜索半径变化范围很大的对齐，例如可能一次就要估计出 +20 的偏移，如果使用L2加速对齐策略，这里一次L2最优估计很容易陷入局部最优，采用L1做精细搜索显然计算量很大。</p>
<h4 id="快速l2对齐">快速L2对齐</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210628111641.png" alt="" /><figcaption>image-20210628111641192</figcaption>
</figure>
<p>其实就是前面那个 L2 损失 可以分解为为局部和、局部平方和 以及 卷积计算两部分。前者可以通过积分图加速，后者可以在频域加速。然后假设为 D2为 待估计参数偏移 （u,v）的一个二元二次表达式，如下，我们可以通过计算几个固定偏移 (u v) 下对应的 D2值来估计固定参数A ,b c</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210628111927.png" alt="" /><figcaption>image-20210628111927519</figcaption>
</figure>
<p>最后全局最优值 (u , v) 即为:</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210628112051.png" alt="" /><figcaption>image-20210628112051053</figcaption>
</figure>
<p>所以这是一种近似最优的L2加速方法，不需要搜索每个可能的偏移值，只需要计算几个离散的点做一个二次多项式拟合。</p>
<h3 id="多帧去噪">多帧去噪</h3>
<h4 id="时域去噪">时域去噪</h4>
<p>这也是该文章的核心部分，通过连拍实现对同一场景做多次观察来实现降噪。但是从上面的对齐策略可以看出，前面的对齐只考虑了刚性变化，对于非刚性运动遮挡等问题，上述的对齐方法无法估计。因此这就要求<strong>这一节的多帧融合方法可以对上述的对齐误差鲁棒。</strong></p>
<p>采用了 成对的时域合并方法。</p>
<p>首先对每帧图像 变换到频域 T0 为参考帧的频谱图</p>
<ol type="1">
<li>首先一个方法，如下式，简单的将每个帧的频谱图加权平均，但是这样效果最差，<strong>因为正交变换是线性的，这样加权等同于直接在空域中对多帧取平均</strong>，因此如果有旋转不对齐的情况鬼影就很严重。</li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210704160856.png" alt="" /><figcaption>image-20210704160856275</figcaption>
</figure>
<ol start="2" type="1">
<li><p>接着还有 3D 卷积的方法，类似于BM3D中的做法 参考 <a href="../传统图像处理/图像处理-传统去噪算法汇总.md">图像处理-传统去噪算法汇总.</a> 将时域的图像组成3D块然后先对两维变换再在时域第三维做变换，利用白噪声正交变换分布不变的思路通过新增维度的正交变换将能量进一步聚集，拉开噪声幅值和信号幅值的差距，然后采用硬阈值或者软阈值滤波滤掉噪声。但是这种方法也要依赖相似块是否对其，否则在第三维中会引入新的频带信号和噪声混合被一同滤除，相当于还是做了模糊。</p></li>
<li><p>最后作者的方法是 对 1 的一个改进。如下式，其实就是 (1 - A) T + A T0 A是个系数 。相当于在参考帧 和 其他帧 的频谱之间做了个线性插值，而不是直接取平均。这个插值系数由 两帧之间的频谱差异 D 计算。但是不是简单的差异，而是拿噪声的强度做了个参考，如果差异相对噪声频谱的强度很大，表明不对齐，那么就给较小的插值系数；反之给较大的权重。<strong>系数 类似 像素级别的维纳收缩的系数</strong>，<strong>只不过维纳收缩中 使用信号噪声的比 来确定收缩系数，这里使用 频谱功率差异和噪声的比来确定每对儿的插值系数。</strong></p></li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210704162829.png" alt="" /><figcaption>image-20210704162829608</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210704162934.png" alt="" /><figcaption>image-20210704162934904</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210704162947.png" alt="" /><figcaption>image-20210704162947537</figcaption>
</figure>
<p>最后，作者说他们的方法 可以在 图像去噪质量 和 鬼影问题 做个较好的权衡</p>
<h4 id="空间去噪">空间去噪</h4>
<p>通过上一节对时域中的多帧频谱图像平均达到了 减小噪声方差的目的，如果是N张平均可以理解为噪声缩小了 sigma^2 / N，得到一张滤波后的二维频谱图。按照<strong>维纳滤波收缩的形式（即使用信噪比估计收缩系数）</strong>，再在空域对频谱幅值做收缩。但是这一次根据人眼视觉特性，<strong>人眼对高频区的人造痕迹不是很敏感</strong>，所以根据这个特性 作者对不同频带的噪声强度乘了个系数，给高频区域更高的噪声强度，从而降低对高频区域的滤波程度（即尽可能保留高频区域的纹理）。其中 f(w) 是个分段线性的函数。<strong>通过此举，来尽量提高图像的视觉效果 而 不是 SNR</strong></p>
<p>也正是这种 不同频段设置不同噪声水平的维纳滤波方法，使得最后在高对比度的区域噪声抑制效果不好</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210704170800.png" alt="image-20210704170800576" style="zoom:50%;" /></p>
<h3 id="融合bayer数据">融合Bayer数据</h3>
<p>对 bayer 图像的每个颜色平面分别对齐融合。</p>
<p>然后就帧融合是 一个块一个块进行的，这些块之间设置一定的重叠，为了防止出现块边缘的不连续效应，使得融合更加平滑，对块进行窗函数操作。在DFT域使用升余弦函数。</p>
<h4 id="问题">问题</h4>
<ol type="1">
<li>这种滤波方法不能有效地抑制高对比度区域（如强边缘区域）的噪声。这是由于高对比度区域在空间DFT域的分布是非稀疏的，削弱了空间降噪的有效性。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210704192601.png" alt="image-20210704192601394" style="zoom:50%;" /></p>
<ol start="2" type="1">
<li>由于算法不会拒绝一个不能完全配准的 块 ，所以有时候会出现轻微的鬼影。</li>
</ol>
<p><img src="C:/Users/10729/AppData/Roaming/Typora/typora-user-images/image-20210704192645530.png" alt="image-20210704192645530" style="zoom:50%;" /></p>
<ol start="3" type="1">
<li>有时会出现振铃效应，作者说该现象基本可以忽略不计；（若频域滤波函数具有陡峭变化，则傅里叶逆变换得到的空域滤波函数会在外围出现震荡）</li>
</ol>
<h3 id="合成hdr">合成HDR</h3>
<p>经过配准和融合之后，拍摄的多帧Bayer raw图像合成单张raw图像，且具有更高的bit深度和SNR。实际中，输入10bit的raw数据会合成12bit的数据。得到输出raw图像后，还需要一系列的ISP后处理流程才能得到可视化RGB图像。这些步骤主要包括：</p>
<ol type="1">
<li>暗电流扣除</li>
<li>镜头阴影校正</li>
<li>白平衡</li>
<li>去马赛克</li>
<li>彩色去噪</li>
<li>颜色校正</li>
<li>动态范围压缩</li>
<li>去雾</li>
<li>全局色调调整</li>
<li>色差校正</li>
<li>锐化</li>
<li>特定色调颜色调整</li>
<li>dithering</li>
</ol>
<p>其中，动态范围压缩步骤中，利用获取的短曝光图像以及合成的长曝光图像来 融合。融合方法采用了 Exposure Fusion 文章中的方法融合。但是这里作者只用了亮度这一个评判因素，计算两张图的亮度权重，加权融合（这样节省计算量）合后做gamma校正并将原来的颜色赋值上去。</p>
<h4 id="问题-1">问题</h4>
<p>在极端动态范围场景，可能存在过曝光区域。在有快速运动的低光场景，为了避免运动模糊使用较短的曝光时间，可能会残留比较剧烈的噪声。在高对比度场景中，由于使用了曝光融合，可能会存在轻微的中频halos。</p>
<h2 id="实验结果">实验结果</h2>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>KinD Net</title>
    <url>/posts/41988/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="主要贡献">主要贡献</h2>
<ol type="1">
<li>总结了微光图像增强中存在的挑战：
<ul>
<li>如何有效的从单张图像中估计光照，并且可以灵活的调节光照等级</li>
<li>如何去除之前隐藏在黑暗中的噪声和颜色失真等退化现象</li>
<li>在没有充足的训练样本和完美的ground-truth的情况下训练低光照增强网络模型</li>
</ul></li>
<li>和RetinexNet模型类似：
<ul>
<li>基于Retinex理论 使用网络将图片分解为两个部分：光照和反射率</li>
<li>网络的训练是基于一对低光照正常光照图像，而不是使用反射率和光照groundtruth</li>
<li>提供了一个光照映射图可以调节的 灵活的调节网络 以供不同的需求</li>
<li>提出了一个可以有效消除由于光照增强放大的暗区域噪声的模块</li>
</ul></li>
</ol>
<h2 id="研究现状">研究现状</h2>
<p>​ Plain Methods： 基于直方图均衡化的方法，gamma矫正的方法。这类方法缺点是很少考虑光照因素 ​ Traditional Illumination-based Methods : 传统基于光照的方法。例如SSR MSR NPE等，通过调整图像光照来增强，这类方法通常没有考虑色彩失真和噪声。 ​ 基于深度学习的方法：</p>
<h2 id="论文理论">论文理论</h2>
<h3 id="主要思想">主要思想</h3>
<p>​ 没有完美的光照图和反射率图，因此需要根据各种约束条件来优化分解网络。作者认为，微光图像中的噪声在暗区域较亮区域的影响更大，因为暗区域的微小噪声和颜色失真会一起被放大，所以作者认为用光照图来指导反射率图去噪重建效果会比直接用DBM3无差别的对反射率图去噪好。最后，作者认为正常微光图像的退化程度相对于正常光照图片要严重，这些退化的因素会随着反射率图最终传递到最后的结果，因此作者认为可以使用正常图像分解产生的反射率图作为低光照图分解的反射率图重建（去噪，颜色矫正等）的指导。作者申明这种使用良好的反射率图做指导和直接使用原图做指导完全不同。</p>
<h4 id="光照图指导的反射率重建">光照图指导的反射率重建：</h4>
<p><span class="math display">\[
\mathbf{I}=\mathbf{R} \circ \mathbf{L}+\mathbf{E}=\tilde{\mathbf{R}} \circ \mathbf{L}=(\mathbf{R}+\tilde{\mathbf{E}}) \circ \mathbf{L}=\mathbf{R} \circ \mathbf{L}+\tilde{\mathbf{E}} \circ \mathbf{L}
\]</span></p>
<p>I为输入低光照图，R为本身的反射率图，L为原本的低光照图。如果将图像分解，会将噪声分解到<span class="math inline">\(\tilde{\mathbf{R}}\)</span> 此时包含(R + E)因此最后调整光照强度再还原时，E与L一起被放大，因此需要用L来指导去噪。那么为什么不直接从输入微光图像I中去除E呢？一方面光照不平衡的问题存在，另一方面内部的细节和噪声不均匀地混合在一起，再就是由于L 的存在是个变量，没有合适的方法去掉，就是同一个场景光照不同噪声强度也不同，难以在参杂一个光照变量的情况下很好的去除噪声，而反射率图就更纯粹，比较适合用来去噪。</p>
<h2 id="kind-network">Kind Network</h2>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212250.png" alt="" /><figcaption>1572948093087</figcaption>
</figure>
<h3 id="分解网络">分解网络</h3>
<p>​ 训练时网络有输入成对的图像 Il Ih</p>
<ol type="1">
<li>保证输入的低光照和正常光照图像分解产生的反射率图相同：</li>
</ol>
<p><span class="math display">\[
\mathcal{L}_{r s}^{L D}:=\left\|\mathbf{R}_{l}-\mathbf{R}_{h}\right\|_{2}^{2}
\]</span></p>
<ol start="2" type="1">
<li>光照图平滑约束，其中<span class="math inline">\(\nabla\)</span>表示梯度。max( <span class="math inline">\(\epsilon\)</span>)避免分母除0 这里是通过输入图像的梯度加权光照梯度的，而Retinex中是通过反射率图加权。可以看出，输入图像边缘处梯度大，光照图对应的梯度损失小，允许此处的光照分布不那么平滑。</li>
</ol>
<p><span class="math display">\[
\mathcal{L}_{i s}^{L D}:=\left\|\frac{\nabla \mathbf{L}_{l}}{\max \left(\left|\nabla \mathbf{I}_{l}\right|, \epsilon\right)}\right\| 1+\left\|\frac{\nabla \mathbf{L}_{h}}{\max \left(\left|\nabla \mathbf{I}_{h}\right|, \epsilon\right)}\right\|
\]</span></p>
<ol start="3" type="1">
<li>底/高输入图像的低/高光照图的结构一致性。作者给出了u<em>exp(-c</em>u)的变化曲线，先增后减。大概意思是，如果两个光照图的梯度都很大或者都很小，输出loss很小，如果一大一小则loss很大，也符合这个函数的变化规律。 ？？</li>
</ol>
<p><span class="math display">\[
\mathcal{L}_{m c}^{L D}:=\|\mathbf{M} \circ \exp (-c \cdot \mathbf{M})\|_{1} \text { with } \mathbf{M}:=\left|\nabla \mathbf{L}_{l}\right|+| \nabla \mathbf{L}_{h}
\]</span></p>
<ol start="4" type="1">
<li>将分解产生的结果要能尽可能还原回原输入图</li>
<li>$ _{h} $</li>
</ol>
<p><span class="math display">\[
\mathcal{L}_{r e c}^{\hat{L} D}:=\left\|\mathbf{I}_{l}-\mathbf{R}_{l} \circ \mathbf{L}_{l}\right\|_{1}+\left\|\mathbf{I}_{h}-\mathbf{R}_{h} \circ \mathbf{L}_{h}\right\|_{1}
\]</span></p>
<ol start="5" type="1">
<li>最后将上述损失按权重相加即可 0.01，0.08，0.1，1</li>
</ol>
<h3 id="反射率重建网络">反射率重建网络</h3>
<p>​ 该部分在Deep RetinexNet中使用的DBM3去噪，然后和光照调整网络整合出输出结果。而在改论文中使用了Unet类似的编解码网络重建。输入为 低光照图分解产生的 R 和 I 。I 用来指导R的重建，高质量图产生的R作为groundtruth来计算损失。同样的 把纹理细节也计入了损失。 <span class="math display">\[
\mathcal{L}^{R R}:=\left\|\hat{\mathbf{R}}-\mathbf{R}_{h}\right\|_{2}^{2}-\operatorname{SSIM}\left(\hat{\mathbf{R}}, \mathbf{R}_{h}\right)+\left\|\nabla \hat{\mathbf{R}}-\nabla \mathbf{R}_{h}\right\|_{2}^{2}
\]</span></p>
<h3 id="亮度调整网络">亮度调整网络</h3>
<p>​ 计算两个光照图之间的关系的方法为：ta = mean(L1/L2) 在网络训练是可以以低光照图作为输入待调整，高光照亮度图作为groundtruth 同时计算二者的调节系数a 并扩充为一个featuremap一起输出网络。最后的损失为： <span class="math display">\[
\mathcal{L}^{I A}:=\left\|\hat{\mathbf{L}}-\mathbf{L}_{t}\right\|_{2}^{2}+\left\||\nabla \hat{\mathbf{L}}|-\left|\nabla \mathbf{L}_{t}\right|\right\|_{2}^{2}
\]</span></p>
<h2 id="实验结果">实验结果</h2>
<p>​ 主要在LOL数据集上对比和各种算法。包含500对正常/低光照图像。分解网络batchsize=10, path-size=48X48。分辨率重建网络和光照跳着网络batch size为4，384X384大小。SGD优化</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212307.png" alt="" /><figcaption>1572948721689</figcaption>
</figure>
<h2 id="后续版本-kindd">后续版本 KindD ++</h2>
<figure>
<img src="https://github.com/zhangyhuaee/KinD_plus/blob/master/figures/restoration_net2.jpg?raw=true" alt="" /><figcaption>restoration_net2.jpg</figcaption>
</figure>
<p>主要是改进了 重建网络 光照图深入重建网络的各个层 ，且重建网络中使用多尺度的卷积contact</p>
<p>本文的创新点在于：</p>
<ul>
<li>将光照图作为反射率图去噪重建的指导</li>
<li>光照图的光照强度可调整功能</li>
<li>分解网络中 对光照强度的梯度平滑中的权重 感觉较RetinexNet网络的好</li>
<li>将正常光照的反射率图作为低光照图反射率图去噪调整的groundtruth</li>
</ul>
<p>感觉的缺点：</p>
<ul>
<li>分解网络结构</li>
</ul>
<hr />
<h2 id="文章复现遇到的问题">文章复现遇到的问题</h2>
<ol type="1">
<li>在使用LOLDateset数据集时， 一定要注意正常光照图和低光照图成对儿 LOLDatesat数据中 高低光照图的名字是一样的，但是两个文件夹中 低光照的图片不一定能在高光照文件夹中找到对应名字的图 这种图应该舍去 一开始读取数据的方法是排序后取相同位置的图片做一对儿 这样不行 因为有漏序号的 后面就都错位了</li>
<li>分解网络 论文给的详细网络结构没有BN层 <strong><em>不能加BN层！！！！</em></strong>！ 一开始以为BN层只有好处没坏处 结果加了死活不能收敛<br />
</li>
<li>在批量训练时 有时候在每个epoch最后一批 Loss可能会跳 可能因为 总的训练样本数量 / batch_size 不能整出 dateloader 中 drop_last = True 舍弃最后一批<br />
</li>
<li>原版本的用2X2卷积计算的梯度，这种偶数的卷积核在边界会补0 但是计算完后没有把补0的边界填充0 会有白边，这不影响，在加上规范化后，由于百边的影响会使整体的梯度幅值偏小。所以复现时不用卷积算梯度后补0 整体梯度比用卷积算的大0.02左右 梯度整体偏大会使光照图区域灰色的一片....</li>
</ol>
<h3 id="关于分解网络损失权重的讨论">关于分解网络损失权重的讨论</h3>
<h4 id="按照原始的损失权重的定义-结果">按照原始的损失权重的定义 结果</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212321.png" alt="" /><figcaption>1573788470551</figcaption>
</figure>
<p>可以看出 网络映射成了恒等映射， 分离出来的光照分量恒为1 这种情况，重建损失很低，但是R的相似度也很低，但是由于其权重只有0.01 所以被削弱了。感觉不符合分解的目的。</p>
<h4 id="rec-rs-is-mc-110.080.1">rec, rs, is, mc = 1,1,0.08,0.1</h4>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210508212328.png" alt="" /><figcaption>1573789025322</figcaption>
</figure>
<p>​ 可以看出增R反射率损失的权重</p>
<hr />
<h3 id="官方代码">官方代码</h3>
<p>​ 与论文描述不一致的地方</p>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
激活函数使用的是 lrelu 斜率为0.2</li>
<li><input type="checkbox" disabled="" />
对梯度进行了去均值归一化 先归一化再数据扩增 还是先扩增再归一化 有区别？ 程序错误没有裁剪 patch ！！！！！！</li>
<li><input type="checkbox" disabled="" />
分解网络equal_r 损失为L1损失而 文章中为平方MSE损失</li>
<li><input type="checkbox" disabled="" />
分解网络中 mc损失 x y 分别计算reduce平均求和 权重0.15 加权TV损失权重为0.2</li>
</ul>
<hr />
<p>别人的笔记</p>
<h1 id="kindling-the-darkness-a-practical-low-light-image-enhancer">Kindling the Darkness: A Practical Low-light Image Enhancer</h1>
<p>paper：<a href="https://arxiv.org/abs/1905.04161">Kindling the Darkness: A Practical Low-light Image Enhancer</a></p>
<h2 id="abstract">Abstract</h2>
<ul>
<li>类似Retinex理论，将图片分解为2部分。
<ul>
<li>一部分用于光照调整（illumination）</li>
<li>另一部分用于degradation removal（reflectance）</li>
</ul></li>
<li>原始空间被解耦为2个子空间，以便学习</li>
<li>网络是用成对的不同曝光条件的图像去训练，而不是用reflectance and illumination的GT</li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>一些操作在一些环境上可以用于调整图像的质量，但也存在缺点。比如，高ISO虽然增加了图像传感器对光的敏感度，但是噪声也放大了，因此造成了低信噪比SNR。长曝光受限于拍摄静态场景，否则图像会变得模糊。使用闪光灯虽然可以照亮环境，但会带来意想不到的高光和不平衡的光线，视觉效果不太好。</p>
<p><strong>3种不好处理的光条件：</strong></p>
<ul>
<li>极度低光，一些噪声和颜色失真隐藏在黑暗中。</li>
<li>在日落拍摄的照片，物体在逆光下受影响。</li>
<li>中午对着光源拍照也比较难处理</li>
</ul>
<p>low-light image增强没有真实数据的GT，因为每个人喜欢的light level是不一样的，所以没人可以说什么光条件就是最好的。</p>
<p>作者总结了low-light image enhancement的challenges 有以下几点：</p>
<p><strong>1.如何有效的从单张图像中估计出光照图成分，并且可以灵活调整光照level?</strong></p>
<p><strong>2.在提升图像亮度后，如何移除诸如噪声和颜色失真之类的退化？</strong></p>
<p><strong>3.在没有ground-truth的情况下，样本数目有限的情况下，如何训练模型？</strong></p>
<h3 id="previous-arts">1.1 Previous Arts</h3>
<h4 id="plain-methods"><strong>（1）Plain Methods：</strong></h4>
<p>处理在全局低光照的图像的比较直观的方法是放大图像，但会在细节上有噪声和颜色失真。</p>
<p>在颜色较亮的区域，放大操作经常会导致颜色过饱和以及过度曝光。</p>
<p>直方图均衡化（histogram equalization，HE），试图把值映射在[0,1]，平衡输出的直方图来解决这个问题。</p>
<p>伽马矫正（gamma correction，GC），以非线性的方式在每个像素执行。虽然GC可以对暗像素进行提亮，但没考虑每个像素之间的相邻关系。</p>
<p>这些普通方法的缺点是，不考虑真实光照因素，导致增强的效果不好，与真实场景不同。</p>
<h4 id="traditional-illumination-based-methods">（2）Traditional Illumination-based Methods:</h4>
<p>与plain method不同的是，传统的基于光照的方法注意到光照的重要性。</p>
<p><strong>Retinex理论：</strong>有颜色的图片可以被分解为2部分，反射率和光照。</p>
<p>比较早提出理论有：</p>
<ul>
<li>single-scale Retinex，SSR
<ul>
<li>D. J. Jobson, Z. Rahman, and G. A. Woodell, “Properties and performance of a center/surround retinex,” IEEE Transactions on Image Processing, vol. 6, no. 3, pp. 451–62, 1997.</li>
</ul></li>
<li>multi-scale Retinex，MSR
<ul>
<li>D. J. Jobson, Z. Rahman, and G. A. Woodell, “A multiscale retinex for bridging the gap between color images and the human ob- servation of scenes,” IEEE Transactions on Image Processing, vol. 6, no. 7, pp. 965–976, 2002.</li>
</ul></li>
</ul>
<p>这些方法生成的结果通常不真实，且在有的地方过度增强。</p>
<p>之后又有一些方法进行改进：</p>
<ul>
<li><ol type="1">
<li>NPE：在增强对比度的同时保护自然光照。</li>
</ol>
<ul>
<li>D. J. Jobson, Z. Rahman, and G. A. Woodell, “A multiscale retinex for bridging the gap between color images and the human ob- servation of scenes,” IEEE Transactions on Image Processing, vol. 6, no. 7, pp. 965–976, <strong>2002.</strong></li>
</ul></li>
<li><p>2.通过融合最初光照估计的多重推导来进行调整光照。</p>
<ul>
<li>X. Fu, D. Zeng, H. Yue, Y. Liao, X. Ding, and J. Paisley, “A fusion- based enhancing method for weakly illuminated images,” Signal Processing, vol. 129, pp. 82–96, <strong>2016</strong></li>
<li>缺点：有时会牺牲真实区域的丰富纹理。</li>
</ul></li>
<li><p>3.从初始光照图估计结构光照图。</p>
<ul>
<li>X. Guo, Y. Li, and H. Ling, “Lime: Low-light image enhancement via illumination map estimation,” IEEE Trans Image Process, vol. 26, no. 2, pp. 982–993, <strong>2017</strong></li>
<li>缺点：假设图像是无噪声和无颜色失真的，没有考虑到退化问题</li>
</ul></li>
<li><p>4.提出权重变分模型同时估计反射率和光照估计（SRIE），通过调整光照生成图像</p>
<ul>
<li>X. Fu, D. Zeng, Y. Huang, X. Zhang, and X. Ding, “A weighted variational model for simultaneous reflectance and illumination estimation,” in IEEE Conference on Computer Vision and Pattern Recognition, pp. 2782–2790, <strong>2016</strong></li>
</ul></li>
<li><p>5.在3的基础上提出了引入了an extra term to host noise</p></li>
</ul>
<p>缺点：4、5虽然可以处理图像的弱噪声，但不擅长处理颜色的失真和强噪声。</p>
<h4 id="deep-learning-based-methods">（3）Deep Learning-based Methods</h4>
<ul>
<li>LLNet（low-light net）,建立深度模型作为同时处理对比度增强和去噪的模块。
<ul>
<li>K. G. Lore, A. Akintayo, and S. Sarkar, “Llnet: A deep autoen- coder approach to natural low-light image enhancement,” Pattern Recognition, vol. 61, pp. 650–662, <strong>2017</strong>.</li>
</ul></li>
<li>MSR-net，作者认为多尺度Retinex等价于前向传播的不同高斯卷积核的卷积网络，受此启发，构造了end-to-end的网络结构，直接学习从dark到bright。
<ul>
<li>L. Shen, Z. Yue, F. Feng, Q. Chen, S. Liu, and J. Ma, “Msr-net:low- light image enhancement using deep convolutional network,” p. arXiv, 11 <strong>2017</strong>.</li>
</ul></li>
<li>Retinex-Net，集成了图片分解和光照映射，此外，还利用了现成的（off-the-shelf）去噪工具（BM3D）to clean the reflectance component
<ul>
<li>C. Wei, W. Wang, W. Yang, and J. Liu, “Deep retinex decom- position for low-light enhancement,” in British Machine Vision Conference, <strong>2018</strong>.</li>
<li>(ps：不懂to clean the reflectance component)</li>
</ul></li>
</ul>
<p>这些方法的<strong>缺点</strong>：</p>
<p>1.这些方法都假设每个图像都存在GT的光，没有考虑到不同光的噪声在不同的区域的影响不同。即，提取了光照因子后，reflectance的dark区域的噪声level明显高于bright区域。在这种情况下，训练均匀分布图像（反射率）的去噪器不再适合。</p>
<p>2.此外，这些方法都没处理好颜色失真的退化问题。</p>
<ul>
<li>提出处理低光照的end-to-end的pipeline，用fully convolutional network同时处理噪声和颜色失真
<ul>
<li>C. Chen, Q. Chen, J. Xu, and V. Koltun, “Learning to see in the dark,” in IEEE Conference on Computer Vision and Pattern Recogni- tion, pp. 3291–3300, 2018.</li>
<li>缺点：
<ul>
<li>只适用于raw数据，应用场景受限</li>
<li>如果将网络改造成输入JPEG格式，性能会变差</li>
</ul></li>
</ul></li>
</ul>
<p>现有的方法都是通过伽马矫正调整光照，在精心构造的训练数据中指定一个level或者融合。伽马矫正可能无法反应不同曝光level之间的关系。第二种方法受限于指定的level是否包含在训练数据中。而最后一个方法，甚至没有提供可操作的选项。（这里不是太懂）</p>
<p>因此，需要设计一个映射函数，将one light(exposure)转换为another以便用户调整。</p>
<h4 id="image-denoising-methods">（4）Image Denoising Methods：</h4>
<p>经典的方法是用特定的先验来处理图像，比如：non-local self-similarity、piecewise smoothness（分段平滑）、信号稀疏表示。最受欢迎的可能是：BM3D和WNNM。</p>
<ul>
<li>BM3D：
<ul>
<li>K. Dabov, A. Foi, V. Katkovnik, and K. Egiazarian, “Image denoising by sparse 3-d transform-domain collaborative filtering,” IEEE Transactions on Image Processing, vol. 16, no. 8, pp. 2080–2095, 2007.</li>
</ul></li>
<li>WNNM：
<ul>
<li>S. Gu, L. Zhang, W. Zuo, and X. Feng, “Weighted nuclear norm minimization with application to image denoising,” in IEEE Con- ference on Computer Vision and Pattern Recognition, pp. 2862–2869, 2014.</li>
</ul></li>
</ul>
<p>缺点：</p>
<p>由于优化具有高复杂性以及参数的搜索空间很大，这些传统方法在真实条件下效果不是很好。</p>
<p>基于深度学习的去噪器表现出优越性。比如：</p>
<ul>
<li>SSDA，使用堆叠的稀疏自动编码器
<ul>
<li>F. Agostinelli, M. R. Anderson, and H. Lee, “Adaptive multi- column deep neural networks with application to robust image denoising,” in NeurIPS, 2013</li>
<li>J. Xie, L. Xu, and E. Chen, “Image denoising and inpainting with deep neural networks,” in NeurIPS, 2012.</li>
</ul></li>
<li>TNRD，by trainable nonlinear reaction diffusion(反应扩散？不是很懂)
<ul>
<li>Y. Chen and T. Pock, “Trainable nonlinear reaction diffusion: A flexible framework for fast and effective image restoration,” IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 39, no. 6, pp. 1256–1272, 2017.</li>
</ul></li>
<li>DnCNN，使用残差学习和batch normalization，可以节约计算成本，因为在测试阶段只有后馈卷积操作。
<ul>
<li>K. Zhang, W. Zuo, Y. Chen, D. Meng, and L. Zhang, “Beyond a gaussian denoiser: Residual learning of deep cnn for image denoising,” IEEE Transactions on Image Processing, vol. 26, no. 7, pp. 3142–3155, 2016.</li>
</ul></li>
</ul>
<p>缺点：</p>
<p>这些模型在blind image denoising上仍然有困难。one may train multiple models for varied levels or one model with a large number of parameters，这是很不灵活的</p>
<p>通过在任务汇总反复思考，这个问题得到了一定的缓解：</p>
<ul>
<li>paper：
<ul>
<li>X. Zhang, Y. Lu, J. Liu, and B. Dong, “Dynamically unfolding recurrent restorer: A moving endpoint control method for image restoration,” in ICLR, <strong>2018</strong>.</li>
</ul></li>
</ul>
<p>缺点：</p>
<p>上面提到的方法都没有考虑到不同的区域有着不同的level的噪声。</p>
<p>同样的问题也出现在颜色失真上。</p>
<h3 id="contributions">1.2 Contributions</h3>
<ol type="1">
<li>受到Retinex理论启发，提出的网络将图像分解为2个部分：反射率和光照，将原始空间解耦为2个更小的空间</li>
<li>网络的训练数据是在不同光照/曝光条件下获取的成对图像，而不是用任何的GT的反射和光照信息</li>
<li>提供了一个映射函数方便用户根据不同需求调整光线level</li>
<li>提出的网络也包括了一个可以有效消除放大黑暗区域带来视觉缺陷的模块</li>
</ol>
<h2 id="methodology">2、Methodology</h2>
<p>一个理想的低光度图像增强器应该可以有效去除藏在黑暗中的退化，以及灵活地调整光照/曝光条件。</p>
<p>网络结构：</p>
<p><a href="https://github.com/GlassyWu/Note/blob/master/Paper/低光照图像增强/img/KinD.png"><img src="https://github.com/GlassyWu/Note/raw/master/Paper/%E4%BD%8E%E5%85%89%E7%85%A7%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/img/KinD.png" alt="img" /></a></p>
<ul>
<li>整个网络有2个分支，分别是：反射率和光照</li>
<li>从功能的角度可分为3个部分：
<ul>
<li>层分解（layer decomposition）</li>
<li>反射率恢复（reflectance restoration）</li>
<li>光照调整（illumination adjustment）</li>
</ul></li>
</ul>
<h4 id="consideration-motivation">2.1 Consideration &amp; Motivation</h4>
<p><strong>（1）Layer Decomposition</strong></p>
<p>Retinex 理论：一个图像I可以看做是2个部分，reflectance R和illumination L，即，I = R ◦ L，R和L的对应元素的点乘。</p>
<p><strong>（2）Data usage and Priors</strong></p>
<p>层分解在自然界是欠定的，因此额外的先验/正则化很重要。假设图像的无退化的，一个场景的不同镜头应该有相同的反射率。光照图虽然有很大不同，但应该有简单且一致的结构。（不懂这里）</p>
<p>在真实场景下，低光度图像的退化一般要比亮图像更严重，此时转移为反射率部分。（这里不懂）</p>
<p>由此得出，亮光图像的反射率可以作为GT，给退化的低光度图像学习恢复。</p>
<p>为什么不用合成图像？因为难以合成，退化不是简单的组成，在不同的传感器上会有不同的变化。</p>
<p>作者提到，使用(well-defined)的反射率完全不同于用亮光图像作为低光图像的参考。</p>
<p><strong>（3）Illumination Guided Reflectance Restoration</strong></p>
<p>在分解的反射率中，较暗光线的污染要比亮光的区域严重。在数学层面上，一个退化的图像可以被表示为：</p>
<p>I = R ◦ L + E</p>
<p>E：表示污染成分</p>
<p>反射率恢复不能被均匀地处理整个图像，关照图可以作为一个好的向导。</p>
<p>为什么不直接从输入I中去掉噪声E？</p>
<p>一是不均衡的问题仍然存在，内在细节被不平均地与噪声混淆，二是与反射率不同，因为L是不同的，没有合适的参考给退化去除。颜色失真也是一样。</p>
<p><strong>（4）Arbitrary Illumination Manipulation</strong>(任意光照调整)</p>
<p>最好的光照强度对不同的人和应用是很不同的，因此，需要提供任意调整光照的接口。</p>
<p>过去常用的3个方法，fusion，缺少光线调整；light level appointment，要求训练集包含目标level；伽马矫正，不能反映不同光线（曝光）level之间的联系。</p>
<p>作者提出从真实数据中学习灵活的映射函数，用户可以随意调整level</p>
<h4 id="kind-network-1">2.2 KinD Network</h4>
<p>网络结构：</p>
<p><a href="https://github.com/GlassyWu/Note/blob/master/Paper/低光照图像增强/img/KinD.png"><img src="https://github.com/GlassyWu/Note/raw/master/Paper/%E4%BD%8E%E5%85%89%E7%85%A7%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/img/KinD.png" alt="img" /></a></p>
<p><strong>（一）Layer Decomposition Net</strong></p>
<ul>
<li>输入：用不同光照/曝光的图像作为成对图像[I_l，I_h]</li>
<li>之前有个假设，在相同的场景，反射率应该相同，首先的目标是让反射率对[R_l，R_h]应该尽量相同（图中上面的中间输出）。（理想情况下无退化情况）。</li>
<li>光照图[L_l，L_h]应该分段平滑，且相同（图中下面的中间输出）。</li>
<li>定义各种loss
<ul>
<li>reflectance similarity，L_rs，反射率相似度
<ul>
<li>即，输出的两张反射率map的相似度</li>
</ul></li>
<li>illumination smoothness，L_is，光照平滑度
<ul>
<li>即，输出的两张光照map的平滑度</li>
<li>衡量光照相对输入来说的结构相关性（这里不懂）</li>
<li>这个平滑项对边缘的像素惩罚小，对平滑区域惩罚大。</li>
</ul></li>
<li>mutual consistency，L_mc，相互一致性
<ul>
<li>保证强相关的边缘被保留下来</li>
<li>即，两张光照map之间</li>
</ul></li>
<li>reconstruction error，L_rec
<ul>
<li>衡量重建图像的误差</li>
<li>即，分辨率图和光照图各自的生成和各自的输入之间的误差</li>
</ul></li>
</ul></li>
</ul>
<p><strong>（二）Reflectance Restoration Net</strong></p>
<p>低光照图像比亮光度图像更多退化。</p>
<p>思路：将清晰的反射图作为GT</p>
<p>loss：L_RR</p>
<p>degradation分布在反射率上是复杂的，强依赖于光照分布，所以作者将光照信息和退化反射率一起引入图像恢复中。</p>
<p><strong>（三）Illumination Adjustment Net</strong></p>
<p>通过光强率α控制，α=mean(L_t/L_s)，这里的除法是对应元素相除。</p>
<p>α可以作为一个指标，用于将L_s训练到L_t，(L_t是目标源光)，α&gt;1表示低光到高光。</p>
<p>3个conv （2个conv+ReLu）+ 1个sigmoid</p>
<p>α被扩展为一个map，作为输入的一部分。</p>
<p>Loss：L_LA</p>
<h2 id="总结">总结</h2>
<p><a href="https://github.com/GlassyWu/Note/blob/master/Paper/低光照图像增强/img/KinD.png"><img src="https://github.com/GlassyWu/Note/raw/master/Paper/%E4%BD%8E%E5%85%89%E7%85%A7%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/img/KinD.png" alt="img" /></a></p>
<ul>
<li>输入是成对的不同曝光的图像</li>
<li>将亮光图像的反射率作为GT，明亮图像的反射图作为GT去引导低照图像的反射图进行增强</li>
<li>定义了一堆loss（个人觉得过于繁琐，不优雅，且排版emmm）</li>
</ul>
]]></content>
      <categories>
        <category>图像预处理</category>
        <category>图像视频增强</category>
      </categories>
  </entry>
  <entry>
    <title>计算机操作系统-进程管理</title>
    <url>/posts/14039/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="进程管理">进程管理</h1>
<h2 id="进程与线程">进程与线程</h2>
<h3 id="进程">进程</h3>
<p><strong>进程是资源分配的基本单位</strong> <strong>进程控制块</strong> (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p>
<p>下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。</p>
<figure>
<img src="https://i.loli.net/2021/04/05/AeMS9o8yiCLPusB.png" alt="" /><figcaption>image-20201209215006274</figcaption>
</figure>
<h3 id="线程">线程</h3>
<p><strong>线程是独立调度的基本单位</strong>。<strong>一个进程中可以有多个线程，它们共享进程资源。</strong></p>
<p>QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件</p>
<figure>
<img src="https://i.loli.net/2021/04/05/7E4Gey5J2B6WoDO.png" alt="" /><figcaption>image-20201209215107055</figcaption>
</figure>
<p>（内核线程）</p>
<h3 id="协程">协程</h3>
<p>协程就是用户线程。是编译层面，由编程语言实现的东西，和操作系统无关。对于包含大量I/O的场景，通常的做法是每个I/O连接使用一个线程维护，大部分的线程都处于阻塞状态。这样由于线程很多，对系统内存资源消耗很多，同时线程的频繁切换也会有较大的开销。这时候就提出了协程的概念</p>
<p>协程是用户线程，所有的线程运行在一个线程上，由用户控制协程的调度，内核感知不到协程的存在，因此它只是对线程进行调度。使用协程需要结合异步I/O使用，因为如果某一个协程调用了IO阻塞的操作导致该线程休眠，那么其他的协程也就得不到调用。</p>
<h3 id="区别">区别</h3>
<ol type="1">
<li>拥有资源 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</li>
<li>调度 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
<li>系统开销 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</li>
<li>通信方面 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC</li>
</ol>
<h2 id="进程状态的切换">进程状态的切换</h2>
<figure>
<img src="https://i.loli.net/2021/04/05/H7qwl3ELoWCYVMb.png" alt="" /><figcaption>image-20201209221158792</figcaption>
</figure>
<ul>
<li>就绪状态（ready）：等待被调度</li>
<li>运行状态（running）</li>
<li>阻塞状态（waiting）：等待资源</li>
</ul>
<p>应该注意以下内容：</p>
<ul>
<li><strong>只有就绪态和运行态可以相互转换，其它的都是单向转换</strong>。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>
<li><strong>阻塞状态是缺少需要的资源从而由运行状态转换而来</strong>，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态</li>
</ul>
<h2 id="交换技术">交换技术</h2>
<p>当多个进程竞争内存资源时，会造成内存资源紧张，并且，如果此时没有就绪进程，处理机会空闲，I/0速度比处理机速度慢得多，可能出现全部进程阻塞等待I/O</p>
<p>针对以上问题，提出了两种解决方法：</p>
<ol type="1">
<li>虚拟内存 ： 在内存管理中介绍</li>
<li>交换技术：换出一部分进程到外存，腾出内存空间</li>
</ol>
<h2 id="进程调度算法">进程调度算法</h2>
<p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p>
<h3 id="批处理系统">批处理系统</h3>
<p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p>
<ol type="1">
<li>先来先服务 first-come first-serverd（FCFS) : 非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</li>
<li>短作业优先 hortest job first（SJF）：非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</li>
<li>最短剩余时间优先 shortest remaining time next（SRTN）：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</li>
</ol>
<h3 id="交互式系统">交互式系统</h3>
<p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>
<h4 id="时间片轮转">时间片轮转</h4>
<p>将所有就绪进程按 FCFS（先来先服务） 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>
<li>而如果时间片过长，那么实时性就不能得到保证</li>
</ul>
<h4 id="优先级制度">优先级制度</h4>
<p>为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<h4 id="多级反馈队列">多级反馈队列</h4>
<p>这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。<strong>进程在第一个队列没执行完，就会被移到下一个队列</strong>。每个队列优先权也不同，最上面的优先权最高。<strong>因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</strong></p>
<figure>
<img src="https://i.loli.net/2021/04/05/TKNOGUfedsZpRcg.png" alt="" /><figcaption>image-20201209225512870</figcaption>
</figure>
<h3 id="实时系统">实时系统</h3>
<p>实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<h2 id="同步">同步</h2>
<h3 id="临界区">临界区</h3>
<p>对临界资源进行访问的那段代码称为临界区。为了互斥访问临界资源，每个 进程/ 线程在进入临界区之前，需要先进行检查。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// entry section</span><br><span class="line">// critical section;</span><br><span class="line">// exit section</span><br></pre></td></tr></table></figure>
<h3 id="同步与互斥">同步与互斥</h3>
<p>互斥是一种特殊的同步。使用基本的锁可以实现同步，但是操作系统需要封装更高级的同步原语来实现更复杂、更实用的功能。信号量（semaphore）和管程（monitor）就是操作系统提供的两种更高级的同步方式，在操作系统（linux）和编程语言都有对应的实现和封装。</p>
<ul>
<li>同步：多个进程/线程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li>
<li>互斥：多个进程/线程在同一时刻只有一个进程能进入临界区。</li>
</ul>
<h3 id="同步的方法">同步的方法</h3>
<p>首先区分一个概念，<strong>常常说的同步指的是 线程间的同步，也就是可以用信号量，互斥量，管程等</strong>，因为这些变量是自己手动定义的，同一个进程中的线程之间的资源是共享的，所以需要使用自定义的变量来完成线程之间的同步或者互斥操作。进程间可能也需要同步，<strong>那么进程间的同步是使用IPC机制，即通过进程间的通信实现的，因为进程之间资源不共享，需要经过内核才能完成通信和同步</strong>。</p>
<h4 id="信号量">信号量</h4>
<p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
<ul>
<li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，<strong>进程睡眠，等待信号量大于 0</strong>；</li>
<li><strong>up</strong> ：对信号量执行 +1 操作，<strong>唤醒睡眠的进程让其完成 down 操作。</strong></li>
</ul>
<p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断（所谓原语（原子），一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断）如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P1 P2 互斥地访问临界1区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="管程">管程</h4>
<p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。管程有一个重要特性：在一个时刻只能有一个线程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个线程持有。signal() 操作用于唤醒被阻塞的进程。</p>
<h3 id="经典同步问题">经典同步问题</h3>
<h4 id="生产消费者问题">生产消费者问题</h4>
<blockquote>
<p>问题描述：两个进程共享一个公共的固定大小的缓冲区。其中一个是生产者，将信息放入缓冲区；另一个是消费者，从缓冲区中取出信息</p>
</blockquote>
<p>其实仔细分析，这个题涉及到两个线程同步的问题，即要求 带休眠的功能。如果只使用一个信号量 那么只能表示 空，但是不能体现满的状态，因此需要定义两个信号量。同时 由于 缓冲区属于临界资源，因此访问的时候还需要对缓冲区加锁。</p>
<p><strong>信号量实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;  </span><br><span class="line">semaphore empty = N;   <span class="comment">// empty大于0时 生产着才能放入 物品  否则休眠</span></span><br><span class="line">semaphore full = <span class="number">0</span>;    <span class="comment">// full 大于0时 消费者才能取出无 物品 否则休眠</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="keyword">int</span> item = produce_item();</span><br><span class="line">        down(&amp;empty);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;full);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        <span class="keyword">int</span> item = remove_item();</span><br><span class="line">        consume_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p>
<p><strong>管程实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"><span class="comment">/* 定义管程 PC   C语言中没有管程这个功能，这里只是用C语言逻辑写一下。管程在编译器编译的时候已经使用互斥锁保证了同一时刻只能由一个线程线程运行，即要么是 insert  要么是remove 这也保证了 拿取的过程其实是串行的*/</span></span><br><span class="line">monitor PC </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">/* 我们使用条件变量full 表示被填满的buffer, empty 表示空的buffer */</span></span><br><span class="line">    conditon full, empty;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/* 当buffer满的时候,我们在full上将插入操作阻塞 */</span></span><br><span class="line">        <span class="keyword">if</span> ( count == MAX ) wait(&amp;full);   <span class="comment">// 等待full信号</span></span><br><span class="line">        insert_item(item);</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 当buffer不空的时候,我们在empty上唤醒取出操作 */</span></span><br><span class="line">        <span class="keyword">if</span> ( count == MAX <span class="number">-1</span> ) signal(&amp;empty);    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/* 当buffer空的时候,我们在empty上将取出操作阻塞 */</span></span><br><span class="line">        <span class="keyword">if</span>( count == <span class="number">0</span> ) wait(&amp;empty);    </span><br><span class="line">        remove_item(item);</span><br><span class="line">        count -= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 当buffer不满的时候,我们在full上唤醒插入操作 */</span></span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">        <span class="keyword">if</span>( count == MAX - <span class="number">1</span>) signal(&amp;full);  <span class="comment">// 发送full信号  此时上面那个full就可以被唤醒了 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> item;</span><br><span class="line">        item = produce_item();</span><br><span class="line">        <span class="comment">/*调用管程中的函数 */</span></span><br><span class="line">        PC.insert(item);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> item;</span><br><span class="line">        <span class="comment">/*调用管程中的函数 */</span></span><br><span class="line">        item = PC.remove();</span><br><span class="line">        consumer_item();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="科学家进餐问题">科学家进餐问题</h4>
<blockquote>
<p>有五个哲学家，他们的生活方式是交替地进行思考和进餐。他们共用一张圆桌，分别坐在五张椅子上。在圆桌上有五个碗和五支筷子，平时一个哲学家进行思考，饥饿时便试图取用其左、右最靠近他的筷子，只有在他拿到两支筷子时才能进餐。进餐完毕，放下筷子又继续思考。</p>
</blockquote>
<p>按题目的流程，伪代码表示如下（用一个互斥变量来保护一个筷子，拿筷子即为把该变量置0 这样就实现了题目要求的 一只筷子只能一个人拿，然后按流程组织得到下面初步结果）：</p>
<figure>
<img src="https://i.loli.net/2021/04/05/YOthIRWPr2Cse57.png" alt="" /><figcaption>image-20201210213841188</figcaption>
</figure>
<p>这样存在的问题是 如果这些人 都同时拿起坐边的筷子，然后等右手的筷子，那么就会导致锁死。可以从以下几个思路改进</p>
<ol type="1">
<li>方法一：至多只允许四位哲学家同时去拿左筷子，最终能保证至少有一位哲学家能进餐，并在用完后释放两只筷子供他人使用</li>
<li>方法二：仅当哲学家的左右手筷子都拿起时才允许进餐</li>
<li>方法三：规定奇数号哲学家先拿左筷子再拿右筷子，而偶数号哲学家相反</li>
</ol>
<p><img src="https://i.loli.net/2021/04/05/VnpkY1modaE3bCQ.png" alt="image-20201210215157312" />方法一 使用一个信号量控制 同时拿起左边筷子的人的数量，初始为4，拿起一个，信号量就减1，这样总能保证有一个人可以拿全两双筷子然后等他吃完释放信号。同时每个筷子用一个互斥变量，保证只有一个人能拿</p>
<p>方法二 利用and 型信号量机制实现 也可以用互斥信号对取左右筷子的操作进行保护，这样四个人取左筷子的流程其实就是串行的了。</p>
<h4 id="读者-写者问题">读者-写者问题</h4>
<blockquote>
<p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p>
</blockquote>
<p>思路：一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="comment">// 来读数据 读者数 conut + 1 修改count要先对count加锁</span></span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">         </span><br><span class="line">        read();</span><br><span class="line">        <span class="comment">//  读取完毕  将读者数conut - 1  由于又要修改 count 需要将它上锁再修改</span></span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        write();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进程通信">进程通信</h2>
<p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为<strong>进程间通信（IPC，InterProcess Communication）</strong></p>
<p>进程同步与进程通信很容易混淆，它们的区别在于</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行；</li>
<li>进程通信：进程间传输信息。</li>
</ul>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<h3 id="管道">管道</h3>
<p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>它具有以下限制：</p>
<ul>
<li>只支持半双工通信（单向交替传输），且写的时候必须同时在读</li>
<li>只能在父子进程或者兄弟进程中使用</li>
<li>数据一旦被读走，便不在管道中存在，不可反复读取</li>
<li>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等</li>
</ul>
<h3 id="fifo">FIFO</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>也称为命名管道，去除了管道只能在父子进程中使用的限制。FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据</p>
<h3 id="消息队列">消息队列</h3>
<p>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示，消息队列存放在内核中，只有在内核重启 (即，操作系统重启) 或者显示地删除一个消息队列时，该消息队列才会被真正的删除。相比于 FIFO，消息队列具有以下优点：</p>
<ul>
<li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>
<li>不需要进程自己提供同步方法，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达；</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收</li>
<li>消息存在于内核，读了之后不会被删除</li>
</ul>
<h3 id="共享存储">共享存储</h3>
<p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。<strong>需要使用信号量</strong>用来同步对共享存储的访问。<strong>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存</strong>。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p>
<h3 id="套接字">套接字</h3>
<p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p>
<h3 id="信号量信号">信号量/信号</h3>
<p>线程之间的信号量和同一个进程的不同线程之间的信号量不一样 …..</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>面经1</title>
    <url>/posts/12158/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="进程与线程的概念">进程与线程的概念</h2>
<p>基本概念：</p>
<p>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</p>
<p>线程是进程的子任务，是CPU调度和分派的基本单位，<strong>用于保证程序的实时性</strong>，实现<strong>进程内部的并发</strong>；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的 动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</p>
<p>区别：</p>
<ul>
<li>通信：由于同一个进程间共享内存资源，因此线程间的通信较简单，通过简单的全局变量即可，也可以结合信号量，互斥量等实现互同步互斥等。而进程间的通信需要通过内核，借助IPC方式</li>
<li>开销：线程的切换开销小。由于每个进程的资源是独立分配的，因此进程的创建和销毁都伴随着资源分配和释放，创建更慢。而一个进程中的多个线程只需要分配独立的栈，其他的资源则是共享的，因此创建开销小。同时线程的切换速度也快，因为进程的地址空间是独立的，进程之间的页表不同，当进程切换，页表需要重新从内存（或外存）中重新加载到缓存中（多级页表可能是分布式存储需要从外存加载）使得切换速度慢，而同一进程的线程切换只需要设置少量的cpu寄存器状态即可。</li>
<li>调试和应用场景：线程调试困难可靠性低，一个线程挂掉会导致整个进程挂掉，适合多核场景；进程调试简单可靠性高，一个进程崩掉不会影响其他的进程，且多核多机的场景都适合。</li>
<li>性质：线程是任务调度的最小单位，而进程是资源分配的最小单位</li>
</ul>
<blockquote>
<p>从Linux实现上，它其实并没有专门区分进程和线程的概念。它使用了相同函数去创建进程/线程，通过设置是否共享资源的入口参数来创建进程/线程。</p>
</blockquote>
<h2 id="多进程和多线程的使用场景">多进程和多线程的使用场景</h2>
<p>多进程应用场景</p>
<ul>
<li>例如 谷歌浏览器的每个页面就是一个单独的进程</li>
<li>电脑中每个软件就是一个独立的进程，这个软件崩了不会影响其他的软件</li>
<li>多机分布式环境</li>
</ul>
<p>多线程场景</p>
<ul>
<li>需要频繁创建和销毁的场景使用线程效率更高，例如web服务器处理客户的连接，一个线程一个连接</li>
<li>对于需要频繁的数据共享的场景，使用线程可以降低通信的开销</li>
<li>对于需要快速响应的场景，例如GUI界面，如果算法耗时很多，就会导致界面假死无法响应用户的请求</li>
</ul>
<h2 id="内核线程和用户线程">内核线程和用户线程</h2>
<p>这里讲的用户线程是编译层面通过编程语言实现的用户线程，即协程。内核线程就是常规的线程（还有一种内核线程的称呼是指只运行在内核态的线程，是操作系统创建的用于完成操作系统事务的线程，也叫守护线程，它和普通的线程一样被同等调度）但是这里讨论的实际是协程和线程的区别。</p>
<p>协程是用户在编译器层面使用编程语言模拟出的线程，不通过系统调用，不用陷入内核，这时候创建新线程比较快，这就是用户线程。多个协程运行在一个线程上，OS感知不到协程的存在，它只是对承载这些协程的线程进行调度，因此如果协程中有IO阻塞操作导致线程被阻塞，那么所有的协程都无法再被调度。这种情况需要程序员自己避免，可以使用异步IO代替阻塞IO，手动调度协程。</p>
<p>而常规的线程是 由操作系统维护的，它的创建和调度都要从用户态陷入内核态，所以线程的切换代价高于协程。但是由于操作系统调度，所以不会因为一个线程的IO阻塞而饿死其他线程。</p>
<p>协程的优点：</p>
<ul>
<li>协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显</li>
<li>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多</li>
</ul>
<h2 id="为什么进程切换比线程慢">为什么进程切换比线程慢</h2>
<p>首先无论进程还是线程切换都需要保存寄存器值，例如SP 栈寄存器，PC程序计数器指向下一条要执行的指令，EAX累加寄存器，用于加法乘法的确信寄存器等。但是 每个进程都有自己的虚拟地址空间， 进程内的所有线程共享进程的虚拟地址空间，进程切换涉及虚拟地址空间的切换而线程不会。把虚拟地址空间转换为物理地址是通过页表实现的，为了加速页表的查找速度，通常要使用缓存来存储常用的地址映射，即TLB。每个进程有自己的页表，当进程切换后，缓存就失效了，导致命中率低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换快，原因就在这里。（<strong>为了加速虚拟地址的转换速度，会将常用的地址映射存放在缓存中，进程切换，页表也改变会导致缓存命中率低，同时就需要重新从内存中将新的页表加载进缓存，所以进程切换比线程切换慢的原因就在这儿</strong>）</p>
<h2 id="进程间通信的方式">进程间通信的方式</h2>
<p><strong>进程间通信</strong>主要包括管道、消息队列、信号量、信号、共享内存、以及套接字socket。</p>
<ol type="1">
<li><p>管道：分为无名管道 和 有名管道，他们都只支持半双工的通信，通信时接收双方必须同时存在，由于传输的是字节流，需要程序自行定义通信协议。管道是存在于<strong>内存中</strong>，只是形式和文件类似，当消息被读取出便不再存在。</p>
<ul>
<li><p>无名管道：只能用于有亲缘关系的进程之间通信。</p></li>
<li><p>有名管道：有路径名称与之关联，以一种特殊的文件形式存在于内存中。所以可以用于没有关系的进程之间通信。</p></li>
</ul></li>
<li><p>消息队列：消息队列，是消息的链接表，存放在<strong>内核中</strong>。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p>
<ul>
<li>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</li>
<li>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除</li>
<li>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取</li>
</ul></li>
<li><p>信号量：是一个计数器，用来控制进程间的同步或互斥访问。</p>
<ul>
<li>如果要传递信息，则需要结合共享内存，来实现同步或者互斥访问</li>
<li>信号量基于 操作系统 的 P V操作，程序对信号的操作都是原子操作</li>
<li>P V，不仅只能对信号量的减加 还 可以加减任意正整数 当信号量为0时，进程休眠</li>
<li>支持信号量组</li>
</ul></li>
<li><p>信号： 用于通知接收进程某个事件已经发生</p></li>
<li><p>共享内存：它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等</p>
<ul>
<li>是速度最快的一种 IPC 因为 进程是直接对内存进行存取</li>
<li>因为多个进程可以同时操作，所以需要进行同步。信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</li>
</ul></li>
<li><p>套接字<code>SOCKET</code>：它用于不同主机之间的进程通信</p></li>
</ol>
<p><strong>线程间通信</strong>的方式：</p>
<ol type="1">
<li>临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。如果有多个线程试图同时访问临界区，那么 在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。 * <code>EnterCriticalSection()</code> 进入临界区
<ul>
<li><code>LeaveCriticalSection()</code>离开临界区</li>
</ul></li>
<li>互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</li>
<li>信号量 <code>Semphare</code>：为控制具有有限数量的用户资源而设计的，<strong>它允许多个线程在同一时刻去访问同一个资源</strong>，但一般需要限制同一时刻访问此资源的最大线程数目。</li>
<li>事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</li>
</ol>
<p>对比：临界区是非内核对象，它运行在用户态，因此只能用于同一个进程中的线程之间的互斥访问，但是临界区的效率是最高的。而后面都是内核对象可以用于不同进程的线程之间的同步互斥。</p>
<h2 id="linux虚拟地址空间">Linux虚拟地址空间</h2>
<p>程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。还有进程运行过程中，要动态分配内存，比如 <code>malloc</code>时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。</p>
<p>好处：</p>
<ol type="1">
<li>可以控制物理内存的访问权限，对特定的地址设置保护，防止在用户模式下执行错误的指令而意外改写内核数据</li>
<li>每个进程的地址空间独立，通过页表映射到物理地址，可以防止不同进程之间相互干扰，一个进程无无法访问其他进程的地址空间</li>
<li>通过页面的换入换出可以在小内存中运行大程序。另一方面由于逻辑地址不是全部都映射到具体的物理地址的，只有在读写时引发缺页异常才会进行映射，因此可以在内存上同时保留多个进程，提高系统的并发度</li>
<li>可以将连续的逻辑地址映射到不连续的物理地址上，提高内存利用率</li>
</ol>
<p>虚拟内存的代价：</p>
<ol type="1">
<li>虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存</li>
<li>虚拟地址到物理地址的转换，增加了指令的执行时间</li>
<li>页面的换入换出需要磁盘I/O，这是很耗时的</li>
<li>如果一页中只有一部分数据，会浪费内存</li>
</ol>
<h2 id="请你回答一下为什么要有page-cache操作系统怎么设计的page-cache">请你回答一下为什么要有page cache，操作系统怎么设计的page cache</h2>
<p>加快从磁盘读取文件的速率。page cache 中有一部分磁盘文件的缓存，因为从磁盘中读取文件比较慢，所以读取文件先去page cache 中去查找，如果命中，则不需要去磁盘中读取，大大加快读取速度。</p>
<p>当系统需要读取某个文件的对应位置的数据时，首先根据打开的文件的 inode 找到 address_space 结构，address_space是建立内存和文件关联的桥梁，其中保存有该文件的 基数树，通过文件的偏移 在基数树中查找页缓存，如果缓存命中直接读取，否则分配一块缓存页并将磁盘中的对应数据拷贝到内存缓存页中。（最后害有一个双向链表来实现LRU？）</p>
<h2 id="操作系统程序的内部结构">操作系统程序的内部结构</h2>
<p>32位系统 一个程序的可寻址空间位 4G ， 其中0-3G是用户态空间，3-4G是内核空间。从低地址到高地址，依次为代码段，数据段，bss段，堆区，mmap映射区，栈区。</p>
<ul>
<li>代码段：存放的是机器代码 和 字符常量，只读，在可执行文件生成的时候以已经写入。</li>
<li>数据段：存放的是初始化了的且初始值不为0的全局变量和局部静态变量。在可执行文件生成的时候已经写入。</li>
<li>bss段：存放的是初始值为0或者未初始化的全局变量或者静态变量，单独分出这个区域的目的是减少可执行文件的尺寸，在可执行文件中只记录该区域的大小。</li>
<li>堆区：前三个大小都是固定的。后两个是在程序运行时新增的区域。堆区为程序员动态分配的空间，在运行中可以动态改变，由低地址向高地址生长。堆的效率比栈要低的多。</li>
<li>栈区：用于存放函数调用时函数的返回值，返回地址等信息，该部分内存由操作系统管理，栈区是从高地址位向低地址位增长的，是一块连续的内存区域，并且每个栈的最大地址有限制，超出了会异常。</li>
</ul>
<h2 id="缺页中断">缺页中断</h2>
<p>malloc mmap 函数分配空间只是分配的虚拟内存，只有当程序访问虚拟空间，并发现虚拟内存和物理内存没有建立映射关系时，就会出发缺页中断。<strong>在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中</strong>。此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。</p>
<p>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</p>
<ol type="1">
<li>保护CPU现场</li>
<li>分析中断原因</li>
<li>处理缺页中断</li>
<li>恢复CPU现场，继续执行</li>
</ol>
<p>但是缺页中断所要访问的页面不在内存时，由硬件所产生的一种特殊的中断，因此与一般中断存在的区别是：</p>
<ol type="1">
<li>在指令执行期间产生和处理缺页中断信号</li>
<li>一条指令在执行期间，可能产生多次缺页中断</li>
<li><strong>缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令</strong>。</li>
</ol>
<h2 id="请你回答一下fork和vfork的区别">请你回答一下fork和vfork的区别</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">vfork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><strong>fork的发展</strong>：但是在早期 Unix系统中，调用fork，fork创造的子进程是父进程的完整副本，复制了父亲进程的资源，包括内存的内容和task_struct内容。逐页的复制方式是十分耗时的。现代的Unix系统采用了写时复制的方法，而不是对父进程空间进程整体复制。</li>
<li><strong>为何会有vfork：</strong> 由于早期 fork 全盘复制的弊端，常规用途中 往往直接在子进程中使用 exec 加载其他映像文件，并不需要全部复制父进程的东西。因此 出现了<code>vfork</code> 。</li>
<li><strong>vfork 作用</strong>： vfork( ) 避免了地址空间的按页复制。在这个过程中，父进程和子进程共享相同的地址空间和页表项。实际上vfork( )只完成了一件事：复制内部的内核数据结构。因此，子进程也就不能修改地址空间中的任何内存。而且子进程将先于父进程运行，只有在 子进程调用 exec 或者 _exit 时，才会唤醒父进程。</li>
<li><strong>写时复制：</strong>写时复制是一种采取了<strong>惰性优化</strong>方法来避免复制时的系统开销。如果有多个进程要读取它们自己的那部门资源的副本，每个进程只要保存一个指向这个资源的指针就可以了。如果一个进程要修改自己的那份资源“副本”，那么就会复制那份资源，并把复制的那份提供给进程，这个进程就可以修改复制后的资源了，同时其他的进程仍然共享那份没有修改过的资源。</li>
<li><strong>写时复制的具体实现</strong>：在使用虚拟内存的情况下，写时复制（Copy-On-Write）是以页为基础进行的。所以，只要进程不修改它全部的地址空间，那么就不必复制整个地址空间。如果有进程试图修改一个页，就会产生一个缺页中断。内核处理缺页中断的方式就是对该页进行一次透明复制。这时会清除页面的COW属性，表示着它不再被共享。</li>
</ol>
<p>fork 与 vfork 区别：</p>
<ol type="1">
<li>fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段 直至子进程使用execve启动新的应用程序为止</li>
<li>fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，<strong>在它调用exec或exit之后父进程才能被调度运行</strong>，如果在调用这两个函数之前子进程依赖于父进程的进一步动作，<strong>则会导致死锁。</strong></li>
</ol>
<h2 id="请问如何修改文件最大句柄数">请问如何修改文件最大句柄数</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -n 2048   <span class="comment"># 将最大文件句柄数修改为2048 但是新开一个 shell 会失效</span></span><br><span class="line"><span class="built_in">ulimit</span> -a        <span class="comment"># 查询 Linux 的相关参数，其中open files为最大文件数</span></span><br><span class="line">vi /etc/security/limits.conf  <span class="comment">## 要永久修改 最大文件数 在 conf 文件中添加  修改以后保存，注销当前用户，重新登录，修改后的参数就生效了</span></span><br><span class="line">*　　soft　　nofile　　65536</span><br><span class="line">*　　hard　　nofile　　65536</span><br></pre></td></tr></table></figure>
<h2 id="并发concurrency和并行parallelism">并发(concurrency)和并行(parallelism)</h2>
<p>并发：宏观上两个程序好像在同时运行，但是某一时刻只有一个程序在运行，两个程序交替执行一个小时间片，并发能提高程序的效率。</p>
<p>并行：并行需要硬件支持，例如多核或者多机。两个程序可以在不同核中同时运行，也就是运行了两个指令，互不影响。</p>
<h2 id="mysql的端口号是多少如何修改这个端口号">MySQL的端口号是多少，如何修改这个端口号</h2>
<p>mysql 的默认端口是 3306，修改端口号 在 /etc/my.cnf 文件 中修改即可</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 登录 mysql 使用命令</span></span><br><span class="line">show global variables like <span class="string">&#x27;port&#x27;</span>   <span class="comment">## 查看端口号  </span></span><br><span class="line">vim my.cnf   <span class="comment">### 修改端口号</span></span><br></pre></td></tr></table></figure>
<h2 id="说一说操作系统中的页表寻址">说一说操作系统中的页表寻址</h2>
<p>页式内存管理，内存分成固定长度的一个个页片。操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表，页表的内容就是该进程的虚拟地址到物理地址的一个映射。页表中的每一项都记录了这个页的基地址。通过页表，由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移一定长度就得到最后的物理地址，偏移的长度由逻辑地址的低位部分决定。一般情况下，这个过程都可以由硬件完成，所以效率还是比较高的。页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间。</p>
<p>早期的Linux系统使用 一级 页表，由于页表是连续的，即使一个进程可能只会使用到少部分的寻址空间，但是也需要将整个页表存储在连续的内存中，这是比较浪费内存的。因此 逐渐出现 多级页表的 结构，通过分散存储的思想，内存中往往只用存储一个一级页表和少量使用到的二级页表，其他不用的二级页表可以存储在外存中，使用时再调入。这样大大减小了存储页表需要的内存空间。寻址方式类似，首先通过CR3寄存器获得一级页表的地址，根据逻辑地址的高位，映射得到对应的二级页表的地址，然后再在二级页表中，根据逻辑地址的中间位映射，得到该逻辑地址对应的完整页的基地址，再加上逻辑地址的低位偏移得到真实的物理地址。</p>
<h2 id="说一说有了进程为什么还要有线程">说一说有了进程，为什么还要有线程</h2>
<p>进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点。</p>
<ol type="1">
<li>进程中一旦有阻塞任务，整个进程都会被挂起，即使进程中有些工作不依赖于等待资源，但是仍然不会被执行。</li>
<li>进程的建立需要耗费更多资源。线程是一种非常"节俭"的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种"昂贵"的多任务工作方式。</li>
<li>进程间的通信复杂，因为不同进程的数据空间是独立的，要通信需要借助IPC，而线程之间共享资源，比较方便</li>
<li>进程切换开销大，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。</li>
</ol>
<p>另外：</p>
<ol type="1">
<li>使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上</li>
<li>改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。</li>
</ol>
<h2 id="单核机器上写多线程程序是否需要考虑加锁为什么">单核机器上写多线程程序，是否需要考虑加锁，为什么？</h2>
<p>需要，如果有一个线程正在对共享数据修改，还没修改完 突然被系统挂起，调入另一个线程，此时该线程再对共享数据读，读出的就是脏数据。</p>
<h2 id="线程需要保存哪些上下文sppceax这些寄存器是干嘛用的">线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的</h2>
<p>保存 <strong>当前线程id和状态，寄存器状态，堆栈信息</strong>等。其中寄存器信息主要有 SP指针 存放的是堆栈地址，PC指针程序计数器指向下一条将要执行的指令，EAX累加寄存器，是加法乘法的缺省寄存器，<strong>用来存储cpu计算产生的中间结果</strong>，如果没有累加器这样的寄存器，那么每次计算加法乘法移位等后产生的中间结果都要写会内存，也许马上又要读回来，速度慢。</p>
<h2 id="线程间同步的方式">线程间同步的方式</h2>
<p>（如果问线程通信的方式 就 加上 临界区，通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问）</p>
<ul>
<li>用户模式：原子操作，临界区</li>
<li>内核模式：事件，信号量，互斥量</li>
</ul>
<p><strong>信号量</strong>。通过PV操作来增减信号值，当信号值为0时，线程休眠。增减的操作是原子的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sem_wait</span>(<span class="keyword">sem_t</span>* sem);   <span class="comment">// 信号值减1，如果信号值是0 则休眠  </span></span><br><span class="line"><span class="built_in">sem_post</span>(<span class="keyword">sem_t</span>* sem);   <span class="comment">// 信号值加1  当值大于0后，其他因为没有信号值而休眠的线程将被唤醒</span></span><br><span class="line"><span class="built_in">sem_init</span>();   <span class="comment">// 初始化信号量，可以设置初值，也可以选择该信号是用于局部线程还是进程间共享</span></span><br></pre></td></tr></table></figure>
<p><strong>互斥量/锁</strong>。主要用于线程互斥，不能保证按序访问，可以保证线程对临界区的互斥访问，也可以和条件锁一起实现线程同步。当进入临界区的时候需要获得互斥锁并且加锁，当离开临界区的时候，需要对解锁，以唤醒其他等待的线程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pthread_mutex_init</span>();     <span class="comment">// 初始化互斥锁</span></span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>();     <span class="comment">// 以原子的方式给一个互斥锁加锁</span></span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>();   <span class="comment">// 以原子的方式给互斥锁解锁</span></span><br><span class="line"><span class="built_in">pthread_mutex_destroy</span>();  <span class="comment">// 销毁互斥锁</span></span><br></pre></td></tr></table></figure>
<p><strong>条件变量</strong>。和互斥锁不同，条件变量是当达到某个条件时，同时唤醒在等待该变量的线程，从而实现线程同步。但是为了防止出现唤醒信号丢失的情况，通常要和互斥锁配合使用，在测试条件变量的时候先加锁，防止在测试且还未睡眠时，另一个线程发出条件信号，而被当前线程错过的问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pthread_cond_init</span>();    <span class="comment">// 初始化条件变量</span></span><br><span class="line"><span class="built_in">pthread_cond_wait</span>();    <span class="comment">// 等待目标条件变量，如果没有信号就休眠。在调用该函数测试条件时需要先使用互斥锁加锁确保原子性。在该函数中进入wait状态前会先解锁再休眠。因此该函数入口参数还有个互斥锁变量。在被条件唤醒后，函数内部会再加上互斥锁。</span></span><br><span class="line"><span class="built_in">pthread_cond_signal</span>();  <span class="comment">// 唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。</span></span><br><span class="line"><span class="built_in">pthread_cond_destroy</span>(); <span class="comment">// 销毁条件变量</span></span><br></pre></td></tr></table></figure>
<h2 id="游戏服务器应该为每个用户开辟一个线程还是一个进程为什么">游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么</h2>
<p>游戏服务器应该为每个用户开辟一个进程。因为同一进程间的线程会相互影响，一个线程死掉会影响其他线程，从而导致进程崩溃。因此为了保证不同用户之间不会相互影响，应该为每个用户开辟一个进程</p>
<h2 id="缺页置换算法">缺页置换算法</h2>
<p>进程运行过程中，如果发生缺页中断，而此时内存中有没有空闲的物理块是，为了能够把所缺的页面装入内存，系统必须从内存中选择一页调出到<strong>磁盘的对换区</strong>。但此时应该把哪个页面换出，则需要根据一定的<strong>页面置换算法</strong>（Page Replacement Algorithm)来确定</p>
<p>先进先出(FIFO)算法：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。</p>
<p>最近最少使用（LRU）算法: 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。</p>
<p>当前最常采用的就是LRU算法。</p>
<h2 id="死锁发生的条件以及如何解决死锁">死锁发生的条件以及如何解决死锁</h2>
<ol type="1">
<li><strong>互斥条件</strong>：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；</li>
<li><strong>请求和保持条件</strong>：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源</li>
<li><strong>不可剥夺条件</strong>：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放</li>
<li><strong>环路等待条件</strong>：进程发生死锁后，必然存在一个进程-资源之间的环形链</li>
</ol>
<p>解决死锁的方法即破坏上述四个条件之一，主要方法如下（死锁预防）：</p>
<ul>
<li>静态分配资源，一次性把要用的资源都申请到 破坏请求保持条件</li>
<li>可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，等到进程可以同时获取两个资源后再启动，从而破坏不可剥夺的条件</li>
<li>资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件。例如 1，2，3资源，如果进程A 按照 1 2 3 顺序申请，而 B 按照 3 2 1 顺序申请，那必然环路，如果都按照 1 2 3 顺序申请就没事</li>
</ul>
<h3 id="运行时死锁状态判别">运行时死锁状态判别</h3>
<p>银行家算法</p>
<ol type="1">
<li>需要预先知道系统当前剩余的资源数量，以及各个进程已经占有的资源数量和请求的资源数量。</li>
<li>遍历每个进程判断 他当前球请求的资源数量是否小于系统剩余资源数量，如果是标记当前进程；然后将系统剩余资源数量加上当前进程占有的资源数量，这代表该进程释放资源后系统总的剩余资源数量。</li>
<li>再按照之前的步骤去遍历标记剩下的进程。最终未被标记的进程都是死锁进程。</li>
</ol>
<p>如果有一个状态是不安全的 就应该拒绝进入这个状态</p>
<p>通过宏定义 重写加锁去锁算法 主要就是在上锁之前打印请求的资源号和请求的进程 从而得到一个持有的图 然后拓扑排序判断是否有环</p>
<h2 id="请问虚拟内存和物理内存怎么对应">请问虚拟内存和物理内存怎么对应</h2>
<h2 id="操作系统中的结构体对齐字节对齐">操作系统中的结构体对齐，字节对齐</h2>
<p>需要字节对齐的原因：</p>
<ol type="1">
<li>平台原因：不是所有硬件平台都能随机访问任意地址的数据，可能只能从特定地址开始一次读取指定大小的数据，否则会抛出硬件异常。因此通过指定对齐方 式可以使代码方便兼容多种平台。</li>
<li>性能原因：数据结构应该经可能在自然边界上对齐。原因在于，为了访问非对其的内存，可能需要做两次内存访问，而对齐的内存访问只需要一次。例如如果内存只能从偶地址开始读，那么直接访问奇地址开始的两字节变量需要先访问两次偶地址的地址，然后组合得到实际的数据值。</li>
</ol>
<p>字节对齐的规则：</p>
<ol type="1">
<li>结构体字节对齐规则：结构中，第一个变量的起始地址为0，其他变量的起始地址要是 变量本身大小 和 unpack指定的对齐数中 较小的整数倍。如果不是，就补齐。</li>
<li>结构体本身对齐规则：结构本身所占的 大小，要是 成员中最大变量的字节数 和 unpack指定对齐参数中取较小的 数的整数倍。</li>
<li>结构体中如果还有结构体：那么内部的结构体要对齐在它本身 元素中最大变量 的 地址上。</li>
</ol>
<p>如何自定义对齐方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#program pack(2)   <span class="comment">// n=1,2,4,8,16来改变这一系数，其中的n就是指定的“对齐系数”。</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AA</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a;       <span class="comment">//长度4 &gt; 2 按2对齐；偏移量为0；存放位置区间[0,3]</span></span><br><span class="line"><span class="keyword">char</span> b;      <span class="comment">//长度1 &lt; 2 按1对齐；偏移量为4；存放位置区间[4]</span></span><br><span class="line"><span class="keyword">short</span> c;     <span class="comment">//长度2 = 2 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]</span></span><br><span class="line"><span class="keyword">char</span> d;      <span class="comment">//长度1 &lt; 2 按1对齐；偏移量为7；存放位置区间[8]；最后 结构体要是2的倍数 共10个字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()     <span class="comment">//结束对齐</span></span></span><br></pre></td></tr></table></figure>
<h2 id="进程间通信的方式-1">进程间通信的方式</h2>
<p>进程通信的方式有 管道，消息队列，套接字，共享内存，信号量</p>
<ul>
<li>管道：管道有 无名管道和有名管道。
<ol type="1">
<li>他们都只支持半双工通信，且收发数据双方得同时存在管道的两端；</li>
<li>管道实际是将信息存储在内存中，消息取出后就不再存在于管道中了；</li>
<li>管道传输的是数据流，收发双发需要自定义数据格式；</li>
<li>其中无名管道只能用于有亲缘关系的进程，而有名管道没有这个限制</li>
</ol></li>
<li>消息队列：消息队列存在于内核中，一个消息队列由一个标识符（即队列ID）来标记，数据读取后仍然存在；且消息具有类型和优先级，因此读取方可以按照数据类型读取消息，而不必按照顺序读出；消息队列独立于发送与接收进程，进程终止时，消息队列及其内容并不会被删除。</li>
<li>共享内存：它使得多个进程可以访问同一块物理内存，但是需要用户使用信号量等辅助完成同步操作。这是最快的IPC，因为进程可以直接从物理内存读取。</li>
<li>套接字：用于不同主机中的进程通信。</li>
</ul>
<h2 id="虚拟内存置换的方式">虚拟内存置换的方式</h2>
<p>比较常见的置换方法：FIFO 第二次机会算法 LRU LRU-K LFU NRU</p>
<ol type="1">
<li>FIFO： 用一个队列实现，先进先出。完全没有考虑页面使用的冷热信息。</li>
<li>第二次机会算法：弥补了FIFO的缺点，当再次访问队列中已经存在的页时，将它标记为1，当需要置换页面是，从队头开始，如果其标记为1，那么将它置0并放在队尾，依次循环直到找到标记为0的页面换出。实现的时候可以使用一个环形数组实现，每次只需要移动指针即可完成对头到队尾的转变。
<ul>
<li>当队列中所有的页面都标记为1时，退化成FIFO</li>
</ul></li>
<li>LRU：使用一个链表维护，当访问某个页面时，将该页面放在队头，当需要换出时，将队尾的页面换出。
<ul>
<li>由于需要链表，速度慢；</li>
<li>缓存污染：出现偶然数据时，会让内存存放大量冷数据；</li>
<li>缓存颠簸：当出现交替的数据时，命中率很低，每次都要置换。例如 0 1 2 3 0 1 2 3 … 这种数据 缓存大小只有3<br />
</li>
</ul></li>
<li>LRU-K：为了解决LRU中缓存污染的问题。维护 一个 FIFO 加 一个 LRU，基本原理是只有当某个页面访问次数超过K次之后才使用LRU的规则置换，否则对于访问频率较少的页面直接使用FIFO的策略淘汰。具体思路是，当新加入一个页面时，先将它放入FIFO中，当访问某个页面时需要记录FIFO中每个页面的被访问次数，如果大于K，就将它从FIFO中删除并放入LRU的链表中，如果LRU缓存满了就按照LRU的规则删除链表尾部的元素。当需要删除页面时，将FIFO中先进入的页面删除。
<ul>
<li>为了解决 LRU 的缓存污染问题</li>
</ul></li>
<li>2Q算法就是 LRU-2
<ul>
<li>当访问的数据为 ABABABA时退化为 FIFO 用不到LRU</li>
</ul></li>
</ol>
<h2 id="epoll原理">epoll原理</h2>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>面经2</title>
    <url>/posts/11838/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="同步互斥和通信的区别">同步互斥和通信的区别</h3>
<p>同步是指多个线程之间存在的一种松散的协作关系，一个线程的执行与否依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。例如生产消费者模型中，消费者需要等待生产者释放信号的条件后才会有动作</p>
<p>互斥是指某个共享资源在某一时刻只能有一个线程对他进行读写，而其他想要获取它的线程只能休眠。线程互斥可以看做特殊的同步</p>
<h3 id="什么是系统调用">什么是系统调用</h3>
<p>系统调用是操作系统提供给用户的一组接口，用户程序工作在用户态只能受限的访问系统的资源。通过系统调用用户可以主动从用户态转到内核态，进而获得更高的权限，访问操作系统更多的资源。write fork 等都是系统调用</p>
<p>用户态切换到内核态的3种方式</p>
<p>系统调用 异常（例如缺页异常） 外部中断</p>
<p>从出发方式看，可以在认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一样的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断处理机制基本上是一样的，用户态切换到内核态的步骤主要包括：</p>
<ol type="1">
<li>从当前进程的描述符中提取其内核栈的ss0及esp0信息。</li>
<li>使用ss0和esp0指向的内核栈 ； 将当前进程的cs,eip （CS+EIP = PC），eflags，ss(栈段地址), esp（栈顶指针）信息保存起来，这个过程也完成了由用户栈找到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。</li>
<li>将先前由中断向量检索得到的中断处理程序的 cs，eip 信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。</li>
</ol>
<p>软件调用 system_call 函数 触发 80H 中断，然后通过80H的中断向量找到系统调用的处理函数，在该函数中根据不同的系统调用号 找到内核中对应的函数去处理，系统调用号是不同调用函数独有的，用户空间通过CPU寄存器暂存调用号。处理完毕后返回值通过 CPU 寄存器暂存。</p>
<h3 id="互斥锁机制以及互斥锁和读写锁的区别">互斥锁机制，以及互斥锁和读写锁的区别</h3>
<p>互斥锁： 用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。</p>
<p>读写锁：分为读锁 和 写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒，优先唤醒写锁。适用于读取数据的频率远远大于写数据的频率的场合。</p>
<p>互斥锁和读写锁的区别：</p>
<ul>
<li>互斥锁 只允许一个进程访问 资源，不区分读写，因此不能多个线程同时读。</li>
<li>读写锁区分读 和 写，而互斥锁不区分</li>
</ul>
<h3 id="linux的四种锁机制">Linux的四种锁机制</h3>
<p>读写锁：</p>
<p>互斥锁：</p>
<p>自旋锁：spinlock 在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样<strong>节省了线程从睡眠状态到被唤醒期间的消耗</strong>，<strong>在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。</strong></p>
<p>RCU锁：在加上写锁后，所有的读操作都被阻塞了，RCU锁就是解决这个问题的。它支持在写的时候同时高并发读，只有多个同时写的线程需要加自旋锁，但是这个也是很高效的。本质是当线程要对临界资源修改时，创建数据副本，对副本修改，修改完毕后，等待所有的读线程退出临界区后（宽松区）才会将原始的数据指针指向修改后的数据副本。这个指针的修改过程是 原子的，不会发生线程调度和中断，同时只能有一个线程访问并修改数据指针的指向。</p>
<h3 id="说一说进程状态转换图动态就绪静态就绪动态阻塞静态阻塞">说一说进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞</h3>
<ol type="1">
<li>创建状态：进程正在被创建</li>
<li>就绪状态：进程被加入到就绪队列，等到CPU调度运行</li>
<li>运行状态：进程获得时间片，正在CPU中运行，可以和就绪态相互转换</li>
<li>阻塞状态：进程因为等待某种 IO/系统 资源设备而被阻塞 而暂时不能运行，当获取资源后 会 转换为就绪态等待再次被调度</li>
<li>终止状态：进程运行结束</li>
</ol>
<p>早期内存小，资源紧张，I/O设备访问速度慢，可能会出现很多进程都处于阻塞状态等待I/O，这时候可以通过交换技术把阻塞的进程换到外存，腾出内存空间。从而出现了进程的<strong>挂起状态</strong>：<strong>进程被交换到外存，进程状态就成为了挂起状态</strong>。而同进程中解决内存占用过大的问题是通过虚拟内存技术解决。</p>
<ol type="1">
<li>动态就绪：进程在内存，只要CPU调度就可以运行</li>
<li>静态就绪：进程在外存，处于就绪状态，换入到内存然后CPU给调度就可以运行</li>
<li>活动阻塞：进程在内存，但是由于某种原因被阻塞了</li>
<li>静止阻塞：进程在外存，同时被某种原因阻塞了</li>
</ol>
<p>新的转换过程：</p>
<ol type="1">
<li>内存不够时：活动就绪 -&gt; 静止就绪，调到外存</li>
<li>内存不够时：活动阻塞 -&gt; 静止阻塞，调到外存</li>
<li>内存不够 且 时间片用完：运行态 -&gt; 静止就绪，调到外存</li>
</ol>
<h3 id="a-a-new-a-a-i-10在内核中的内存分配上发生了什么">A* a = new A; a-&gt;i = 10;在内核中的内存分配上发生了什么</h3>
<p>可以首先介绍一下内存的模型 各个段的作用</p>
<ol type="1">
<li>A *a 是一个局部指针变量，在栈区，开辟 4/8字节的空间分配给指针</li>
<li>new A 是动态内存分配，在堆区分配，大小为类A的大小</li>
<li>将指针 a 的内存区域填入栈中类A申请到的地址的地址。即指针指向 new 分配的地址</li>
<li>a-&gt;i：先找到指针a的地址 0x000m，通过a的值 0x000n和i在类a中偏移offset，得到a-&gt;i的地址0x000n + offset，进行*(0x000n + offset) = 10的赋值操作，即内存0x000n + offset的值是10</li>
</ol>
<h3 id="给你一个类里面有staticvirtual之类的来说一说这个类的内存分布">给你一个类，里面有static，virtual，之类的，来说一说这个类的内存分布</h3>
<p>static修饰成员变量…. 在全局数据区分配内存；static修饰成员函数…..在代码区</p>
<p>如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。对于含有虚函数的对象，在首地址处有个虚函数表指针，指针指向了该类的虚函数表，虚函数表是个数组一样的表里面每一项存放的是该类的虚函数地址（虚函数指针），虚函数表存放在 代码段中的只读数据区，虚函数表中的函数指针指向的是代码段中的虚函数。</p>
<h3 id="软链接和硬链接区别">软链接和硬链接区别</h3>
<p>链接除了解决了文件共享的问题，还可以隐藏文件的原本路劲，节省空间，提高安全性等。硬链接相当于一个 inode 有不同的文件名，删除源文件，文件实际不会从系统上删除，引用依然有效。软链接相当于创建了一个新的文件，新的 inode 只不过存储的是指向的文件的路径，使用 ln -s 创建，删除源文件，软连接就失效了。</p>
<h3 id="什么是大端小端以及如何判断大端小端">什么是大端小端以及如何判断大端小端</h3>
<p>大端是低字节存在高地址，小端是低字节存在低地址。联合体变量总是从低地址往高地址存储，所以使用联合体判断</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Test t;</span><br><span class="line">    t.i = <span class="number">0</span>;</span><br><span class="line">    t.i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (t.a == <span class="number">1</span>);  <span class="comment">// 如果 a == 1 说明int的低地址存放的是 低字节 是小端</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态变量什么时候初始化">静态变量什么时候初始化</h3>
<p>对于C语言，不存在类的构造问题，静态变量存放在 全局数据区，在编译时就可以初始化；而 c++ 的静态对象存在构造问题，全局静态对象在 main函数执行之前初始化，局部静态对象在第一次使用的时候初始化。</p>
<h3 id="用户态和内核态区别">用户态和内核态区别</h3>
<p>是操作系统的两种运行级别，二者权限不同。用户态的权限级别最低，运行在用户态的程序不能直接访问操作系统的数据结构，只能通过系统调用，异常（例如缺页异常），中断从用户态转向内核态。</p>
<h3 id="两个进程访问临界区资源会不会出现都获得自旋锁的情况">两个进程访问临界区资源，会不会出现都获得自旋锁的情况？</h3>
<p>???</p>
<p>单核cpu，并且开了抢占可以造成这种情况。</p>
<h3 id="windows消息机制知道吗请说一说">windows消息机制知道吗，请说一说</h3>
<p>当用户有操作(鼠标，键盘等)时，系统会将这些时间转化为消息。每个打开的进程系统都为其维护了一个消息队列，系统会将这些消息放到进程的消息队列中，而应用程序会循环从消息队列中取出来消息，完成对应的操作。</p>
<h3 id="c的锁你知道几种">C++的锁你知道几种?</h3>
<p>锁包括互斥锁，自旋锁和读写锁, RCU锁</p>
<h3 id="说一说你用到的锁">说一说你用到的锁</h3>
<p>生产者消费者问题利用互斥锁和条件变量可以很容易解决，条件变量这里起到了替代信号量的作用</p>
<h3 id="内存溢出和内存泄漏">内存溢出和内存泄漏</h3>
<p>内存溢出：指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误</p>
<ul>
<li>内存中加载的数据量过于庞大，如一次从数据库取出过多数据</li>
<li>集合类中有对对象的引用，使用完后未清空，使得不能回收</li>
<li>代码中存在死循环或循环产生过多重复的对象实体</li>
<li>启动参数内存值设定的过小</li>
<li>使用的第三方软件中的BUG</li>
</ul>
<p>内存泄漏：内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。</p>
<ul>
<li>堆内存泄漏：</li>
<li>系统内存泄漏：</li>
<li>虚函数：</li>
</ul>
<h3 id="你都使用什么线程模型">你都使用什么线程模型</h3>
<p>OPEN MP</p>
<p><strong>Future模型</strong>：Future是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。在 c++ 中 使用 pakage_task 类 对可执行对象封装后 可以返回一个 future 对象，通过future 对象可以异步的获取 可执行对象在其他线程中执行后返回的结果。在线程池的实现中，就是通过 package_task 对函数和参数进行统一封装后返回future对象，用于异步获取任务的执行结果。</p>
<p><strong>fork&amp;join模型</strong>：该模型就是 递归的将一个大任务拆解为小任务。然后由单独的线程分别执行小任务，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果。在图像分块多线程中采用了fork join 的思路，最大线程数预先根据cpu核心数设置，如果输入图像大于1000 就分四个线程分别处理。让后汇总结果进入下一步。</p>
<p><strong>actor模型</strong>：actor模型属于一种基于<strong>消息传递机制并行任务处理思想</strong>，它以消息的形式来进行线程间数据传输，<strong>避免了全局变量的使用，进而避免了数据同步错误的隐患</strong>。actor在接受到消息之后可以自己进行处理，也可以继续传递（分发）给其它actor进行处理。在使用actor模型的时候需要使用第三方Akka提供的框架。</p>
<p><strong>生产者消费者模型</strong>：生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题。（线程池就是采用了这个模型，生产者为用户，用户通过GUI线程像 任务队列中放置 地标，多个消费者从 任务队列中取任务完成）</p>
<p><strong>master-worker模型</strong>：master-worker模型类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker子线程，然后由子线程处理任务。如需返回结果，则worker处理结束之后把处理结果返回给master。</p>
<h3 id="说一下微内核与宏内核">说一下微内核与宏内核</h3>
<p>宏内核：除了最基本的进程、线程管理、内存管理外，将文件系统，驱动，网络协议等等都集成在内核里面，例如linux内核。</p>
<ul>
<li>优点：效率高。</li>
<li>缺点：稳定性差，开发过程中的bug经常会导致整个系统挂掉。</li>
</ul>
<p>微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的。</p>
<ul>
<li>优点：稳定，驱动等的错误只会导致相应进程死掉，不会导致整个系统都崩溃</li>
<li>缺点：效率低。典型代表QNX，QNX的文件系统是跑在用户态的进程，称为resmgr的东西，是订阅发布机制，文件系统的错误只会导致这个守护进程挂掉。不过数据吞吐量就比较不乐观了。</li>
</ul>
<h3 id="说一下僵尸进程">说一下僵尸进程</h3>
<ul>
<li><p>正常进程：父进程和子进程是异步的，就是父进程在创建子进程后，子进程什么时候结束，运行到什么状态，父进程是不知道的。Unix中，子进程退出后，除了会释放子进程占用的系统资源，但是会保留子进程的进程号，退出状态，运行时间等这种基本信息。父进程可以通过 waitpid() 系统调用来获得这个信息，调用子进程信息才会完全从内核中删除。</p></li>
<li><p>孤儿进程：就是父进程提前退出，子进程会被init初始进程托管，并在子进程退出后由它代为处理最后的信息。</p></li>
<li><p>僵尸进程：就是子进程退出后，父进程未调用 waitpid 系统调用 获取 子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，占用着进程号。</p>
<ul>
<li>因为系统的进程号是有限的，用完后就无法创建新的进程。</li>
<li>僵尸进程是每个进程必经的阶段</li>
<li>可以同过 ps 命令查看 进程，状态为 Z 的就是僵尸进程，可以通过 kill 命令清楚</li>
<li>子进程在 退出的时候可以向父进程发送信号，告诉它及时处理，或者 fork 两次让他变成孤儿进程由init 进程接管</li>
</ul></li>
</ul>
<p>守护进程(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。</p>
<h3 id="请问gdb调试用过吗什么是条件断点">请问GDB调试用过吗，什么是条件断点</h3>
<h3 id="种io模型">5种IO模型</h3>
<ol type="1">
<li>阻塞式I/O：如果当前进程获取不到I/O时间，就进入休眠状态，会阻塞当前线程的其他任务，但是并不会增加cpu的负担</li>
<li>非阻塞式：类似于轮询，隔段时间检查一下时间是否就绪，中途可以区处理别的事物。但是反复轮询会降低cpu效率</li>
<li>多路复用：多路复用和阻塞式类似，也会阻塞当前线程，但是在一个线程中可以管理多个IO事件，原理就是统一管理一批文件描述符，当其中某一个有响应后就处理。</li>
<li>信号驱动：应用程序使用套接口进行信号驱动I/O，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据</li>
<li>异步式：信号驱动I/O是由内核通知应用程序何时启动一个I/O操作，而异步I/O模型是由内核通知应用程序I/O操作何时完成</li>
</ol>
<h3 id="如何设计server使得能够接收多个客户端的请求">如何设计server，使得能够接收多个客户端的请求</h3>
<p>多线程，线程池，io复用</p>
<h3 id="死循环来连接时新建线程的方法效率有点低怎么改进">死循环+来连接时新建线程的方法效率有点低，怎么改进？</h3>
<p>提前创建好一个线程池，用生产者消费者模型，创建一个任务队列，队列作为临界资源，有了新连接，就挂在到任务队列上，队列为空所有线程睡眠。改进死循环：使用select epoll这样的技术</p>
<h3 id="怎么实现线程池">怎么实现线程池</h3>
<ol type="1">
<li>设置一个生产者消费者队列，作为临界资源</li>
<li>初始化n个线程，并让其运行起来，加锁去队列取任务运行</li>
<li>当任务队列为空的时候，所有线程阻塞</li>
<li>当生产者队列来了一个任务后，先对队列加锁，把任务挂在到队列上，然后使用条件变量去通知阻塞中的一个线程</li>
</ol>
<h3 id="内存池">内存池</h3>
<p>内存池是指程序预先从操作系统<strong>申请一块足够大内存</strong>，此后，当程序中需要申请内存的时候，不是直接向操作系统申请，而是直接从内存池中获取；同理，当程序释放内存的时候，并不真正将内存返回给操作系统，而是返回内存池。当程序退出(或者特定时间)时，内存池才将之前申请的内存真正释放。</p>
<h3 id="动态链接库与静态链接库的区别">动态链接库与静态链接库的区别</h3>
<p>如果可执行文件使用静态库编译，那么编译的时候会将静态库中的可执行代码编译进可执行文件中，而动态库是在程序运行时才加载的。</p>
<p>因此区别是：</p>
<ol type="1">
<li>使用静态库编出的可执行文件更大，但是运行执行效率更高。而动态库需要运行时加载所以慢一点</li>
<li>动态库是系统中所有进程共享的，如果两个程序使用了相同的动态库，那么只需加载进内存中一次，而使用静态库编译的文件则在每个程序中都有一份实现，因此动态库更节省内存</li>
<li>动态库方便后续维护，如果需要更新功能，更换动态库即可不用重新编译可执行文件，而静态库不行</li>
<li>静态库中不能再包含其他动态或静态库，而动态库可以</li>
</ol>
<h3 id="c语言函数调用的原理">C语言函数调用的原理</h3>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210617224928.png" alt="image-20210617224928241" style="zoom: 50%;" /></p>
<p>函数调用流程如下：</p>
<ol type="1">
<li>首先要将当前PC设置为下调用函数的下一条指令，便于调用完毕后返回。同时将PC设置为子函数地址</li>
<li>还要将调用者栈帧的 栈底 bp 指针压入栈中, 并将 sp 指针赋给 bp ， 即当前栈顶为子函数的栈底</li>
<li>将调用函数的入口参数 从右到左 依次入栈</li>
<li>通过PC跳转执行，最后返回值 可以通过eax保存，具体的返回值保存方法
<ul>
<li>返回值类型的，如果所用内存较大 eax 寄存器无法直接保存下，那就预先在栈上开辟一个空间，然后将变量的地址作为第一个隐含的函数入口参数传入函数中；否则直接用 eax cpu寄存器作为媒介返回。</li>
</ul></li>
</ol>
<h3 id="分页和分段存储管理有何区别">分页和分段存储管理有何区别</h3>
<ol type="1">
<li>页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率。段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。</li>
<li>页的大小固定且由系统决定；而段的长度却不固定，决定于用户所编写的程序。</li>
<li>分页的地址空间是一维的，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。</li>
</ol>
<h3 id="多重继承虚函数怎么实现">多重继承虚函数怎么实现</h3>
<p>如果继承自多个类，并且每个类都有虚函数，那么实例化后的对象 就有N个虚表指针；如果虚表中最后一个是 星号 代表还有下一个虚表，否则无。</p>
<h3 id="c原子类型如何实现">C++原子类型如何实现</h3>
<ol type="1">
<li>单核系统中 简单的关中断 屏蔽任务调度即可</li>
<li>在多核系统中 不仅如此还存在多个核的缓存不一致性的问题 ，还需要结合CAS实现 原子操作。CAS一般有硬件指令级的支持，原理就是，首先从内存中读取要修改的变量，将他和期望值比较，如果和期望值不同，那么就说明它被修改了就什么都不做返回false，如果相同，则对变量修改并返回true。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如我要执行 i++  首先是  从内存中读取 i 发现他等于 0 然后在cpu缓存中执行+1为1后要把它写回内存，这时候 CAS 作用就来了，如果回写的时候，我先读一遍发现 i 不是 0 而是 其他值，说明在我执行i+1过程中有其他人修改了内存值，因此此时 返回false 不能将自己cpu中缓存的1写给i；</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_and_swap</span> <span class="params">(<span class="keyword">int</span>*accum, <span class="keyword">int</span>*dest, intnewval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( *accum == *dest ) &#123;</span><br><span class="line">      *dest = newval;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="进程调度算法详解">进程调度算法详解</h3>
<h3 id="多个线程轮流打印1-100">多个线程轮流打印1-100</h3>
<p>思路</p>
<ol type="1">
<li>通过一个变量来控制线程同步的逻辑</li>
<li>如果</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="keyword">int</span> ready = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintString_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(ready != <span class="number">0</span>)</span><br><span class="line">            cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        ready = <span class="number">1</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintString_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(ready != <span class="number">1</span>)</span><br><span class="line">            cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        ready = <span class="number">2</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintString_3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt&lt;<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(ready != <span class="number">2</span>)</span><br><span class="line">            cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;C&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        ready = <span class="number">0</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread  <span class="title">t1</span><span class="params">(PrintString_1)</span></span>;</span><br><span class="line">    <span class="function">std::thread  <span class="title">t2</span><span class="params">(PrintString_2)</span></span>;</span><br><span class="line">    <span class="function">std::thread  <span class="title">t3</span><span class="params">(PrintString_3)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="inline-和-define区别">inline 和 define区别</h3>
<p>define 是预处理阶处理的，只是简单的替换，并没有入口参数类型检查啥的。而Inline 在编译阶段将代码段直接擦插入到每个调用它的地方，但是并不是函数调用的形式，因此效率比较高且安全可靠 是一种空间换时间的手段。</p>
<h3 id="两个线程对一个int-a-1-的变量同时进行-a-操作一万次那么最后a的值是多少呢">两个线程对一个int a = 1 的变量同时进行 a++ 操作一万次，那么最后a的值是多少呢</h3>
<p>10000 - 20000 之间 考虑多线程冲突</p>
<h3 id="什么是闭包-lambda表达式">什么是闭包 lambda表达式</h3>
<p>c++11 中 匿名函数 可以实现闭包，但是概念上 闭包是指 包含函数指针和上下文数据环境的一个结构体，相当于捕获的上下文数据+函数地址。如果一个函数没有捕捉自由变量那么其实就可以实现为一个函数指针，如果捕获了自由变量，他就是一个闭包，当他脱离当前的环境，依然可以正常执行。c98中没有匿名函数，但是可以通过仿函数来模拟闭包。</p>
<p>因此匿名函数返回的就是一个匿名的闭包实例，他是个右值，可以通过捕获的方式封装当前作用域的变量或者他们的引用。</p>
<h3 id="c11-vector库中有什么改进">C++11 vector库中有什么改进</h3>
<p>有了移动拷贝构造函数 避免了很多不必要的对象内存赋值</p>
<h3 id="模板类和泛型编程">模板类和泛型编程</h3>
<p>C++这种语言不像python javascript这种动态语言一样，一个函数可以传入任何类型的参数。C++的模板弥补了这个缺点，在定义函数或者类时可以将参数类型设置为模板，当调用的时候编译器再根据调用的类型去实例化对应的参数类型。优点是更灵活，大大减少代码量。缺点是 模板的定义和声明必须放在同一个文件中 这点和c++常规的定义声明分开编写的原则不同。</p>
<h3 id="磁盘io的原理">磁盘IO的原理</h3>
<p>操作系统使用DMA直接将数据从 磁盘 拷贝到 页缓存中，或者将数据写回磁盘，这个过程不需要处理。但是将应用程序地址空间和内核空间之间的拷贝需要 CPU 开销。</p>
<h3 id="序执行-内存屏障-voliate">序执行 内存屏障 voliate</h3>
<h3 id="linux的字符集">Linux的字符集</h3>
<h3 id="读写锁的实现原理">读写锁的实现原理</h3>
<h3 id="c死锁检测">C++死锁检测</h3>
<h3 id="操作系统的内存映射是如何实现的-共享内存如何实现的">操作系统的内存映射是如何实现的 （共享内存如何实现的）</h3>
<h3 id="共享内存能放什么样的数据结构是用什么数据结构实现的">共享内存能放什么样的数据结构，是用什么数据结构实现的</h3>
<h3 id="进程在操作系统的存在方式">进程在操作系统的存在方式</h3>
<h3 id="epoll原理和类似的中间件之间的区别selectpoll">epoll原理和类似的中间件之间的区别（select，poll）</h3>
<h3 id="消息队列内核是如何实现的">消息队列内核是如何实现的</h3>
<h3 id="信号量linux是如何实现的如何进行进程的通信">信号量Linux是如何实现的，如何进行进程的通信</h3>
<h3 id="信号了解吗进程的信号通信底层是如何实现的">信号了解吗，进程的信号通信底层是如何实现的</h3>
<h3 id="讲讲io模型">讲讲I/O模型</h3>
<h3 id="pv操作如何实现的">PV操作如何实现的</h3>
<h3 id="什么是中断">什么是中断</h3>
<h3 id="liunx下如何shell下查看cpu内存资源使用情况用什么命令">liunx下如何shell下查看cpu内存资源使用情况用什么命令</h3>
<h4 id="介绍一下io多路复用">介绍一下<strong>IO</strong>多路复用</h4>
<h3 id="缓存的管理方式lrulfu">缓存的管理方式（LRU，LFU）</h3>
<h4 id="将一个文件从内存中写入磁盘设计一种数据结构来加速这个过程">将一个文件从内存中写入磁盘，设计一种数据结构来加速这个过程</h4>
<p>（应该是LSM树）</p>
<h3 id="负载均衡算法">负载均衡算法</h3>
<h3 id="cpu流水线">CPU流水线</h3>
<h3 id="缓存一致性协议">缓存一致性协议</h3>
<h3 id="程序中通过地址读取一个变量的过程">程序中通过地址读取一个变量的过程</h3>
<p>（虚拟地址到物理地址，MMU，CR3，转换的细节，这里问了一个我不懂的名词，说是MMU获取页目录地址的过程）</p>
<h3 id="进程优先级和cpu的任务调度策略优先级反转">进程优先级和CPU的任务调度策略（优先级反转）</h3>
<h3 id="高并发下同时操作任务队列">高并发下同时操作任务队列</h3>
<h2 id="linux">Linux</h2>
<p>Linux命令 awk，strace，gdb调试相关</p>
<p>Linux常用命令</p>
<p>Linux与Windows最大的区别</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络-网络层</title>
    <url>/posts/34443/</url>
    <content><![CDATA[<p>数据链路层 是专注于两个设备之间的 交互连接，而网络层则是为了跨区域之间的交流。</p>
<span id="more"></span>
<h2 id="网络层">网络层</h2>
<h3 id="概述">概述</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406091935.png" alt="" /><figcaption>image-20201206191411763</figcaption>
</figure>
<p>与 IP 协议配套使用的还有三个协议：</p>
<ul>
<li>地址解析协议 ARP（Address Resolution Protocol）</li>
<li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li>
<li>网际组管理协议 IGMP（Internet Group Management Protocol</li>
</ul>
<h3 id="ip数据报格式">IP数据报格式</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406091942.png" alt="" /><figcaption>image-20201206191956087</figcaption>
</figure>
<ul>
<li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li>
<li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li>
<li><strong>区分服务</strong> : 用来获得更好的服务，一般情况下不使用。</li>
<li><strong>总长度</strong> : 包括首部长度和数据部分长度。</li>
<li><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li>
<li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li>
<li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li>
<li><strong>标识</strong> : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>
<li><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li>
</ul>
<h3 id="ip地址编址方式">IP地址编址方式</h3>
<p>IP 地址的编址方式经历了三个历史阶段。</p>
<h4 id="分类">1. 分类</h4>
<p>分类的的方法就是将 IP地址划分位固定的两段，一段是网络号，一段是主机号。IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}。有ABCD四类地址，前三类的就是网络号和主机号的长度分配不同。对于拥有大量节点的少部分网络，使用A类网络，因为主机号长度更长。对于主机数量少的就用C类网络。</p>
<p>路由器仅根据目的主机的<strong>网络号</strong>来转发分组，从而减小路由表所占用的存储空间以及查找路由表的时间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210526222951.png" alt="image-20210516194527774" style="zoom:67%;" /></p>
<h4 id="子网划分">2. 子网划分</h4>
<p>可以看出，两级 <strong>IP 地址</strong> 不够灵活, 对 <strong>IP 地址</strong>空间的利用率比较低。如, C 类地址的局域网最多分配 254 个<strong>主机号</strong>, B 类地址的局域网最多分配 65534 个<strong>主机号</strong>。如果有个单位有 255 台主机，则只能为其分配一个 B 类地址的 <strong>网络号</strong>。这样就会浪费很多 <strong>IP 地址</strong>。</p>
<p><strong>子网划分</strong> 将之前的<strong>主机号</strong> 进一步划分为 <strong>子网号(subnet-id)</strong> 和 <strong>主机号</strong>，三级IP地址，从而提高 <strong>IP地址</strong> 的利用率。路由器将<strong>子网掩码</strong>和目标地址进行<strong>按位与</strong>操作，从而得到目标网络的<strong>网络号</strong>和<strong>子网号</strong>， 进而将数据包发送到相应的网络中去。</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210516194627.png" alt="image-20210516194627674" style="zoom:50%;" /></p>
<p><strong>可变长度子网掩码</strong> 允许将网络划分为不同大小的子网， 每个主机和路由器端口除了分配一个 <strong>IP 地址</strong>，还需要配置一个子网掩码，以确定其所在子网的规模。如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p>
<h4 id="无分类">3. 无分类</h4>
<p>前两种 A、B、C 类IP地址编址方式网络号都为8的倍数，其划分不够精细，存在很大程度的浪费。因为大部分机构都倾向于申请B类网络，以避免同一个机构需要管理多个类别的网络的问题，所以B类网络用的很快啊。基于此，无分类编址方式<a href="https://baike.baidu.com/item/无类域间路由/240168?fr=aladdin&amp;fromid=3695195&amp;fromtitle=CIDR">CIDR</a>应运而生。<strong>CIDR消除了传统的A类、B类和C类地址及划分子网的概念</strong>， 将 <strong>IP 地址</strong>分为<strong>网络前缀(network-prefix)</strong> 和<strong>主机号</strong> 两部分，可以更加有效地分配IPv4的地址空间（可以把多个C类网络聚合成为一个给机构使用，例如一个C类网络主要是能用最低8位254个主机，那么使用如果把低10位都保留给主机段，将22作为前缀分配个机构，就保证机构获得的IP地址中能接入的主机数更多，即划分不够精细的问题得到解决）</p>
<p>使用 <strong>CIDR 记法</strong>(<strong>IP 地址</strong>后面加上斜线，然后写上网络前缀所占位数)记录 <strong>IP 地址</strong>。如：<code>128.14.35.7/20</code></p>
<p>CIDR把网络前缀都相同的连续IP地址组成一个“CIDR地址块”。我们只要知道CIDR地址块中的任何一个地址，就可以知道这个地址块的起始地址（最小地址）和终止地址（最大地址），以及地址块中的地址数。</p>
<p>CIDR 的地址掩码可以继续<strong>称</strong>为子网掩码，子网掩码首 1 长度为网络前缀的长度。虽然，“CIDR不使用子网”，是<strong>指CIDR中并没有在32位地址中指明若干位作为子网字段</strong>。但分配到一个CIDR地址块的单位，<strong>仍然可以在本单位内根据需要划分出一些子网</strong>。这些子网也都只有一个网络前缀和一个主机地址号，但子网的网络前缀比整个单位的网络前缀要长一些。</p>
<p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 <strong>构成超网</strong> 。</p>
<p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p>
<h3 id="地址解析协议arp-局域网">地址解析协议ARP （局域网）</h3>
<p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，<strong>IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变</strong>。（图示的是一个局域网之间的连接，局域网内的IP无重复，局域网中设备通信使用内网IP，但是如果要访问外网，是通过网关以公网IP的形式访问的，因此不同局域网中的设备可能会有相同的 IP地址 但是公网IP全球唯一，由运营商提供）</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406091950.png" alt="" /><figcaption>image-20201206192612627</figcaption>
</figure>
<p><strong>ARP 实现由 IP 地址得到 MAC 地址</strong> 每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406091958.png" alt="" /><figcaption>image-20201206193111967</figcaption>
</figure>
<h3 id="icmp协议">ICMP协议</h3>
<p>一个新搭建好的网络，往往需要先进行一个简单的测试，来验证网络是否畅通；但是IP协议并不提供可靠传输。如果丢包了，IP协议并不能通知传输层是否丢包以及丢包的原因。ICMP是基于IP协议工作的，但是它并不是传输层的功能。ICMP协议就是这个作用：</p>
<ol type="1">
<li>确认IP包是否成功到达目标地址</li>
<li>通知在发送过程中IP包被丢弃的原因</li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406092004.png" alt="" /><figcaption>image-20201206193518864</figcaption>
</figure>
<p>ICMP 报文分为差错报告报文和询问报文</p>
<h4 id="ping">ping</h4>
<p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。 Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p>
<h4 id="traceroute">Traceroute</h4>
<p>Traceroute 是 ICMP 的另一个应用，<strong>用来跟踪一个分组从源点到终点的路径</strong>。Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p>
<ul>
<li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li>
<li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li>
<li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li>
<li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li>
</ul>
<h3 id="虚拟专用网-vpn">虚拟专用网 VPN</h3>
<p>IP地址有两类：</p>
<ul>
<li><strong>本地地址</strong>——仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向因特网的管理机构申请。</li>
<li><strong>全球地址</strong>——全球唯一的IP地址，必须向因特网的管理机构申请。</li>
</ul>
<p>RFC 1918 指明的专用地址</p>
<ul>
<li>10.0.0.0 ~ 10.255.255.255</li>
<li>172.16.0.0 ~ 172.31.255.255</li>
<li>192.168.0.0 ~ 192.168.255.255</li>
</ul>
<p>这些地址只能用于一个机构的内部通信（局域网用），而不能用于和因特网上的主机通信。在因特网中的所有路由器对目的地址是专用地址的数据报一律不进行转发。</p>
<p><strong>而虚拟专用网VPN技术实现的功能就是使全球地址也能访问本地地址。</strong>VPN技术的实质就是在互联网上传输私有数据，但是使用Internet传输私有数据是不安全的。可以通过采取一定的安全措施使得这个传输过程变得安全，比如采用PPTP 或 L2TP等传输协议对数据进行加密和拨号前进行身份验证等。通过这些手段相当于建立了一段安全的专线，可以不安全的环境安全地传输私有数据，这就叫做<strong>虚拟专用网络</strong>。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406092010.png" alt="" /><figcaption>image-20201206220955214</figcaption>
</figure>
<p>若远程用户想要访问WebServer，先要向公司内部配置好的远程访问服务器拨号，拨号拨通之后，<strong>远程访问服务器就会给远程用户一个私网地址：10.0.0.8。即远程用户获得了两个IP地址：一个公网地址23.23.2.20，拨号后获得的一个私网地址10.0.0.8。然后该用户就有能力访问企业内网的WebServer了</strong>。当远程用户与企业内网WebServer通信时，数据包中的源地址和目标地址都为私网地址，但是互联网上的路由器不转私网数据包。解决方法为：（<strong>关键就是 套了两层 源地址 目标地址 最外层就是在互联网中必备的 公网IP，内层是VPN服务器给他分的局域网IP和目标主机局域网IP</strong>）</p>
<ul>
<li>远程用户在公网上访问企业内部服务器RAS时，先使用RAS服务器分配的私网地址作为数据包的源地址，企业内网的WebServer地址作为目标地址组成局域网数据包。然后远程用户再使用自己的公网地址作为源地址，RAS服务器的公网地址作为目标地址对局域网数据包进行封装，组成广域网数据包。由于广域网数据包的目标地址和源地址都为公网地址，所以数据包可以通过互联网顺利中转到企业内的RAS服务器上。</li>
<li>收到广域网数据包后，RAS服务器再去掉其中的公网目标地址和源地址，把数据包还原为局域网数据包，最后中转给WebServer。</li>
<li>同样的，从WebServer发出的数据包，经过远程访问服务器RAS中转至公网前，先对数据包进行封装，加上一层公网的目标地址和源地址</li>
<li>即远程用户和企业内配置好的远程访问服务器RAS都拥有一个私网地址和一个公网地址，在公网上通信时使用广域网数据包，在私网内通信时使用局域网数据包。</li>
</ul>
<h3 id="网络地址转换-nat">网络地址转换 NAT</h3>
<p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。（<strong>和VPN的区别在于，用NAT可以使得内网的主机访问互联上的资源，但是 互联网上其他用户不能主动通过NAT访问内网的机器，所以这时候就要用VPN</strong>）。</p>
<p>原始的NAT不对端口映射，例如校园网只有3个公网IP，那么当内网的用户要访问互联网时，就需要把内网IP 和 公网 IP对应，然后数据包以公网IP为源目标的形式发出去，收数据包的时候再替换。这样很消耗IP。现在的NPAT其实将<strong>传输层端口和内网IP都进行了映射</strong>，即便只有一个公网IP，每个需要访问外网的内网用户 都使用这个 公网IP和互联网通信，只不过将内网IP和端口号一起映射了。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406092014.png" alt="" /><figcaption>image-20201206221613385</figcaption>
</figure>
<h3 id="路由器结构">路由器结构</h3>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406092019.png" alt="" /><figcaption>image-20201206224057134</figcaption>
</figure>
<p>路由器从功能上可以划分为：路由选择和分组转发。 分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p>
<h4 id="转发流程">转发流程：</h4>
<ol type="1">
<li><p>从数据报的首部提取目的主机的IP地址D，得出目的网络地址位N.</p></li>
<li><p>若N就是与此路由器直接相连的某个网络地址，则进行直接交付，不需要再经过其他的路由器，直接把数据报交付目的主机（这里包括把目的主机地址D转换为具体的硬件地址，把数据报封装成MAC帧，再发送此帧。），否则，就是间接交付，执行（3）</p>
<ul>
<li>A发出目的地为C的IP数据报，查询路由表发现下一跳为E</li>
<li>A将IP数据报交给数据链路层，并告知目的MAC地址是E （ARP）</li>
<li>数据链路层填充<strong>源MAC地址A</strong>和<strong>目的MAC地址E</strong></li>
<li>数据链路层通过物理层将数据发送给E</li>
</ul></li>
<li><p>若<strong>路由表</strong>中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器，否则，执行（4）</p></li>
<li><p>若路由表中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由器，否则，执行（5）。</p></li>
<li><p>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则执行（6）.</p></li>
<li><p>报告转发分组出错。</p></li>
</ol>
<p><strong>数据帧每一跳的MAC地址都在变化（源MAC地址和目的MAC地址）， 但是IP数据报每一跳的源和目标IP地址始终不变</strong></p>
<h3 id="路由选择协议">路由选择协议</h3>
<p>路由选择算法--更新--&gt;路由表--供--&gt;路由器分组转发时使用</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210516212802.png" alt="image-20210516212802846" style="zoom:50%;" /></p>
<h4 id="asautonomous-system自治系统">AS(Autonomous System)自治系统</h4>
<p>自治系统是在单一技术管理体系下的多个路由器的集合，在自治系统内部使用内部网关协议（IGP）和通用参数来决定如何路由数据包，在自治系统间则使用AS间路由协议来路由数据包。</p>
<ul>
<li>自治系统AS内部的路由选择：RIP 和 OSPF</li>
<li>自治系统间的路由选择：BGP</li>
</ul>
<h4 id="内部网关协议-rip">内部网关协议 RIP</h4>
<p>这个和局域网 概念不一样。</p>
<p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。 （路由表 ： 目的网络IP 距离 到达目的网络的下一跳网络）</p>
<p>距离向量算法：</p>
<ul>
<li>相邻路由器X 将他的路由表发给 当前路由器W，先修改受到的路由表中所有下一条地址为 X 并把距离字段 加 1</li>
<li>对修改后的RIP报文的每个项目做如下操作：
<ol type="1">
<li>若收到的路由表中的项 若 目的网络H 在当前路由表中不存在，则将其添加到W的路由表中，那么此时 W就知道 要去H网络的下一跳是X。</li>
<li>若W的路由表中有下一跳为X的项目，则将他们都更新为 X 新发过来的项目 （因为X发过来的路由表是它更新过的，肯定是最新且最短的）</li>
<li>若W的路由表中 到目的网络的距离大于 收到的路由表中到达相同目的网络的距离 则 替换为最短的 如 原本到Net2 的距离是5，下一跳节点是P，而受到的来自X的路由表中 到Net2的距离是4（下一条一定是X），那么就用这个短的。</li>
</ol></li>
<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16</li>
</ul>
<p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406092116.png" alt="" /><figcaption>image-20201207194718827</figcaption>
</figure>
<h4 id="内部网关协议-ospf">内部网关协议 OSPF</h4>
<p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。 开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。OSPF 具有以下特点：</p>
<ul>
<li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li>
<li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li>
<li>只有当链路状态发生变化时，路由器才会发送信息。</li>
</ul>
<p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p>
<h4 id="外部网关协议-bgp">外部网关协议 BGP</h4>
<p>AS 之间的路由选择很困难，主要是由于：</p>
<ul>
<li>互联网规模很大；</li>
<li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li>
<li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li>
</ul>
<p>BGP 只能寻找一条比较好的路由，而不是最佳路由。每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406092111.png" alt="" /><figcaption>image-20201207195714344</figcaption>
</figure>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-树</title>
    <url>/posts/19968/</url>
    <content><![CDATA[<p>数据结构之树，例如二叉树，平衡二叉树，堆，等</p>
<span id="more"></span>
<h1 id="树">树</h1>
<h2 id="树的类别">树的类别</h2>
<figure>
<img src="https://pic3.zhimg.com/v2-e7a99fda571a4294e9b2196d58f8e65c_r.jpg?source=1940ef5c" alt="" /><figcaption>preview</figcaption>
</figure>
<h2 id="平衡二叉树">平衡二叉树</h2>
<p>给定一棵树 判断是否为平衡二叉树，即任意节点的左右子树的高度差不超过1，即为平衡二叉树。</p>
<p>这道题的关键是，任意子节点的左右子树高度差不超过1。如果只是判断根节点的左右子树的高度，那么写一个前序遍历的递归即可，如下代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">height</span>(root-&gt;left), <span class="built_in">height</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入根节点，通过前序遍历的方式往下遍历，遍历计算左节点高度-&gt;回退父节点-&gt;遍历计算右子节点高度-&gt;二者高度取最大+1。但是这么一次遍历 最终计算的只是 根节点的左右子节点的高度。因此还需一个递归，来遍历判断所有节点是否为平衡节点。加入以下递归调用的方式。先判断当前节点的左右子树的高度差是否满足 再判断左右子树的子树高度差是否满足…..</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(<span class="built_in">height</span>(root-&gt;left) - <span class="built_in">height</span>(root-&gt;right)) &lt;= <span class="number">1</span> &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树">二叉搜索树</h2>
<p>（采用二分法思维把数据按规则组装成一个树形结构的数据）</p>
<p>是一种特殊的二叉树 （参考：https://blog.csdn.net/John_xyz/article/details/79622219），它改善了二叉树节点查找的效率。二叉查找树有以下性质。二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低,均为O(log n)。对于任意一个节点 n：</p>
<ul>
<li>其左子树（left subtree）下的每个后代节点（descendant node）的值都小于节点 n 的值；</li>
<li>其右子树（right subtree）下的每个后代节点的值都大于节点 n 的值；</li>
<li>没有键值相等的节点</li>
</ul>
<h3 id="二叉搜索树有关操作">二叉搜索树有关操作</h3>
<p>​ <strong>插入</strong>：若b是空树，则将s所指结点作为根节点插入，否则；若s.val等于b的根节点的数据域之值，则返回，否则；若s.val小于b的根节点的数据域之值，则把s所指节点插入到左子树中；否则把s所指节点插入到右子树中<strong>新插入节点总是叶子节点</strong></p>
<p>​ <strong>删除</strong>：分三种情况，如下图，1. 如果待删除的节点是叶子节点，那么可以立即被删除；2. 如果有一个子节点，要将下一个子节点上移到当前节点，即替换之；3.如果有两个子节点，则将其右子树的最小数据代替此节点的数据，并将其右子树的最小数据删除。</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406095944.png" alt="" /><figcaption>1599307406058</figcaption>
</figure>
<p>查找：最佳情况Olog(n)Olog(n), 最坏情况O(n)O(n) 插入：最佳情况Olog(n)Olog(n), 最坏情况O(n)O(n) 删除：最佳情况Olog(n)Olog(n), 最坏情况O(n)</p>
<h2 id="avl树">AVL树</h2>
<p>平衡二叉排序树，首先是二叉搜索树，其次是平衡树。因此有二者的共同特点。所有子树都是平衡二叉树，且左右子树的高度差不值不超过1。https://www.cnblogs.com/lanhaicode/p/11321243.html</p>
<h3 id="平衡因子">平衡因子</h3>
<p>某结点的左子树与右子树的高度或深度 差即为该结点的平衡因子（BF,Balance Factor），平衡二叉树（AVL树）上所有结点的平衡因子只可能是 -1，0 或 1。AVL树的数据结构中 存放的是 节点的高度 height。</p>
<h3 id="查找节点">查找节点</h3>
<p>和二叉搜索树类似</p>
<h3 id="插入节点">插入节点</h3>
<p>​ 二叉搜索树每次插入节点都插在树的叶节点。在插入后，树可能失衡。处理流程为： ​ 按照搜索树的方式插入新节点 -&gt; 搜索最低失衡点 -&gt; 判断失衡点的类型 -&gt; 调整二叉树平衡</p>
<p><em>失衡的类型</em> ： <strong>RR LL RL LR</strong></p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406095948.png" alt="" /><figcaption>image-20201102213545758</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406095950.png" alt="" /><figcaption>image-20201102213920250</figcaption>
</figure>
<p>​ LL 和 RR 型相对简单。只需要旋转一次即可。</p>
<figure>
<img src="https://img2018.cnblogs.com/blog/1590962/201908/1590962-20190812202510882-2058601498.gif" alt="" /><figcaption>img</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406095954.png" alt="" /><figcaption>image-20201102214304915</figcaption>
</figure>
<h3 id="删除节点">删除节点</h3>
<p>​ 比插入还复杂，但是本质还是那四种旋转方式。只不过删除可能会多两种 RE LE 类不平衡的情况。</p>
<h2 id="红黑树">红黑树</h2>
<p>红黑树是特殊的二叉查找树，首先它满足二叉查找树的所有要求，其次为了缓解二叉查找树不平衡的坏情况带来 数据查找效率降低的问题，引入了红黑树的一些独有的限制。具体的有如下特性：</p>
<ol type="1">
<li>每个节点要么是红色要么是黑色（用一个数据表示）</li>
<li>根节点是黑色</li>
<li>每个叶子节点都是黑色，并且为空节点。（这里的叶节点是黑色的意思是 常规的叶子节点下面都有两个空的null，算作黑色节点，对于只有一个孩子的节点，他的另一边也是一个null空的黑色节点）</li>
<li>红色节点后必须是两个黑色子节点。即红色节点不能连续。（黑色节点可以）</li>
<li>从根节点到最后的null(黑色)的叶子节点，每条路径上的黑色节点数应该一样。</li>
</ol>
<p>在上述4，5的约束下，红黑树的 最长路径（红黑相间路径 2N）不会超过 最短路径（全是黑色节点的路径N）的两倍</p>
<h3 id="插入节点-1">插入节点</h3>
<h3 id="删除节点-1">删除节点</h3>
<p>参考 ：https://zhuanlan.zhihu.com/p/22800206?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1266313842667769856&amp;utm_campaign=shareopn</p>
<p>​ 首先，红黑树删除节点和普通二叉搜索树一样，首先找到待删除的节点X，如果 X 有两个子节点，那么在他的右子树或左子树寻找替代节点S，然后将替代节点S的值和待删除节X点的值交换（颜色不变）问题就转变为删除节点S （且此时的S节点最多只有一个孩子，因为由二叉搜索树的性质，替代节点一定是右子树的最小值）。因此最终问题都归结为删除 至多有一个孩子节点的节点。 下面详细分析：</p>
<ol type="1">
<li>如果删除的是红色叶子节点，直接删除即可，删除一个红色叶节点不违反任何特性。</li>
<li>如果删除的是黑色叶子节点，明显删除了之后经过该叶子节点的路径上黑色节点数量少一 需要处理。</li>
<li>如果删除的节点有一个叶子节点，两个一黑一红，可以直接转换成 1 解决。</li>
<li>如果删除的节点和其叶子节点都是黑色，将叶子节点和待删除节点值替换，那么问题转换为 （删除一个黑色叶子节点的情况 2）</li>
</ol>
<p>综上，所有情况都转换为 情况1，2两种，而情况1很容易，下面讨论问题2的解决方法 （删除一个黑色叶子节点）</p>
<p>​ 这是，待删除的叶子节点是黑色，那么他一定有兄第节点 （如果 S 没有兄弟节点，到兄弟 null 的路径上黑色节点数比到 S 的null叶节点上的黑色节点树少1 。不满足红黑树性质5的约束）下面就是对它的兄弟节点的颜色讨论：</p>
<ol type="1">
<li><p>待删除的节点是一个左叶子节点 即图中的 80 为待删除节点</p>
<ol type="1">
<li><p>兄弟节点是黑色，此时兄弟节点可能会有1/2/0个红色节节点 （此时兄弟的子节点不可能是黑色，需满足红黑树约束）</p>
<ol type="a">
<li><p>兄弟有一个红色右节点</p></li>
<li><p>兄弟有一个红色左节点 简单旋转兄弟节点和兄弟节点的子节点位置即转为 情况 a</p></li>
<li><p>兄弟有两个红色节点</p></li>
<li><p>兄弟没有子节点</p></li>
</ol></li>
<li><p>兄弟节点是红色，此时兄弟一定会有两个黑色子节点，如果是一个也不满足条件5约束</p></li>
</ol></li>
<li><p>待删除的节点是一个黑色右叶子节点 即中的 110</p>
<p>… 同上分类</p></li>
</ol>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406100001.png" alt="" /><figcaption>image-20201104210955575</figcaption>
</figure>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406100003.png" alt="" /><figcaption>image-20201104212934752</figcaption>
</figure>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406100006.png" /></p>
<h2 id="b-树">B-树</h2>
<p>二叉树虽然搜索效率也很高，但是二叉树应用的是场景是对存储在内存的数据查找，对于存储在硬盘的数据，数据量大，且硬盘读写速度慢，而将整个硬盘存储区的内容一次读入内存也装不下，因此需要用B树/B+树，主要用于数据库的查找索引等。因为B树每个节点可以存储多个子节点（键值），所以B树需要对硬盘的读写次数较低（尽管比较次数较二叉树多）。B树的阶数一般为磁盘每页的容量大小 （从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读）</p>
<h3 id="规则">规则</h3>
<ol type="1">
<li><p>排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；</p></li>
<li><p>子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉；</p></li>
<li><p>关键字数：非根节点的关键字数量大于等于 ceil(M/2)-1 个 （向上取整） 且小于等于M-1个；</p></li>
<li><p>所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</p>
<figure>
<img src="https://pic2.zhimg.com/v2-2c2264cc1c6c603dfeca4f84a2575901_r.jpg" alt="" /><figcaption>preview</figcaption>
</figure>
<p>如图中，每个内部节点如果有 n 各关键字，那么他们就有n+1个间隔，子树的所有键值一定在对应的间隔大小范围内。</p></li>
</ol>
<h3 id="插入节点-2">插入节点</h3>
<p>​ 插入的规则就是，先往下搜索到最底层，插入，如果当前位置的关键字数量超过了它允许的最大数量，就取中间那个键为新的根，左右分裂为两个新的子树，再将新的根归并入他原本的父节点中，此时父节点也超了，同理再分裂向上增加节点，若直到根节点还是超，那么此时树的高度就增加了1。</p>
<figure>
<img src="https://pic1.zhimg.com/v2-3057eaab2b1764dd51c2a8658791cc98_r.jpg" alt="" /><figcaption>preview</figcaption>
</figure>
<h3 id="删除节点-2">删除节点</h3>
<ol type="1">
<li>如果删除的是叶子节点，且删除后数量依然满足要求，就直接删</li>
<li>如果删除的不是叶子节点，且删了之后数量不够
<ul>
<li>如果它的左边 或者 右边 兄弟节点树比最低标准多，那么就根兄弟节点接节点。具体的，如果是跟右边的兄弟节点借，先把右边兄弟节点最左边的键移动的父节点，再把父节点中对应的节点移动到该子节点。</li>
<li>如果它的左右兄弟节点都不够借，就和左/右兄弟节点合并。具体的 将该节点和上连的父节点比他大的键以及右边兄弟节点一起 合并为一个子节点。（和左边兄弟节点合并也类似）然后此时父节点由于给出一个关键子，可能数量少于要求了，就对父节点做同样的调整。至到满足要求的节点 或者 根节点（此时树高度就减一了）</li>
</ul></li>
<li>如果删除的不是叶子节点，类似二叉查找树里的操作，寻找右边子树最小的叶子节点或左边子树的最大叶子节点与他替换，就转化为删除叶子节点的问题。</li>
</ol>
<figure>
<img src="https://i.loli.net/2021/03/28/kBc3dPOD1ZV4RwY.png" alt="" /><figcaption>image-20201111220009652</figcaption>
</figure>
<h2 id="b树">B+树</h2>
<p>同样B+树也是通常用于数据库和操作系统的文件系统中。B+树的特点是能够保持数据稳定有序， 其插入与修改拥有较稳定的对数时间复杂度。</p>
<h3 id="与b树的区别">与B树的区别</h3>
<ul>
<li><p>有 n 棵子树的节点中含有n个关键字(即每个关键字对应一棵子树)；B树中有最多n个分支子树，则有n-1个关键字。</p></li>
<li><p>所有叶子节点中包含了全部关键字的信息， 及指向含这些关键字记录的指针，且叶子节点本身依关键字的大小自小而大顺序链接；B+树中叶节点保存的是 索引值和对应的value。</p></li>
<li><p>所有的非终端节点可以看成是索引部分，<strong>节点中仅含有其子树（根节点）中的最大（或最小)关键字</strong> B树的子节点是介于父节点对应关键字的区间之中</p></li>
<li><p>除根节点外，其他所有节点中所含关键字的个数必须 &gt;= ceil (m/2 ) B树是至少 ceil (m/2 )-1个关键字 ，ceil (m/2 )个子节点；</p>
<figure>
<img src="https://ivanzz1001.github.io/records/assets/img/data_structure/ds_bplus_tree1.jpg" alt="" /><figcaption>img</figcaption>
</figure></li>
</ul>
<h3 id="特点">特点</h3>
<ol type="1">
<li>B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</li>
<li>B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</li>
<li>B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</li>
<li>B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li>
</ol>
<p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快。</p>
<h2 id="线段树">线段树</h2>
<h2 id="堆">堆</h2>
<p>堆(heap)又被为优先队列(priority queue)。队列中允许的操作是先进先出（FIFO），在队尾插入元素，在队头取出元素 而堆也是一样，在堆底插入元素，在堆顶取出元素，但是堆中元素的排列不是按照到来的先后顺序，<strong>而是按照一定的优先顺序排列的。这个优先顺序可以是元素的大小或者其他规则</strong>。Linux中的任务调度器就是堆实现的。 堆的一个经典的实现是完全二叉树(complete binary tree)。这样实现的堆成为二叉堆(binary heap)。 完全二叉树是增加了限定条件的二叉树。假设一个二叉树的深度为n。为了满足完全二叉树的要求，该二叉树的前n-1层必须填满，第n层也必须按照从左到右的顺序被填满，比如下图:</p>
<figure>
<img src="https://i.loli.net/2021/03/28/9w6YBOVIz18edCD.png" alt="" /><figcaption>img</figcaption>
</figure>
<p>堆常用的用途：</p>
<ul>
<li>构建优先队列</li>
<li>支持堆排序</li>
<li>快速找出一个集合中的最小值（或者最大值）</li>
</ul>
<h3 id="堆属性">堆属性</h3>
<p>在<strong>最大堆</strong>中，父节点的值比每一个子节点的值都要大。在<strong>最小堆</strong>中，父节点的值比每一个子节点的值都要小。这就是所谓的“堆属性”，并且这个属性对堆中的每一个节点都成立。 由此 最大堆的堆顶 是最大的，而最下的是某个叶节点，至于那个并不一定；最小堆 堆顶是最小的元素。</p>
<h3 id="存储结构">存储结构</h3>
<p>用数组来实现树相关的数据结构。它在时间和空间上都是很高效的。这点远优于二叉树，这 也是完全二叉树的特点。对于某个节点 i,其父节点和左右子节点 在数组中的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parent(i) &#x3D; floor((i - 1)&#x2F;2)</span><br><span class="line">left(i)   &#x3D; 2i + 1</span><br><span class="line">right(i)  &#x3D; 2i + 2</span><br></pre></td></tr></table></figure>
<h3 id="插入">插入</h3>
<p>插入就是先放在数组最后末尾，然后向前索引它的父节点，如果不满足堆的定义，就和父节点交换。</p>
<h3 id="删除">删除</h3>
<p>通常是 pop 堆顶的元素。删除它，就将数组最后一个叶子节点拿过去 替换原本的节点，然后将它下沉 堆化。</p>
<h2 id="哈夫曼树">哈夫曼树</h2>
<p>哈夫曼（Huffman）编码算法是基于二叉树构建编码压缩结构的，它是数据压缩中经典的一种算法。算法<strong>根据文本字符出现的频率，重新对字符进行编码。因为为了缩短编码的长度，我们自然希望频率越高的词，编码越短，这样最终才能最大化压缩存储文本数据的空间</strong>。例如常规的 每个字符都是占一个/多个相同的数量的字节树，要存储 n 个字符就需要 kn 个字节的空间，这是等长编码。但是哈夫曼树是一种不等长编码，根据序列中不同字符出现频率不同，分别重新进行不等长编码，出现次数多的字符希望它单个字符占用的空间少，出现次数少的可以多一点。只不过哈夫曼树实现不等长编码使用的是 二叉树完成的。 另一个，不等长编码虽然是无损压缩节省存储空间，但是得保证 不出现歧义性，例如 00 0 分别表示两个字符ab，那么单看00可以有多种解释方法，而哈夫曼编码是一种<strong>前缀编码</strong>，不存在歧义。 ​ 前缀编码： 任意一个字符的编码都不是另一个字符的编码的前缀。</p>
<p>https://www.cnblogs.com/penghuwan/p/8308324.html</p>
<h3 id="构建哈夫曼树">构建哈夫曼树</h3>
<ul>
<li>将字符序列中，不同字符出现的频率按照 低到高排序，每个字符是一个节点。构建一个小顶堆（优先队列），保证每次取出的树的根节点的频率都是队列里最少的。</li>
<li>从优先队列中取出两个 节点（出现频率最少的两个），将他们合并构成一个二叉树，新的根节点的频率为 两个 节点的和，再将这个新的根节点入队</li>
<li>再从队列中取出两个节点（可能是之前已经合并过的树的根节点），再左右合并成一个新的树，将新的根节点入队</li>
<li>循环上述步骤直到只剩一棵树，完成哈夫曼树的构建。（此时所有字符都是树的叶子）</li>
<li>根据哈夫曼树对字符编码。叶节点中存储的字符 重新编码为 ，从根节点到叶节点的边构成的编码如下图</li>
</ul>
<figure>
<img src="https://i.loli.net/2021/03/28/a5zYbvtFNHldpAs.png" alt="" /><figcaption>image-20201109222200118</figcaption>
</figure>
<h2 id="前缀字典树">前缀（字典）树</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isEnd; <span class="comment">//该结点是否是一个串的结束</span></span><br><span class="line">    TrieNode* next[<span class="number">26</span>]; <span class="comment">//字母映射表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210419110553.png" alt="image-20210419110553476" style="zoom:67%;" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210419110622.png" alt="image-20210419110622319" style="zoom:67%;" /></p>
<h2 id="树状数组">树状数组</h2>
<p>对于求数组区间和的问题，常常会预先计算一个前缀和，然后再求任意区间的的元素和时，时间复杂度就为O(1)。但是如果原始数组会动态改变，那么前缀和数组也需要做相应的修改。例如 array[1] 改变了， 那么 sum(1-n) 中的前缀值每个都要改变，复杂度又变成了 O(n）</p>
<p>对于这种需要动态更新数组的问题，使用树状数组可以 即将前缀数组维护成一个 树状的结构，用于均衡更新 和 查询的时间复杂度。</p>
<ul>
<li>查询 / 更新时间复杂度 O(logN)<br />
</li>
<li>构建的时候复杂度为O(NlogN)</li>
</ul>
<p>树状数组的思想是，原始的前缀数组 C 的第 i 个元素 C[ i ] = a[1] + a[2] +… a[ i ]， 当更新一个元素时，该元素之后的前缀和都要改变，牵一发而动全身 。如果将前缀数组中的每个元素负责的范围缩小呢？例如 C[ i ] 只负责它前面的一段小范围内的元素的和， 整个区间的和被划分为多块小区间的和 即可，这样 当只有 C[ i ] 掌管的小段区间中的元素值改变时，才会更新C[i] 的值，避免的牵一发而动全身的问题。</p>
<p>基于以上思路来看树状数组结构图 C为前缀数组 A为原始数组，二者长度相同</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210702230002.png" alt="" /><figcaption>image-20210702230002397</figcaption>
</figure>
<h3 id="lowbit">lowbit</h3>
<p>观察上表的规律 可以发现 C[i] 计算 的是 A[j ~ i] 共 x 个元素的和，那么这个数量x 和 序号 i 有啥关系呢？</p>
<p>2^0 2^1 2^0 2^2 2^0 2^1 2^0 2^3 个</p>
<p>0001 0010 0011 0100 0101 0110 0111 1000</p>
<p>可以看出 序号的二进制的 最末尾 0 的个数 k =&gt; 2^k = x 可以用下式高效计算</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210703101419.png" alt="" /><figcaption>image-20210703101419090</figcaption>
</figure>
<p>负数的补码为 原码的取反加1 所以实际为： 11010100 &amp; (00101011 + 1) = 00000100</p>
<p>因此通过上述关系可以很很容易知道 C[i] 计算的是多少个元素的和。当我们要求 [0 ~ i ] 个元素的和时，只需递归得向前计算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">		sum += C[i];</span><br><span class="line">         i -= <span class="built_in">lowbit</span>(i);   <span class="comment">// 向前回退 因为 C[i] 包含了 A[i] 以及 前lowbit(i)个元素的和了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单点更新">单点更新</h3>
<p>通过分段管理的思路可以大大减少元素更新的时间复杂度，例如上图中 元素 A[3] 改变时，只需将 C[3] C[4] C[8] 增加一个对应的deta值即可。那么如果根据 元素的下标 i 找到它对应的父节点的 序号呢？</p>
<p>先看 C[3]C[3] ，lowbit(3)=1lowbit(3)=1， 3+lowbit(3)=43+lowbit(3)=4 就是 C[3]C[3] 的父亲结点 C[4]C[4] 的索引值 再看 C[4]C[4] ，lowbit(4)=4lowbit(4)=4， 4+lowbit(4)=84+lowbit(4)=8 就是 C[4]C[4] 的父亲结点 C[8]C[8] 的索引值 从已知子结点的索引 ii ，则结点 ii 的父结点的索引 parentparent 的计算公式为：</p>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210703102548.png" alt="" /><figcaption>image-20210703102548264</figcaption>
</figure>
<p>所以就可以很容易写出单点更新的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= len)&#123;      <span class="comment">// 这里 len(C) = len(A) + 1; i 其实是A中的 i-1 </span></span><br><span class="line">        C[i] += delta;</span><br><span class="line">        i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间查询">区间查询</h3>
<p>有了上述基础 区间查询 就运用前缀和的方法喽</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(y) - <span class="built_in">query</span>(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>基本数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>面经-数据结构相关</title>
    <url>/posts/36891/</url>
    <content><![CDATA[<p>整理了面试中常问的数据结构相关的知识点</p>
<span id="more"></span>
<h2 id="树">树</h2>
<h3 id="红黑树和avl树的定义特点以及二者区别">红黑树和AVL树的定义，特点，以及二者区别</h3>
<p>AVL树是平衡二叉搜索树，每个节点的左右子树的高度差不超过1，左右子树的高度做差称为平衡因子，平衡因子的取值只可能是 0 +-1 绝对值超过1的就不是平衡二叉树。 红黑树是以 一个数据位标记节点红黑颜色的树，也是二叉搜索树，每次插入和删除节点都要满足一定的着色规则，从而约束红黑树使得根节点到叶子节点的最长路径不超过最短路径的2倍。（每个节点非红即黑，根节点是黑色，每个叶节点是黑色，如果一个节点是红色，其子节点必须是黑，每条路径上黑色节点数目一致）</p>
<p><strong>区别</strong>：红黑树是弱平衡二叉树，AVL 树由于平衡条件过于严格，导致每次插入或删除节点都容易使得平衡打破，需要频繁的旋转调整树，导致效率下降。所以在需要频繁插入或删除的应用场景，红黑树速度更快。<strong>红黑树插入节点最多旋转两次，删除节点最多旋转三次。</strong></p>
<h3 id="哈夫曼编码">哈夫曼编码</h3>
<p>哈夫曼编码是哈夫曼树的一种应用，用于数据的无损压缩。根据序列中字符出现频率，使用0/1来对字符重新编码。是一种不等长前缀编码，出现频率高的字符使用较多位空间编码。具体：</p>
<ol type="1">
<li>哈夫曼树是一种自底向上构建表示的最优前缀二叉树T</li>
<li>算法以|C|个叶节点（每个叶节点表示一个字符）开始，经过C-1次合并运算产生最终要求的树。</li>
<li>构建步骤 …</li>
</ol>
<h3 id="map底层为什么用红黑树实现">map底层为什么用红黑树实现</h3>
<p>介绍AVL树定义特点, 介绍红黑树 定义特点</p>
<p><strong>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。所以红黑树在查找</strong>，<strong>插入删除的性能都是O(logn)，且性能稳定</strong>，所以STL里面很多结构包括map底层实现都是使用的红黑树。</p>
<h3 id="介绍一下b树">介绍一下B+树</h3>
<p>B+树是一种多路搜索树，主要为磁盘或其他直接存储设备而设计的一种平衡查找树，因为磁盘相对内存而言读写速度慢，使用B+树相对二叉搜索树 每次 减少磁盘读写次数。B+树每个节点可有多个孩子，每个节点中的键值有序排列。所有值都存在叶节点中。相对B树有以下特点：</p>
<ul>
<li>内部节点不存数据，只存键值</li>
<li>叶子节点存放数据，且和相邻叶子节点构成有序链表</li>
<li>每个节点的最大子树个数M 则键值M 而 B树M M-1</li>
<li>….</li>
</ul>
<h3 id="说一说map和unordered_map的底层实现">说一说map和unordered_map的底层实现</h3>
<p>​ map 的底层是基于红黑树实现的 因此map内部元素是有序的，且查找速度log(N) 而unordered_map是无序的底层基于 哈希实现，查找更快 接近常数级别，极端情况会O(N)</p>
<h3 id="map和unordered_map优点和缺点">map和unordered_map优点和缺点</h3>
<p>对于map，其底层是基于红黑树实现的，优点如下：</p>
<ol type="1">
<li>有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作</li>
<li>map的查找、删除、增加等一系列操作时间复杂度稳定，都为logn</li>
</ol>
<p>unordered_map</p>
<ol type="1">
<li>内部基于哈希表，以（key,value）对的形式存储，因此空间占用率高</li>
<li>无序</li>
<li>Unordered_map的查找、删除、添加的时间复杂度不稳定，平均为O(c)，取决于哈希函数。极端情况下可能为O(n)</li>
</ol>
<h3 id="回答一下epoll怎么实现的">回答一下epoll怎么实现的</h3>
<p><strong>epoll应用场景</strong>： 对于高连接的应用场景。例如 有上百万个用户通过TCP连接至服务器，但是每一时刻只有几十个或几百个TCP活跃（接受TCP包 ，需要内核完成读写文件操作）。那么epoll就是为了在此种场景下高效处理数据连接。在linux内核2.4以前，使用select 或者 poll事件驱动的方式实现。</p>
<p><strong>select</strong>: select的工作流程：创建socket－&gt;绑定端口bind－&gt;监听listen－&gt;accept-&gt;write/read。当有客户端连接到来时,select会把该连接的文件描述符放到 fd_set（文件描述符(fd)的集合 相当于数组）,然后select会循环遍历它所监测的 fd_set 内的所有文件描述符，如果没有一个资源可用(即没有一个文件描述符可以进行read/write可以操作)，则select让该进程阻塞的等待，一直等到有资源可用为止。而fd_set是一个类似于数组的数据结构，由于它每次都要遍历整个数组，所以它的效率会随着文件描述符的数量增多而明显的变慢，除此之外在每次遍历这些描述符之前，系统还需要把这些描述符集合从内核copy到用户空间，然后再copy回去，如果此时没有一个描述符有事件发生（例如：read和write）这些copy操作和便利操作都是无用功，可见slect随着连接数量的增多，效率大大降低。可见如果在高并发的场景下select并不适用，况且select默认的最大描述符为1024。</p>
<p><strong>epoll</strong>: Linux epoll机制是通过红黑树和双向链表实现的。 首先通过epoll_create()系统调用在内核中创建一个eventpoll类型的句柄，其中包括红黑树根节点和双向链表头节点。然后通过epoll_ctl()系统调用，向epoll对象的红黑树结构中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。最后通过epoll_wait()系统调用判断双向链表是否为空，如果为空则阻塞。当文件描述符状态改变，fd上的回调函数被调用，该函数将fd加入到双向链表中，此时epoll_wait函数被唤醒，返回就绪好的事件。</p>
<p><strong>总结</strong>： epoll 的机制感觉就是 充分利用了回调函数。使用一个红黑树 存储当前的所有感兴趣事件 （百万级别 很多休眠），而使用一个双向链表来存储 活跃连接。TCP开始活跃时 系统 在中断中调用事先注册的回调函数向 链表中添加 活跃事件。用户只用通过 epoll_wait() 去链表访问活跃事件的数据和id即可。</p>
<h3 id="请你说一说topk问题">请你说一说Top(K)问题</h3>
<ul>
<li>直接排序法：直接调用一般的排序算法，对所有元素进行排序，然后去topK，这种方法效率低，对内存需求大，因为进行了很多无意义的排序。</li>
<li>基于快速排序的变形：根据快排的思想，每次从待排列的数据中随机选取一个作为 参考数据，将比他大的放在它的右边，小的放左边，分组完成后，如果基准元素右侧的个数n=K，完毕；如果n&gt;K，则重新对左边数据进行一次相同的分组操作；如果基准元素右侧的元素个数n&lt; K，则重新对左边数据进行一次相同的分组操作，此时K=K-n；</li>
<li>基于堆排序的思路：首先构建一个含有 K 个元素的小顶堆，每次读入数据和堆顶数据比较，如果小于它直接pass，否则删除堆顶元素并将其入堆。遍历完成后，堆中数据即为TopK</li>
<li>分治法：</li>
<li>Hash 法：对于含有大量重复元素的数据，可以先通过hash法把重复的数去掉。这样可以减小很多的不必要计算</li>
</ul>
<h3 id="请你说一说c两种map">请你说一说C++两种map</h3>
<p>unordered_map (Hash) 和 map (红黑树)</p>
<h3 id="请你说一说红黑树的性质还有左右旋转">请你说一说红黑树的性质还有左右旋转</h3>
<p>https://blog.csdn.net/weixin_43939593/article/details/104420724?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159021709219725211930470%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=159021709219725211930470&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<sub>blog</sub>first_rank_v1~rank_blog_v1-1-104420724.pc_v1_rank_blog_v1&amp;utm_term=%E7%BA%A2%E9%BB%91%E6%A0%91</p>
<h2 id="堆和栈">堆和栈</h2>
<h3 id="说一说你理解的stack-overflow">说一说你理解的stack overflow</h3>
<p>​ 栈溢出概念：栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变。</p>
<p>​ 栈溢出得原因：</p>
<ul>
<li>局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。局部变量是存储在栈中的，因此这个很好理解。解决这类问题的办法有两个，一是增大栈空间,二是改用动态分配，使用堆（heap）而不是栈（stack）。</li>
<li>递归调用的层数太多。递归函数在运行的时候会执行压栈操作。当压栈次数太多时，也会导致堆栈溢出。</li>
<li>数组指针越界</li>
</ul>
<p>### 栈和堆的区别，以及为什么栈要快</p>
<p>区别：</p>
<ol type="1">
<li>地址生长方向，栈是由高地址向低地址，堆反之</li>
<li>分配方式：栈是系统自动分配内存，有硬件实现，存放局部变量参数等。而堆是人为实现的一种结构，需要手动申请和释放内存。</li>
<li>栈由于其先进后出的特性，不会产生内存碎片</li>
<li>栈高效</li>
</ol>
<p><strong>栈高效的原因</strong>：栈是操作系统提供的数据结构，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行；而堆是由C/C++函数库提供的，机制复杂，需要一些列分配内存、合并内存和释放内存的算法，因此效率较低。</p>
<h3 id="手写代码两个栈实现一个队列">手写代码，两个栈实现一个队列</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.<span class="built_in">push</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.<span class="built_in">size</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = stack2.<span class="built_in">top</span>();</span><br><span class="line">        stack2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(stack1.<span class="built_in">size</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = stack1.<span class="built_in">top</span>();</span><br><span class="line">        stack1.<span class="built_in">pop</span>();</span><br><span class="line">        stack2.<span class="built_in">push</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<h3 id="小根堆特点">小根堆特点</h3>
<ol type="1">
<li>堆是一个完全二叉树，除最后一层外，其他的都得是满的</li>
<li>小顶堆，父节点总是小于他的左右子节点的值，因此堆顶的元素最小。大顶堆相反。</li>
</ol>
<h2 id="数组">数组</h2>
<h3 id="数组和链表的区别">数组和链表的区别</h3>
<p>数组的特点：数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。数组的插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。但数组的随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。并且数组不利于扩展，数组定义的空间不够时要重新定义数组。</p>
<p>链表的特点：链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。比如：上一个元素有个指针指到下一个元素，以此类推，直到最后一个元素。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表数据结构了。不指定大小，扩展方便。链表大小不用定义，数据随意增删。</p>
<p>数组的优缺点：</p>
<ol type="1">
<li>随机访问性强</li>
<li>查找速度快</li>
<li>插入和删除效率低</li>
<li>数组大小固定，不能动态拓展 可能浪费内存</li>
<li>内存空间要求高，必须有足够的连续内存空间。</li>
</ol>
<p>链表的优缺点：</p>
<ol type="1">
<li>插入删除速度快</li>
<li>内存利用率高，不会浪费内存</li>
<li>大小没有固定，拓展很灵活。</li>
<li>不能随机查找，必须从第一个开始遍历，查找效率低</li>
</ol>
<h3 id="判断有无重复数">判断有无重复数</h3>
<p>​ 一个长度为N的整形数组，数组中每个元素的取值范围是[0,n-1],判断该数组否有重复的数，请说一下你的思路并手写代码</p>
<p>思路： 把每个数放到自己对应序号的位置上，如果其他位置上有和自己对应序号相同的数，那么即为有重复的数值。时间复杂度为O(N),同时为了节省空间复杂度，可以在原数组上进行操作，空间复杂度为O(1)</p>
<h2 id="排序">排序</h2>
<h3 id="手写快排的代码">手写快排的代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="海量数据如何去取最大的k个">海量数据如何去取最大的k个</h3>
<ul>
<li>基础的对所有元素进行排序，效率不高，因为只用求K大 并不需要对所有元素排序</li>
<li>快排的变形，选取基准数，左右分区，如果右边比基准数大的个数不等于K，根据与K的大小关系选择是对基准数左半部分or右半部分数递归求K-N or K 大。</li>
<li>最小堆法。首先建立一个含有K个元素的最小堆，每次取序列中的元素与堆顶元素比，如果比堆顶元素大，将堆顶元素弹出，改元素入堆，如果小，就说明他肯定不是K大中的一个，跳过。依次遍历到结束，最后堆中的元素就是topK</li>
<li>分治法：将所有元素分为N 分，如果每份的元素数量可以放入内存，就分别对每份找出前K大，否则继续分治处理。最后每份挑出了K个，一共有N*K个元素，可以使用快排的变形找出前K个。</li>
<li>Hash法：对于含有大量重复元素，使用Hash去重，如果剩下元素可以读入内存了，就直接排序，否则可以使用分支法读入内存在处理或者堆法。</li>
</ul>
<h3 id="快排的时间复杂度最差是多少什么时候时间最差">快排的时间复杂度最差是多少？什么时候时间最差</h3>
<p>元素倒序，O(n^2)</p>
<h3 id="什么是稳定性排序">什么是稳定性排序</h3>
<p>对于相等的元素，排序前后相对顺序不变</p>
<h3 id="快排算法最差情况推导公式">快排算法最差情况推导公式</h3>
<p>一般的快排中的基准元素选取的为 最左边或者最右边的元素。 当选取最左边元素作为基准，而序列原本又是正序的时候，每次左右分拨都要挨个交换位置，就和冒泡排序类似；所以O(n^2) 反之当选取最右边基准…倒序…..； 当元素都相同时</p>
<p>所以可以随机选择基准元素，降低出现最坏情况的概率</p>
<h3 id="稳定排序哪几种">稳定排序哪几种</h3>
<p>插入法，冒泡排序，归并排序，计数排序，基数排序，桶排序</p>
<h2 id="哈希">哈希</h2>
<h3 id="hash表的实现包括stl中的哈希桶长度常数">hash表的实现，包括STL中的哈希桶长度常数</h3>
<p>主要包含两部分，一是Hash函数构造由key的值使用Hash函数处理的得到地址。另一个是处理Hash冲突</p>
<p>前者构造Hash的方法主要有 直接地址法，平方取中法，除留余数法 后者的方法有：开放地址法，链地址法，再Hash法，建立公共溢出区等方法</p>
<p>使用链地址法不一定必须满足 桶的个数为质数….？</p>
<h3 id="解决hash冲突的方法">解决hash冲突的方法</h3>
<p>​ 当不同经过hash产生相同的地址时，即差生hash冲突。此时解决的方法有如下：</p>
<ul>
<li>开放地址：所谓开放地址，就是当hash过后 地址重复了之后，按照一定的规律从当前地址往其他地方搜索表中的空内存区 （Hi = H(key + di)）。根据寻址扩展的规律分为如下。产生新地址的方法能覆盖所有表区，免得内存浪费。再读取时，如果在Hash的地址找不到对应的元素，那么就按照指定的寻址方式往其他内存寻找元素对比key，找到表尾也没找到说明不存在。
<ol type="1">
<li>线性探查：di = c x i 就是地址线性往后递增 （注意对表长取余了 所以会循环 可以覆盖所有区域）</li>
<li>二次探查： di = + - i^2 就是平方规律分别向前和向后探测</li>
<li>伪随机探测：di 是一组伪随机数</li>
</ol></li>
<li>链地址：向指定地址插入Hash值时，如果该地址已有元素，桶内使用链表存储新增的数据。那么在读取的时候也是遍历链表找到对应的key的内容。</li>
<li>公共溢出区：建立一个公共溢出区域，把hash冲突的元素都放在该溢出区里。查找时，如果发现hash表中对应桶里存在其他元素，还需要在公共溢出区里再次进行查找。</li>
<li>再hash：再散列法其实很简单，就是再使用哈希函数去散列一个输入的时候，输出是同一个位置就再次散列，直至不发生冲突位置。每次冲突都要重新计算散列，计算时间增加。</li>
</ul>
<figure>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210413153208.png" alt="" /><figcaption>image-20201117201021698</figcaption>
</figure>
<h3 id="哈希表的桶个数为什么是质数">哈希表的桶个数为什么是质数</h3>
<p>哈希表的桶个数使用质数，可以最大程度减少冲突概率，使哈希后的数据分布的更加均匀。如果使用合数，可能会造成很多数据分布会集中在某些点上，从而影响哈希表效率。 例如常用的Hash函数是标准的求模函数，质数的因数只有1和它本身，合数不止。例如 6 和 7 ，当Hash数是2/3的时候，6%2 = 6%3=0 也就是经过取模Hash后 Key=2/3在同一个地址了。</p>
<h3 id="为什么hash表的容量是2的幂次方">为什么Hash表的容量是2的幂次方</h3>
<p>JDK 里面实际不是用取模 而是 位运算与；一方面 使用与操作替代取模，提升计算效率； n&amp;(capacity-1) 9%8==1，只有2的幂才能有此性质。同时 为了使不同 hash 值发生碰撞的概率更小，尽可能促使元素在哈希表中均匀地散列。因为如果capacity是奇数的话，与capacity-1相与最后一位一定是0，则不能充分利用hash表的空间。</p>
<h3 id="hash表如何rehash-怎么处理其中保存的资源">hash表如何rehash 怎么处理其中保存的资源</h3>
<p>Hash表中有个负载因子，代表 存储数据长度 / 表的长度。负载因子越大，查找复杂度就越大。每次往表中装载数据要保证负载因子 &lt; 1否则就需要rehash，保证可以装载成功。rehash过程类似数组扩容，开辟一个新的原桶数组的两倍大的空间，并把原本的桶的数组中的元素全部重新Hash到新的Hash桶数组中。</p>
<h2 id="动态规划">动态规划</h2>
<h3 id="手写代码最长公共连续子序列">手写代码：最长公共连续子序列</h3>
<h3 id="手写代码求一个字符串最长回文子串">手写代码：求一个字符串最长回文子串</h3>
<h3 id="手写代码查找最长回文子串">手写代码：查找最长回文子串</h3>
<h2 id="链表">链表</h2>
<h3 id="手写代码如何合并两个有序链表">手写代码，如何合并两个有序链表</h3>
<h3 id="手写代码反转链表">手写代码：反转链表</h3>
<h3 id="手写代码判断链表是否为回文">手写代码：判断链表是否为回文</h3>
<h3 id="什么是单向链表">什么是单向链表</h3>
<h3 id="判断两个单向链表是否相交">判断两个单向链表是否相交</h3>
<h2 id="高级算法">高级算法</h2>
<h3 id="加密方法有那些">加密方法有那些</h3>
<p>### LRU缓存</p>
<h3 id="洗牌算法">洗牌算法</h3>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>基本数据结构</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>算法和数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的面试题</title>
    <url>/posts/48726/</url>
    <content><![CDATA[<p>记录了CS-NOTE中整理的高频面试题，把不会写的单独记录下来了</p>
<span id="more"></span>
<h4 id="数组中的重复数字"><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/submissions/">数组中的重复数字</a></h4>
<ul>
<li>这道题可以用判断环的方法找 环的起点</li>
<li>通过swap的方式 swap(nums[i], nums[nums[i]]) 将数组还原为 num[i] = i 若遇到 num[i] == nums[nums[i]] 则为重复的数字。</li>
</ul>
<h4 id="二维数组中的查找"><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">二维数组中的查找</a></h4>
<p>​ 类似双指针的 使用方式之一，不过不是 二分查找，而是 设置行列指针，选取矩阵右上角为起点，这样行指针往左移，列指针往下移，数据分别边小，变大。<strong>核心思想就是两个指针都是单方向移动，且指向的数据变化趋势是相反变化的，这样依次判断 和target的大小关系只能 有一个放行的指针移动。</strong></p>
<h4 id="替换空格"><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">替换空格</a></h4>
<p>​ 主要在于 如果只能在原字符上操作，首先遍历判断空格数量，将源字符串扩容 + i x 2；接着从字符串末尾两个指针，依次从后向前填充。例如 原本 “ss ss” -&gt;“ss ss ”</p>
<h4 id="二叉树的下一个结点"><a href="https://cyc2018.github.io/CS-Notes/#/notes/8.%20二叉树的下一个结点">二叉树的下一个结点</a></h4>
<p>​ 1. 该节点没有有子节点。当它有右子节点时，中序遍历接在它后面输出的节点应给是 它子树的最左边的叶子节点</p>
<pre><code>        2. 该节点没有子节点。这时就要回溯了，一直找到它父节点，知道它是父节点的左子树为止。 具体要参照中序遍历的输出规律。好理解</code></pre>
<h4 id="矩形填充"><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">矩形填充</a></h4>
<figure>
<img src="https://i.loli.net/2021/03/28/aMROkmxHqfGSeX9.png" alt="" /><figcaption>image-20200912171353588</figcaption>
</figure>
<p>f(n) = f(n-1) + f(n-2) 斐波拉西</p>
<p><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">青蛙跳台阶</a></p>
<p>​ 这个和上一道一样，状态方程在于 看青蛙 最后一步是跳一步 还是 最后一次一下子跳两步，就转换为 斐波拉西数列。最后(a + b)%c = (a%c + b%c)%c。</p>
<p><a href="https://cyc2018.github.io/CS-Notes/#/notes/12.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84">矩阵中的最小路径</a></p>
<p>​ 考点是 回溯算法，使用深度优先遍历实现回溯。回溯 和 单纯的优先遍历的区别 在于 回溯在每次试探性的前进之后有条件 判断 剪纸。如果沿着某一方向下去 不满足条件 马上返回 ，并且需要还原 之前的状态</p>
<p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">机器人的运动范围</a></p>
<p>​ 这题就套用DFS BFS模板即可</p>
<h4 id="减绳子"><a href="./leecode动态规划">减绳子</a></h4>
<h4 id="数值的整数次方"><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/c-cheng-fa-kuai-su-mi-by-yizhe-shi/">数值的整数次方</a></h4>
<p>​ 这个题考察的是 快速 幂乘法，a^N = axaxa…xa 这样直接一个个乘肯定是很慢的，会超时。将N 转换为 二进制表示。如N = 9，则a^9 = a^(1001) = a<sup>(1x8+0x4+0x2+1x1)</sup> = a<sup>1</sup> x a<sup>0x2</sup> x a<sup>0x4</sup> x a<sup>1x8</sup> ; 循环 计算 a = a*a；即 计算了 a<sup>0</sup> a<sup>2</sup> a<sup>4</sup>… 对于N的二进制 为1的位置 就乘进结果，为0 的就乘1。</p>
<h4 id="正则表达式匹配"><a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/shi-pin-tu-jie-dong-tai-gui-hua-zheng-ze-biao-da-s/">正则表达式匹配</a></h4>
<p>​ 动态规划。f[i] [j] 表示字符串 s (目标字符串) 的 前 i 个 字符 和 p (正则字符串) 的前 j 个字符 匹配的状态。那么对于 f[i] [j] 当 p[j] 不是 “*” 时就很简单 只用看 i-1 j-1 的状态 和 s[i] 与 s[j] 是否匹配（相等或者为‘.’）即可。复杂的是 当 p[j] 为※号时的情况。如果 ※号的用法可以分为两类： 1. 他前面一个字符出现0次，就是消掉他，那么 f[i] [j] 的状态由 f[i] [j-2]决定。 2. ✳将他前面的字符重复1-n次的情况。此时 若 s[i] 和 p[j-1] 匹配,例如都等于a，那么就由 f[i-1] [j] 状态决定，此时相当于 s[i-1] 后面再加一个 a 此时 ✳再复制一次即可 所以状态取决于 f[i-1] [j]</p>
<figure>
<img src="https://i.loli.net/2021/03/28/VFQRBkwazWuAI7s.png" alt="" /><figcaption>image-20200914202819724</figcaption>
</figure>
<h4 id="删除链表倒数第k个节点"><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/submissions/">删除链表倒数第K个节点</a></h4>
<p>​ 核心的 使用快慢指针 先将快指针 从头往后移动K个，再二者一起 往后移动 ，知道快指针为NULL 责慢指针停下的地方就是 了。为了排除 边界情况 可以在链表头加一个 哑铃节点，然后 每次让慢指针停在 待删除节点的前一个节点。这样就不用备份慢指针的父节点啦。</p>
<h4 id="链表反转"><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/fan-zhuan-lian-biao-yi-dong-de-shuang-zhi-zhen-jia/">链表反转</a></h4>
<ol type="1">
<li>双指针，两个相邻的指针，每次反转一个。一个初始化为NULL 另一个为头指针</li>
<li>递归 / 栈</li>
</ol>
<h4 id="合并两个有序链表"><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></h4>
<p>​ 递归！！！！</p>
<h4 id="顺时针打印矩阵"><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">顺时针打印矩阵</a></h4>
<p>​ 使用的深度优先遍历 + 减枝 速度较慢。反正都是暴力</p>
<h4 id="包含min函数的栈"><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/submissions/">包含min函数的栈</a></h4>
<p>​ 要求O(1)的时间复杂度取出 栈中的最小值（不是每次都删除最小值），使用一个辅助的栈来将最小的保存在栈顶。当push进一个数时，如果 比当前栈顶最小的 小 那么就进入这个辅助栈….. <strong>单调栈</strong></p>
<h4 id="栈的压入弹出序列"><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">栈的压入、弹出序列</a></h4>
<p>​ 用一个栈 模拟 出栈操作，如果最后栈空，则OK。首先读取push数组中的一个数，并加入堆栈，如果它和pop数组中的数相同，则马上将其出栈，并将 push 数组指针滑动。</p>
<h4 id="二叉搜索树的后序遍历序列"><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">二叉搜索树的后序遍历序列</a></h4>
<pre><code>    1. 递归  分治法。抓住 后续遍历 和  搜索树的特点

        2. 单调栈 </code></pre>
<h4 id="二叉树中和为某一值的路径"><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">二叉树中和为某一值的路径</a></h4>
<p>​ 前序遍历 先判断是不是 和满足要求 且到达叶子节点 是 这里 的技巧 可以在 遍历完左右子节点后 再将当前节点的值出栈。这样不用来回拷贝vector 省时间</p>
<h4 id="复杂链表的复制"><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">复杂链表的复制</a></h4>
<p>​ Hash表 保存 每个节点 和 新new的节点的对应 遍历两编链表 第一遍 new 拷贝所有节点 并 map 第二次遍历 链接节点</p>
<h4 id="二叉搜索树与双向链表"><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">二叉搜索树与双向链表</a></h4>
<p>​ 首先 二叉搜索树 -&gt; 有序双向链表。就能想到中序遍历。暴力的方法是，首先中序遍历将所有节点存下来，然后链接。也可以在中序遍历的时候进行 指针的转换，这样只用遍历一次，而这样的难点就是如何 在中序遍历中转换指针的指向。 ​ 申请两个 节点指针，pre 和 cur pre指向上一次遍历指向的节点，cur为当前遍历指向的节点。初始 pre 初始为 dummy指针。在中序遍历的位置完成 pre 和 cur 左右节点的指向，同时更新 pre 的指向：（可以看出 在中序遍历回到节点时，此时已经完成 左子节点的遍历，因此左指针可以修改。此时也确实只修改了左指针） 最后 使用dummy指针找到节点头。最后的cur指针指向的是最后一个访问的节点，即节点的尾。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">       <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">cur = root;         <span class="comment">// 变更开始时更新 cur</span></span><br><span class="line">pre -&gt; right = cur; <span class="comment">// 变更左右指针的指向， 符合双向链表的指针指向， 即当节点有一个指针指向前一个节点， 前一个节点也有一个指针指向当前节点</span></span><br><span class="line">cur -&gt; left = pre;</span><br><span class="line">pre = root;         <span class="comment">// 变结束后更新 pre ， 以便下一次使用</span></span><br><span class="line"><span class="built_in">dfs</span>(root-&gt;right);</span><br></pre></td></tr></table></figure>
<h4 id="数组中出现次数超过一半的数字"><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">数组中出现次数超过一半的数字</a></h4>
<p>​ 使用Hash法 空间复杂度O(N) 时间复杂度 O(N) 由于 题目说某个数字的个数出现次数大于一半，那么可以使用 一个计数变量，当遇到相同的数字+1 否则-1 当减为负，这个数字就是当前遍历的中最多的。而遍历完，这个指向数字一定是 最多的。</p>
<h4 id="最小的k个数httpsleetcode-cn.comproblemszui-xiao-de-kge-shu-lcof">最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)</h4>
<p>​ 这道题的考点是 快排中分治的思想 或者 优先队列（二叉堆）。二叉堆的基本性质是 堆顶 元素 top 总是最大/最小的。因此构建一个含有K个元素的 优先队列，依次读取剩下的元素，若比堆顶小，则弹出堆顶元素并 将新元素入堆…. ​ 类似解决 topK 的题都是这两种思路 最好。快排的思想是 当前选取一个基准数，然后比他大的和小的 各放一边…..</p>
<h4 id="数据流中的中位数"><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">数据流中的中位数</a></h4>
<pre><code>    1. 第一中方法是 每次插入 都保持 数组有序，使用二分法插入元素。取中位数的时候 就直接取中间即可。查找O(logn) + insert(O(n)) =插入新数据一共 O(n)。

        2. **使用优先队列的方式**。构建一个大顶堆和一个小顶堆。大顶堆保存中位数左边较小的 数据，小顶堆保存中位数右边较大的数据。每次插入新数据，先将其加入大顶堆，再将大顶堆的最大数据弹出 加入小顶堆；然后判断一下两个堆的大小，保证大顶堆的数据量&gt;小顶堆的。求中值的时候，奇数个数据就是 大顶堆数据 最大的那个 4，3  偶数二者平均。 加入新数据 时间复杂度 O(logn)  </code></pre>
<figure>
<img src="https://i.loli.net/2021/03/28/HNhUWojJM6A1tsx.png" alt="" /><figcaption>image-20200917215844317</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; lo;                              <span class="comment">// 大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; hi;   <span class="comment">// 小顶堆</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Adds a number into the data structure.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lo.<span class="built_in">push</span>(num);                                    <span class="comment">// 加到大顶堆</span></span><br><span class="line"></span><br><span class="line">        hi.<span class="built_in">push</span>(lo.<span class="built_in">top</span>());                               <span class="comment">// 平衡</span></span><br><span class="line">        lo.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lo.<span class="built_in">size</span>() &lt; hi.<span class="built_in">size</span>()) &#123;                     <span class="comment">// 维护两个堆元素个数</span></span><br><span class="line">            lo.<span class="built_in">push</span>(hi.<span class="built_in">top</span>());</span><br><span class="line">            hi.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the median of current data stream</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lo.<span class="built_in">size</span>() &gt; hi.<span class="built_in">size</span>() ? (<span class="keyword">double</span>) lo.<span class="built_in">top</span>() : (lo.<span class="built_in">top</span>() + hi.<span class="built_in">top</span>()) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="数字-1-的个数"><a href="https://leetcode-cn.com/problems/number-of-digit-one/">数字 1 的个数</a></h4>
<p>​ 这是个找规律的题目</p>
<h4 id="把数组排成最小的数"><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">把数组排成最小的数</a></h4>
<p>​ 排序 对于 相同长度的字符串，直接 从高位到低位，小的字符排在前面。对于不同长度的字符串a, b 比较 a+b b+a 大小即可。就是正反组合 产生的新的字符的相互比较。</p>
<h4 id="把数字翻译成字符串"><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">把数字翻译成字符串</a></h4>
<p>​ 动态规划</p>
<h4 id="礼物的最大价值"><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">礼物的最大价值</a></h4>
<p>​ 动态规划 二维dp 每个位置的最大礼物价值只由它的 左边 和 上边 格子的最大数 的较大者决定。</p>
<h4 id="丑数"><a href="https://leetcode-cn.com/problems/chou-shu-lcof/">丑数</a></h4>
<p>​ 首先，判断一个数n是不是丑数，就看 n能否被 分解为多个 2 or 3 or 5 相乘的形式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(n!=<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>) n/=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">5</span>==<span class="number">0</span>)	n/=<span class="number">5</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">0</span>) n/=<span class="number">3</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 但是要输出 第n个丑数，暴力遍历从1开始的所有整数 计算 是否为丑数 然后累加到n停止，虽然可以使用备忘录的方法 加速计算，即如果 k/2 为丑数 那么 k 也为丑数，但是依然会超时。 <img src="https://i.loli.net/2021/03/28/X2iSloYLq1yJWe4.png" alt="image-20200922213736488" /></p>
<h4 id="数组中的逆序对"><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">数组中的逆序对</a></h4>
<p>​ 使用 归并排序的 方法。 分治的思想。在 归并排序中，每次 将数组划分为左右 两半 部分 分别 sort 然后再 merge 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> lf, <span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lf &gt;= rt)     <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (lf + rt) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, tmp, lf, mid);   <span class="comment">//递归的调用归并排序  排序后  左半部分 和 右半部分都是有序的</span></span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, tmp, mid+<span class="number">1</span>, rt);</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = lf, j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= rt)&#123;   <span class="comment">// 双指针将两个有序的 左右半部分合并为一个有序的数组，此时需要一个缓存数组 tmp</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= nums[j])&#123;</span><br><span class="line">                tmp[pos++] = nums[i++];   </span><br><span class="line">            &#125;<span class="keyword">else</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                cnt+=mid-i+<span class="number">1</span>;            <span class="comment">//  相对归并排序增加的一个计数变量  </span></span><br><span class="line">                tmp[pos++] = nums[j++];  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">            tmp[pos++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=rt)&#123;</span><br><span class="line">            tmp[pos++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = lf; i &lt;= rt; i++)&#123;  <span class="comment">// 将tmp的内容再存储到num中</span></span><br><span class="line">            nums[i] = tmp[i-lf];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, tmp, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="两个链表的第一个公共节点"><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">两个链表的第一个公共节点</a></h4>
<p>​ 这个题 暴力的是查询的算法，但是时间空间复杂度较低，最好的是双指针算法。两个指针分别从A,B开始遍历，到达终点后就换个起点接着遍历。最终二者相遇的地方便是交点.</p>
<h4 id="数组中数字出现的次数"><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">数组中数字出现的次数</a></h4>
<p>​ 这个题用 异或 做 异或的性质</p>
<figure>
<img src="https://i.loli.net/2021/03/28/mQfvBUKTstk4xGa.png" alt="" /><figcaption>image-20200923110415455</figcaption>
</figure>
<p>​ 如果对于一个数组 只有一个数字出现了 一次,其他数字都出现了两次，找出这个单独的数字。根据异或的性质，全员异或 最终的结果便是这个单独的数字。而此题是有两个不同的单独的数字，要找出这两个。最直观的想法是，将这两个不同的数字分别放在两组，然后每组中除了 这个单独的数字就是其他成对的数字，这就退化成了 第一个问题。即要求分组的数字 有以下性质：</p>
<ol type="1">
<li>两个不同的数字分别被分到不同的组</li>
<li>每组中 除了一个不同的数字 其他的都是成对的 这样组内 全员异才能满足 最终的结果是不同的那个。</li>
</ol>
<p>​ 如何分组？首先全员异或，结果肯定是 两个不同的数字异或的 结果。而这两个数字异或结果为1 的位 代表这两个数字 该位 不同，一个为1 另一个必定为0。例如 011 111 异或， 100 则第三位肯定不同。这样根据该位的值来分组 可以很好的分开这两个数字到不同组，对于其他数，相同的 该位 也一定相同，也一定在一个组。由此两个条件都满足。所以这样分组，再组内异或 分别就找出了两个不同的单数字。</p>
<p>​ <strong>而解决此类 除了 除了某个元素出现一次 其余均出现 m 次的问题</strong> 都可以统计 二进制各个位元素为1的个数，如果个数 % m 有余数，那么表明该位 是不同的那个数字为 1 的位置。</p>
<h4 id="平衡二叉树"><a href=".\leecode特殊数据结构">平衡二叉树</a></h4>
<h4 id="滑动窗口的最大值"><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">滑动窗口的最大值</a></h4>
<p>​ 这道题考察<strong>有序队列</strong>。实现有序队列 要结合 c++ 标准库中的 deque 双端队列，即可以从前 也可以从后插入删除数据。对于队列，如果后进去的数据 比我队列尾端的数据小，就直接放在它后面，如果比他大，就将原本尾部的数据弹出，直到遇到比他大的数据，再将其放进去。这样 队列头部一定是当前队列的最大数据。删除的时候，只用判断当前要出对队的元素是不是和 头部的相同，相同就弹出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span> <span class="comment">//单调队列（从大到小）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; que; <span class="comment">// 使用deque来实现单调队列</span></span><br><span class="line">    <span class="comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span></span><br><span class="line">    <span class="comment">// 同时pop之前判断队列当前是否为空。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span> <span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。 </span></span><br><span class="line">    <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span> <span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value &gt; que.<span class="built_in">back</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">push_back</span>(value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="comment">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span></span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="n个骰子的点数"><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">n个骰子的点数</a></h4>
<p>​ 直接动态规划 或者 递归+dp备忘录减枝 (因为直接递归有大量的重复计算)</p>
<p><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">圆圈中最后剩下的数字</a></p>
<p>​ 首先， 考虑一种规律。对于一个圈 不管起点是从哪个点开始，假设是 2，最终最后一个留下的是第3个，那么 如果此时开始的位置 为3，那么最后剩下的位置就是 4 （此时不考虑成环返回的问题），因为其实所有数字围成一个圆圈，处处堆成，起始位置和最终位置肯定是保持一个相对的位置关系。</p>
<p>​ 如果 假设 f(n-1, m) = x 代表第n-1个数，从0开始，m个删除一次，最终剩下的数的位置 是 x；考虑 f(n, m) 的关系。n个数，在第一次删除，即去掉 第 m -1 个数后(起点是从0开始)，就剩下 n-1 个数了，此时就退化为 f(n-1, m) 了只不过，这里n-1的起点是 m%n （删除了第 m%n-1个数，就从第m%n个数开始）。根据上面的规律，f(n, m) = (x + m%n) % n。起点相对 f(n-1) 的 0 变为 m 终点也应该相对 x 向后 + m，由于是环，所以 % n</p>
<h4 id="求12n"><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">求1+2+…+n</a></h4>
<p>​ 判断，循环语句等不能用。使用递归求和 但是需要有判断 递归停止的条件，<strong>可以使用 &amp;&amp; 逻辑运算符</strong> 替代 判断。当递归的返回值 n 为 0 就开始 return</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        n &amp;&amp; (n += <span class="built_in">sumNums</span>(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="不用加减乘除做加法"><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">不用加减乘除做加法</a></h4>
<p>​ 使用位运算 比较简单</p>
<ul>
<li><p>计算机中 申请一个 int 型的 变量，它在内存中直接存的 补码。因此此题只用将两个数 按照加法的逻辑计算即可，不需要再转补码了。</p>
<p>位运算 两个数相加 可以分为两部分 ： 无进位和 + 进位 满足以下规律：</p></li>
</ul>
<figure>
<img src="https://i.loli.net/2021/03/28/yPMmYSpuXVrzJ6x.png" alt="" /><figcaption>image-20200924203153740</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;   <span class="comment">//当进位 为  0 时 就停止递归 计算结束</span></span><br><span class="line">        <span class="keyword">return</span> b ? <span class="built_in">add</span>(a^b, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a&amp;b)&lt;&lt;<span class="number">1</span>) : a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>相关的编程题汇总-动态规划</title>
    <url>/posts/51702/</url>
    <content><![CDATA[<p>记录了动态规划类的题目</p>
<span id="more"></span>
<h1 id="动态规划类题目">动态规划类题目</h1>
<h2 id="连续子数组问题">连续子数组问题</h2>
<p>连续子数组问题 要充分利用 <strong>连续</strong> 这个条件。连续子数组（区间和）也可能是前缀法求解的题</p>
<h4 id="等差数列划分"><a href="https://leetcode-cn.com/problems/arithmetic-slices/">等差数列划分</a></h4>
<p>​ 关键是 对于一个等差数列 例如 -1, 0, 1, 2, 3 这个数列 第2个开始 等差子数列个数 为 1 依次为 2+1=3 3+2+1=6 可以理解为 当只有三个元素时 子序列就只有 他本身1个，当有四个元素时，子序列总个数分为以下两部分（含有三个元素的子序列个数 + 含有四个元素子序列的个数） 前者就为 上一次的个数 + 1 后者就为上上次的个数。以此类推 如若 有 五个元素的等差数列 那么子序列的个数 就为 3 + 2 + 1 （三个元素的，四个元素的，五个元素的子序列）所以 dp[i] = dp[i-1] +1 ; all_cnt = dp 求和 （非等差序列的位置的dp = 0）</p>
<h4 id="连续子数组和">连续子数组和</h4>
<figure>
<img src="https://i.loli.net/2021/03/28/UaJ4dIolSTCO7bh.png" alt="" /><figcaption>1597909311300</figcaption>
</figure>
<p>基本方法是积分法，记录每个位置的前面所有元素和。基于此将子区间的所有元素求和转化为求差，两元素的差等整除K 就相当于两元素对k的余数相同。判断相同 这里用了哈希表的方法。 (sum(i) - sum(j) ) % k= sum(i~j) % k = 0 =&gt; sum(i) % k == sum(j) % k</p>
<h2 id="相邻元素状态转换">相邻元素状态转换</h2>
<ol type="1">
<li><strong>1股票交易类问题</strong>，<strong>我们这一次买还是卖只跟上一次我们卖还是买的状态有关</strong>，例如前一天刚卖股票，有个冷冻期，那么今天就不能再买。</li>
<li>打家劫舍类问题。上一个元素的选择与否关系到当前元素的选择与否。通俗的理解可以将状态值 设置为 上一个元素是否选择，那么状态数组就为 dp[n] [2] ，这么理解就和买卖股票类的问题相通了。</li>
<li>非典型的，上一个元素的操作 关系到 当前元素的操作；<a href="https://leetcode-cn.com/problems/minimum-swaps-to-make-sequences-increasing/">使序列递增的最小交换次数</a>，当前元素的交换与否只与前一个元素是否交换有关。他们的本质都是： dp[n] [k]，其中 n 为序列数组的长度，k 为当前操作的状态数，为1，2或者3…<br />
</li>
<li>题目本身可能不会很明确告诉你 相邻元素的转换关系，例如 <a href="https://leetcode-cn.com/problems/delete-and-earn/">删除并获得点数</a></li>
</ol>
<h4 id="母牛生产"><a href="https://cyc2018.github.io/CS-Notes/#/notes/Leetcode%20题解%20-%20动态规划?id=_5-母牛生产">母牛生产</a></h4>
<blockquote>
<p>假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。</p>
</blockquote>
<p>​ 一只小牛在三年成熟之后可以每年开始产一头小牛。那么 第 dp[i-1] 表示第 i-1年的小牛数量 首先它可以顺延至 i 年 因为不会死。其次 这其中还有一批 牛已经是成熟的母牛 可以每头再产一头小牛，那么 i - 1中有多少头成熟的小牛呢，因为小牛变成成熟母牛需要三年，那么 第 i 年往前推3年的 dp[i-3] 第 i-3 年的牛到 第 i 年 隔了三年，也即是 dp[i-1] 年的牛 每头可在 i 年产一头小牛 即 第 i 年牛的数量是 dp[i] = dp[i-1] + dp[i-3]</p>
<h4 id="删除并获得点数"><a href="https://leetcode-cn.com/problems/delete-and-earn/">删除并获得点数</a></h4>
<p>​ 主要思想是 构建上面 那个 all数组，就将状态转移函数简化了很多。all数组的含义是 对数组中的每个整数元素 的 计数，数组的下标代表 元素i 。例如 all[1] 代表 数组中元素1 的个数。如果没有则为0。 这样 dp 的每个状态的切换只在相邻的两个下标发生，dp[i] 与 dp[i-2]没有关系。这样简化了状态转换的情况。</p>
<h4 id="使序列递增的最小交换次数"><a href="https://leetcode-cn.com/problems/minimum-swaps-to-make-sequences-increasing/">使序列递增的最小交换次数</a></h4>
<p>这个题的关键在于 每次只能交换相同位置的两个元素。当交换求前n个元素最小交换次数的时候，只需考虑前面两个元素时候交换，并且对应的交换次数。这么一来就会有四种情况，两两取最小。1. 上一次没交换，这一次也不交换，总交换次数不变 2. 上一次交换了，这一次不交换；3. 上一次不交换，这一次交换； 4. 上一次交换，这一次不交换。1,2 3,4分别取较小值，并保存 用以下一次迭代。</p>
<h4 id="打家劫舍-iii"><a href="https://leetcode-cn.com/problems/house-robber-iii/">打家劫舍 III</a></h4>
<h4 id="打家劫舍-ii"><a href="https://leetcode-cn.com/problems/house-robber-ii/">打家劫舍 II</a></h4>
<h4 id="最佳买卖股票时机含冷冻期"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">最佳买卖股票时机含冷冻期</a></h4>
<p><img src="https://pic.leetcode-cn.com/7ae8b65cf80c5e9980ea33973abb6678f10098646aeac699cac12817b7e250ce-309最佳买卖股票时机含冷冻期图解图.png" alt="309最佳买卖股票时机含冷冻期图解图.png" style="zoom:50%;" /></p>
<p>​ dp[i] [0] dp[i] [1] dp[i] [2] 分别代表 当天 持有股票时的累计财产，当太难不持有 且不可买入时的 累计财产，当天不持有但是可买入时的 财产。理清从前一天到今天的状态准换关系即可。 买入/卖出 是动作，而 持有不持有才是状态，由不同的动作，导致每天不同的状态，因此要以 状态设置数组。</p>
<h4 id="买卖股票的最佳时机含手续费"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费</a></h4>
<p>​ 类似上</p>
<h4 id="买卖股票的最佳时机-iii"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">买卖股票的最佳时机 III</a></h4>
<h4 id="买卖股票的最佳时机-iv">买卖股票的最佳时机 IV</h4>
<h4 id="给-n-x-3-网格图涂色的方案数"><a href="https://leetcode-cn.com/problems/number-of-ways-to-paint-n-3-grid/">给 N x 3 网格图涂色的方案数</a></h4>
<h4 id="青蛙过河"><a href="https://leetcode-cn.com/problems/frog-jump/">青蛙过河</a></h4>
<h2 id="背包问题">背包问题</h2>
<p>这类问题通用的寻找 dp 的方法都是 将 目标值/背包容量 设置为一个维度， 按照物品列表再设置一个维度。例如 零钱兑换中，要凑够 N 元，N元就是目标值（容量值），那么dp 的设置就为 dp[n] [c] ，使用前 c 个硬币 凑够 n 元的方法数。<a href="https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/">背包类问题总结</a></p>
<ol type="1">
<li><p>组合问题：组合问题就是 给定一个目标数，希望找到凑出这个目标数的所有方法。这类题就要注意题目意境中是排列问题还是严格的组合问题，如果是排列问题 那么就允许 1 2 1 1 1 2 两种情况的存在。在青蛙跳台阶、 <a href="https://leetcode-cn.com/problems/decode-ways/">解码方法</a>的问题中就是排列，这是两种不同的方法，但是在 <a href="https://leetcode-cn.com/problems/coin-change-2/description/">零钱兑换 II</a> 中这就是相同的，不能计入总数，因此一维度的dp求出来一定有重复。</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/coin-change-2/description/">零钱兑换 II</a> <a href="https://leetcode-cn.com/problems/combination-sum-iv/description/">组合总和 Ⅳ</a> <a href="https://leetcode-cn.com/problems/target-sum/description/">目标和</a> <a href="https://leetcode-cn.com/problems/decode-ways/">解码方法</a> 爬楼梯</li>
</ul></li>
<li><p>True, False 问题：不用考虑重复问题，对于分割等和子集问题，其实就可以间接的转化为 凑出目标和问题，判断能否凑出该 sum / 2 即可。</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/word-break/">单词拆分</a> <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/description/">分割等和子集</a></li>
</ul></li>
<li><p>最大最小问题：其中一零和问题是一个二维的背包问题，就是他的容量由两个维度1/0共同决定，因此它的最终状态就是 dp[] [] [] 三维数组</p></li>
</ol>
<h4 id="完全平方数"><a href="https://leetcode-cn.com/problems/perfect-squares/">完全平方数</a></h4>
<h4 id="分割等和子集"><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集</a></h4>
<p>​ 记录两个思路 一个是自己想到的 按照 回朔 + 记忆 的方法 一个是 看解答的标准的动态规划的思想。 ​ 首先 无论怎么做 要判断能不能分割为两个和相等的子集就是 先求和 然后除2 即为在数组中找和为 target的组合。</p>
<p>​ 思路1，对于数组，每个元素有取 和 不取 两种状态。因此 回溯就是 从前往后 对于 第 第 i 个元素 return dfs(i， target-num[i]) | dfs(i, target) 前者是 第 i 个元素取得情况下 能够满足，后者是 第 i 个元素不取的情况下能否 后面能否 满足和为 target。但是直接这样写会超时，因为会有大量重复的情况。为此加入备忘录 设置 dp[i] [target] 记录子问题的结果 防止重复。这种由于递归的 子问题就是 dfs( i, target) 所以在加入记忆优化 也必然是使用 dp 数组存储对应组合的状态，防止后面重复。</p>
<p>​ 思路2， 动态规划 dp 数组的含义 dp[i] [j] 表示 在数组的前 0~i (包括i) 中，能否找到取和为 j 的情况。最终就是要求 dp[n-1] [ target] 的状态 。 ​ 考虑一下 要求 对于前 i - 1 个 增加了 第 i 个元素 可以分为 取了第 i 个 和 没 取 第 i 个 元素。dp[ i - 1 ] [ j - num[i]] || dp[i - 1] [j] 两种取 或 不取。 意思是 如果第 i 个取了 和 为 j 成立 那么 反过来 抛去 第 i 个元素，前 i -1 个元素任取应该能找到 和 为 j-num[i] 的情况，再取一次 num[i] 就可以满足 j ；那么如果这次 i 没取 但是 和 为 j 的情况 很好理解 没取相当与不存在，考虑 i - 1 的情况即可。但是还得考虑 j - num[i] &lt; 0的情况 ，此时 num[i] 肯定不能取，因为已经大于 j 目标值了，所以此时 == dp[i-1] [j]。</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210401152541.png" alt="image-20201014225610678" style="zoom:67%;" /></p>
<h4 id="目标和"><a href="https://leetcode-cn.com/problems/target-sum/">目标和</a></h4>
<p>​ 这个题 技巧和上面一样。自己做的时候先想到的不是动态规划 是 递归+剪枝 也不会超时。单纯的暴力递归 复杂的 指数级，会超时。</p>
<p>​ 递归的思路。首先每次 选择 target - num[sel] 或者 target - num[sel] 递归。判断到最后一个元素且target==0的时候 计数。剪枝的方法是，增加一个当前剩余元素的最大和limit 起始 limit = sum(nums) , 递归时 limit - nums[sel] 。 通过判断 当前 target 是否在 区间 [-limit，limit] 之间，不在就返回 不递归。</p>
<p>​ 动态规划的方法。首先状态数组 含义和上面题 一样 只不过这里记录的是个数。dp[i] [j] 的含义就是 前 i 个元素的和 为 j 的个数。最终就是求 dp[n] [S] 那么 第一个元素就已知了 dp[0] [ num[0] ] += 1, dp[0] [-nums[0]] += 1; 那么怎么挨着求到最后呢。首先 j 的 范围 肯定在 正负 sum( nums )之间，因此就建立一个这么宽的状态表 （这样 j 的 值是稀疏的，不会取到这里面的所有值）但是这么建立表格 方便循环。没用到的 计数值为 0 即可。虽然看起来增加了很多无用的 j 的计算过程 但是相对递归的指数级 时间复杂度 还是好很多。状态转移就是 dp[i] [j] = dp[i-1] [j - nums[i]] + dp[i -1] [j + nums[i]] 注意数组索引正负的问题和 后面溢出判断的问题。</p>
<h4 id="一和零"><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">一和零</a></h4>
<p>​ 这个题 也可以看成背包问题。将 每个字符串价值看成1，每个字符串占用的体积即为 0/1 数量。背包的容量为最多容纳的0/1的个数。状态 dp[i] [mc] [nc] 的含义是 只有前 i 个 字符串时，背包容量 (总的0/1个数) 是 mc nc 时最多可选的字符串的个数。 ​ dp[i] [mc] [nc] = max( dp[i-1] [mc - mi] [nc - ni] + 1, dp[i-1] [mc] [nc]) 含义是 这次选 则第 i 个字符串，则可以取得最大数量，就是上一次最大容量为 mc-mi nc-ni 时可以取的最大个数 + 1，另一种情况是 这次不取 第 i 个元素，二者取大的。</p>
<h4 id="零钱兑换"><a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a></h4>
<p>​ 这道题和 面试题一类中的 矩形面积填充 和青蛙跳台子 的 类型相似。这个题要求到兑换金额为 amount 需要的 最少零钱的组合，那么组合的到最后 amount 只和 dp[amount - coins[i]] 有关，其中取最小即可。</p>
<h4 id="零钱兑换-ii"><a href="https://leetcode-cn.com/problems/coin-change-2/">零钱兑换 II</a></h4>
<p>​ 这个题 和 青蛙跳台阶 很像 （dp[m] = dp[m-1] + dp[m-2] 值看最后一步 是跨了几层阶梯），但是又有本质的区别，青蛙跳台阶有先后顺序，总的次数实际是个排列问题，但是这个凑钱的问题是一个组合问题，1，2 和 2，1凑3是一种情况。所有状态方程不一样。</p>
<p>​ 首先，是组合问题，假设硬币集合 [1, 2, 5] 那么就按照一个硬币 一个硬币增加的逻辑 来思考。就是所有取硬币的方式 只和硬币种类有关，只有1 硬币 只有1，2硬币 含有1，2，5硬币这种。然后总的数量 是 需要凑的钱数 amount。也可以从 背包问题 推广到这个题，钱数是背包的容量，取得物品是 硬币，只不过要刚好 把背包装满。因此按照背包问题的通常方法 状态 + 选择，即选择每次选不选当前的硬币，状态是凑成当前金额数 的硬币取法组合。</p>
<p>​ dp[k] [j] 表示 含有前k个硬币集合，取够金额 j 存在的组合组合数。那么对于 只含 前k-1个硬币组合的情况，组成 金额 j 中的硬币 含有几个 硬币 k , 含有0个硬币k 就是 dp[k-1] [j - coins[k]] 个取法，含有两个 硬币 k 就有 dp[k-1] [j - 2*coins[k]] … 以此类推求和。但是这个状态方程起始还可以简化。<a href="https://leetcode-cn.com/problems/coin-change-2/solution/dong-tai-gui-hua-wan-quan-bei-bao-wen-ti-by-liweiw/">具体推导</a> 结论 ： dp[k] [j] = dp[k-1] [j] + dp[k] [j - coins[k]] ; 可以这么理解 就是 要凑成 金额 j 可以分为 不使用 第 k 个硬币 dp[k-1] [j] 和 使用第 k 个硬币 dp[k] [j-coins[k]] 这一项其实是保证了 肯定取一个 硬币 k,至于取了 &gt;= 1的几个 k硬币，其实都包含在了 dp[k] [j - coins[k]] 中了。因为 dp[k] [] 这一行 凑齐前面的金额其实都是使用了 &gt;=0 个 第k个硬币的。</p>
<h4 id="最低加油次数"><a href="https://leetcode-cn.com/problems/minimum-number-of-refueling-stops/">最低加油次数</a></h4>
<h4 id="单词拆分"><a href="https://leetcode-cn.com/problems/word-break/">单词拆分</a></h4>
<p>​ dp[i] 表示 s 中 前 i 个字符能否被字典中的单词拆分。判断字符串是不是在字典中 可以使用Hash来加快判断。有多个单词，其中在 I位置 有一个是 true dp[i] 就等于true。</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210401152523.png" alt="image-20201018115551358" style="zoom:67%;" /></p>
<h4 id="组合总和-ⅳ"><a href="https://leetcode-cn.com/problems/combination-sum-iv/">组合总和 Ⅳ</a></h4>
<p>​ 和 零钱兑换问题2 对立 这个是排列 问题。</p>
<h4 id="解码方法"><a href="https://leetcode-cn.com/problems/decode-ways/">解码方法</a></h4>
<h2 id="中心扩散">中心扩散</h2>
<ol type="1">
<li>这类状态转移的特点是：按照数组的起止位置建立状态 dp[st] [ed]，并按照<strong>子数组长度 从小到大 开始遍历</strong>，<strong>然后中心扩散</strong> 类似dp[i] [j] = (dp[i-1] [j] dp[i] [j+1])</li>
<li>因此这类问题的关键点是 看长度为1的子数组（st == ed）的是否可能为迭代的起始边界值，例如 最长回文子串，当只有一个字符时，它必然是回文，然后依次从中间向四周扩散。再例如 <a href="https://leetcode-cn.com/problems/predict-the-winner/">预测赢家</a> 问题中， 当只有一堆 i 石子时，先手比后手多的分数一定多 nums[i]</li>
</ol>
<h4 id="预测赢家"><a href="https://leetcode-cn.com/problems/predict-the-winner/">预测赢家</a></h4>
<h4 id="最大正方形"><a href="https://leetcode-cn.com/problems/maximal-square/">最大正方形</a></h4>
<h4 id="戳气球"><a href="https://leetcode-cn.com/problems/burst-balloons/">戳气球</a></h4>
<p>正确的建模很关键。一开始做的时候，想到 假设 k 位置为第一个戳破的气球最终的收益，然后遍历每个位置，取最大。第K个位置被戳破，那么 剩下的就是不连续的数组，即 dp[ i ] [ k ] [ j ] + n[k] x n[k-1] n[k+1] 但是这时候就需要带断点的数组，中间维度K为断点。这样建模很不好写。</p>
<p>答案是 设置 i j 的开区间中最大的收益，并且 最后一个戳破的 为 k 位置的 气球，由于是开区间，而 k 是最后一个戳破的，所以 k 左边的部分 和 右边的 部分是完全独立的两部分，建模方法就简单很多。<a href="https://leetcode-cn.com/problems/burst-balloons/solution/zhe-ge-cai-pu-zi-ji-zai-jia-ye-neng-zuo-guan-jian-/">很好的解析</a></p>
<h2 id="记忆搜索">记忆搜索</h2>
<p>事实上大部分动态规划题都可以用 递归+记忆的方法实现。尤其是那种 很明显存在 递归 选择 的题目，直接选择递归，复杂度指数级，运用备忘录的方法剪枝，可以加速。通常记忆搜索是自顶向下的搜索，而动态规划是自底向上的迭代。</p>
<ol type="1">
<li>有些题目，很难找出 它 动态规划的状态和地推关系，但是当回溯/递归的思路很容易想到，只不过会超时，超时的话再加上 记忆剪枝即可。例如石子游戏问题<a href="https://leetcode-cn.com/problems/stone-game-ii/">石子游戏 II</a>， <a href="https://leetcode-cn.com/problems/predict-the-winner/">预测赢家</a> 特别是前者，很难想到 将 M 设置为dp数组。<strong>但是很容易顺着题目的思路写出递归的方式</strong>。dfs( st, M) 即从 第 st 堆式子开始取，此时最多能取M堆，先手可以取得的式子总数。最后发现超时，简单 根据动态规划入口参数 设置记忆 dp[st] [M] 即可。</li>
</ol>
<h4 id="石子游戏-ii"><a href="https://leetcode-cn.com/problems/stone-game-ii/">石子游戏 II</a></h4>
<p><strong>关键思想 在于这个是反向推的，</strong>假设剩余的 n 堆石子时，先手 开始 取，能取得的最大的石子数，但是还要考虑 此时 M 的值。想想 如果此时从头往后递推的话，那么M 的取值与前面的取法息息相关，很难讨论全面。而从后往前推，就算是 M 最大 为石子堆数的总数，就便利把所有的 M取值情况都算一下好了。注意：虽然 M 的取值都算了，但是并不是所有都有效的，这个由石子的总堆数决定的，例如表格给 i = 1 时，此时为剩余堆数为5 即 第一堆开始，而第一堆第一M = 1为设定值，此时的 算的M = 2,3,4..在 石子只有五堆的情况下是无效的。 那么 从最后n堆开始，先手能取的最多石子数 dp[ i ] [m] 1&lt;=m &lt;= L(总堆数) 这是前两个for循环需要遍历的。对于特定的 i M 如果 i &lt;= 2*M 表明先手可以一次拿完剩下的所有的 即为最大 = sum[i : end] i &gt; 2xM 则 先手可以 取 1&lt;=x &lt;=Mx2 ，有这几种取法。遍历所有x的取法，取最大为 dp[i] [m]。对于特定 1&lt;=x &lt;=Mx2 剩余 i - x 堆时 先手取得的最大的数量 那么 i 堆时的先手取得的总数为 sum_n - dp[i] [i - x]。遍历x 求最大的。</p>
<p>（事实上，尝试 dfs 的方法上述问题更好解决，而动态规划的方法起始很难想）</p>
<h4 id="新21点"><a href="https://leetcode-cn.com/problems/new-21-game/">新21点</a></h4>
<p>这个题目和上面类似也是反向递推。设置 最终问题是 最终得分不超过K 即为获胜的概率。假设 当前起始总分数为 i ，那么求 dp[i] 总分已经有 i 分后 获胜的概率。很显然这次总分数为 由于一次抽取的数字只能是 [1, W] 由于是等概率抽取，那么 dp[i] = 1/W x (dp[i+1] + dp[i+2] + … + dp[i+W]) 。即递推公式，两次抽取获胜概率的关系。从规则可知，最终抽取总分数 只能是 1 ~ （K-1+W）当得分大于等于K时不能抽了。而整个得分区间又可以分为两段。一段得分区间是 （1~K-1），这段区间内的得分之后至少还能再抽一次，于是可以用到上述地推公式。另一段 K~K-1+W 此时已不能再抽，小于等于N的获胜概率为1 否则为0 是固定值。</p>
<p>综上可以从后往前推出 dp[0] 的概率定义并不关心你中间过程是怎么抽的分，只知道当前持有分数再抽下去最终会获胜的概率。而这个起始概率是从末尾已知，往前递推的。</p>
<h2 id="错排问题">错排问题</h2>
<p>错排问题就是 1~n 个序号的元素 和 1~n 个位置交替放，序号元素不能对应。关键在与 2，3 ，4，5 和 1，2，3，4 这种错排可以划分为 5 和 1 能否对应的问题。5 和1 对应放，剩下的就是 2，3，4,否则 5 和 1 不能对应放就相当于 2，3，4，5 和5， 2，3，4 元素个数为4个的错排。</p>
<h4 id="信件错排问题"><a href="https://blog.csdn.net/carson0408/article/details/78927984">信件错排问题</a></h4>
<h2 id="子序列两个字符串问题">子序列/两个字符串问题</h2>
<p>事实上这是一类问题的划分，解决这类字符串问题 常用的套路可以归结到使用上述总结几个设置 dp 的常见方法。</p>
<ol type="1">
<li><strong>对于两个字符串之间的关系问题，将dp 设置为 dp[i] [j] 以为 s 串的前i个 和 v 串的前 j 个之间的最长公共子序列长度/编辑次数</strong></li>
<li>单个字符串 的摆动序列这种问题，就是以状态作为 dp 的第二个维度。dp[i] [k] 在 i 位置结束的子串的上升序列的长度…就<strong>类似 相邻元素状态转换 问题了</strong>，自己根据可能的状态设置dp数组的第二维度的含义。</li>
<li>字符串问题还可以设置 dp[st] [ed] 即字符串的起始结束子串，用到类似 <strong>中心扩散的原理判断回文串</strong>。</li>
<li>有些问题可以间接转化为 最长公共子序列 这种经典问题来求解，例如<a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">两个字符串的删除操作</a> 根据题意就等价于求最长公共子序列</li>
</ol>
<h4 id="最长上升子序列"><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">最长上升子序列</a></h4>
<p>基本的方法是 动态规划法 高级的是 二分法+动态规划。动态规划 的状态数组为 第 i 个元素结束的 最大上升子序列个数。那么 以第 i + 1 个元素结束的最大上升子序列 可能是从前 i 个结尾的任意一个接过来的 因此要取最大 同时 从第 j 个接至第 i 个元素 如 num[ j] &lt; num[ i ] 那么 dp[ i ] + 1 否则 1 因此O(n^2)</p>
<h4 id="最长公共子序列"><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">最长公共子序列</a></h4>
<h4 id="两个字符串的删除操作"><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">两个字符串的删除操作</a></h4>
<h4 id="编辑距离"><a href="https://leetcode-cn.com/problems/edit-distance/">编辑距离</a></h4>
<p>这个题就有意思了，按照 第1种情况去假设dp数组可以解出来，但是状态转移方程可能会列的不对，原因是 插入 删除 替换三种情况没考虑全。</p>
<h4 id="摆动序列"><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">摆动序列</a></h4>
<p>这个题 可以按照 题目最长上升子序列的思路 dp设置为 dp[n] [2] 0 表示i位置结尾 上升子序列的个数 1 表示下降的个数 使用相同的n^2的时间复杂度循环即可。但是这个摆动序列相对那个题目可以优化，因为是摆动序列 其实 状态转换 就只和 当前元素与它前一个元素的大小关系有关 再与之前的无关 所以可以做线性优化 o(n) 只循环一次 若当前元素大于上一元素 当前元素的上升个数 等于前一元素的下降个数 + 1 另一个不变…..</p>
<h4 id="最长湍流子数组"><a href="https://leetcode-cn.com/problems/longest-turbulent-subarray/">最长湍流子数组</a></h4>
<p>这个题目和上面那个 摆动序列很相似。将湍流数组的定义抽象化 即为 求最长的 连续的 摆动子序列长度。和上面那个题的区别在于：</p>
<ul>
<li>摆动序列可以不连续 但是这个最长湍流 必须连续</li>
</ul>
<p>所以状态方程略有差别。但大体思路都是 根据上一次是上升还是下降摆动 来推导这一次的状态。</p>
<h4 id="最长数对链"><a href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/">最长数对链</a></h4>
<h2 id="矩阵路径问题">矩阵路径问题</h2>
<p>这类问题比较好写。状态转移在题目中都交代的很明显</p>
<h4 id="最小路径和"><a href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和</a></h4>
<p>​ 这个题的关键是 从左上角到右下角 每次只能向下或者向右移动一步 那么 对于从起点到 格子上的任意位置 (i, j) 只能是从他的正上方 下来 或者 正左边向右移动一个 选较小的 即 min(dp[i-1] [ j ] , dp[i] [j - 1])</p>
<h4 id="不同路径"><a href="https://leetcode-cn.com/problems/unique-paths/">不同路径</a></h4>
<p>​ 思路同上</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>研究生期间个人项目总结</title>
    <url>/posts/17412/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="0d51c7546d2e3cc070774176287db7bbd34b4f20e48e72ba72450360dc4170fe">995e50c340763ee1a325e8c3b289bb94042f5aabaa770bc0112db74bfe3b3d8bcf0171a02d8c4b6eedae4b4b26a86161431175103a500b68cf1d3dbbdd04f85d35762aea72a48c2a2cac2124ecd27d29c728d3918af6cc5eac6cbde519c3cd20e8ea469b25f60291f93fb23f5e5c9716c379bce14f3e57bb81a01c2fba21edfb5f3440786d833e239686cbc8629cde50aca46d0066006001510b73cb7d2bb7a8d9ea7d46249de7e45a70421e79bee187a989a45133e441a50398e38889e39b811c300df494d27e6e0c15f9a50e67b62a85d42a82c9d2ef26be650d9940e186b952f63ca95a6c71928216fe5a34cc4014cf86e3419020b119c0f8093270ac1f741a589a96955cbd6e9130692c098b82ce0f252b4ecc67e380b42633674b4cdc349ef9b14003a636727cc9b9eef92ef7970be7f5b2ddb5acbd2914188a28e867b6642a724880348eac9a5986a39c85e66df2ae114bf6df33f3964c7680cc29c359a10b0251eae21028d93aa831f3a7beb54e787b2a76e86996e4340c3f5a8e4f16ac17d05685f560e3b4decf4d328286e604444cf4bec3a7fa802ac2d9a015b8e439eea4a3542905cbe2923d714a0b377b98a6010fa21dfb97107a08c0867ad293555a58b4217c499688c5e333b0254fd2115861a5aac2465f85b0359b51a13a76d8026a20d4ec3eb99996fe78f321992f96ed1b3523ea5d8a82f19ff43ad59c4832acccbcf625219aca1c60e5d85c9650dc18172326006d18bebfa8363410dc8978ead088d427575643d4472bd6ee56b55c832d8c538d9a24e999a8d40c55189734a2f2fc1919f2b3ed13a7a079b7a936bf65d782d74c60659970ba7603cc5b2bd59b06f86621b416803557bf393debe0f7d2ca1586c348d691702a2789d6316cf632149d4f5ec61b409348fc306e9c1d880c7f0d666dc49e123e8511d5f5d18ada47afef115f0f639182061f18ef861306bec2a313fa8bf4572b8e79403362f4a0af5d041ae47efc4e2a0e723daab26c4cd8c959b6cdf25ede5260520d3eece3003a3a40c46de16eb4c8edec0a5f3e801679756189379ca85cec52a57923ab8d80d6e3c18ac7b20021bdc62a662ad201b8d8f13212fb9e607e3191822dfa029293ec34c853327185d767cf39fa233fb4bbd9b36730ab17891336462c06971270ddc962df296e72ca1d5ae266516361c77de87168663500e6da3e9d34d448f6915dd8d23ed39ecbefc2c041aa54a1b48153b207971fdf56f9c054da0df1f9cbea591c9a69e01d8f1bb7e6d5be2c431e4ad067790c4e122c308b9ecddf13c2c4a8ce99d11194f267b4be5478344612849a64b3b5744d7bf35d9655bbe0840aded8c704741da64196d5543d2d1c3b19da8354e542f3c0296930a62d959b06e23e86e09608e83bf9788f84d65c81bbb4d265f12810e36edb1506897e457361f874c8e7ea3bdc4b4beed5c0b6c1557b25410b24befceb02d9373292c5c1063637edf42fe52ef15352a65ff45f1bf1f421dba7390612a668467b35c86e9f5b8800d9e7428ce4c10c7cadb5a0cdda86cdd96fee204e2a132b0a9a21e50f9e6b11453e3873cc437dd69bfcf23ad73f84e56fc673040547167012c5e2cb4ecbc5f381b3fe066cc6785b25294d3ffb5699d3091c46ace9c9bcefe1f0b894b2761b96d9e4d70ac22a6f8dfe4467b327fa702b9359e4a218ddf634dcf4ff58c26040172203497ab5704beb7f0aab458b4148e5a280d1b4d463796abae2c5e22ab7f5b26b62ad4a479c1b563f0c4de280e1b7b637e1cb3f6768d60f95532f9ad31080f99e5f38192ee995ebda4474b6366d6b21c6a8dfe2b99313c39e3454d8205806d97b6850c80bb04ce80228ef3c57612d32502c311164a6d826219b3c37474cef17f459ed29104379d31bb0e1cafd3d0d3c517bb042abc682fe957b0aaa74896c5a3895d09eaf09538ade96520d6ae3e2feb944143a1b6705b7e4c752c14db52caa5799c4725e0b728fbabb3795f78545c33e2913b6a70429e49470c0427fd5f8d925fb0cfb10bff02a2049a5e1c08bd7b9488252241369dff320258f87ba511c075b8fa68346761f6eedf90f6d86443e9cf782b33a59072d806e8d536a946e2607b0ce4a5d5aab6706d7391c91b7bd1982a76bad6d0018b400b25d98fd141b5c3ae03f190c64061cf3eb4b5f111bd04975c2c51fbb21c175ee5cda23bd451fc7346d63ca66bfe7712c2e4ff37d3dc4ee4f97faf3e1183c6ae7e092ef0a3bcbac99a421f183642a363df350151d7b9d6ed5c77fedeaff75025e967e326dd452bae5bd6619645dc82ef30a21f5334bf5ade26cee85f2e7ce1c1ceea38b98f0ab9007502aecccfc3a74adbc3090a1666ad53ce93e4276d3b64c1b896a5e9f5b18f3887d92686a492e373b0442173ac0e0b96e9c07387ab1aebe711c4d95091993707b7041e757646d9800fba5d4cfd094d3ee504a23fed716259872350032327a861f86421c18109f4e1e877807eabdf90180933bcbf1b6da12f7de13b83ff57ccbd5dda00f58634c90f010d562075f764315824ebd1309a77fc2f5e83340a17fe41ac64552f24a54bb4aba957075fa03320d4f3fabbc14c4bbcf1a3da3576b60f56a59577a8cabb9e5fb5e3c203ba86f05a91b4496159a8e471c682fff607de67f4a7186f8b2dfb049ed3e67ca66c6b077d438b2772968adf6db1a505c028a8930a7db00ee736b19ae019b3e1655691d47b167ebd9abf0b2ad45d9c974e4a373305ffcd2a74501562848bbc948f074abefce0b53e854178cad0bc58c9791832422fc5c3eb6eeefbf8db852d30ede131ef534207d6f6b17782087985b25a3fccd5adfc998b43d50bd37e218f331d9c305759e24329e4ab4fac5f154b3f60770329eb4692a42a97e65b4cf923ff85b11c8caee93068132f9377ad857326769865f5765fce6551f780a9ebf95aedbe98cf02828fd84884f3b8d50dd269cc348369deda1e92940e785a14dc8bd2a71485cf60e2810ee6fc3ed548bbb66a57172490e95475fb6329d01cc34a7a8e70d8bb91b81d8be56cce0f809a58545d61385b68695326401cc04eea19c7f1e0c26bc4b8119055ce32fbfd3d4e62913f00ad44897b84637f3632626547b3e3d2f4917869a93d6b6fdbfae3f6f252416345c3bdcf96b198ea85e4dc5bfc61cf3423fdde3cb05348a207d08937cfb17dcf0c5087d3d76574fba556127c4eb8e883f6ffa3526879ad38c4eaf6381b157a63195c2c5e2b85238f2b0d726afecefec1f0e23d32e37cc68233ba0e0a32716e7790d3e83065f29a056d733ac046a17dc3d4feebf6843cf37b395f67bb977fa1a85d75c35a856cb4bd5de3f743a722d5e98e06ce70e03a4e625bb9e946583f8015748d048b6af75bf6264ab20fe923a3da1764895e2caa2e0d615650857b23f2b4b86a162003109aae37b0317befa4179d35fb512ab24308c92e306ec0e6ea4eedae8ab1b3c06d70e9c2449052ed05fd61431221e350241ecf65fe283c67e0b7356240836c6a90d26c2021a49deb5063b93c4c751b07a4efa8cc05c1ad83573a2b93adfdd3b2bee174156d4a2551c0307928fb8b4d041c6c56bf50565d3d488457416011f0a216fba83d47dc21c5e5a8df728493884734de5fedbc552c5e373f251a8d2a94ad620ae48c2d51a0379b06df709b9491df4e5774222bf81137a6c286a15e5f571ce7c7e6ee6c2b0167c30b3d6b0b8f34d94a474e7ab4352d56ecabfe0a2f1e507632fcbfdd33ef12c12a8e028d576a88e0fcc2791c52ec7daeddfddc8b76a0bf22163546ee118fa6653bd8c47fb6183190604d7fe9f4bd08d4f7e6f157fb61941a639c420b6396a92008177d3209dc47eeb01c45473eb4e195bcc534eeea87038aae7d2774212c5ca51f0c9fc0ef7c96b8f78386af6c17f66035cc02996f071d47d3a26440abf5373fe71630f3c3959cdeadc467ca2c786f5b6b01c461859f7387cc2c2835e4587bb4eb868320530553eeb11ebd36a883b19249621caa11eb7816d2545e0e461bc057e1af58a9fb725276e5ae449492a2f822a98ca3328b708d6eaf8626914be7a8ac8377c90a0c29282466da4325844c973d1cdc52008da1fef9b8224ead472585e44cd367a1ab07441bdf68ef9c77dc7e9e9b0e4c9ae0e3bcc317cae28ed68e0797e57eccad044e5547fa2398c4d98cf002ddad12f26c4000fc4ab47b8f7aef6bde7911b517d6b8472cb540c7185408c1393e433140e9c1aa21dd2e7e13c52aaacc416b89fc75d1004fc3cd5b838df1518018cd9ec1058ea33d4ba6333d99381de433829452cdbb296f36264430b4157205f9a0c78591784ff180d99b45da9f376b22112fb3ae95f38982450740b3d16a56fb793dfc34b3e4bc01b4b7f5968cc4130a8ef11c374e435277923cb5a36e2023004e4684d5a345b95e127071cddc82d696204bef30b7755b62a67af0f90b89b9ce82ab315aeac6bb2e4f83ec9c5245fcfa1fa5e53a58b3cb2d2ea80a3eb8b1e1058614fc4f4f8492978564a4fe26dc6bb4ce1c72ba00452af3ac2b12c78d50708f384520026a2b1ece53bdde40d09e16f95c08193060f8559f783d7865bca2d9c0825b069dc9d043668ce3fe8b2f5f937032951c6e5b687e83a6576f0dcd4b7f7b6749c528795904447af4e8d776ccf6d12c29fec434a5626de38cd2dfe0c11ab3c6ea59375189fb8f6acd0859608e0e93efab72e1a0ecf03b1b319c3c2094b234f142a1914c45cc1c8e59f3cf2991a70c0c473fe680ba51761699a1e0305ce362b7b90de091652d3442296e3dd06c7121ea96e39264370f88f216c46ff336e649553c0658769cfefeac8963f75ec09bd13f4342a49e47a22862d111f3e4a26fc193709fd4b3413e39e71fc6c2f5fdbaa9411cb18669f385463630334816ee7faa39042924dd506b97b3f2efac90cc72564c266931859dd255b39fcedf07ab5aad5a0a7df10c32d9bc6f0effb483e8ee36f91250577891d49e5aaf055fe5fc9402da6e1590cd1c28fa004b2c11f329fa22c51b51142969f9c643a4fc3a0b27a1d34b6845f513c3cc316412926c5ae9c499998082928be8429b35d320fdc007c706a3d321aeab7c1f44d617756ba29765c8c96aafa37f1caefd19d6f3b87d81ecb1a506dd92d1ad66318c6b9c1fdb78ae993c16e5b6ed11f05a95513c251e6bb0bee8104e3a2e81f33fe1e98a656df98ecbb20d65607c3fbb6bb9681f2634c8a71bbce9a77489d4550c3fb18820eaf0609ae1ac62373912b977a8d3a42a66211face47cc9c0b4e569556c36144ce14515be53c439aef256780a946839f7f3cb1154cf9e47a9f331cd260effd2a9b57bb2d668f348d8b1f142982dd183cf99ce0a18599e13cfc3f7febb0cb102da75918f19ead27e7e6076bd78be03a2886d2d105893b99a020e8e17d0d7714b0820a842c37c84091dc1f189dd53e01f3b4800deb75b7fcd9fec2e6ecd0bcb67aa76bab103634c10d9f8d74854bedda1ef089ab69455c398dff6067ba28bfbc0e965417e3b845addac12bcbbee512d8ce4ab6dc2b59669b46859ddacfedf71b93030ee8e12c065b78c1e7e9bb0ae1a0ab40ccfbfc182b98e2b855311a81289cc976ed4014c694bd98581273594b6074e64a09c82a87cb430bf6bf0c9b00b1ef07e97c09f805bb3f2d146a26b36b024f98b1728e63166a763b904f8b8eed01e172b4f340d949717a0eb2e54312b450d00e25ef6a820ddd4aefa7dc5b19be1a862fc10460d7d2546322f80c887a719a82f04e7f8c364a10d79893333dd2d13323acf933388c428258687adb4977284bb110cda63688d2f496dc8e225a8b7a2773367ca0ba575b8426c417c8b59c8f6ac1abbf885b5158e657dda170f0d93a9134f446293765be02ac49244ee92770e6f1124e2fec019e489a69f8c3a7229e83a088c7d349cc05c4de8ee02aff181b3e0a9fb150a4c4280384f9e65def7dc331d555360dbdc150439cea7be10efe60a9f6e85fc150be4c42912ab55c2c84daf18df3349eec0442cf096d008743cb239bead9864be8878bd61963d5d41b6833e829a4064274f436e7de0ed689fad3f13197840af84c5584e5e87bd5a000819b3c366b70bf58221adb90aa381c96eabc6d92a92be3e539ed48f95b9078afc4f3043f25a68a527512715167af66672f31e9f5292f32d7ab5f9a867ffe3baff9ec03918db850ef0ae4748e1b76e7d2acdbb158ab1a4fdba5050680d8276a6c8f11e5fe1f5c97faf32564e2baf209caefb2abf27c008e59f4c9d777ca7198c800b8b16d0863e9a7b767d1bd6b4eacd14551a64074dd9b9cb05611b9c2245733e397a75567562d633577e968c7caef43a504dce96781dde717404d0a2f1a3b65f4a8a7f9282af75c955cb2a521e651ca411b3255d32c04e4163d5b3c75183ceaaad5c6b80871d3d600e372d58670851fd2123695998c1a34ead43ed3691460fb65591fd635adfb4cd6cb9940001a52c422a8cb657bbabb35ddb5a87dbaff60edbf4b1d7672743fa4adfd41121a49688a894abbfff21b3fce948e5200ea7cd19d3db386f236a54f5930a1f25cd77aa4998e2f246079fd763370b75553472b2ed7f9707fd0cb26e7780bd23f016d9ee9a64e9543892d4b9096240087b49d78839a834060c7420ee95d8dd04564b29156766f84e440b023352d07d669fc1cf43d80b7d4c558da1159ca12dbcf0c4e09c47aeb0df0b034263f549b650e730e382a3e3a5e3addd8fc433f9f54231b3f8cce4484693e689d79f41e0468d819ec90d1a5ff43b928ca58bae8a5a20d6ad4861b8f68b2a585e61e3700cfba07ed11f513c312817c25a9080cc248601716654c7b73403681244052ccf511ebe3baa4c041c7cd89ea85bf5fb55bf0cbf2470179d690f83085db34eab1ac350cc9538f2a83c1f105c1e89484f4299cd31999a1c664bee66ec52dcf7cd12d1bb3c8e51e6321f4dfe4229c9d62ae56fbd81e8698289c56600eca45028d2db8a67e95d6bc84f61518a55d314a3644a659a94142cbd69df77104a15519b5525af8cb48dbe3e6082566658b11d99cec4f51d6b1d3e69ee77af78ada380e441277c433e7f798b76da9a33196ef6198303bb1c7bcddc947aa67974126202b5900c5004229fbaa827098837bc485840f21f5c01cabb2761787bf4c08d2cfc2ec56661bdbd90cdc3ec9ab0b3e3cabd8b4a8353dafeb335224de0c9b08f30c9719e5baa5b9b396048fe8225e375a5ac69b7cdc8cc94c8a170476b1f1b4ebafd4e81cf75fae5aaceb630e076b85dc04870f8358c64c18d01b8aa8b01be8c1b045b84ed7b7f4f97d845ebb59e2c4a6635e6771fb11962a9830b25e4b899a7ea83ebca36189b5bc1c35fb3fd66eb44a880933dce8f9c5bba4257b9cfa84e41d990ecd1a6662a2cd1de4aed0aa12d4127b39dbc8d4360da5ac9e2ede9ebb919e4acf3a72a52da87fb05089a068ba1992feb6facd2c56031999b614dad01e55e96c332b39a50619bc79d1c74466cb8fe275c58a38c62bccc9047137b90d8385ca0248cfdceee5b33a594f6b8b8abbc7ce51f369ae8437dc4e3d23bb7b44635c80052cbcec937456985e99251a67b783071e803b23e6f15380ab085ce681fdeabd5a568ab7cb6df193d6f78fe5bc3c61bc2982bd0e7aa4a61c707352ac5648b64f2b50ffcdf2f30121407e3882e4abc1004cc4f18948e6c3591235a86f59bbf7ddc8adb1b3fb75bf4812514f80ba07dfe7bfd20cf53d5fde3c13c47ae7dfcfe86a4fa8d551c32aa666ddab3e6e8d7936584f316f5d5c33bdab6b9d16eef508e32041fcb87d1e8196f497225ad8345b61693a1e78a63ccd5162a5baeb3c7e129e8398984ad1eb1d227bab9203e880bee2bb3380880764c85563ffedd17c36b8677fd486732ee526d1b4c918be50c05e5da81139e06ee9fe6d0865afcf44b446f225ca9cd0e0ddccde226054696cec92c494584241174b29e0cf26c3f032e5f9744c23f35bd977006d00c416514216c4d61951d8e31f855579dbd3e3ca943b85597f36e21ffcc2d6df72c81944c0bc872a4b3d1f92d2719bdd9c6f98cc52231f4156d425c818a705acdf0beecc6bb5ca7c663e91a17c5cffe5f9840e3e84115deac27c89885905b5f48f1008034cf7aae4c98901c8bc55ff1deceaeea2ae5c991a30496f2687f5d85874b81059bff0fd375dd111cec52a6fa27e6a7f0a5d6dad24f9cb4c85f48cbf406a2d91faa7b429f65c9a6b3e802d7ddc2d4accb5a37d0871eb82ada41e938e92ba932244c04b147799edc23bb58dfed06419c562e0f33158b4748c3f104eab667e5c415d3cfef0d1d986ce6aca0fa13fbef9c9475d7fa97fdf8fdc4607608f5a841143c4099bbfaa24113bc2f06e7a36596b04814ddea66cd4a0b18dfd8afbc748824c6ff6fa368f671fa7443608cc6ad31e836ddaef8002533afd97d2a1df533e45910eff13198e5fc99aa9f828e0bf7e875e0d98f14cc2d999bdcdbde0b7654ca3a8ec66a83372f524d8850eea519c6e9874df3e64771349e9fd57b7a41d09e6d572db3b843336acaef657e638e7161860ca0751429f4ddaddeccdeb7dcc92699d663294c746bdb8ed32856c000e88b316f1bab77f7b38e04817f95b4750a41127eb4e50ea21f2a8a0050e9a111c0ac650450e78faf8f74a9460f903044aa859cdb4d8a48d9bffd77d214a6242d16bf3bb5868d239fabe4c4dad8ba9c572f1eb938d896e974df6c8793e89e1ef06163ed7f195aa671e898bc372f8985ff80b298ab7eac0e1250fdc4be87ad539dc51b174f940974d85f5917abf39c4c17ed321c6a13c35303ddda93ff650f242649224ad07e9a558ee608d6bdfb8e712b8db7ef05b06c4eca633b3c89b0635263cea5ff2b7a25ef017c447f373e9e0e36d37bdfbb754b44581a1608c87e3ef12f7ea57c93ea240f9845e7dc8ca7be939f30b6c0ad9767c4b169db4e46815e001ec07d6077a81f1963ff1247f0d6823e504b8a93dab0dd94ae37a406cef7339b8c4fca0244b7a9ad03167693c97225dd4f70b984d2a7da83a555b809b3a824f3a11c99eb8d6290161746f4ff7fc732c73d31208ac0a7908ea530639cda5a31da57dfa3746403ceafea4a98454ff5a51390437eba1edd02e3ed97e87f3c331f4f9fc31a8a93ae9ed91ac3f075c06b4deca7368f2d3609e5139fd1ce0a5ced520e63f8505ec29219466ea0c1465ffe39efb0645e39c7cf14a2729432188851cdc965cb935f81f13af67e8ba34e9d874e9e27fe35266ec4d77e3f90e6f21e8b65c046f42bb84fceed0c1d4d1955d52534a2f72ddd85042608fe819017f82248e162e81c01b72504123a4e616eccbcc3ec529c0386ab18a8829e97af68fea88ee742dd58a95af22b1d9a037be34059536fb1b3f3095dae9778cfff4ea0c6a34877f94134f891032fa76abf4ffb7df9013e259b998d4b125484c723d63d79166bb6628b08012045af67423b9925469dcc44f4ed07b74a1a10618f846ad2c5c95efbd7d9b7c48c87420c56afaa6a84864564b99f72fa873acde3e0e428168b86162ace8e8709b0aead99ec05f5c7b4d24c865e988886f8ff5312967734002a2488e2deb22b3e40890fe7b7de8677f39aed7e5457db35eda338f885d719efe46e2239334d445350216978d2aab1bc2ff1502ac7fbba6d838f5439135d7dcd56eea26a84a903d141b835db2a9e04d428e062af3cd359cd6952de8f650e1d9183773d6bdc9a68ea2991c865ab1de11b5ed6d427f6da15d7266a82bb41746b973a4556ea9ad70af8dd18e9d4d154949c840c8aed7b4df5f8ee141a1f9694729bb923162c0f7d1f14187ab8b50b2d6806ab161f1696699ef3ecdf62554de394e310c2904e633f38095be962edda2ee0f50f33f87e9499be3a16b02462391f684789aa8a97c386bef2c065fec1ecb393aadae959e42b9fd1eeeea7d16082b92d8f2903a832489dcca6629aa7646db9d5aa243d81961ba4ddac54a9c9130736ef9ed9d8c6023ec2533bda09e158182df965a24a6fb3f0026f5d39ba883c4ec59a14c13d8c524519ebec8fa823010dc061a74612c03e40ad095ef2be6975146eb5a2c5082e39da9c84d6f3b9a99c2664fa6fd9955207d0fb70fa50c5ff719c95613fda9d6a0ad692afdae6f43edcb7559f2930092a77f7ddf9e6b7ab57eff385aae3e58d518de6074b00a5d7437b6b1c3a511e94b9e37bde42c4d2483796db6687aa9298656bcc4d75a11967c46070b41894b15beb5cd295647bf7199111a5d6cc3eaad534e5184f8e95108cc36a84e535999f055eab3b06aad3433750ab0d64ce6e5f9288a16e262e458c843926353e53c09a844b74faef027c98b218d450c08e6f1be9e55f1131e523d23503d490614b9aac6c582a8849c2b39f3a4cbce95e3afb152a0ef9d87c54ccb74ad5927f0d37894f0a48a99fc41affe2592fa0295b51d0730de40449d526ab8f306d6eb3f0cfcfcc770553fd61af431e11c4ba070d988896f4ccac9d82c7e3dbb59c1c8aa3c79b7e2aa33e5755fc5539c1bd47092937c1c1f81dce49ddfb3a4b3d203097756e5be692f303631d604d7fd075d847c69557a9ebcb116de74b0ca26a93d0ad530ceaa8290bcdf53c9e3026e23c2e4d7b38d979a7aae8537e029c29510039d81a17763a5c38753dfdf9d0cbbba495ed2ac9fc81c9c740ab1b28e262ae38d710ef42b4ff1db792f08898f9c630876e8997154f653d361b8618a610dcde102dc8043c33bd7f99ba1a9526a8b36a9dca02cd2e49c96b01f6a49a146636473706e8bf0a4f4c879ca95fee551a3127df1eb5a12ca83b5e1b536fda38e62f7a6c4ecddb48d1d17a5476dd2906c695d34224c1eef27ffafd58f9d9596ad765001f6639bf6ef3e495c1ccd1aef208633b5020db81475143a3e7a9419e94a7bae4e879dfe1e30aaf37162912566e4659b04ca19be173516156287a09c7a5de1da67c5410a99d209f2262307818b787ecf1515a54bf7aac15564ad62cfcb61cbb9f9119e58d30b8ec33bfd944b146ce93c3b924bb367cbf49ea4f713f5d3734de2a55759f2900ef6c42c89cf529c57fadc7230cab62328e13a9104c8ac8af7955324c2f18d156bd66c4575e0c8f711dc72ae2586a95029c700347420f752e34172f2f20190973003b8a556a50c3b2e9d2017f543cc8d199120184467cecdec29fa6c07b7f7d84302320ed9d133b402a7ef83ba2d9e9bd7d745255302a408736eba9235dfd198c50c7558474d51b0daf973acad600af089dcd0974a004a00a0a3d1bc72446cebbac14484282cbb94cd9e009d99e4e178a6773c5a7046450827353a83730f8f572d035ef1a0d84a301f8a8caaa0748a85b7460545340cbbdfa6926ba6114531a65654949b7232b8c17923eb26aafa2f078db7e82005c4207bf8404be75d38d0bb9bdfac33f2718eb5b5ad2889f1bfbc35e1018563a8eafc0c90bf804f381d564397debbcd7ae227cfe133023ed1b96783baae35a912b61e5eb2f74ad55db1cce2601b67a6b34c4e772fe00eae7e38a8f3b24d74b1644fa0b8e7c082f8553936655fdb5c713c137ef8f5fdbad63c1843dd5d69c45ab55b06954bebc5a045a1beb5275a51b05e4fa521bdaf24ca1e958c4a53b5a84c676d4d74efed4f619654e975de6689ace47fec7ac14140d8e8ab32604c737071bb934941b3ad49c299f43d4d671a3484ebaf5ab486148ee1065c94dd10a662571ebdc337c63dd7e3f9bbdb1fa136240048479897161049363cd62d7f085fa01987f9b05dda6747e0c734a60fcdd54d4e73b22ad75e1d1e781065055db9c119a1a0bfd7d995624c477267babb18f2321360b28079ab25b89ee6b04f5dbc073422c58ec12c45279cb3bc71ba4923b69a60ece001219a9c5bd3ffae91b24661f675e670feefe0fe26501c8976697d13ced92a7cde5f5e521e3c23f6d5fee3a39fd46729bcafc62f7d7708a5ada34b4f85d4e40633f7a68acba4931ef86348dbf87525295ec8768ed7d52162cb0f3a3db35c63bfb9a8ad21a0c945f707fa2fa6d88dd411f2593a15ce993c378df6b432cf1f4ee8ef67f57e743aa6dff751baecf17234f7ed83bc80f790c750f63626115db9b35a4d0e5d92bf56433c2550971116fc299f86ce6f553b09fde125aced7e7c1344830b606c9a42a60676834a8471b298d8b379a7c8cf3024d1e627ee3b8e7dfa60246ccce8a5e4ec83c8a641acf9ac2001ee3f80fa128f41bffef4dc41a6f969c8544c1e352a5f5742238d6f04305ae7198f6fc30c8f703a3ec9567e64812be0b66a5fa53d9a46deb391b013433fe1fccd81304e71acdfe41eae6606398efb4d2a7cd945199207feabe195401c0f89f40fb8905760d37d8f4b45944d67aafd105a4e81df3b7ef3fa3afead2bf19329079c680c3c9441441c18ea47e2b32fffb2c5b920fcf2e313b688a69f4ba568a7ee2a10e8a21daddfc2c974640704958ef68e290f9c34762131c4032e8fce5c5437f84cd91b47c2cb5e58d5a1a1c15f841d8238256d902ba96b0f0c67e5583831afff7647e3c3c5769e916b420dfe4aae2c07a7223faaa28fae364bd9fdd4266899cd6d5bb8c1660858a68142510db93122318d86eb33c62833ac3d82a22ecbcb333cc6a3d7ee688edb32a92243aa9efc1532914d51b1bc712eef4e11ae4140aebfdad6bc073692d3d123d81e7bc3a0d0ab8c0c5d0c39a5acf617d93cbc60fda97e630c827ad8cb4f38496b70dbaa9d2b20d34a214fc505f2dd1703549e146a9668675214b95b8ab37953d855721fa63c535c2a108fba4010020f956a6e5fd3880ec8285d2b69763aab6ea31907d8b7cbbabf91154029d755b7d9442b5523adc5742e1d0e26cbcd74e3690c50db279105550e7ff336a071f58166114af42b15ae3ff8fd57090572f15486a0fa3a53da3eb73695bb8fa502f74c0fd5ca1ab88198fb9939542b33db539d2aa0dfc30a403ad7bd87d8b8f9dc952cddf584a40b203c8f29ce5d9981ee389cd306b874e27751d826994ccbbf27436c3c05e9d1ce5aae8c1895d425f0dbf456bd213e226c38dadd08cd26e378180f7849ca9e1f0574ecb8575545e9c2806dcda1564b6a02f509dfeabf44946cc01b665811fdce62c1a01399b0acca99d053b141da18eba2430602c3c8d3f960ba6b241d5365120d56bf95f9258918e54bee46c846ccc26ed102a489ce31056095239ace37b078dab67bc7be5d9d00ece805c09874ac0727870a3500a51c1e688b8782e0fc65ba6641704cd6e5cf19d1c22882b69c55c02fda84e1d7a0d805c68e0f4148c235c3660439d5b131974da948cfc96b7e9d9fda3fa5b5dc9a52d884cb79543a516a0315e88e69978cd63de76770b1bfc67a5ab807bf2d1417e072e9a7a7ce6ff4da2e281cb7a5521fb59640617338059978f897408df0e5426f92a985a936f7146a1463f6510c8dadbd31f4fadf4cee0eca5e099843ec0c75f692f09b43d816eb6adcafb4d05cf620292ce5e290c099991222c0b8f9af65b881d866b4b7bcece310f734cf4c1bf7de8d178f3310bc4084c01a91118f5abd1ce0275a1c919a24bfff803f0fa694a6aa2107975d6d8f721e792335c30c97f11b2b370b3c88b010d98cb1ca26d4253be047529b64222b284cbf978aa3f1bf47444431219abe62b7c596bf1ae60e81e964a919b31d5a22af63884e5a5654f367982809198d984580e61cfcdb2e2ac4aa564e5e07da12e75cee8e07ef0a0c2dc393ef602e6b90b02ffff29baaebc8cc5b8249417e1bdb3f9f91c19e643e6cd63c0399f54338fd857fca02d855e8eb26c9b29a98cb9e24615632f5cf03a6be0b0226435da1b5cfd33a2f24a14bf30c95b68f22728df6f603436a376f727c76dd69552730e8037b82e796783d614855c4c86bf614a474537a08c3759d0fc95adfd07919e5cd0d6587f0df81c32a30223a36354f8504d29d9ea6eb744955a0ed131804b1086b5750d38d76bfc2042a4bc98c8234f0141175476487503b218569717b0ee6168c0df42ee862961c3d58b53ba45447241bead797c4f1a44a5e35f5eb0d9258ec6c3e1c6b9bb0b857586350c42857f5fa54473361c25d42d71146cc406d7fac6bedf3972f2056540bdee660d5126893905e26c1fc276b817ea1cae2261bfd260e466dfc0f6315df8bcf1d75ba11beadec780ee90186fa31f77ccee8add2fabe65c19c1ed607860f0ae25d6d0e01c78992a61c887f23846a3b30531b7ee0fb19fad9647965097747e14d3a383f93500aedac44c4c5ade0927fb0b26181d639a97df091d606de867baeae18418417518e4c4c1f729e3e9f9975af6bffc1cbfcae3d7b6299944713b8345909ca444aface717a844b919b81ee0eb6ee625ea304bc53712cd79f1ee9133e94f498887263588820f9934c1fa4976905a1ccb458c0923a8926b28ddfad445292fab0293ede09f664b70c44878d7057aa8caeeb943d29f0a50ebaeec29276ebc2425c4b725633f1517c222bdfd128e0f4ef9dd9fe6a461571723e84438b04f026cee9a48d9b34fdb4bc2d8618fd0393bb943aa9cc15a6b4bf6db3f4a6ff4559e0db574127447066bb09a893411c23321805722c2f654ce10fc3746b3f4e265d07a473df15c7a387c1e87e599e9342fdd1f1386d06b491c302abcb95ecb90d6c2372e916c53b25c9eaab575de058a5ec7680ec17aefae7cbd00ae867de7942631bc772e61b83f3f12affb7251ea17059a1aade97452605c2d7b4cd46221501dd49392ac9d2f06e6d57ff35401650fc81a69dfce42ef6a2b85113e99679d89b9074acae43950f14539c1c7d4cda5b82a45a58c7ee7dd74e14d78175007296704040c8c4e8a181a5df53edc6bab362142789ad844d1697c9baa4df3f140715e934eb50485332be15013d075cf193f140a3f306a5e09d24ec25ead8fddb8c5e13b3359a0b2864b06bb42e4525913cfe44cb12155164acf5298eab6323f13b163300feb9fdd840ca00dda61286257c4df30695bebb737ab873a338e5addfd53bc9ef51ccfa9b2e9f345379c9dde290e64b735ce0747c502715161a364561b3c504806e563973b8569e95c2b66fcb4a8e7ddd645b17a5b7cd2f0eb1cc8b8cd82dfe01cd0ede2ff924f95dd94a581d049321ccb1e6336bda788d2e8392bed3f1fe472587d4269f5a0112a75061787ffd876cb0080620bd168cde570d918b468d17c4cf1db9bfd0cfa7336bd3c264357ddefd48f61931b4fe64d166554bc15934b601ba7d1d06efeffc2d577a9516aa56955402ce43ef447224b6e17a98a2214df3a4c91ae59c447746b918bafe6c3b62329715bd7101b0ee09cef98c709a81f077ed00283a231a2c92180958b5cfeac9ee2b1b2c9fcd783df9b123cba44e8d9d529c8b1d4e509d13bea0316ad3c5f12bc6c11b920d4c0afbd1a97f7b0b3abd416b94ebc088c88375e3adf5bec716cbc07d958c67ce8d4ace4d59744187bb6757cf4bfef1da711d28792230a2ae0170d6abef92b8ce3340a8835917640387d03d927c8184c93ec384256cf7c5a369f5ad410b610848a0d813d1607afe89ee9c2224ebf0d84f44c07abcfec283a16be8e3bb5a04c6c01b0ada3a2a78316f492a6dcef391dac2f2355e24ba353ffe1d8233be794034f3ee0e2db36e9830e6936c92685851a80d16765af7b84cfddcd137f415f71b9a96b0f84fc959fb2716f0d75b7c28950a361114e7dcf98abf070e6605e35d2fcdfc8b466468b82e9c788ac468526dbe6e3c60d67e5edefcf44551babfbce9b2a548f18e5b095ad1fcbef27338e065dc62118526570228ca4494f18ad96d8cd57385ce9b73e694f8921be3ca25e8cf46b750527ada82f8c781cb058beec95436a9bdf531d4ab1ccb93018307fd7206254e8d177e7c67b3acb03bd19470697599e90fcdc1970911fad5647ff2aeb5eef6c80766253293f81259cc8465cacac4a499691628a46d58f13c983a95f4ba92ad5838ba185e90e45207cb8d62bc9a3706747887fceb7587b5fb36dc0b83777fd3c194a39b1361ecea4e391fb15b9fe91bac99802fe462889ee33f4908905b9f3d42f4686689d20551916e3a820b5e0e422ed21e76733d1b259e7e1125d6c0fb7d367b862fa8f7832cf696c5baff4a85c6656395268834a1e025963c3faf53395e2f031ad7387643452903a199a2f8e39ce7f00446c970b77b75f9e2b8e0b12d28257d372fbd9cdbb8d8f9b4dcb960eac393ea982f7463b886c592e5931ffe01feb20f316b1a4c8bbb0bb14ebc1439cd2a8996bbeceb4bad4f068751985a513562ce91a08fe24b56f649b420fa307727ae56115b9cdeb1235eec80b7f28e8991875b8577cd2cd77a3317d45d947e44eeb062c81cace14884173f7f946e36a6c9f72c11c066178aad7d7a25a666b2a39213b68d616ac475e107d7aa5704357af0e23110f86d6978a1611f957da88d2553da69e317fc2becfbeecceb100b1ba1d8ece8ea11e20c38fb4f898e925a1607c31a2c627206b24f3aa49dffe32f4ac32513af86f542383409d0609b2074ba535101b1618d18876c5107fb5433a96b7b1fc6e4026144b2320f3003038524b35f560cadd34d3cf55683526e8bcda7e05c3112632b1178f99b7c6ebf4151c4d0c126f675d04381738f3bed386a952c5f49e26e2da6e1f621e6087a63507853f904c5d26828359fd9f28b12b585fadb1219425fb557129f7eb3ea1225e9e11a410a2685b0d987b89e8bf905c5e24d83d948d07af29338cb1330efa3d024d27cb8d548023d9ed9c6650d49aa07c27cf5e9f9dee1a9224d5a4207f0896566e64b83b61f6af7d22cf81ae59aa9686f94468a7f94ef069b80dfa0bcdce870f2202dd88b1e582610577db6dc2254aadc23078128828f114e6ec8509c29613ac161fe6ac4a75c8e99f17c2db4186c65a56067080f8f37a8f4593f6c3b2c9c39cf512ec510dd66e7ad2f2fe8f945701dab96b4869460be0de6d39f5ea9c6e7d23c2306a043f2c0fd6ac6f4ce32d6a9b0692a6cdb93f9072ca389d1f59bd3d5a6d6632cd4c32c1c504ed9f96e8ae0b6637ca027660b9daadfea99edecce51e0858a071f7c22d2ab685762c38585ad9f2349091808f0a01fe777e20ee0fe0b24abfc9ac3cd55ef1ab0daa49e9ea5d83eaa348b819790f38d9efc23ccf4f8f9a8bb5639274a4c134952de09f91c068994b197df93b8c04147bd32ab317193df8fc3caf51f7ebdac5168f8d313d69b5b8471e1d8f3f8d9d8d59f78a9028264317c7a349f90a44ea21ffd613d5fd8e198cc4d445ecf21a03a75ad433ee02b427af5aac6e820571363749d743acc2901c51083fb6b16b12c415fcb9f2cf4a9d0323a1b826c9bce8fbe9922f39f62fd49d6c9d99e634372bdd7977025bf4c4a331464edfa74981fa89cfdbc04d48877c85e1c6be8b9c0e7564634d868b2b2b4d65890fb535b8788dd147e197458337c80c887698fda110e5f335b838b14c83ff9fc924631ec03b31ea6c75e4cb180700302d9c1826068abea1f0345e6069e08c96736275c997d9f70af7fb50d5667327310362bbaca7cd49576185992257e5b56f8610b6060b0eb20f7cc7b21e6b8ae78845d41730e39455c2beb3ddc62d3024d216d484c9ee054f895e6808693b5f505ac0fe360d5a162ff791a50beda91caee4e3ff3f7d2a16d3248987c6ae37369678ff8a6368572549be061f869fbbfcdc1fa91768cfe812ead341332b919a96d97a9701e90a674e2e561b82489cfdb5d34e64346eb55ced3fb5cae52484f803586d84c7f3f4dfd76fccfb45c9dcd07a3baa24898bab89d14aa8785b3f5d50a62bd477b4bce9531ad7c96551aa0b7e1fdcc19ff83bfe6974220a8e75df68c58db2b19772846fe1d6f80e32de1e05408728c0fb39036146562a4ab221d49ba2152c8df2e5f9779a3a77a3daeb820c928d3edc66341026dfdeacb990eca7ab31382c097e12f4ba98539675103ddeb65fb36b89a5594b07d57af3495ea28b26995b8cd36c2125128c683753c20392554df7082d9e16e1c494e78abd1ceb983509dd0030d771ce29c1eaa874b2f8901ad61404b9e16cd419e30f1c2e5720cea679a8c4466b3edbf5cb41413ead4d3af4fa9dca03dd60e3b6113591ec38cd484e913fdcfebc9d86698b58695964765bce1a85a8df6527d7275def8d1c3f6f479caa21123419bbb71588cbc8fa453daddbda3171133a0aa8d1793d24166a9f1423d7223a6301b3f98884eefdb17c63e6a6ef66b0bd8ea57d3b9eaaf0b651ef37da719a886ed09bd32c816e68d80c5274c7a1c90d559b358c5acda501dfb71c136f7de3292cb71d1000b1f5d9c7324d57b9d74bbace7f7fcf9c7544e0d079d41b49b779af7071c957f0deff586c0fac340f4d9506739320319230517b18c1f221c7ddf95d48cf397fa15b8e9fd357e4561c0e1a4884be015d72ac7e178a5dd79e8ff9e6fc3b397c4c234bd5229cd9a6c574763f3a1964f5cbce5211836880eea99da02589ed2b7628fd2564708ccfac0a20a052cc30ab81d83c20375567bafc20879b3cef574ada752317c318c2e3072de4342585c74ae6416ca1f77726ff3f928ff3b42a5da1695b1d61249a1b40f7a0c14996684eabb204c9e05e49844cb4b53aced27c50297bccc00a2ffc4d73fbdf4600599b46feebd84e8367e2bd4fe2fdd0936d74f21240e9a0387786c9caa2f7c288fea7d52cc69ab948c072313bc49da40178dcf273a86816e28fa01808b4ec73b40c96d2e76b22bc80cca5e5fd68baaea12474a728fcd5d65620f7748a9cea7271bb891482c852274e4ed5ff65602194f5e6bde091ad38ef5efc4d7deb3f4ec91fa6c5055037dc8e89b8d414e2f36fa19ff2feb26482990313f25f323bce57f722481f273d3cd921583a95c71c249fea6fea9c864e161ee519a8daba5144a349af9b211883e87365d065a6f612d4ba03f7128c8550e8a8ddfff468c23b8f07448bae215ec050eb48a3335c8d5a851b5ead4e446e2224e0d3e5145da42aa2446f72a60e1f3d7bcb53dc17dafb197f91344bbe3ffcf8d6a45d45507f0dbcd0323a6ea4baa0874d9ccb1a84183a9afe7a9463789b716cd6471a0ada952fcd8b244827548fbd2e7734e6dfb1a3924926b006312ae9f963a3e44144df63e3012958607c77e3d4f309fbf4d428c7822a80d8f6f06198d8ecb099af416e5f7bb3fc4a636f7302ef1ed49bd8bf656c0513812bbf4a1a07d171e98c2f1a0a3c9fa5ae48cc68666219ad1875cc2fece2aa5ebf02ff05c800e464fa3c8ff484624c66f513f47b1db282e688f6b8addb7a7582f4957ceb4f6f62773101232b0efb45ac3e7d6f85a0e3409b5fb2cff1441c830cdbc79da117cb7c2f0e7886c9534b94954c7488c9cc6c33a905bd3649ee956d36bdc621ad23e16d4b9d414ced9042d4554af9ca9a96c5a436e09b8d30a645a2d32e6b79f8c9067a7dfc8ebdbdc3c9b47d1d4ae58359df9f3377414a0c62920618c62f7606af12d120d408fe2ad13488fd5084c138b74f0c243caa251bc4b8de4b1a9faddd742e3ed94ec9155868c25c6ad6856ce97c3ea50ff518fb3f67b88531eed75aa9a76886faa77f4525bcabd6ebc4075bd888c6a5877e3c7010f5aa87eb21fe3f5008fdf79ca1bdf15a9550ec8db15b46bca13ac5a84ccb5f931094592711439a5e141fab48ea44a4a14782383d8ce9ed9145039cc2e67f63b2be11e4f73e4cd391e99f57e40261fe5d496dba1d101c10d878a0787d4fa1d5e2f0582bee7255ae413b97c725f0665fc1a4099666211c1b05e616373800ac6b567545bae94b8efaf8a7c3343956de0ec7d5620f8c8b967b939485582f8a2ca425cefca5088443e9b90818ce0f47c00eaeecea82368dedb4ca289d408b37f3c07e299f461004a4b18a920bd959df87456bd4c873a473a5dc1e58b262ad0e6b7c078498444fde69038d05b5c0e64c6595421250ad370afc1e1fc0cf8070c66d8a206354a19c80017e3be932879119bae04c0c70e789306bc587af5d016dd52172f89f085a8d76248f657ce93379013776b85c84fdf2f50f67bd5679ee8a5a0b33551b19aafb14353b888011cc6d9455b0f98aebb0ce37eb34c4a8c75f00c7c4d5f691fb83d032375f10a6f1998eee87c12d281f2880be673ec9603e56cd9febeb1c502e958d7f9080c34b84b55efed034c424e168eaec347ed5efd18dfb7d4775fb0d6cbbdd7991e26246608954a81bf5874ac174e52db78571d41d69babcca6740ad0279457ab8110ef5dbf6dc8410a3efe80a1e7960a75a65672ee408a7ed62ca1218d550ef76d9dba9b17e5e603974db5045525cbdf75b6da937af2225c1b262ddfafcaedf73bd56077a879a34ec5df993784ba069a4daaece36e90010f51fdae16a6e09207bbb9a05a709d31dd2350a40d07887d29212e2b71bf7cd5ea6e495193590c2593353d9f36d9cf7ef14d9c6e4df04536c0c4491b5d026da8597d41c83dda4ca495ed9d33bbaba2e3104034b822bd004ad08b7dd0fb469c9c314592b67685822fb8de1db91e6ba6268fa1c5ace9bbfbcc1c4433d4c214f3b84a1a5d60f6118f9f2becad604c7c04ebc3c2e63439d1fa26069d814899b3bec9df03e9028cf64d5e1b33511e2fd958241f15b88dab1064db97292034b56e6d1bec2835ba96c3ab0f8c568b6a850b06e977ddc0a6886ba543dfb90866a8d2a412a72d3e75d4e83bdd1c563e5f7b298be3b00fada3efb3def802f7886d92fb309f47c197095c87deb7a0940cf4bafaf21555ac2cf70e97a7fc29ba846b99902539be2e9cd9a6818d6a8f8c2a9de81b5c8b232c326e9172bdcab2739f116b80c4840c6ddeb60c3eabc64f068516b3b1e2baf8141a2462775e5c4e468c8b6e15ab6864ea0c4e4e1271f560e664f1b06192ae06f574afc97d3b1a54223a8ed5d2c20b7f86939ed32d755c4e0364dbd153c95f75d19b18cc7300ebf0393f6604384838378980e78d547175d91a9c4fd18d068784a330cd85822c3cf761eee38a01a66b92a5bd743c365bd95a2e897669590bd175410f29b46b42e865c3db8c9d0b86c3056f64692e0219177fd05d57c2a3ed8e689578e918f7d2e1ce6cb807d49ee950a1f5aef07b84b1b65ab0c256396821c5a73754f9f3754c1504f62d578b233c5bbd892124118c7fd5c49baecfc35f1cd1cdd5e3cfa10a3c167a0c8ba0a599144d41087008b700315a8e6209fbaceec5f0147d480a51aea3a5c8db990fcace25c6c99b3df36b7621602227b73d0b4b4773e0741665d40b77f58e7570787f3062a6edd39004793f165b7ad8f3c08d5f4e36ac742d8a3c5e2d639f01dcb036e3a95dd8c3b54aceba96dd491c11adada2efe676059f35729b207c17193d59acd86da49480e2a84b2a4e8b33a7525c5e5e2bf20b4b4dd4cb1863a6c2c7d9a3acb8ee2ca7049049f6486096a80035c7466e06115dabd04db3a202ec4723384504776f91f73337ed815afa997004af6a5fa72d4e11edf831e89faf50060c2813af0ebb6c3d32efd8ea05646d60186b71ea0c82e5ccdc97f93297774bd3ed4ab758cc989903489331ff8493dc6cc0ccb3c1b6877789607a80b249fa85dc67373cf90cf06c104dd78aa89f2a40d93d3859d0edaaf0af71590778c0e98c0a40949ee83f692d74cd6a2a2a609c3ca52607041ee5e67b63557cfcd3af34a8b00ad862eb0bc92b922fb4eb7e64726942a6f31773908c7092bb0c3a09155b241ec5202d26867183225d2b6bc0eed82d5ad6113ec78df7fcc3d218b3f37eb41fa6c9b8d27be0eb9e9c52034c53dcce0655abfbda70eeaa5102653f8679e724b4a20ff9f5118f34d771de816f610fdcf905056aa851a16b6897ea2fa3b2b5ff71abb2914f76186c53653311db2f6c17aa814001204f483c6f9ccb14ad6c943d6a8c6b9dbcbfb15f98af21c13c14c9ddb72773e1d041aad8673cdc7b95afa28299a0c85ba08bb8355a537a93226074e5d42197ccbe1a1a4425d6a1ee22e137f0a29984b9490aedbeb62d9c81083b0e5dc26eb4981671b6726dd07091123ee0cb35a41819a64a113dff3b73d399ba4b05e437c9c04f7987b31362f200caf803d8a77e05cab6e2acbedcadd28dfd260fb4b51d485c952305785c588248c9de57c373815e033f4c365f9b146175a96275182801524be26c548faa6ffdb35b34a4606f07d9edadb7b739c6de06cfed22092bd327861875a653559aede3e6cef6068a44708d374e4b036f1b5d08e2d32bfa5d9759cc374d2de6b06e0778c5ded00bbc8056ae6336c412c3f134fc611828fe53dd58772acd05678ffce9004628661f39595a1ab1fdec53fe5c640353176c7cdfe44b469825db4a2d89a9448a233bff24f977168f8df1e681a1132eadad7486f85a5780f8ad576f8576402ae43a61fa1b507d1030d731528e478c1a652f499c57f9bbdf93e6071b10b2d7584a36f2b7fe644be2b78cc00632e0e9b985b763d395b1442799aa9ac7a7358cafc96fb66d380b2e62f9f125bd3d47974a757d04d9df12fd06f2e5afead0c9fda43948bd1c3d4515c24d1a866c7659c30ba9cb65cdfc1363016b13d0dbca0cbeaafc3e31d3e5abd16cfe4b9596b87591e74c415282a00e6f7f486b69c1ea9c6a900cfd042e5ec0d148f853788a6f830dd5889d36be040eadeeee2f7d6b468d5325f68ca5745a68ab1331f45170323b8202fa555576365e24cf161d94000bb13294ac6c5fa75c62ad33a4557af28269393ddc4cd0f013a00042524e01755944b3663e66ca72b6ad4756909f1408c96d3ee5fd37f972803ea0747171d2ce0649a0e204e8966f1858eccd60b44e5f5df55e420fd44913f04a6e89d3c238d869c234493bf1c849836f97f425e734e0b4c73ace034b101576ddf59e05421ae5a992923147235c1690253e232fa6c3320773558ac55dc94c57b61471aa12d934d7cb96b18b6187592160df2aa498a13498d5da2634cd260d57dd2ecd9dc935d47e66dc02da7eed09bfcc8544b355a69a342141bb60c337e6748e7f20cc5da355134a75006654abea531eb223177bdfb9cc203ee0db199f5f87b09c46d4cbaf36d207581cdc057ddeff3831a3b52ba4e82a174078fe40268094f53f1ab42a35d20cdcde25aef961c4b735aadd3986b977279e2c92ad370c9ee56008348af46d9f960bc8be8fe904d83fd76fad7a4a432a173b16be747db77e729f54af1da3a3ea82d03f4b844a4b7367b38c5380e0f1415c75c81633c5828f1f794ef9ba53e843006d9a5b7216434ee2c4603f4a687b047c0227f190dbb8ab143ccdb166bbd476ac320d18227c7c00eaa6219fcaba3305c8a1ef941a9ace72ec7adf5cb8434943f8495063b876f8c6ba5dcae12da8252f19a4853d170012d061cd96160734c2e076b45f4e602d7905f686b3b68a45680b8508b34d3bc770a854c0354aa8f7b739ab8dc9c0fa90343e154be41d6407c3de972323922282be5bdc9f81a8e9772a126b308d2eb9634340cb1f87bf9ede867964ec424331a5d185cc769b2c850dcfbd499584664face861be151a41f95c4d2d714f9de75661ee7bdd1874fd4c2a76d97ebfb6da7550560fa93afd6fcbc7706c299a02ad2c246696302eb50ef2a8607363266b19477ba5a9cfe02528594050d754fcd077ce241c2686fe08fac8c6a21da9433895c967d3464be6cadb7870c6d5a286eac1e5e2bc6e1db9d7f7c5ed403a2d639a31fd41769a9510d0123c3714e0168241a45c15ff7ae8f81f58d1c6256ef048caf06a7a8667885df56bb415b7323e868333a848f486aeba49d9d106acd28aae5344b9c3d9177c66bfb75c1ab4e17a9ad8bb94171fb9bab0b650502a4690c6c019fa7ac7ff9ce02413b6132999a7d87570694b9a3e84fd84ebd3df476d812099b7a6b0f6095e19e27439126cac518d0396abfe1fa8189ed6649d92fe9986cf80a017a66b1854f697542e961c0949db14c0c9d606a04935c8394877f19b60a0b28650aa988ba8f962e8c51e2999f7405a375471b2956dfcbaeaea60549ab51da4da7bbb34c1cfeb53166db10519414844fe0fd5ad50aae3b88b4004e7d6868e086effb5cc7ed684f1b103c9fb9830eb76707efcabf57b3b7af4e70dfd0af9abd720e7e8e8b2e25b3126eda0b7544bbb8bae132d537653a1ed4df99ce29a623f4dc2eaa9ec48a80aeff5dc7f5efa969c68353f804dc71b84b419e3a69418bb3744fe288d1a452bc60974b9aeb57901dbb9ef31c85aa956c65df7f16ca560a3b349111d2bbfd42e1e0c6163caebeb12c0ffe5e7db0bd80028397a05b60135e107c324d2eee6f22a4e41cb5ec8b9ccc370b76921743dc1ab3118858456597da0a157c7347816ab9f83b7b2823a3531980d86b3bc606a168357af2f356c3d132d0ea23fd8e0bfd3e2189c02feaf7a5ed5c9c2d0056b2e24537f0daddaab2d52c77a18325db94f130bb0b0beed3654e0a071b11056e076c8e012bca4d7d5fb3c76b6042468788beb13a0e97afdca4b71c260da280c13fca3788ce97e2c8ab056bffc36a2c1f64df086b200f7a586c3f68f4106cc29a7f821826071bdbf3088ad98d6bf3a9889867625f5d83ca33128fdacd2a8e88ae4f44ae7b63e9471937878426368ad8526a9f0564ba7d692a114af933a9715bbc06d392666326a8742855f6f238cf6ee669cb449fcecc31fdf92a053b0f386fbee0f1dedb1fe659979bec7265ea218e587e7a60599036ca313c2e18450d7f3661f9f8044993b7d1ab4a2a5ee44da1c8085579da1c8b715192ce9f144ac89342c4bc60b03f044e2fab647d2517230dc7e9ea08788ecdf291f6b941380ae90d4567078bba2b8c23920e50352687a6de1043714f506b20a5d369676d3a5c2c0bd6fb7f241439b5d8a2d1591f62148f930408e8a8dca82d896d08293ea0175275cb67cab63b1d1b150eb9ded2a50b52d3f64a21ee8caa49540f9cdbac624179433ee300711e58765487487a39eff244e332fef807c20bdd799a4789611334d59be80e894e2147ee6ee90a573b34452df55294ed3e9bd108fbc06c8a508002554b0d76780c037e263a1064d288d7498653ad70361a37b4f3348baefa31f69e3425960c701974e9b709c60e9969a0f2ff14cfa9d25b6ec4787da2f8cabeccf5cc5bf3eca591cf426aae5002b063bd6619ac4ad191dac503e8d892c4851af9518bc7300df60b00625f5e9636fbfcb3d2e3ac78356a6eb0760e5ea97e7855b9aea5db6ffff82baa939eab38c5bf01bbc8b9a02e5aa48e4f166b2f98f5c6e42132dd82d3ca419e58cd0735ea59459e798eb002872fd69e00344845f3936f6500d17f9a3f7234573bdf0934f68d9263903e312646e9542570f1382d26f4c2e26e0c85e0252c1e1b31bbe885652eaeaa583be9b0e959c1942878fa2e4e5f8fc2491ebc188182842a3c2cd512dde380f916a2c80b26ca3d9dacd12023c4415a3f144f56cab861dac52e865f834cc576e750b8b29b82e19d30df2e65b091e0aaf22006542b1aa934b470f23680c5c9a14e7899a41cc205c37d931ed78ea10ab0192f50080122478f6453310d425d05e03dff03161feccf5694f4205165ec72c9907119cb9ec015eb3549c79ca42e9ecd40437f461cc556532fe0bab314afacfdb98e3eda7ebfe6b71f8e092c5d4bdf0c8eef7c21f2e1865e83c601b6b44b8cfa0d3c6693880ee834c7f5b017ce08fc9564345e3ca1e36c73dbb14fc1c9b17ae992395c39ce9c2ac8765b539067ddae6c5588cf7fe72299d2ee588ea6d86121b02a51278b1cb99d59b31de10e73a315e3b3dc07a3f848c944e9b671c06d96c2f3c5ea7dac0d6527dbde0a06252667ef6d56e50b83ea8789f7d77739d455eb2930d883a3e093785e2cb2705143c4368712fbb452713d4a9bc2f22ae76640bd4f5cca2a8e81517ea386bcaec7a958d010c34407b8661fbcd3065bfa2060984068c8e1d4202e5b444f290036e302b88c233e9445b15be567d7570861b4f7e216759a6b4f82cb1bcdfb201bf9521f17b943b7c387950a931891701825d314ab2bb27767c841887253247f72902db2708de0e81f6885ac4d3aecf632e22562f9042cf135e401940f52ab5a10bd1cbbf6fb14329abada49ea962a2f926ec6d9aa73b9158b8620382309c18d7d1d0a8fcdb6c56684695f13be35c96e38bf3ec2faa5d42761f00c9a498d24a7020b2ce57d3f68468c87379e60e3eb5d5a6560f07ac130d10c18a0eabdbb08f0120925cbe9fc4ff4f9386cfd25ba74bcab582484baf4945d9aacde0c651b1b2aa05807f65c076a2f3b7b2d9a617a4dfdf339b499ade115599b12b8a7d8212c55d932a40f498cf869e10476a98a26a13810461227feccb41f08bc1557b79ae98ff6666f13c4905aa9b2874ab477dbc0b1ec2cc4294ebdb25afa8bb24d013d245d451934c773ded0a488f237208164507f6d1fbcd6c2aae170220a046344e0a1e2b3635b8eaae4ff50c2c5f34951831b79aff0cf7dff75b6e87fea066b2257723f6be79e5e7a7193a41c05f008f8c293c6157b79fc058fb801ab1333d6cacf0113a1c8f76faca2649c0edd6ab3fd91e4cb61379cca2f6c0b37de5d400e3dfb302342a6a50f1fc3647ca499e98755c319a4a13e5548dac76a6926e45c1f5b2fb3a7b66178c9a04dfd280896a9db23b86467bf12f0de9fa504d66bd7988ad98b53674cd199767253606af179303e9db76d8251edfc35e635bc8d258bc7441bf91534b05e74b6aaa21fb37c0b7115ed08342a08dfbf1017810d33f62ef1450614c11c34f7c6046d70d5530f84804967f5d810e5a5996ffcce2784f634559d1cd32348e91530b7d785bc099f9bc66d30984dab472bafbcc8694e64beea6bd60d703f91088842122137308615bf7b1f51a4870e82a60858bdfe1d2224d923e2f9bade027c21b95d8ed54922ec9a844e2b6fc3c90ec92380ab9ca88a908eaebe439b5b62aa5d34ddb0925112cb4f1144bd9178c40fd9c2d2340ae8b6f8bf25697194d98be1a18cd4def65167bcb644fe9664e4f2746e0001d1841c34f357fab327443f8018ab95a059107b2209ab27ac1c239190410b46471bcc9a4c7c0d3a69b615073a63c887e61fa42ee8f21ec8470aa7346df045dd103d3e208199d2f4297a8c15ca80d924ae46191fa6577df50329fed584123843d93f1a814b16df927a4f9647bdeb04375168948669ee03bb10ce11ddc56214c7a9c5f2b072fb232596af9acafdc75a9307df48fd2907a94486525806f36f009d087151014c4d7e16aa1fa7ae6dd8ddc28fffa4fbaf9430c48b8ee1a44b9cc7dd88ee8c42feb5e52abc71ca8b9ee018a24668868bfae34500963f9238f23598f4353f440d79eead2d835cc5ff239e536b2884cc268d5707d35d5933841f5e78c37692aa8588d5c5371f134e6c1e6522cab82ead3522496a395be6202504f300fd445159051fa09bf9f83b3e0f6a401223e0bbb1f810a7416304bc0fa784372efbbe6d233bd0f1479d19f1a6758d037c3bb89aec450f546c6330fb495e52fa474ad6590f66f06bfb77bd4132251518285edc98eb1ecc993ddef6b5d9442120841e576426eec19b7de2b26fdb12785fb30a15fca7b8be39c11489841309686e5150180d2303681c165ce2fd6a95ad29236807b90813c9bd9c7cf96fb58431e8bfd09f0749663e8bfaef30eae696ef7516c23a9522ada47c145d706d5f9facd9f7ffd931574756a2e9cee292993f4379da147e1b0f6e1469152e45a7188d7945f2a9806c48f70f538bce90598e4f433617f1fbcd11581a3661164b5714a0d974c3df69bd51aa8ab35e14691014bd024ea9680a9b37a012ddbd5ad81f14715dace8c22c631cd88965bf8ee682394996a4573f9252b01d72d030607cc22bd96f7b3a6aa3c4ebfaac67dce83817f122e68fe791fa395a769208e2042b36858d9c82e390de0ab0363df098d3412dff5255bad77b006cd5297f34e02c27bf9356eafb3ebf2d762e25be3e8e03323c65a63db4d9f13fd9457835be537853ce903d5b3765461bdff9ef10c325beab4f88a84b6785488976e2e4bda515830ccbbf950750b5ce91fcc6bb4c1ed98f01775e84250b2b690f2fe258277361802d87170dcdb787356eaa4b9df06978990077696ce525204f5d14728ad33c9b4f3f0436334d347feb23e36e7dc57ef70b539387b5fecd8b2b6609205aefdc390aaf6e82116b0577c32c827b680f0103687941f588b469593c0cd9f777a097cea1fa790e1332609bfd8f8f1ec61395bb1bbe05601e5e2e66d1e98154414812c96c1bbe7920aaf776531b010339e23f8da4f78bd44794c66341709a83b506eaac6c1038a1a9871d089b1faa8dcfef39dfd52dcd6eed2f0ceb3ef5803a3aa574590341d1b195ef0bd969016c302a4d2671c9c3a433ae4116a5b1823233cf2e8febd53db9496409e31e7e6d90948b52f30b2f3e13d67326178650e9cc8fc3c847ec087017aa37933e068563e3555ea8a1b05502d01c2f34d5728328ff9f031e0e59c22b3929589bc34184e4f27ea61ffe2a61d2dfabe489d3c05ba46fe18c1f13fc17bc9d976789c2e7db27e08711c6c4a5b9119b7be7f9f53d2c2dfc34a25005bc29c10c80083946f0cb5d782025cc3a7e80b96450b8cdc8a141f1a60cbe1bd139309e4101a0b24786438a171e516ad672bc7889dd91af05aa6a7232369b52325aa19a8780b25118761880e89a0a16d1825d658a9343b20d2d8440ed4b7d11a8ab26f7289d3e977a4ed0794c9e07dde6fe05abf7f7180e1ed87e5042efb3b75cf66a5adc79960c2203c44b6e0af265e12cf985f5adeb862acbb075ddad1ee004666423935e9f7476d567309fe663696445ccea36cca9a8b1195399137b533e084dc9a0ece0b61f313612c311115c30d0defecaebde6d60585987a3acbd360cf2a647a2c1648d574e68287156bab616e06bb3c4bb1b4a19a9c42bd74261e83a2ea8f0cb18e6c797294ef068133f7f16351053aa442185c855460d737f277e6c92f437071a93452b790ec86beb5d59caa69373f5e9a781ce86adc8707aa4f19c276442e68211e600687270e497da3d3e42fc9e29546274be01265be3980325d7dd85ef9698f7e117eee1d935ad445107ac5a95737d6ae39178ede85860ccbdf88a72617729376550bc3ad3c94da8daf2a8d5664009b45b8bebc3a70288b6edf50b34c47b356a13a535f8932b1ccf34dd9b577117ab0fa54b7a46b1f1644590cb594c89e52db486494c62b1779ca2d4a8331a79a0f0ef6c70fac65a5836b09ea15697e2792fc068d2308163522ff75fb5e96e601d360f7c042271c45ba84247b866eaf1775b25062c6e26825ef465e5d09f8253dc5317346c4c57411a93e19a1782745e55c2209f3b165d4dd827826e2b9b0693418d80945dce8ba4370db0555aa1b008d1823d3c3366840b6d3f1ff4b68094bd7b4c9e193aec0805f6afd49c313e084ddf039ac412bda4dd34b3fbd2eeee47238caf7ff0db1c2472a951c218b8559b6c7a62a03867303c4feed445f75445b94875106099e5e6a2cb9fd95840fdcd8f63b9776257e12f1d49b41bce93c01ff92369325b3de3e648443de74b3d597422219968146005dc114a88866fcdbd1f20c02fe0ec4673c5a990fe1794aab2dcfc58d6710313603edc494a1056c42b3719c2d60dfe2642216bd01be40203a30e01dd312f5d36cbce8525fa52dedbb87ef710d3d6f6f190948a73eb39b0d70c3e579c8e2e7ecb8f9bdb62ff207f8059400c43900a2fb454f0ff90ec313cecd44911fa5924245fef8df4c95a4b53d859663f16e368cb823ff13c9df22722d626985f724e4fc2c2fc15ea36730c44d0d89944221e2fc866c3ae1fb03d41d42971714e3cda4d397fd1f9cd5b8b715543b65060f9dcfa4573d573b8f5b8ecf9104c6218b05d8b2e643d9cd961869951b04571016a7f1f3940ecb7d02a46a24950a016a457843bbc7ea42f89f6b8cb987c419883f9cd3ec17a0f88264945cfdead1558aa16f5896f8b96fa5f32e01b9d978c09fe0a8a7b081068a164bb5a89002759f42c04a1dc3a5d4051f11c0c08438bd810b44e8420a92a9e367a290f355d22f922c553cfc2679cec102a1442f72cfb674c88f62d85a28b034095013a6e45cc935897f6407aa46a836fdbea798b4accd774c2952167275c14d73acb504ee0660a1099a61c996774613578aa450a2142785f8251cf35bfeff82b95f2b360ac1ca6c19df4800b6e17367efff7b9f55674a437fddc3f2f98ecc71c7651e6b2d68870346718f79665da9ba8f799b3bf3757f10a2877f600f6250efb111b3a560f4ff2f461af39e058df1fe17167ae66f5ce1e8a1fbb825147fd47a612ae0f9233ff07a7ecb1f0adad2e28abe68a9960a20bdf8370e8d71b87376a6b6e136fcca7737fd91441da7e8af7c5cfee9c5ede57189ea26421aff7074e04c85a7d7b1777c450e53817ab552988729caa0e73fc09333f7e28b315ccd8a607b43eb1915b3b9fd199f76aab5500e99705036ab20f787fc0ea94cc9757a9234433e3058ebd3fc69608a82a8e23e124a8228b6d16d9b26f7d16d03f24b64aa10806e92f65446ff035ac9e35e81d028a7606e78d722ed10ddb610b5d2e397c8e8fb9fb6a18aefc2d8eb815333327012db8c719d1395def16d92f1452ce932c152d06e73070c3c0a9e216f0bfd2ad66420e3622432947a3b5ffd0d08d0ef0b091c54df908dadd435ea39e1c258c9d06d2b252c58fa03f0614301c30b2622ff52ba6c8356793bb99505289b8677481f6f19efdda75475b001aa9d10b43516b08d8ced5a32fbb4775879cd809c5fd4a666537de434c4257fc2a794d43c9803f486bd68ebda544407175061d821ab463d7daa9ea84a3bffa8125d972e0877f4757375a2c4b3c26eb2b11fce47c006ee33415da134f6ad75c9401c2c1861af4d1fc460293e1feecc6a4e137bb96ba35a34fe37ca34bf37029b2b7989e3d4fd79cbca66bbfce7e5ef7e7958e4e71509d5375eeef02969430b324fe143805bf44dfc88e2f719deea05cfb5f8e02ea377612cfff427ebbe432a6ba5f8ae19b15ddeffcc61109cc9e692b04b0a84f42fe5a3983cab2d8abca7fa9bdf68a7fbada562193feafae91ffce1daadc17018afd373c166370a96917ef694f0038212c47bc0546ebd94ac5b75de06abac5e8ab20df28672c81c21934ad57d2e32c8571dc21011a6f93969e2737f2178ea764852fc271e2f1fae7531c623574a4fbe5e195a6703eff660a3afae3d71044e18f88f6a0857bb820d242987ea5c284ff1b181ca1bafc7f9e0ceca8ad116057166381e355ccfb0dabed56c2eec8fd6bdb413be202e55cd37583ae92ad6bcf753d0fa8394f470c30bc51274443468fabf5dd0246daef6d4f82765e9ff50facd6e719728c5115f4454ebbca9ff3e9ac753927e8a82d2d08523de71e8649813ebbf2b15f1914121dc8119abd2ebc42b6989fc049f0171fd50a229c72b349483cdcd4b790d16f1c04bfff607d6f2b0a02af66f550193b3899a39ac6aa59536798fba066065237945bebc671092c4c9b21fb29518dc7438bbb401b0bd36941dde04376bbe954147f86ed43b21ce96f437d557b42830dd75ec9289b4e639ec1335abee780bff65d71ca4b6d6d36b8950737014d6855865b93d68877fe831dbf2e698db4bf24f2baef06eedaa0ee4fe43c71e4a22df5a4d96a9af9ec9d6cdac8d03c6519488b897f907b901de14854501329a7a360b30e59d6a825a280074d27c4e4982e00b74f30b8c5f5c21e015d362b519eb36929a962b0b14838be1ebdbafffbc09ba3b7d52f46f6f2eb0302ad62d2ffa900d418481a64e07b72cdd718e903dbbc3792d693720d12dfb79c31ba49021e85c6d0586348313bde215df9878814104582a59c313167817bf83243162405087205b080630e9df986ddb1441d3c3a6d3801549f41a73e037119b234c57326e8e6c37b270cd7d67927e03c12a18dd3df15212c69a95c45fd5e127599771a4f3e756f90b0f9e9c475fbe8ab53d62032f2c0b2dc241251fcd72217042f13b45ac87dd1d68a9e9b7a447791beaf68714783b0719535908ff6125932b6e28023755e73a00f3265ba9a792122ff7c5eb0f4ed7d2f3c4a49e4e0df13a76672b32f4f336bcfd30ee73cacbcba329546ffa7d720f40f00720c421d59b3901a489d9d5ae1fc98af0d2f83969ca8c655a3343d569b204e89f027a038ed1276443f8e3ee6d0ff781863ea7c54d6dc51dc30349db1833478ee5e6782ed3a8fbec9ff716e47c21245917759477f10d95f1a68540a94370d82f52946ee64bcfe197386801f671adfa85e8dedf2a706bce98e257761d2f4218a411c243bf758a104e859be197b0d6f0c75b7c391023868f03ff8a054a826466a01892156993ccb15c9480d126544fddf310d256de5c03561484c488869ded0023bef3108745639c92c72075f571e0aa33a191e4885fa84e7241938542eb6e88b348c969a3d4287445131097ca8a5568168aa3d88484040eed6adc8e3b25d110efc0431b2911b10ec9a48d6d9732cdd362df6f998103991a3a721a995e36c269f52b75c7c3008dba918211813fe11d6ec12ee3cb8e45f7d9afd122c35a123eedba091e1f8eac6b6e482b5086635fb56fc1baf1fe8ded1c1af2d2086f5cff9c7bf3c5cb21ed41959bbb7e2ff599e41c91a8ba9e544ca3570ac8ebf466f59e1eda755245722b4801ebf434aee28934271cdd92cf9c197011e9d0ac8e83dae285fc518246dc950d6cac58a52980b9a8e94f34a81a5d6279ba697594145b118c59e578580af2c481f52a59d74ffab7e8c05166f417388e1e66c32431d02bf27fc973be770bcc621308970ba1def0b1bf8f3ac7594879d482dfd2e2b8840a4f46ad0edd97d23e5d6aef9be6ae16b6c06fe84ec3bd0d0a77fac396ac46347d98716b2bafe31efe12396459379ef25f593ab2718d33e9e45cd14df018dbade2d8c8d8de0bc17bd2d1990210f037a1edd8d1eba16f4a0ef94a84d13c4fd0dea6d458068b894abe87fef8dc2f8efe37558950de45fc5876b0309d12480e7ca3e748a80a101a2c589e3243985435eab0483c95df2c3d8203cd6c157e91f178223130432bc80c70fbbd66302ad2a04d00f605491b1a7b221347aa3916bbb1aa1436639ae39d5052fbbff39245c748e9c554fecc72f9cbdc7c4f30da28bdc5ae5269861d0c110ce78e6aa655ab254ffa36bd4d430e1b04ef4b1a380776b86a45ae43ff3a334524a3e5ae3dc9f359ef00f86bf341eca6a0b6ed5e8bcf5443d0a706668d467306f8a65375a37a05368a3eedfb2ae629521ed1111dbe29ef159cbc770e05caa912e1b753f373b5b2d79be7ab953ba1c02c8f69e6f38aa8b5cf392fecc6604be60061801ca539b3e5288ad3851d4d45c0de933bfe6c001408e6d3c05952fb535d41f429c74e63f30cfd28bf2c16d81145b57cbee55151f2ebbd9a746705990176007446717bb0a07902db2a4780d5cba36e49c4ee942db01caa4b3134066086f889c83d06a6e3465d23c69371ba7e111c23a03fbe862dadf78884624af7185f9c705653c73a142aae957fb33e87889f04646ea9f32a99645b0d9785b545a49c6baf4a03136e3e788a19e2db1cc0483437d97487c819b0ba92abb48e084db9737c50f3321471decc7e8c654c3870a0657a305fcf3b12f242ef841c08f5d1fa907f9e461ed0c53550ae5f95e3529294f39fb4503c4489d5f20aab94f859cacd55c84ea9554b402838948dc9710d1ae2a7a12a910868842c0a33c9828285d14c3b157d1373c66a2164a1af7a43e4037c922e49c2d7bdaccef7abe9e626b0f8fd03865af86fe7b3785ac78cc96c33a3edb987d2e84a7d89586b6303c8212b1f6dc32a0d4b6df80e3f67b2caac6568d35299ae8ba28c536610e8fd832c1434b9c0a9a5afde52fe7a23b8e9d49762e8a5b2df722e841d89276e05cdcf0e7385d0c389d49db5e6bdd3fbc3094067f8c80c8da1af6cf538457f5b862f3e82ad9bb896856b95e970af9a3c47b7819f799672726ee7308cb68cde14d8b56ff744d9329d652265bd2dfe27d80584e269557380056059bb9450b4c744d473ddbb8d399965349407b9d5da56b53777178d94a8e07df99cef6bc53be9c53c496d8c288fda273744875f40156998be588766c2edfede496b6f8a36e8ab5c6fbef238cf3f0270babc57b0b0b76069a241eef38adff418bf6936f2712c081e49ee5b958533214e822fae3f4ae142820b1247dcd8cf52d273262083b80b4591a29a6d87a3e85abdffe86eb4359acc0c63e624c01db88ee2418961acdf4c7d2d854237a3a34a747d0ca7d3f0235ac5c2798872166ad304a909419a3abd3ee3c3d28e9ac867343852dcd70abaf446bd28389121db58db38fe75e08c452d642633c4fa460923047d39431733e56ab1082d69468c5d67d8e1af0210ba89938ccc44073a5bd1af8876c07014618cb835274cee79f57b0bfea9bacc9eaf55cf94a2acf4e0c987e90b2a34e1d4dc1b08aaafc4638ab48fcc500f94275144e7f2baf9ddd253a091c407c1b5e208a4f4e9b0d20f1f08c973b2bc1f5c3623ae5bdfce06005c5e4217d04573fb9778187c9c0d71978151481824dc710937da0a791c5f7273a67a204b9b76f0e4d819a7086d3513a506895cfc6f4f89634891b10eb01fcd59988f7e76d2897bcb9d6015f648ec827d31f5b4988a78bb70fd20d83edb6a72139fd2ce24cf0acbabfdc744a1b7c2e3ed466b480831072377e08c673babdf7375a7674e83013480b5d49a6b773a839357447e6779cb1caf3434ab05f20390507007d8670e600813c4cf2f877d3f235e2ae1cb13c5749b13b68730cb3144c4cfd42226d5d16c7e5084d856424e3614709cfb671fd764760e463eddb4a3d481bc2118c253343648009accc510dc1213be91154d5cd0b35e8f5332371da22ac15085c9c12e6ccbb7c899f915a056b9da1c21cade6720a8fb936a9048bf7742ea2e4e165e54a739584ebd63a3beaa46d2610551b751fdcc1da8804d00725b3e9e8450f2cac9a275da5355cbc254d64d3f76324de070020807efaeb785278aa4bf17d910e1a4562eefd35e0556f5bda03b50388fd12935fc7ff3cf8e4808f269894392f2b1455cfb7baaf142130b0ed348a41efbf2fd08ac403a5964082c46c69c493c53ff6cc913af323b2125bfd4095dc2c5c5fb246ccaa8ac87854071525e0eea4ef9ba069fe3b707dc9a5c45e4d2a880d187363d3f2c1c248287a7b1575475e77178da5a79f86a61c1319a25bf4f309e02d18772780d298a736e22213e6d56c3c6268fc98c194614513b43d7727bdf9111f062b19bb2941b75abd55de8f796eb124ff41d02c80303a8d26a22e45ad9ddf8c3a808927adca1bdac6abafc50b7cd2bbfe15ce83ee5bb213b0343511d6c938bc50c881749dc221d5c2f1b4fba0f196c2840d227ee981fd69dc1af73ce1a274b50ec9f82d2df80b82f48f64804add1b7c891d033975bc63ea6a08f67a09cf5a47c11337b140ba902cfa2412ed75f70b4f4cc54b387322bde5900fbda9300872b70c0dac8945feef20f28f7e5f656ac8733014d53b6a1c8b809a8b3f7959b8b1c9a2bc3a9c056ec69a5c76cb59ca56b5c288e6bffb6ac0d4b4d261b1ed8517da3f7e61f959ec415f6e7c38cd71427718193fe5dcbdde432f17ec37a9ea3e17f9070c43fea14cf4aaa00326a72b416f0bee3dc38f7eb62ff2daeba39e791787f01d5fe346d178a3739be6ae1c75e1faafb224f5279935691543059cf5df4c424026aadee090419fc85a7fb085b4ccb7b12e6d23cf67e18a1a50b04fcf6672e4a8e0e92dcd06d178ebb976c9c85d49a46013f5d7161faa525ef89630572f2f3177258024e794f5a284f00624eb430e351d5665dac3f0185f2dd3dbd6a5c9498c3e10e5aa46d75efbc91350bfe9f9f21f659eb5ed1e101c699db5d89b10748a1aa9607bc6736886f8b1ce74a232c021a092c4b7760ff4155fc7b0601335d49dd2f1be4216d5b8b52c6673db91b3c0498b4c0a15849e641da7e620a8efdf36b173813ad0d7514078d85add4958198b7332c010ba2be63fb8db9e679f79e3a4ac8b25cdd03eb5a9847b54e3d006b86ccf8af780e503d4dcb7cd53481752d740fec71ffcb8cba81f7da6bb72a2a14e7efd4b2a7a89040fccb4992f8981604e65f6c441944b26e07162a2a940d653a7ddba578564e161fefefe4dd4785a0e4fe463c3dbc2296e7f8e0a2a76197c39772311b3847cd6a9f5ac7194a532e8001d495351063bb9ed63df90531290fdd9e05f7da32b593ca3000bc590b3ce6835c06858dae0eb10caaf130811b1c629e97824531316b3fbfd0924ec02d36761540b478f798b96b40cf7c668c314d42139c03c8cdd515243b43846c91dd06a0eea3cfa83d4b8ab672fffa6d5183e01493bdfe05944294120f57b83ceb4b8c3fb116ca91f925bb4939d91ebfe9b5a45f0a4473c644755ffc1d76f5416d6f464f0a6a512fedf165782e1c696a30556ead4cde6b0f20f8c30cc6aaf07a2a29d6a1437e07587b246528c5794063fd3323534f5df62910a623f43477d2822b6e577fd6ec04176bc60814d1eaafda20e4358468c879431e2047a7782860992e0b7511cc6ba44d124fb6c70eef1e42757da3eaf6e13a0f3620263a0992894c31a04a315535e829ff46207487a2c2dc8eb86abdb418683230cc61a5b83acee1de0c8ed81d6098f21a4fd44adb4f5a01c4a78fbea5abb856571cfd27af4cd2cfbb30405c8bed5468f6ae70e2061bcb7ea8d50776f788844136684ba694351e9f4a9b3e17b57ce02191fefeb7ae0fec35fe84e27ce5aed8cebfca3869fb90818f3d9da1f6ce3e8872dfacdb42f7b11bd7d5bdedaa78cd78fdd81c57e51f56ab859a01126cf4978c9bc104b408801bb9ac5bda6ce349531168f687709621682ce6173c95b35f865f14cb34eb68b842af9d7c6c865822199789c25c536927df1394d6106dc9ed97a4441583e980dcb083d59173d5b2ee4ce648656a5e781fd1c881f3bb86bd2df77dcbc06cb91306e638183827804310c6cce3d50e52251f03fd97ccef2cab9c7811c9efa02dd2faffb5f661db89d505f4310a783c78094e4d627ffc869e1df4df325c4b33e36e6ff963526bb32b702378de20119580d9aae7bcbe620700728c416f9688e7b750812ce9db4f88c29cc70fff88badbb6498f775af9699451e7053242c3cb37b8e84ae9ec54c742cb7d4e94f909d2c9b58d44489113e85f52295b2effe87271efb63742820165c9009bdb84e61704fb6f32f75e10873f6f97b8e97920eddc57714de22f8e16fcee6afc1de62a8d44d48e1ee2c3c5932e136523448c31fb8c44a9603e5daf29882540e061c7807f8ca21b61b2baa928bcc06379112e3b5e58bde440c68c5aac2259da7f6c0b7d9f97f59415e77d8158606121aac6a0bf78e9f04f9ff14e2a5877b14d0d086d60b8293c7e88548da23c38fb76c5fa08f80598af4a25eed5cf1e9c098688176fa6ec494aed0d7bd6053d0f64874d77d86ca263cfe386f3ff7f9142564bc5142569710f9965ce0c85fbdb4e710f95adf91c90f7d5f9d3cca948f572eff31a06104023de9cbc6e4832713c242ad51a8462341794002175b4fbc82404c4e4a5bb6c049d71bbc12353fdc33f38dcfbf2be19126c76a749b3d022ae869b48d915ef97ce201e16fad04c87e074dc0dcaea648fa8a4f2b96a368e8de866bec4bfb32e19010a674ad2309f7a8f80fd30b58bd2a48f07ef2021f687da1b40c0f0b0fe3efeb663857ef11e201079a4e795626c32cd72dcf13cc9146c0191ea0f627a1e065c849095b939ec29c020b15bde25c34b1b332f205db7e1ed3ee1ccffba62c1f8b129aebdbd7982ae92610ece6ef24f6170f3204d9f9443ade427b6633c8cadb91913149d20ff2716e5dcc2b1c788ab1587107120dc75389342606b2f064ebe6caa85d7d2286abc65ee1b564f56ca12623e52ed57e7cdca20ba1981e1baece8f343e08e6e2bb7508311ab65218e04c72c5b397a0ba510afeb614d89bf1c81df3f3607a8c933f0e3377af724132e0f30ce8161003926f544c22914333ff7f85a388daf6698a5548687fbb2dd6f190cfa34f41ccde8deee9a3de9b4d891062c41921cf08369a2bbeaafe6bdf6ed6f913910652a9ed9756226651890dbbe584ac46e1bbfb5d20a49f47d6e73a5ccf6588ea533cd3abf1d2efcf15e14713a07019014b784d1b7adc5622abdb7c28ee40edcf2aee652270d702a119234ab5d5e2b3b89427e19b20f2370bfcd2f2e589c734cb4529b32f424a1eaa2802c87e7bec7c20582c7107039f1a184a15c94337971a2ee465d0eeccbe0327d17fcfd679ece6a1f4c45cd8070342ca264106ffc489f9b0b7c844085ba1f69c6b679fdc2d50b0446bff28bafa6f3a5b8bf73a2b762551d01ae136e08b6cc1bc98ec64bdb9f71f8ed0cfb5000a8c0b6dd48a3d505250bb219de207d48b4ac9416b9911f008039f0fa46ddfbc5c184d46ada07e0ae369e0247aac4baf97691dfb23c483fdc9e4b5751aaf9a2f8d75a1c3c8447881da1c006e5c42f081f75a83e131b26961edb699a879ed667238017044fa5912e4c8f2c646195a3cf77e29781718e5d8b3cf2f57dbc8e29a63628984d7babeb14e013394507d5f7a60e32d7a00f0fa5034fb420a0f2944d52d814fb026a4e510e1ef73960458561959fe95e9f49000c448e794dd25d9aad3ab01fa4ad350340b7021854808cc868ae4a6c0b1aae91d8119c8a54872626b35f8bb50eb8e94847733be1ea9d9e8ed11799bdc6a79f22eaa1a3be14aeeeca11f861e9f638e6a5903fc5f5069b316029fa97b10855385b2ac215a12db06bb38b43af462b2bdc0d07839a030a7db1f7a961a40a0c20dd8be83f79a5c32bd30e9b6ecd63dee3538592b5f6937942d0d503204739194f8d15a1af8789fe7b5905188fe2fdcf92c3de4db5c1b3e2ab49393f8196815ae3d7cf5faa9d5e45706de3d7d12b0dbf962d02c2dd9d3f870e5401f82c226d40ffe98fe3bbc879e5dfd7dd99b9bbf3f1b6d34214248f4a0f8f31ee0b82105ba48acf943742e66527c07e7d1840886f0a09f3844178eaeffb3b096c9c3b8c43d1d65fa7c5783968408828c63aecb6f5cd3aa080c679fe866f35669a176689b35af687fba32524384aaed55affa1df3950d02e4b4747f2fb8d01d7ab7f715334ebbf18d3700b10a05dff5369cd709ee1a7ea4a715a0e5182ddcaea9968870d41275669099ad3c4f2b3859850455f53afbdac582ab676c07a8449e98a017530be63045396a60c407a37c233a3127dc19aee39266e5415b115273a3436250e895be5eb944a0ac70c2927fb0ba3032ed3641992ab12a7ad93e186a805479a8b99a8d852662ef2fa2904cb7f1a7cb330d65c6f0de5077023f9a4efc8193b185afb920cb68474854c3bed89c2ddd90f3e0f2083c7bdccb24fff2fc2a1dda05ea65093ed1de6518b31768c787e31b1cae0a384e5625285d8a0739c95d83b7b922f4cec8e2ed227d0f48d637406ec21e642392e1ea1c11ed00456f957676ad4c690358a72981c4e30d7bde267c262252abcac0fbc2cf457e80b748e2af94ddb165110b253bd819c88f93322df04a857cc8732cd11c4b9de827ab7337be5748b2bc76cba8cb3ef00c96e111bf9da0a9f58016749addc2b188a309e80d262c4da897637ffe380b7b9a48a641f3cfca679220438cd252d1b451adf648779dd86df1e0dc27431fbe2923e13b7d62133370725260387d94dacc1103e2aac4957a5b45032ccf8c7a897b07d2dd009df0aa725dc1c609de368ddeeb8b99f91e9ab42b60dc7e847b82835558179c78b368546e0e6aa948f7105f40f24f0146266d097be90685b72071e41b39533b190fa492824ff44a6daaceee8ee5f2cee687f54fc53860921ad49673d950a3be32a5f66c548164911db4d0f94f9d6be91b8e1bf89cfb2fdbdb479eca3248543ed5cdea5e8c9a51c752024f37bddc0f350773975b9978bd53f898ac4c7d61abc5def7a1139a3ffb830c750e8e62585ddd309664c5874e816865a3c609f39dd9e185f2dc946cb8835016638670347f334463a0ac3220001adbcce2f3e00a785a423a4159a94026837461c2452356b2778db51274bb862b8dbccf71a9f298472b49fb261127dfc8c9cde762218732d2fd651098f0abb5ce25c332ea890af7027b20c1f0a7715b3d066592b2ba055b98b784fc95125a630824a88a7e6880c7a2d195eada5c98520bd858db29efe151a6a990c2da86c3b70db1e54dceb7305d6302ab4867af98c899f9aecb88aa903236dddc1e359ad5c47679828d58bcd77eaa967aa4c31ec78c69046f62d61b2ad4c49c715eb6a2062aef12aa25c144699a628d2b9c4e82cb04ec90ae144fa20be1e3514866bbd33823f01b97b64420210b10c506ad159cb433432db4b33ca620077e138d01fbda5782a7d62c2500aff7f946cdb51f7e6349f498c561e847cf4ae7899efff8d8de85bb3b6dc27dae50e6460ce1a1e6c824d21f4a09886d14df233505d6b2949345e737d453687052c7baf37cc4243019df68ed930ce226a5cd600f5a52d73d17b5ac69d5630fcad85cad39970a02bdf706e7231babdabc54160c7f6ecdf8a8a980105ad0e5fbedd2cc1eeb9072bea6e28a44a60d6012df2b8acfc1870fec7cbf2329ad7a13586dbd89e99ee8d9bb6e696f1b4df6fb7d7f2dac2c20b4c05e01d4829687f9eb05e95987fa25807ff5fc3e5e997f02e094b91c64c11923cdde53a70aa1395bf1a6f19fd69236e6cdb7d9d3e0f1941552ee132805221457d058dfc337b84d7a1a03535bdf0e678a5c993f07ac2ab1ca8f7dad774cd740567d8e71d080b026c2bb79b1b47a5e7c430600af14c108cb70718d95b2804a230ac4330e2c834b8738eb25b6c70ac43f1d17cafcdf74df9bfc42844eaa8ab0ec0bf73cb95421da6f9d22431d4d22bbe731ea089d661dc0a24fd9e841a7815f47466503750a642a302813c3abf0c0c8677f800d5eed427e88db17d3df8e05835509f938029b5aeb05c0d512b199697aec3d7c4a0cafa35ad86a18d7e6a9ca8ab1f20dd055f1390878d1c5db311a111c832d72c0b13ed3269841811c8cc3e1091558bd1e3a1686c46c0f2563858818532ea2ebfd8164def3725df301c528cd2d47a9f8d9672242ff02568c5007182a79221d13d8ad6d4e601ac24506cc494bbc5c819f444ef500d65591e11646d54449e1527b605e52aaf302823ee11d1226596d779a05b0b831372b4f3acdeb5f43b22b294fbee4011e3c7e883d54001245551849b6770cafa3a4ba99ba1d19ff08dc046cc097754cf3e00f6983b6eec5d0e5f742cc8a1b607fea962557ff46e2587cd39e00944a33c1ee050613109f3b8cf127602dd22cb16aecb8af613a27b85394f589c3d2e75c5cbab78a334f27602657816b409aaa794038b558a2ab2f81eeaf2d1789161bc52b145fa2987b411171773d39a30d3349588e71e68f3b9b31e175c5c259023398dff793f2e68f53f1566bd1c7fcb0668e8255adfb5ff8a960e0fbf8f97c4e15c2397510fc491496774c22c8d84a27347c046d62075d0bd82a222dac1f05a518567025d957bd6bc7f5a8d7e6ff23a96ed70fbf06c93ae36c9e090bc5bab3a589fa11aee47767bdafba664031c105382ce952ce45c2e36a3fdee3975ea1217463dfe52a7660a3ef2f7c1f263f7410a50bbc56bcb01837817c8fe81e609fc9a2278e07a1f0645fe0a6223b0f1f161ba971c057bf188acc0081714afbee502b3da06381e4ba44790744ebe1a146ed1e330f6fc1f372d9258484a4a70e863179037ce25d2d23fedfcb2649596aa0029e472a23ce1cea833c796d9d120ce73375995f2c877cf3f00a6b4b1d2fbd8dd571a1606b618e224f7b0ce3e783a5bd45f2f5ddad6a80353edb220858a1d37115228fbc558de761764e87adf128e7c1c0cd91ba372319474436a17be4aa046add177c0da9e1bd15e48f3502512d54466ff35dbb3550de2540094c8b3c364e81a8bbc7ec7d60e857be4e3a8d4261f978160ea9dca8d5b089a59883e2ea290ba063097c436c0eb1c5d1d1d31bfa010535bcf90e23c0cf8ec0214ef7c9c9530a0b13e307b6f3d23ad02c3876e0273133b4667b1f6c5e5e8599b3876a28cd01c5f8f2ad84291a58ae9a218ed04e30a89e42d0b2117c9d5886e81597f3fed19f2033ed39334af0dd9ec1213ea9c1740624c37dd51c6bf2c27ca6aaf42efe4063e4dabb85b11d5cdbb1a976318ed9d26b6409219e1db889055730058f4caa93af7bca616040c8d163116ded8b4a16d1fdacbde02998b273750b655d6d9142d785507176106bb6c20f68311a58a7d2c81f641ae24b5e7827c151b93e5f7ffb38b08e0f847bd720413acbc78098d1f0a59fda6105be40b9ca1b944c88703bb15b458226be65ff8ddde71789d10e486cfb37384a364c0d048b8b4401eafaac1ff1713be79b501f8a920b1bd0b41eca278bf9a50e430498201511cfed41726ce9ca0001df72676b8bf5971fce848d6557355fc70b07db02e3f54ea611a8398491af7bc80fab8d0b3dc3b7045dbefa32195631918b4148d7248d791df405b79f5d9466f08469c833691e8a62d07e350b16324088c9e13344262df9790635170dd5836ad79f05d722bd927fc42460e3b9307b611e5097b3b7be422a4ddc9dc9d706c27d11c4fd77c6910f1005d8f85d0d59dda6d842f33e7d68d2e97f0e1e927d064c101f452357097ee9723ae668792f536c3e6c2c2d76f55b718ea9ffb5a9ef6ce50c4bc285e77df200d77362d0b838adcf1aff75c0cfa82d652d6382235332a0d8b1b4f8361883008a792a3efda161a6a03726323d173fcd2ed3e464e428edf7a7a4a21acc2b9e356f2e2ac3a312997f96900ea076db19496e56c3b15704dca9161d419bdcb10ed5d74112f80166dfeacf1fd85f94320127f6484e6061f0766a3a38f5a01bb95b2c3cfb128da29518257e3eb42a2910e0f4d1b2a63b8898a3bf08e94bf6e50e3081b40f49304d2ee393460cba51c3a238d78507ecf0479e24abf2bece87f10f3ea2d0c8770b7b4be9ab03ff3325d1d8a7a1b337bb9f130528019b8b6c0e3e638b5c91e1dd0989da58f7dfb901fa0615470925fd0c62a24ca4bcb4cae90fe094e9497a0d1b76503c6dd5193b83a77635bc12206dcdc09fb1e7f3c718237584f3c312261dcd886aef2673ab9b6c418e999949fb0121f523dd08cd51e6734d7f20f7fed65aadb4c076e40f7fff4c8b91e33211397e7c675ba381ae375eec5fb21a0a8d874b45f9cfb4939a805d4af7d24812eabf828035f9c519f1728a628169e359149fdd88d24fbd12f30428bc70d76e048c313324bc156d32bf6b6e5d7dccebf9bc9eabdb085a62599e56f144cc27d23e9301e92177bd7211796d66de7337e4e5c85fb5ea8d8fc00f70d343169921ebed09a97c5765b6f8585861c9c39a98fb01b95bc03dca9e61de9413573ca8adf102f70809957dde78951190ff19ce9bc8e8255d2f5a23b12aa722ce19b8d64c4bf0b7c45496d8d96db4ffcb8bd5ce90453bc3c842df3005986456ad43190dfdab6843c830572479bb7425ac8f19e888d170c98b9f47f6e4f3944db3f67630f49d566fc741df77c02e559106df4ed516f123891989cb3bb28c16273ede5190161431207826a3e5cb2a04e62aeb92993cd331422bc0eee7fb5b9f1216520380f9a29327eaddfe5cbe9f8a5d80ff5dde42d6b71a1ff4c7a5301a635ce9ccec6de2e311cbd7248dcf1efe2906a66ded32b437d1c7a9fedd06f843eae935e4e76f5e802e5585c3f42d7d70cc0f83d4f84207c6f3b2c59d55aea2ebde74f84fbda69b20ab861024b0afb5e473dbd32ed5bc9c912dd1c571ad573914961e72ef319b6c30b00296f2f166f05f630cf43b0bcd4a77067942d8fae033992cfbd7953d8973bb591f671e89f9e41cc752d1aa7ca63980730d14522fdbc31c2a6a58eb3265c12a7c6df3d79fea37318908d529b84c5e5a96aac976362db7d8532b52023c83ad7c6cf54f65a465aed24e54dd2b7250d8c9f752c9635fd262ff6bd74cb2c7e2238bd3a76d91f7ab14b72a96726c8be9bec8cf4974cb8efdea7a332dc40ebc8a1e5075bfb0c9d70dc9e41386940dc85137cc28bd29007b43ca54ee0f7bf17e551caa7bb90dfe809af7486182711d51434e27f41a39d2b1fbaeefd2bd7d6efd2f56a9185028901341be1f68aa5126f7b21c99a1d384c948525b753cebd0565fac4d772c60186525a0ab2cfeb7c323845b92f2929393ea156d0b58d8713bbda28ddf9a4884e684942c5d1827108fcf13631d7c376083f8c294984795ee3fafa4515d999473090ed177c846181cdab2a4d4666d2bb874dce0e32e7cefdf5996730540a4ef4dce2088fa2207bc3264d123c823dfe382f5120ea637d864e48717a59dd3ba025d496ca1ad02173c0a516720c8ab724dcc1f91563633ff9603589748c9ee7c445d1cd5c869506b4d408e124e2c8a20b008448c3c71099ea4b9ae915c5fcb1dcb9df436d5690613612a3f6be17d4d64763c4ad753fb68d6d878b8850833941e3d56d5921393d02a4a77a87ba63183dfd1f3e1af8e1369b3d1129da124412184add8b2bb84869f06a051dd9854dade56d584a8ea3494b79b18e3e2b66d5a5ad1bc2147095f6c006368c5e64db988f6d86adcb7cd87795edd8de309f6888dcec0a7acfc96fa7d522d0796854a36486b83a84d405744b4ac5ecb43546a00a864f614e13abd5fa63018a3386628ada2b8ede7f82cdf69dba34476f478424541de1d47d494785613de7a6e2afcd2cc694823f67b5ad5b2ea4d50ea6068935069c397a260bde16b1ea6145666b56feede18493f6b01097adab18cd62f046fc419f6e9bc3ada323638bf7798956117b47bc1d9afd330841000db12f2f343d3d24175bc696540de0c8ba011015f6a1029634cc94a650ed49d2e24ba3c71765f951e704d2226e58d3d5102f4890158b7eef7b1a51452f344ff74eb3310697df26bb7108a697d386b9b175a642702fe9dc76126dd29be9b8bc00f76fd1511a85c726cc7c1e44d5f9ed32c7c050d5f95ac5ea6bcd1a067c5c075a36458d6852fa9729aef7d35c6184e57e0c012e1b917b5eabd76887a1ae2cdf2ce4aa997c5191611016c5ebe0c9433b827b3bc8e030a750669e683e2249c25b11e951e013116c069d40aaa52d0ae0505b038909593d9f98d7b26db6024da39f4a08a9b090e3ff77512a1cd9b36d9e4a7152333032908b7d26c94e479049ff4b7839e37bd6b08b3f09e70b052e13705e4d239378278edce956d5ede319e12457bfd9cab7784bc4b590aa6bd9e0dd86215fe409745bd124f584afcd234065f9da276b0d3cac399632c250b2e3cc07eba5ca0319775a6ee5f049072d3d648474b4024a1c4f6e12abedf13dd1f5a3cb7c3b4ad8807ebbb466ee22d4ed55a585398d46207556d860f3c7a3cedb9574280ef7b1ad4c19378ec8a3cb3a92a354e87ed5d8eda7e55e0b13c7744efc60a1e58cf0516f22dcbd9a369c9a99da8738d44c7ce7a8342890cef2e01714a661223552250eb3b328be74be382bf9f835cb93b36f60a8cf1b692e921fb996c0aa42f7dd5a6b7d9d8eb91f5278aa94f1f1238cf645690bdf3a8293ddedea81713416232cab64f31a32530478debd5d74b0f371a407ab1a7a3e660946a5da49138cc24ad67dd59c611796f95d4fcc1d82b3e4a2a1292d50d3f9aa6aefca3c9d2c9c2944fc6991e1b71ba5a4a235695eea33cf30e055a0ef8fab97c4fdefca3ccb5337e2f2bb280fd87a39f6556cd2711e899bd55f1037da62631222733beba88a1de8ad0c4211c671f0c4b8461433886687ace41a115d8c0b992f166a001756e23d250f987e254234fa875a58d2297c3807b11b1bc7e6855f4e9732774b31f277a2a8ac827df2dce50f40a3fefc39085949e5e1e7fc44ffbd63e142c5661b8046844bc13ec3220e64fcc8a392f2d6fbbc68816cc8aad1684d07087288f5e1be45a08f81944851745c80ff8fa3d2566ff5920beb33bac1587dde6fb70451425da3081948c4fc7bbc6796008a03019d2156493e0bea7b9a38c7a72bd539593b72f24e4a3b938bbd204310e86c5c3e86e4f3bec7dc52a0a2e5822c1ec2953383e2685b503043f71f26b1be724f1e23c5f382bf1a1ad9b6cc996218d36de55d44b9e80679ab0e8bfe2a6c1bc22928098b81373b91d6cb5deab4540e857d3bf8775952d61e797e74a067140dec9641d38dae7a288d792197f66d65c7cbb9f387f3bf01d29b43896be4c1b000fca1fafbf97f3ae97b3a41ba96d184a00ad0bf6d7b880b9071e7ddfd74ecebb0d6be505cf6e66c7df85ed1bd7d71742272d324db52cc91410a031091f2f0eaa3ddbb93a5691f41e32651adcb35dc4a954474dfdcf8ca6fe829fef509913f0ddd67e6c38637e69add269146f4b8fa8b02efa294c84231ef172d7d850295e407eaa0ec8494eb73a45ecbc156056e9e4b9a60c64ced08ec050ac03c73f41b1f3559995b836a492c021425199fbe899a6c64e55f3b74afaa2742948607238cf04ebf4d08ba9950d4ee2468fc80fa4b3ca5f3509272240a4e061da5b676284ddff4f230daa82ed6fb39711e14a5cef4a123abc5b20b22a1c041539f2544adc0815bd5ba8be4011a6096c92b23c6ab5e89682f3164e883295b504da912e0f96cb471aec9ecb6d803026c247076b4693607b05e32f256ddcfc64992be1a2f33f8c50a8a105680a6ea0378c2de18e0988aeba264e986765bd3741893291db4a0626bf5d2c58ef34d21d9c5a8a722d4e49900310c31683891f87cf23937de40c602e8cc9fe443f83708b60c3963b1c73dcbc296f4e01590ad0085ae450fa37bda2eb44300dd2e94014991d642ab1feac1a302d8c7df36083f015268fd7892bbadb02404e1cb890a0521829649d06d3aedc82152d83a00d1d27e32d118865294da5a6f400f9459e3ef0accd8bf3884707dfb5b7a090f80ac1af0cae44a2c9dd68fb109eb6db57456058a3afb0b66ca3540836f1fc74a16fd2a5d2edc6714a0c83c3de6f9b4baeaa1af6d7eb9c1d3745dee9017f8be47f5e5b7f568f6735d1f37066876970c45dbf224a6376cd017f3c4261d5d699e5c76508d1c7dc07000f46510e0ad189163945130cacac0e37e8d1c552cc2a592c60ace75dc0a57509a71767d2e16736307d6125d7f9e253de78228ea5349bd2f92b744bd5824862a40328ae8580e42cd6b4d96090f153b9539a64ee82c9827be29cdb67be18d33c4f138ae585bbc75a1698985a1b5a8ededa9b175d6ce20ce0c79f351c778564545a0a76a51111a95d51587c895e7b18389a6c59f81b5128a46fd935e3976940d78db5065956e2f128c21a83d7b670c0bb2ff8e098e45dc3affe7d910a662a66dc55bda2e15a0e2e2960f6f36f669e4ccf8229b4594e9180d902030dc33acc0bffee6abbb83d13b4dda2e8129cfe73cda0cfb8965d29d9f76e1a2e6433521609c7d3a5589327cd0abcf82d7412ae49addd3bba342345071b647adaca96b882e5bb6e322414d5fe2f130a71397fcfd568baa249a7b2d9f5ac1abcb22ca7ee136e1ff89aba8f5ee331086b5359f08036f537d4fd5d9ab207af8133fba8f82186cdb02c8931fc292282b594239432e4261592562402aafaf9e9c16454bd58af07cef4aaafca97fa4e8a1b61e6ca8d46cb00b37af4e0e0febdd5e4a38c7f09329315d7f6ebc4470ea0782dacf0c4f884e98f398a6d058296e8050403cf0a32fc32966294b79ada0d4ffacac4d51ff6acdd4f4cfff8d396e02a82344a014b1950c4b0196539ff04dd08a0cf58298da4801f1ea75df316230e5a63ef4d04aabac9d7d1925015ca8bb03a3a23dbebc3f3b0e64a0d894c6a5947722d7c1567c96d3591d32fc1b6a2eaec8c2da37d1624a64abb873a1ab315a9bfef39e306544bf7e11096b986517233f8605ce2b3ffeaca5bc40f95b145ed297d90f788612db4cf72149f360d61939db5d2792766b290adc02c1cac678ed7fefc48f0ea2e6ec28590bfe5c6643847cf90af6e00471e635147d31fac2ea854803e5ac8ec61014d66735a6272765b8a2d85f90d964e6f0aa388931926a8b0d3a749f59a485c0bc3eb39e42cac0b85da6d1074b3f99f78b83eb8a1bab6f9fb4946aadef4e237d4a3494c34ea4392beb67b9cb0178ad63f884f74a29cd5a15ed63b14290d4c20c425a49055ff1d0a1738c019caa9a52307a03a377f5fd8807b7c46fd30d9bd973df999743d88eb6781269cd04bcab026a6f02b72bd91fe49f174fb31b852cfc3552e78ba7032bd3167b99022a4f4bebeb9bf3606429caef2a330bcd86fe3d656dad770846dfc38ba1f344ef33c588bc9172ad88b9c0f5e9e0fc070f693b4c0c7080b66b30010e2477789d76018a90576718dea5ef7c0b6d008c8af05a1b3072f106efae0133b74503298030483f9e4095559842030e7b9a5cb98befef726f87eb9152d874f4e0b9652ffe8bf8f59f6d3e6edad901604f960b6670c58c9bc71018268cefae45d45690ef5f6624e2402e35208f9c9add4e46ab08a546388d383b8f9492a185e46dc12aba876b5e967cf99409ae863046368d5871092ca54c94fb555a281349271a94cebbbd1410a649204802554b636e86908263fa74f3b1343b33b406f2f28dc713994481e410aa7bfcbba5328d4477ea8c821db1e3a97b9dca8c86dd579212e279090edbae68b22a42e9a98d47cc9f4a570850bf3c8cb925a8c30a709b5fc4222e8f7b10e5c2f9235f3f23c0a74944c853b32dd4cc5cde1a6ce25b1f590de9945a836da4de88d5c3a9269270e45495049ce698393d82ee898c65116e99725a2adf96887a5e197b3327132a338bd1683f791704ac3b3d960bd3b1b8375e8f2c7dff22157e129c58de384e1853071768acc394c252ac4e1ee38a16ded6498250984186edb1a34f124487b9105aee5c7f0d341798210d8ad5becda3ba515a5173a9b6edb4e11373676e2941847d8fa58bc0a5e8ec9b0228f09ad92f11c55405cb33c99c426894cca4dc849d70e56beaa8568ab6f17ff812dc2ee3b1fc60420cb7d48637be06ca95190e01e641b1e3eb95f07107bf7c356e8b9f47febc3b00ac152337470677594488e8339dc4a00f23137c33316cee890e3f460fb25e16ef9aa4e410d7117deb67c03426fa6944e881a38d59e8a3bf97e4e9ffefe25043d21cd8136391dffff7e232abe63c948f7696f32e9bdfe4ffea3d4ba24bad14f74a83c5771d0a9ad4c9505292add28921c5378f1cb11a444aafc1c9af95751d9ef47537f8bf1ec02844e83413c1ef7532ed2f753e9e12f22646de7bd5870f11c22424024cf95bd7bd19e33a4122139685450e13c30fffdda749a3210cde67aee5f023db282a0773739bb076a41cb2e96b36c9f68c00c9a9056db079e6c182332d8ce78147b2cae61f95df6de11bac68bc3e18a7003bbea1571737bda640f4f0ed851df69e2008360bcec3e1cf3d295973c4aac70d8a7179a4d76649776f3c19068de659ccc44825301a12787207007628163a51bf5d060a492ae899ef74adb35b467adca5888a36e6ccec886137763e907c5b6b02373e9b92c05b2972611c040b4c69457ebdc9887e47ddf8acad2e76187d554a797c7bd9068f1cc11b6da07d8c676e600d8d735aa19a8d364a181b617a1e9992eccea4ceaa943d43d1fea174a5145aad8454bf3e638af3781d2975cfd32e0fb4412ab3bb31ea3be04ab7422b83ada89b8b2a3d6b61a600b996a36ef0267730ba91b5fb28f4ba7e3975f0d8dfab3fb39f9899a4c7927faf1539e1e85cb83f62c4f5061a84fff12bc7aef2362156e139b76ec69d46916b4b05c6711a242b274400dd0b7e6fdc9204e8ee48e344e378388cf09fef383d32d7aedd1042643bbc391916d04ff87a94d7d93d6a47452cc4b4c6e2ea2999965df9fb751987cbac6a63ac2ad193c598fdb3db10b17a92396a24facfb25f21c5442faf16e6c5960d0a47556e6099f82a24078575bde22179614858799cada367fab04b587590946d305e951e3b13438053d333c3cb27b706f5420d6ff003842b163d6364dd61859d7cd4db3ef8d528f4889eed35dc293cb708a153e6d5e01b8b16168e25dace35e8b547fe51494c29be473ce6bef397b2c4e35a0be024e67a3ee4ff4a7c786bbfaceb1b2e22b66b8fd82f0028bed487cca1ad0cc81f83e21cd4379e1515cc887d5bab87401ff4f807933bc91f867542bd283b8ed8dc0f4e20b5b754c46265cec5311a552ea5756eb4e2bd6e4544d2bf78ae8fc5bc67a426784655225de093df1cfe55e09523601aef8853f6a4aa8ee3faec74cf187e6b86e3582269e11ef0ed505a5867d26d704daff56c84c89ef98cb4bfc165532b87a591c32dfcc97b7228a82b3d9fd1d31f0a7c88050e56ee0ba7f51922b5bec348eb36050687c13a0d9cdae8a99c6f818c7ebc24bf00c23cc721fc4b07c82c005da274feacbad717c17ca783fdc1c728a48777c9deb0f782e42c13c0914b921db583570a8d8c88bad5b7dfe186b76255b6dea6a5fffae80b5c7d35e190e20e300b506820c467b07ee9631d71ac7381c0ad36a3a36003480d796733972c4d031c994d709b81a233d828c7219a3fb6d3064f6a505d41480bb45c91348518a8fea272b91191d22ff50fb6e8fb2efe7774edb7b1c5e4c2ebccb24ad7ba10c0e289fd5a9fcfe296dd635f09195082832133acecdf0ce022e3bc315ecf119837f45233ba1ae91cf2f21fb726cc5ec750fb247d816acc843e5fead9ecbc624a5e62e296f4efcfe4073c8888a23ce34fc16fcbc2a31fbc0c7814409f0c5ebfad65e56bccee987bcdcfea1ed677caf6ca3abf5b2ba0840cc5661e8af34e0d0bd756a57e86fdf0e5fdc7fba3a3bc6a74393ad817c5133da5159f3881a632756ab21582e4dd3e7a6087137d450566e0fad52fdbbe08e54f37e2039de92f70e2be893493c19429e2a0269c726e661f463dc5053fcc69c1fc53a7a3ca2ff49e3d5d45be05baf184c75a09872fb515702a5432340477731fa4db150f8377b723bde06623ba7cd6686a3d4e13ec88f272a89d226ffc884844bd9856a36785b236ab797327543343f0fe09ed4fbc8c20591c0da3d846109bdfd3176add0c7d44e2ed97a891b9ae0fe2b9a8b39a4929b0490fc0a9cb35189ebdb9253e9d4a6d9d6327cb1cef811f8c82302fcb50d9f2dd6c54aeb058da616312fb00d8977cd7920bdb4a3e9d04a43b427b30a8fddd2aa412128cf394383e5b9ea2db3e77f4bd85ec7107278243b2dda84a7ccd27de2c7b88d226945bdc9845d48b6cc7bb07ff13b889d9a4faaabef522ee5b0b10446920ee9fb831d49a7592d17f42db99f03e6741f9a410e59e6bb82b0a272dab51d13f9b49ca2eef8c6227959c8f313754a389ce73c25d6966a07003a0a5cdfe9f9069f366d3d5d0b8c4c8319c135459f38e80c6816f3918b26deefffd06295a14ae32c00aded8ed2d6bb2dee692b443c86fcd1f00f9b1974364389f48f655d7d7a950009fc946cd9bd41ed73acaffa340171edaae6c92cd9a2e3f90f099a476eef0391db3e82b32eead9b2ac56cc7373e24d33f07887bc119dd964bc4279b064a40c6fb5bd63f0e9c9420c966b9791f01d26280690469233ff747e61ec687f55702a59b8cad49ce3c418ed542758978f076ef587886f8d27f9e14b9961a9415b4a7ec4acb4ab7d8288095d7d9e3d6d4ca0fb661bf99743b4af5db16a5630f3c89b747e172d9c819fabd41cfbe2b658aff91cea5a7986c9aed3117d3887c7d909c0c678a6478060a9302335583a33f39bbedeced68b3ab340c11f3c94ff052662e3dacc2fb4741da0fbb93d03bb850ee884718f9391be7525f39e15a203e752c4ac19ef2b50a4b8366c2875610da165b240292e7af6094848c170ecdd40d40bb73f7014feacabca866e213cbf7d436b2646ca4ef16018246d469461fc29511f9cdc9093ee806bd39ce955766cc56d01f43568d59bd2ab10fe9c767d7110ed2f72ba64d3dda0e7efabd7a4bf6c1e3cf35cc1ed323304cf59f7496aa14207275c8f5659eda850bcce78fd50f32fb94651b51edbe306c7cd9453a7cd5f1a71202455526036329a6e9d0ee0bce3a052d3cb5146fab817da3e7065ffdb27d9bc17c6c7db71ae57a7a34ba20c744a2fecd144e769ec99d7dc35936da039119885883b7c3ad7415fe6ef8512854d79bda38748400fd6e42a75864c0b63a00be9ad6336e8054c5e4fc3ce63dcf7023c80974fd1790d69bd67a21aae7cdfc0520feb4d63db39927fa2c18353e4931737edf5c17a25f899d587563b9cf8b26d58f58c21414fc3579c64543e77bb14a935334b340a35293964a7e9e96368200b564333f12a82d5823d4a73f18d53c086799cea901a98cb56b57c82a7a563e95e2e2a1ed3e54581a2299210654a6d00430ae7b0b3e3b07b404eb2696a10cf22bc77f55d01be42681134acb246bdca8973a6b55eca68120e62b3c051dc25d303fec1888f1af692f428f99b6a843399f65e4dab61a00df1d626d5d7616e8e0e2ef877f7cfb80e3b4aee2e2853fddd3240540869d3d700d3ef066b276c0dc31c708da262e3c56ec31b78af1077de445b831889835a4d1391457888d7ab1421a2bf13af3ff73437733f739c6ca52b503ea47bff09032708b9e949866d8d320f58c98ea19647122d16d944912114da87c497ee51e7e91cf9b3a7210aff4e2466581228b03defa72d064f042f8857a17742f2cbf674dd233e8e61309629d5eeb1cb73b64d6b5508231a5a4ba17e79ab18cd067a2c751a2ab20ae464de90a33c454221fcd77a6fa95d029976f9f47101940a4d859155c082e4549c3f5d4de5e1c2797ba14f6bbe18fdb41f2bb0c5ed67f37d8f9f2ef7e147cfc344c1c51732856f91c97d700b9ca9bd454ae2e634bc99a7034c743b72fbdb17a8f46ae84817c3c3384d704899ff5980c106fcfebaf502b10a59048f33c74365eada29dff352bc00d7b3f42f3012459d34f2396ab5ba1fbc8abfae95bdc36fa657b7a5866a49a3827557f55da807739264d990b59ef6f8d19a3f935626450f9203937d5b4b11343d3839bf4b52af6bd8ca415eb926574b0093ac8d4cf5e5f19e7a51febfb77968158a47e9832db30c1119b567684ab41d2f6d6abc311713959e51ed09795b2cc1d3e3b530ed7bb6b2b414e66e3f16f44393e2542d2c3fe72c9303df8131e5f655229949926a3dc41e09d266a17747b7868aa88032c373eb6633320ad477b66d1640782b790c506540abc36bc70125aa40c1871668ea3b1cf1bc39b75919527f48a4dd7e8d139fa46ba2140929aa6e21f8e22befdd0766f2755d49fda51486c1897b745ea8036db2583e627020eff5d934eb6b093a5df22b6b3faca894baa05aa5d87fecffa85ac81713285622db3b3661eaf3a15ba47ff9b61e292937dea34fd0208ea820b8819ae1423485345e847dde9e0753b6960d8ccf67eaa7450147b2579df42c656af5d2e8865855ce73c4a13f6fea13045222e4af8e1a503f2f965f70cbb0cd7eea2e43c2c3719b775c7847539f7457c6b1830a3661bfac248f8e55e38e0ee321614d53648702022692dff1c8303d7322f8c2ae8e90719af035e08f4767e43ef9058ac9be6aa79245408ef08ff9c2ae32234cc89e08f4315ef729de9e23bd37ffa1cd0f8dafa25cb1359a65b4f801b3af227b9901510bb82eebcfb18dcf2e0d734410612603500dd7c0760fdd0577d6dc22b3836649d52476de89406804744324bfbd1ff4fb1b60cc189869b30caf312e38fbb6c1339a8acc51d02100adbada291d22655ecaa82f43c59e6549834a3059012d9c3a044b2f337dbb68bf235d0656049153d7433cc54d7a792ac56658364d6e266b358ca0c1d1e11c25dcba2de24ba654e61707b59ad847edeef3ab67a798c7f63a94f21779ad638f8b0706becc922ffb18a23261da1a7abcf3bf87c55315e697e042d497ffcb50d4bd8970b264088b38f0794b673abc23ea0a184ac5589d920c7d47014b955653922b2bc217f51017874ad35124608db3e22ea44654ec7a5f20e968485986b796aa5c346b0e6bf6709c03c85fed524a458c7b3a1c5b51492792f91ced451cd66002b9c0336780ebde04fb1e13fdb198da658fea9d8a67ef554acd7024dca54ab373fa0e2af84174cab7044af754f2223315d705207cd7ca427ec0d279774be9187a6223056b6e9a97f033ab344788ad2ff9b441f5f983d97b35a61278aec78c9b678a79bad02ef4e9179adb4092d05156d85036f78309a826d9f1cac8854175a497ef204b9313572f0ceb8a1926b82572b0af402cd31cac341783e56497a2f336db049075b8799164495fc098f63c54e2400a20086854ac7472bad3057f225ef4f4d542a0bfd4b48dea9219264c5ec29e991a792fcead1a612b9a7c27ab5a343ee7a65f15d3d2ee515453e8d12079ed01ffd8bca38727436d810ff4da4292832f6cd045d54e73977d74137ef64378556f7e2b05e40395853ba351077acd3ff14d49e1037bcdc3c2cce081571cc6358b00fd07a83067df5f66384b6e8354ea7eac5b64ebbb0358ce0c4eeb76ccdc85501fe5aab8eace25bc5daebc84b97cc878ba3814ae2e8dd3d95fcc788b193f04843980878a6b9703cbdae650a77acc58817b0be8aed23490e3b872b6272aa6935ace4a4ca96fa6c7766fad191fa9d06b81f15c4ff467ce55002b311bff0bac3158deffc8c684829d927c6238119eaa786a8768bea7da561bea59ae2f0b843ee1bd001a13afca71ea3a84564dbd96d1e161ddac520a250e6e506cb3ca944a48b28de67f9870b4fdd5b78d3fe42e9ce3a6615ef1d7ca831185c7f2796c12bc98113bc8938a3ec83b558f95da7b1f685fe4cb138f76fb62cf10637f8bdbdf59517eb58531e95b07bd03e83e1b7bb6797d0751202de09fc6e22140f2e986e346d071b74dff7a0926cba1a36561d44b0f9c477f535cca2aa0156ac4fd0fd437bf2e48bc918fb242a862935fddf1c4bc13d4330dc6bfe0b851dec31defc3cf2d47f59304179b53d92149593eb980a7addf9a5d276c6f2288f3981186417979ea4552ba361afba55672bb8e5e9727746ed9c8cb35cec85ef87b5d9fc7729e067131335c7258fe8befc1d65c47c45965454a7ad315bc691a28592ec4e6c9cb09930260c56793b703c6e252bf5aa32cef3314dcaaa4e233b86b7887d1e4c8cbd7b3b6f35099f35149e7ddb45b32c1d092f4ee4787fd0c05dcce164f27787e212c649c347ed9645a0848cf0039ad692b3eecdbc48c364e8dc00bbf622361697add299d67a1231f2364540c265f17b6b69035d5471357cc158f650b2b28f0d05032ad91083f7013c4004dae4ed3d64ec35d3fc3c1f7b137ca26ff047cd541f0707c666c3c5b269ef9970725aec833823bff5c32340eb57ffbbf9c7e65df60f2b62c767dd3ddf7652915e2595c1e9134e14392babd56f396c2f4030aad8456f5b38d93b259581505d3c836eed4545686a12eba599d25a7f6b86e23931b4f65bd7e893aa66200857a3f6d6ffb1a72d1843e7506d3ed05fa5d55d2d66f56aab454761f6bf9cda49e175584a147c28b245e016a0323633d8820d629a0b01c864f4dd82af06e7995e985edd9ce979afe1ea3f0b1bb6bda43c15ab9b581fdff70095ad6884b2665bcdfd06fba0f61a9d6aecb9a69df7418edf3df9df405fb1cedc7b2213cd6b9828fa312e478e4c5043e34287b8677214dd4fc6177f6eba3a8cefb6a40c6f0f8bef31945c9f2f2e7c43058293c080804011e18d31798cdf4174f8985a9ea40a2626f9bac99b9de534fe71fd188f8a64d68e222ee81127c448ccfd67127b4076efe6fe49fe255e22e923b6755aa8af37b5388ecbbf4d0a89c9a7d020bfd1b3f83afb82fbd1ededae4d41ba2ab4a64b5cd5377405c910a8f4b792455c378c363092b12d2e0ec214bb35eb813481e7cabd36915c393f61156759a36891524b4c81121a509cd2ac81750d4cd13dd91fb7eef7ce5b59ffc6d91d8b34ad167b7e7a0f5a1d4a3b6fb1c0378369d03dd46e56cf44db4538b1bf052a8b38109b60caef3b3c251ef5f3af3c9d42983d84308a19cbb79a6620d089db1b0b4ed14574999fa79e67f23deb395be4b80fec8abaebbd22dc6957db8ba8cdd793b39f7956fa913ebc538ac180637f0af5eff5e4684357ebaabc37588024012d7e93da1581340458052e36a1b699c9bbaa138ab419b033f7844105fdaba415344a06473b550431bb9b2f84929fbc1eb1306ee2a9b8e24b77c1acc39be10e7a7a43c11f1562984daa8a7be8999fd143a9558ce22264a216e100af30a8f336ea638086530848326798f5f9a52d6e53fd14aa332930d396d0ed0444f506d07bcdab3e23929ad615c70f152a7d71a44b32db8d5103a7baa097c99b69312a727489c2f97deed6288795a4eebc6f9d657909a353efc4db95976f42351188638cc980edea9904ee77cc4c497e86a6b777896abbdfd3f22a97b3f5b61a7f0f66867fcdcda8c2c3514f528cfc7103fbd7a8c047955565311c23e609521fd923826612f8e7d78af5d71d1fd0f637156388370515297a3ea1487f988c41bd0ee9080290ad8fd362a919baeb7003cf0e553d55dc522ea3e358e5c2896cfa81284646899001983920f1d7941f292a884f6e229cdebee46a6adccca08ff9bc1ba8c02d50f04ebea97c9014febb5e0e79f2de29eee12709560ef2b994d8fe272268141d7d6d723ba5760d353203fbc0a59abb1a79bf724666542f711a818592e58c2913e93854b77f5f5be4d1bb8bdacca55f826c4d8f4ea4836d3a953a4f317f84d593f7f1f73af6ed704f282f3b3d1f9fc80c66252a605d1705dcca501fd377280a79633f534bdbcac61400a93a1cd1c210a731f8863a8b4be2092943c44c509f27b70badea1fe56c98ddd04f4e5b98c701c2dfda6052b421225b1770fe3197066fdf5430ce1cb55d1bd732d8c128272e12cd22bcdc937f13ef73492155181cdb523ba65a5e07c9be8445a4d81ac3408b2965f49af8b3a649d546a494c028f652038c957d45452233484340c1ccf5f3f507107f716c3608189fdd4554423c18e6b14ecaf83ea73ab112b253541539556fcbc3227590eca3480606f3acbc11aab65f63cef12a9f2c8655b819c8867ff4567a33b62e2cff18a80e12d399428f85608a4d08128f18ad27c0b07af591522b7c003b63d232afd748a9afad8d662a9bdf82f15a7c2d57123ba4a2598e3ce79e200390db2aa7c3ac77845a6e34792fb10650b965f2116edf473609cd862dcece2c4bb7a72cfa1821f53eb2039fb1256c9e2cafd5f8fd0cbf8ad9c57ad28deca799c0b50e83cf3b347a067eb244099f74fe986933bdeb055fcea0012121ee24be54a06cff62d7badb7667f2be5ec1f2e39aa89fb9d041577471f286703ad6eb7968921fa84f675cbb26806a89890511ef5a73546f41f41b65b1c2e017a554bd7d984a01b8ef00fcaf2c8168c2e769075d624ea219586f52e1eb65a823c832e13335f4ba397a27ed57a3a2a47690ba144d5fdf9e9962272b444cd290222e227a75f4ce1f98bea53fbfd68f71bf191103b4fa1cfc797301d03c2563085e5a2eec82e1dc2e2f4e8c2cc5106d33c8f997518ff09493fb236f94e5185a9fcf4361609cd1adf18f931ec4378e8503c6257f4816ed2be149b88067122273dd071fd3bf1c770469fe3dc024a52ecb1a9768b4a8817c4787f69831a92328b9b864e2824e084142de391cce7b784df581f2ba3d7aa449e8616ae974823d2a0eeddcbffd5bf59a0ba91b519142aee2a592bc0c120af00f216e868006618d4ef109b56c48f09977df9c2d03afc23eb4a0121ce1aa3edd38b841ea0c1546e5eea0c3e85b3ad421285f19fc4aa023ab70de7153fa4e88890b6ce459b24c3809f667f8fb98af692868b4cb182861c5e1a4c302d601e7702b8a334739ece6827560d281ad1ae9214496812dcab20aabafc55a01b963da210ad603bc11292fcd64bb8bebdc8e5c75da611932c45277b4a1f0544b227eaabefc953a6e95b65eb2531fd660db34bd4b2de398b5874ef440f8ee515c18fc6e4696c6c3a0eb2f502107f0c4c93fc7db5535f4f61d0949b1c390bf02d083e0f671fd31cc1b084989d750c3aad6135b1e3215c2133416747f682c281bede485a6c40509ac51056aa516b09ab480fb0251d1f0c7dfe3d0ad33d73c7a932f308d1b9ab7d430aea225e59f10b4e2704e7af5327278599531bb29b4ca6f15fb27b11a89cc349074d7a925b7ef960960d637224816c87a3fc6c6fc7bc58e55185309b9d84d57b23b7604ecf049a7dcbffdc97459c58c9956785733494afa6d61af5ea2caa0932bf79d145eed513641c1ed843cac3171f2f1459aa4ad8c0ba1a73209d33b74d8386afac7a05c2da72fc2dcfc97c4e7e2fea6e439d9e2c06802f2fc718bafb73f6f56648dd178073027fd834f286767985e5af66a8fa29dd8e699d4b060331a5a2dddf4ee10a8bba6faeafae5290d617427a567277e4ca20e920ebe4f4e3e58bedc934d1dee1828dffaa9a9413629a387b3f60a271ce9052d922a79ae1af8e5bfd16098158daf4d765441221fa6cd0573eaac2434566ceaef427fd6c630daa9b1227b91ae6ae86562934fa29436baffa673e3a20eef86f61551c1e7ac2b171ffd02bdf9ee714966f9a55782dd84875a6c0876344b7ffae2f041f7d9f7e7dd4193ca1239e25fa8acdd472aa0a3e8bd61d0e10fae8b5b1da66fd2ea0d9f13bb1e99d703f19bc43bfd078b235a33abe495dced76254302df02d3aad0233f48f53483f40a07308972db724c5f5e5b83250f95218e90bb9edbfbffa585f9b5630ee8669324f4768bcc6ee7dbd59aaee6129e6a5c3fce60c42b61e35df1ad5b1b08d37bdca79b1d1fc382997c377bdaa8a8115c0fdde2391d3db9da44360300c083ff319de4a46018e4b4b6b9687160994efed0510b2667cf06b3f58f9c608ccaf122b625ad5c9f938f3f03e59069d85e4f5a0403df900f769f2bb9b708feb25a256d8fe6b236a92110c350c60484340b8d45aa4101870f641f9d8f6b5aa7e63cb7b19327c74bcc8c44ae874c4726ea5f70f46fda075d0868a0230b70e3816f8702b80b73555fc0cae0b73439fb7e46273dc3aa2df4f16fe0d88aadc7c751f9fa4952b7586147615dde0fc637cdba8c54a4a497098463fb589123a6dce067000c9a3c5ff6a99907cdef935d1ea13916e098b09ef5f418658802d5b3aced8ee0416adf415d4fb5f9c466cc6bc254e85f7fc906a5cd63df7b69bf2ad342c829fe27119de34d11bdda795f36243b4947424d6a4b33cb6c74483b841e096418dc5494511ff7a061745b590a07f7c122b4ec32e8165be7be4bf0f51017b93fa86c64c5967561e9bcda0329466c7502e2387ad7ab746f47ed2c5a7b0451778dae72be5914b5e42032d8d108e22eb8787e28c3d6af27633d35b5684cdad9737e48b653eaad16e45cba8a4bc5162876b3704ec39e9c091cd4501435d209215f33a1cc0c2aa74a416e133d0164ef2d052e8f3ed66354f325b8461efe6443f60f6236d603bf350d49296f88ab487618003c0ffd2180ecdfdc27fed71605f66bd1420b8487b2fe01e09f33</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>其他笔记</category>
      </categories>
      <tags>
        <tag>项目总结</tag>
        <tag>加密内容</tag>
      </tags>
  </entry>
  <entry>
    <title>面经</title>
    <url>/posts/65115/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="tcp怎么保证稳定性">TCP怎么保证稳定性</h3>
<ol type="1">
<li><strong>序列号/应答/超时重传机制</strong>：接收方在就收到消息后，需要发送一个应答信号，其中确认序号表示期望下一帧接受的数据的序号。如果发送发超过一定的时间没有收到应答信号，会重新传输，这个时间为 一个包往返时间 x 2 + 固定偏移时间。</li>
<li><strong>滑动窗口</strong>：如果每收到一个包都需要应答的话，发送速度就很慢。因此TCP中使用滑动窗口来表明接收端一次最大可接受的数据的长度。发送方不需要等待接受方的应答信号，可以一次发送多个包出去，接受方也不用每个包都应答，只需要对接收到的最后一包序号做应答即可，如果发送发接收到了相同的应答信号超过三次，重发该序号以后的包。</li>
<li><strong>拥塞控制</strong>：按照上述方法，如果把窗口设置的很大，发送方连续发送太多的包，就会导致网络拥堵，因此使用 慢开始 快恢复 的策略解决。通过一个拥塞窗口变量控制。起始拥塞窗口大小为1，发送方只发送一个包，收到应答后，一次发送两个包，依次，4，8，12….当拥塞窗口大小大于阈值时，进入拥塞避免阶段，将拥塞窗口的增长方式更换为线性增长，即每次加1。期间如果出现了超时，那么发送方将阈值设置为当前窗口的一半，拥塞窗口设置为1，重新开始慢启动的过程。如果出现了拥塞，即发送方收到了三次相同的应答信号，代表 了一部分包，只将拥塞窗口减半，并采用线性速度增长，这就是快恢复过程。<strong>这样可以达到：在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。</strong></li>
</ol>
<h3 id="tcp三次握手四次挥手">TCP三次握手四次挥手</h3>
<p><strong>三次握手</strong>：服务端处于监听状态，等待客户端的连接请求。</p>
<ol type="1">
<li>客户机发送请求报文 SYN= 1， ACK = 0 信号，并设置一个随机的初始序号x</li>
<li>服务器收到请求连接的报文后，如果同意连接，发送应答报文, SYN= 1，ACK =1 确认序号为x+1，初始序号值设置随机y</li>
<li>客户机收到服务器的应答信号后，确认收到的应答序号是否为 x+1，并再次应答，应答的确认序号为 y+1，序号为 x+1</li>
</ol>
<p>源 IP 可以伪造，所以要随机。报文不一定会按发送的时序到达目标，所以要加一。</p>
<p><strong>三次握手的原因</strong>：首先前两次发送和应答是必要的，相当于请求连接方需要确认对方存在，所以需要确保能收到对方的应答。而第三次应答也是必要的，这是为了防止服务端打开重复的连接。当初始客户端发送的连接请求超时后，客户端会重新发送新的连接请求。但是超时的请求最终会到达服务端，通过第三次握手，客户端可以过滤调延时到达的连接请求。至于四次就不需要了，因为三次已经很稳定了。</p>
<p><strong>四次挥手</strong>：由于TCP是全双工的协议，因此在一方请求释放后还需要等待另一方也同意释放，才算完全释放（确认号都为收到的序号+1，ACK值在连接建立后都为1）</p>
<ol type="1">
<li>客户机发送 FIN=1 sew = x 的释放报文</li>
<li>服务端收到释放报文后发送一个 响应报文，确认序号为 x+1 此时服务端可以接着将剩余数据发送完，服务端进入close wait状态</li>
<li>当服务端准备释放后，向客户机发送FIN=1的释放报文，序号为 y 确认序号为 x+1</li>
<li>客户机收到服务端的释放报文后，向服务端发送确认报文，序号为x+1，确认序号为y+1，并等待两个 时间周期（报文最大生存周期） 即可关闭。</li>
</ol>
<p><strong>四次挥手的原因：</strong>当一方想要请求释方连接时，需要主动发出释放请求，同时还需要知道对方同意释放了，因此前两次是必要的。但是由于是全双工通信，此时服务端可能还有数据每发完，因此当服务端发完剩余数据后还需要再发送一个释放连接请求，然后应答。延时等待是 因为 因为防止服务端未收到客户端发送的应答信号，服务端会再次重发FIN，此时客户端认为服务端错发了数据，就会回应RST信号，这时服务端也会认为出错。同时也为了让本连接时间段内产生的报文从网络中消息。</p>
<p>TIME WAIT 是主动关闭端在最后一次应答后需要等待的时间 发生在主动释放端<br />
CLOSE WAT 是被动关闭端在收到请求释放信号后的状态，这个时间用将自己剩余的数据发送完</p>
<h3 id="tcp的模型状态转移">TCP的模型，状态转移</h3>
<h3 id="osi七层模型和tcpip四层模型每层列举2个协议">OSI七层模型和TCP/IP四层模型，每层列举2个协议</h3>
<p>物理层：用于定义如何在不同传输媒体上传输bit流，向数据链路层屏蔽不同的传输介质的差异。传输的是比特流。协议有 802.11，RJ45等</p>
<p>数据链路层：用于点的点的数据帧的传输。由于物理层传输的bit可能有误差，因此数据链路层将物理层的bit流封装成帧同时采用一定的差错检验重传的机制来为网络层提供高质量的数据帧传输服务。PPP MAC协议</p>
<p>网络层：用于数据包的源到宿的传递和网际互连服务，通信单位是主机。传输的是数据包。IP ARP ICMP协议</p>
<p>传输层：用于端到端(进程)的可靠报文传递和恢复，传输的单位为报文，TCP UDP</p>
<p>会话层：建立、管理和终止会话，传输单位为SPDU，主要包括的协议为RPC NFS</p>
<p>表示层: 对数据进行翻译、加密和压缩,传输单位为PPDU，主要包括的协议为JPEG ASII</p>
<p>应用层: 允许访问OSI环境的手段,传输单位为APDU，主要包括的协议为FTP HTTP DNS <strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</p>
<h3 id="搜索baidu会用到计算机网络中的什么层每层是干什么的">搜索baidu，会用到计算机网络中的什么层？每层是干什么的</h3>
<p>首先如果是新接入网络的主机需要通过DHCP协议向DHCP服务器获取自身的ip。</p>
<ul>
<li>首先将一个DHCP请求报文传递给传输层，传输层将目的端口和源端口设置为 67 68 后组成一个UDP报文</li>
<li>将UDP报文向下传递给网络层，由于此时还没有ip地址，因此将目的ip和源ip分别设置为 255 0 组成一个ip数据包</li>
<li>将ip数据包向下传递给数据链路层，由于此时主机并不知道DHPC服务器的MAC地址，因此将源和目的MAC都设置为255 以广播的形式将请求以广播的形式发出</li>
<li>当DHCP服务器接收到广播信息后 向上层层处理 得到IP，UDP报文后得知这是一个DHPC请求，需要对他做出响应，将分配的IP地址，子网掩码，DNS服务器的IP地址，默认网关路由器的IP地址和子网掩码 等信息放进一个DHCP响应报文中发出。</li>
<li>主机收到 该帧后就可以设置自身的IP地址等信息</li>
</ul>
<p>在知道了自身的IP地址以及网关路由器的IP地址后，便可以对输入的域名进行解析了。首先会在本地缓存中查找，如果没有就要通过DNS协议像DNS服务器获取域名到IP地址的转换。主机在向网关路由器发包时还需要通过 ARP协议去查询网关路由器的 MAC地址，如果本地已经有了ARP缓存可以直接读出来。完成上述步骤之后，便可以通过DNS协议向DNS服务器查询域名对应的IP地址了。获取IP地址后，主机通过应用层的http协议向服务端请求页面，如果使用的是https协议，还需要加密。http使用TCP协议来传输，TCP协议是传输层的一个协议，http报文传递给传输层后 TCP 可能会对报文分片并加上TCP协议相关的信息后传递给网络层，网路层使用IP协议实现数据包的网际路由功能，根据一定的路由选择算法例如内网的 Ford 和 <strong>OSPF算法，外网的BGP路由</strong>算法来实现网际数据的发送，当然在内网传递的数据报还需要通过ARP协议来获取网关路由器的MAC地址，并使用MAC协议在数据链路层转发到网关路由器。</p>
<h3 id="http-和-https-的区别">HTTP 和 HTTPS 的区别</h3>
<ol type="1">
<li>HTTP 使用明文通信，不对通信内容加密，存在被侦听的风险，不安全。而HTTPS 使用TLS协议对内容进行加密，更安全</li>
<li>HTTP 会话建立的过程只需要TCP的三次握手，而HTTPS建立延迟较高，因为需要TLS握手协商对称加密的密钥</li>
<li>HTTPS 要求服务端向认证机构申请获取证书，同时需要客户端安装对应的根证书</li>
<li>HTTP端口80 HTTPS 端口443</li>
</ol>
<p>HTTPS 缺点：</p>
<ol type="1">
<li>握手的时候还要 协商 对称密钥 所以HTTPS协议握手阶段延迟增加</li>
<li>需要认证证书和根证书，所以麻烦，并且加密解密需要cpu资源</li>
</ol>
<p>HTTPS 的加密原理是 首先通过 客户端向服务端获取公钥，即证书，这个证书需要服务端向特定机构认证。客户端在获取服务端发来的证书后需要对证书认证，而这个证书实际就是一个公钥，客户端使用公钥对生成的 随机数进行 加密，发给客户端，客户端使用私钥解密获得这个随机数，这个随机数即为随后对话过程中对称加密用的私钥。这样做是因为公钥加密比较耗时，对称加密速度快。</p>
<h3 id="httpssl实现https-https如何加密">http+ssl实现https / https如何加密</h3>
<ol type="1">
<li>客户端向服务器端发起SSL连接请求；（在此过程中依然存在数据被中间方盗取的可能，下面将会说明如何保证此过程的安全）</li>
<li>服务器把公钥（证书）发送给客户端，并且服务器端保存着唯一的私钥；</li>
<li>客户端用公钥对双方通信的对称秘钥（类似客户端生成的随机数）进行加密，并发送给服务器端；</li>
<li>服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密，在此过程中，中间方无法对其解密（即使是客户端也无法解密，因为只有服务器端拥有唯一的私钥），这样保证了对称秘钥在收发过程中的安全，此时，服务器端和客户端拥有了一套完全相同的对称秘钥。</li>
<li>进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即是第三方获得数据包，也无法对其进行加密，解密和篡改</li>
</ol>
<h3 id="认证-签名">认证 签名</h3>
<h3 id="http-返回码">HTTP 返回码</h3>
<ol type="1">
<li>1xx 请求已成功接收，需要进一步处理</li>
<li>2xx 请求已经成功、接受、理解
<ul>
<li>200 ：ok 客户端请求成功</li>
<li>206：服务器已经正确处理部分GET 请求，实现断点续传或同时分片下载，该请求必须包含Range 请求头来指示客户端期望得到的范围</li>
</ul></li>
<li>3xx 要完成请求需要进一步操作
<ul>
<li>300： 可选重定向请求，被请求的资源有一系列可供选择的反馈信息，由浏览器/用户自行选择其中一个</li>
<li>301： 该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一</li>
<li>302： 请求的资源现在临时从不同的URI中获得</li>
<li>304： 请求报文头部包含条件，但是无法满足条件服务器就会返回304</li>
</ul></li>
<li>4xx 客户端请求报文格式错误或者无法完成请求
<ul>
<li>403： 服务器收到请求，但是拒绝提供服务</li>
<li>404：请求资源不存在，无法找到文件。举个例子：输入了错误的URL</li>
</ul></li>
<li>5xx 服务器无法完成合理的请求
<ul>
<li>500：服务器正在执行请求时发生错误</li>
<li>503：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li>
</ul></li>
</ol>
<h3 id="http1.0-1.1-2.0改进">http1.0 1.1 2.0改进</h3>
<p>HTTP 1.0：（默认短链接）HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接。</p>
<p>HTTP 1.1：默认 长连接流水线模式 ，需要自己断开。客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果。防止客户端无法解析。</p>
<p>HTTP2 对底层传输改动比较大：</p>
<ul>
<li><strong>HTTP/2</strong> <strong>对消息头采用 HPACK 进行压缩传输</strong>，能够节省消息头占用的网络的流量。而 HTTP/1.x 每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。头压缩能够很好的解决该问题 。（以前key-value 的消息头，使用静态表和动态表压缩，动态表会变化，使用哈夫曼编码吧 ）</li>
<li><strong>多路复用</strong>，HTTP1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。而 HTTP/2 做到了真正的多重请求-响应。HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息，并行地在同一个 TCP 连接上双向交换消息；同时，流还支持优先级和流量控制。</li>
<li><strong>服务端推送</strong> ：服务端推送是一种在客户端请求之前发送数据的机制。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 再发送这些请求。当客户端需要的时候，它已经在客户端了。(如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、logo 以及样式表，因为它知道客户端会用到这些东西。这相当于在一个 HTML 文档内集合了所有的资源)</li>
</ul>
<h3 id="为什么http2可以多路复用">为什么Http2可以多路复用？</h3>
<p>因为Http传输的文本格式限制了并发的解析，不读到<strong>分隔符/换行符</strong>就不知道什么时候能把该请求读完，所以也不知道该从哪里读下一条请求，而二进制格式传输数据的方式，采用帧结构，每一帧前都有帧头表示该帧的长度。这样就可以快速分配内存，执行下一次读取。</p>
<h3 id="ip地址作用以及mac地址作用">IP地址作用，以及MAC地址作用</h3>
<p>MAC地址是设备的硬件地址，每个网络设备都有唯一的MAC号，用于数据链路层对同一个局域网的网络设备寻址。而IP地址是IP协议提供的，为互联网中每个设备/主机分配的唯一逻辑地址，以此来屏蔽物理地址的差异。</p>
<h3 id="请介绍一下操作系统中的中断">请介绍一下操作系统中的中断</h3>
<p>中断是指程序执行过程中，遇到急需处理的事件时，CPU暂停当前正在执行的任务转，保存现场，然后去处理对应的中断事件，处理完后再返回中断处继续执行之前的任务。 中断分为两步：中断响应 和 中断处理，前者由硬件完成后者程序完成。产生中断的原因有三种。</p>
<ol type="1">
<li>CPU外部事件，例如IO中断，定时器中断等</li>
<li>程序处理异常，例如栈溢出，浮点溢出，指针越界等</li>
<li>程序使用了系统调用引起</li>
</ol>
<h3 id="tcpudp的异同">TCP/UDP的异同</h3>
<ol type="1">
<li>TCP 是面向连接的，而UDP是无连接的</li>
<li>TCP 是点对点传输，而UDP可以一对多多对一，多对多等</li>
<li>TCP 是可靠传输，保证传输数据包无差错，不丢失，按序到达；而UDP是尽可能交付</li>
<li>TCP 传输的是字节流 具有拥塞控制 和 流量控制，会根据接受方的接受缓冲或者网络状况设置数据包的长度和发送发速度。而UDP面向报文传输，不合并不拆分，保留上面传下来的报文边界。</li>
<li>TCP 首部开销大，20字节，UDP 开销少8字节。源端口 目的端口 数据长度，校验和</li>
<li>TCP 效率低但是可靠性好 UDP 反之。所以二者应用场景不同，TCP通常用在文本传输等需要保证正确性的场合，而UDP用在例如视频传输这种实时性要求高但是对错误有一定容忍的场合。</li>
</ol>
<p>各自应用场景： 对于效率较高，但是准确性要求相对高的场景。例如文件传输，接受邮件，远程登录等；对于实时性的场景，但是对准确性要求没那么高的场景例如 QQ聊天，在线视频（多人同时视频）偶尔断续不是太大问题，并且此处完全不可以使用重发机制。</p>
<h3 id="tcp粘包的原因和解决方法">TCP粘包的原因和解决方法</h3>
<p>发送端：如果接受取的缓冲区比较大，TCP发送端为了减少发送数据包的数量，将发送间隔较短的数据包合成一个大的数据包一起发送。而TCP传送的是字节流，没有消息边界，像流水一样，因此这样接收端收到后无法较好的将数据包拆分。</p>
<p>接收端：如果接收端没有及时将接收缓冲区的数据取出，也会导致粘包</p>
<p>解决办法：从协议上入，发送端强制发送,接收端强制接收(破环了协议的封装性)；从应用程序上：双方约定一些协议，（包定长、包尾、加入包头信息)</p>
<h3 id="udp如何传输文本文件">UDP如何传输文本文件</h3>
<p>在应用层上加入tcp的可靠性传输，<strong>加包号</strong>，接收方对包号进行检查，滑动窗口机制（发送文件的数据量）和拥塞机制（发送方速度）</p>
<h3 id="udp为什么有边界">UDP为什么有边界</h3>
<p>udp基于数据报，一个数据报必须作为一条单独的消息发送，即使接收端连续收到两条消息，应用程序也必须要通过两次读取才行，所以就有了边界。</p>
<h3 id="请你说一说http协议">请你说一说HTTP协议</h3>
<p>HTTP是超文本传输协议的简称。定义了客户机如何从服务器获取web页面的请求协议，以及web服务器如何把web页面传送给客户机。HTTP采用了请求响应模型，客户机发送一个请求报文，请求报文内容 为：首先第一行为请求类型，有get head post , URL 和 协议版本，接着是请求头部信息，key-value形式组成，然后空行接请求主题。响应报文的内容为：协议版本 和 应答状态号及对应的描述，接着是响应头部信息，空行和响应主体信息。</p>
<p>HTTP有如下特点：</p>
<ol type="1">
<li>简单快速：从上述描述可以看出报文结构简单。由于HTTP协议简单，使得HTTP 服务器的程序规模小，因而通信速度很快。</li>
<li>无连接：是指每次请求响应完毕后就关闭连接，这样可以避免一个客户机一直占用端口</li>
<li>灵活：可以传输任意类型的数据，使用 cotent-type来描述</li>
<li>无状态：无状态是指HTTP协议对于事务处理没有记忆能力。缺少状 态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接 传送的数据量增大，优点是，在服务器不需要先前信息时它的应答就较快</li>
<li>使用80端口，TCP/IP协议传输</li>
<li>支持C/S B/S模式</li>
</ol>
<p>一个使用HTTP的例子如下：</p>
<ol type="1">
<li>在浏览器输入URL，本地浏览器首先使用DNS协议向根域名服务器获取域名对应的IP地址（也有可能本地有缓存就不需要像服务器获取）</li>
<li>获取到服务器IP地址后，根据IP地址和80端口，和服务器建立TCP连接</li>
<li>浏览器发送读取文件的HTTP请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器</li>
<li>服务端获取到请求报文后，将对应的HTML文本发送给浏览器</li>
<li>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接; 若connection 模式为keepalive，则 该连接会保持一段时间，在该时间内可以继续接收请求;<br />
</li>
<li>浏览器解析响应报文 显示收到的html内容</li>
</ol>
<h3 id="get-和-post的区别">GET 和 POST的区别</h3>
<p>本质上说，GET 适用于从服务端读取数据，而POST用于更新服务端的数据。GET只需要发送一次请求报文，服务端响应200 ok即可。而POST 则先发送 header，响应 100 continue 后 再发送主要数据，接受200 ok即可。</p>
<p>总的来说二者有如下区别：</p>
<ol type="1">
<li>GET 通过URL 提交数据，把数据放在 url 后，而 POST 放在 HTTP 包体中</li>
<li>GET 使用 URL 所以支持的参数长度有限，且只支持 ascii 编码，而POST没有这个限制</li>
<li>GET 的参数直接暴露在 url 中所以不能用来传递敏感参数，没有POST安全</li>
<li>GET 浏览器会主动缓存get的参数，而Post不会</li>
<li>GET 和 POST 本身并无差别，都是TCP连接, 但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</li>
</ol>
<h3 id="socket编程中服务器端和客户端主要用到哪些函数">socket编程中服务器端和客户端主要用到哪些函数</h3>
<p>(请问你有没有基于做过socket的开发？具体网络层的操作该怎么做)</p>
<ol type="1">
<li>TCP 服务端
<ol type="1">
<li>打开 一个 socket</li>
<li>bind 绑定ip地址和端口号到 socket 上</li>
<li>使用 listen 监听端口</li>
<li>收到连接请求后 使用 accept 函数建立连接</li>
<li>调用 read / write 读取发送数据</li>
</ol></li>
<li>TCP 客户端
<ol type="1">
<li>打开一个 socket</li>
<li>设置要访问的服务器 端口号 和 ip</li>
<li>connect 和主机建立连接</li>
<li>read / write 读取发送数据</li>
<li>close 关闭连接</li>
</ol></li>
<li>UDP 服务端：
<ol type="1">
<li>打开 一个 socket</li>
<li>使用 bilind 绑定要监听的端口</li>
<li>使用 recvfrom 接收客户端的消息<br />
</li>
<li>sendto 发送数据</li>
<li>关闭 close</li>
</ol></li>
<li>UDP 客户端
<ol type="1">
<li>打开一个socket</li>
<li>设置服务器的地址 ip 和 端口</li>
<li>使用sendto 和 recvfrom 向主机发送和接受数据</li>
<li>关闭 close</li>
</ol></li>
</ol>
<p>（socket 的 type 参数 SOCK_STREAM SOCK_DGRAM 表示使用的TCP/UDP协议）</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210422110337.png" alt="image-20210422110337565" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210422110355.png" alt="image-20210422110355685" style="zoom: 33%;" /></p>
<h3 id="selectepoll的区别原理性能限制">select，epoll的区别，原理，性能，限制</h3>
<p>和阻塞式I/O模型一样都会阻塞当前线程，但是多路复用的优点是 可以一次性监视所有socket的变化，通过将文件描述符集合传递到内核，让内核监视所有socket的状态，一旦其中有一个数据准备好就会返回，效率相对 阻塞I/O更高。缺点是 需要进行两次系统调用，一次是 select 一次是 recvfrom。因此当连接数不是很高的话，多线程+阻塞式I/O模型效率反而更高。</p>
<ol type="1">
<li>select : 每次在使用 select 之前要将文件描述符集合 从用户空间拷贝到内核空间，并遍历一遍（在内核空间遍历）如果有就绪的文件，则直接返回；如果没有，根据select设置的超时参数来决定等待多久再返回（如果超时参数为null，为阻塞式，只有当某个文件就绪后才会唤醒该进程，否则就根据超时时间主动返回select），将fd从内核态拷贝到用户空间，然后在应用层轮询遍历找到响应的连接。
<ul>
<li>由于文件描述符集合使用数组实现，因此可处理的最大连接数不是很多（多了也不行因为轮询遍历就会很慢）</li>
<li>需要轮询判断具体哪个文件描述准备就绪，因此连接数多了之后 复杂度多</li>
</ul></li>
<li>poll：相对 select 么有太大的区别，只是将数组换成了链式结构，从而支持同时处理更多的连接了</li>
<li>epoll：解决了上述需要轮询的问题，通过注册回调函数实现，需要监听的文件描述符用一个红黑树维护，当某个事件发生时通过注册的回调函数将响应的文件描述符添加到链表中。因此 不再需要程序轮询遍历。
<ul>
<li>LT：LT模式是指水平触发，支持阻塞和非阻塞模式，内核会告诉你一个文件描述符是否就绪，如果你不进行任何操作，还是会继续通知你。对读比较友好，得到通知后读一次就行不一定非要一次读完所有的数据因为下次还会再同时，但是对写不友好，因为发送缓冲区大部分都是空的，如果你并不想发数据，并且socket一直在监控中他就会一直通知写事件，所以必须保证没有数据要发送的时候把他从监控列表中移除</li>
<li>ET：边缘触发模式，只支持非阻塞，内核在通知你一个文件描述符就绪后，如果你不进行处理，以后不会再通知。这个对读不友好，必须非阻塞的一下读完所有的数据，否则如果没有新增的数据到来，那么之前残留的没读完的数据他也不会再通知了，但是如果一次读的数据过长会带来饥饿问题。</li>
<li>两个模式的优缺点是：ET模式效率更高，减少了epoll 重复触发的次数，但是ET模式下必须使用非阻塞模式的套接口，避免由于一个文件的阻塞读写操作而忽略了其他的响应，因此这种可能会漏处理，需要更严谨的程序逻辑。</li>
</ul></li>
</ol>
<p><strong>select 应用场景</strong> select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。select 可移植性更好，几乎被所有主流平台所支持 <strong>poll 应用场景</strong> poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select <strong>epoll 应用场景</strong> 只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p>
<p>其实 select 不好是因为 内核 是没有记忆的，因此每次都要将 文件 描述符从用户空间向内核空间拷贝，实际中首先管理的文件描述符变动不大，因此没都全盘拷贝做了很多无用功。为了使得内核对我们需要管理的文件描述符有记忆，在内核中新建了一个 eventepoll 文件对象，它是存在内核中的，并且其中维护一个红黑树用于存储所有的文件描述符，用户通过 epoll_ctr 来向它注册要管理的文件描述符。同时还维护一个就绪队列，当某个文件就绪就将它添加到就绪队列中，通过回调函数实现。而用户只用调用 epoll_wait 去访问就绪队列是否为空即可。所以它不用遍历所有管理的文件描述符，也不用每次都要将所有的文件描述符从用户空间拷贝到内核空间。<a href="https://zhuanlan.zhihu.com/p/340666719">参考连接</a></p>
<p>epoll wait 流程：</p>
<ol type="1">
<li>服务器创建非阻塞 socket（server_fd）。</li>
<li>epoll_create 创建 epoll 事件驱动 (epoll_fd)。</li>
<li>epoll_ctl 监控 server_fd 的可读事件 EPOLLIN。</li>
<li>服务进程通过 epoll_wait 获取内核就绪事件处理。</li>
<li>如果就绪事件是新连接，accept 为客户端新连接分配新的文件描述符 client_fd，设置非阻塞，然后 epoll_ctl 监控 client_fd 的可读事件 EPOLLIN。</li>
<li>如果就绪事件不是新连接，read 读取客户端发送数据进行逻辑处理。</li>
<li>处理逻辑过程中需要 write 回复客户端，write 内容很大，超出了内核缓冲区，没能实时发送完成所有数据，需要下次继续发送；那么 epoll_ctl 监控 client_fd 的 EPOLLOUT 可写事件，下次触发事件进行发送。下次触发可写事件发送完毕后， epoll_ctl 删除 EPOLLOUT 事件。</li>
<li>客户端关闭链接，服务端监控客户端 fd，如果 read == 0，close 关闭对应 fd 从而完成四次挥手</li>
</ol>
<h3 id="为什么et一定要非阻塞">为什么ET一定要非阻塞</h3>
<p>阻塞：请求获取资源后，如果没有没有获取到则一直等待 非阻塞：没有获取到则返回为空 如果是 水平触发模式 每次 epoll_wait 后的文件描述符里一定是有东西可以读/写的，因此使用 阻塞的I/O 调用一次 read write 一定不会导致该文件描述符阻塞，而且只读一次都没事，因为是水平触发，你可以只调用一次读，如果此时没读完，下次epoll_wait 他还会再触发，还可以接着读；当然水平触发模式下也可以用非阻塞的方法式，就是 while 循环一直读，直到没有数据返回 erro_block 后退出循环。</p>
<p>但是在边缘触发模式下，只有数据缓冲空到满时会触发一次通知，最后一帧如果没有新增数据那么就不会再通知，所以读的时候必须一下子读完所有的数据 即 while 循环读取所有的数据。但是此时如果你再使用阻塞的IO读，那么最后一帧数据读完后必定阻塞，因为阻塞IO就是如果没数据了就会阻塞读，所以边缘触发模式只能采用非阻塞IO读，最后没有数据了返回ERRO退出while循环</p>
<h3 id="et模式读的饥饿问题">ET模式读的饥饿问题</h3>
<p>解决方法：创建一个描述符队列，通知要读的但还未读的就放入该队列中，定时定量去读，读完则将该描述符移除。</p>
<h3 id="使用linux-epoll模型的lt水平触发模式当socket可写时会不停的触发socket可写的事件如何处理">使用Linux epoll模型的LT水平触发模式，当socket可写时，会不停的触发socket可写的事件，如何处理？</h3>
<p>当需要写出数据时，把数据write到fd中；如果数据较大，无法一次性写出，那么在epoll中监听EPOLLOUT事件 当EPOLLOUT事件到达时，继续把数据write到fd中；如果数据写出完毕，那么在epoll中关闭EPOLLOUT事件</p>
<h3 id="多线程同时操作一个socket问题">多线程同时操作一个socket问题</h3>
<p>设置<strong>EPOLL ONESHOT</strong>标志位，保证一个socket连接在任一时刻只被一个线程处理</p>
<h3 id="tcp-快速重传为什么是三次冗余-ack这个三次是怎么定下来的">TCP 快速重传为什么是三次冗余 ACK，这个三次是怎么定下来的？</h3>
<p>统计概率问题：<strong>只收到两次，一定是乱序；乱序也会造成收到三次ack</strong>，只不过概率小，如果丢包，一定会收到三次。主要的考虑还是要区分包的丢失是由于链路故障还是乱序等其他因素引发。两次duplicated ACK时很可能是乱序造成的！三次duplicated ACK时很可能是丢包造成的！四次duplicated ACK更更更可能是丢包造成的！但是这样的响应策略太慢。丢包肯定会造成三次duplicated ACK! 综上是选择收到三个重复确认时窗口减半效果最好，这是实践经验。</p>
<p>为什么会乱序：负载均衡、路由器流量调整造成的多路径传送</p>
<h3 id="请你来介绍一下udp的connect函数">请你来介绍一下udp的connect函数</h3>
<ol type="1">
<li>因为UDP可以是一对一，多对一，一对多，或者多对多的通信，所以每次调用sendto()/recvfrom()时都必须指定目标IP和端口号。在未建立UDP套接字的上调用connect
<ul>
<li>变成了一对一的连接，可以和TCP一样使用write() / send() 传递数据，而不需要每次都指定目标IP和端口号，写到已连接UDP套接字上的任何内容都自动发送到由connect指定的协议地址。可以给已连接的UDP套接字调用sendto，但是不能指定目的地址。sendto的第五个参数必须为空指针，第六个参数应该为0。</li>
<li>但是它和TCP不同的是它没有三次握手的过程，调用connect只是预先记录了ip地址和端口号；</li>
<li>依然是不可靠传输，如果不调用connnet 那么给同一个目标发送消息 是 连接套接字→发送报文→断开套接字→连接套接字→发送报文→断开套接字 →………效率比较低；connnet 后中间就不会再断开套接字了；连接套接字是需要一定开销的，比如需要查找路由表信息。所以，<strong>UDP 客户端程序通过 connect 可以获得一定的性能提升</strong></li>
<li>在一个已连接UDP套接字上，由内核为输入操作返回的数据报只有那些来自connect指定协议地址的数据报。这样就限制一个已连接UDP套接字能且仅能与一个对端交换数据报</li>
</ul></li>
<li>还可以通过在已建立连接的UDP套接字上，再次调用connect()。TCP套接字只能调用一次connect()函数。
<ul>
<li>指定新的IP地址和端口号</li>
<li>断开连接</li>
</ul></li>
<li>由已连接UDP套接字引发的异步错误会返回给它们所在的进程，而未连接的UDP套接字不接收任何异步错误。</li>
</ol>
<h3 id="arp地址解析协议">ARP地址解析协议</h3>
<p>每个主机都会在自己的工作区建立ARP缓冲区（ARP列表），表示IP地址和MAC地址间的对应关系。（不是永久的，隔一会儿更新，因为IP与MAC的对应关系会变）ARP广播查询目的主机的MAC地址，目的主机ARP单播响应自己的MAC地址收到广播响应时比对是否和自己的IP地址相同，相同则响应，不同则丢弃不管，如果广播主机一直没有收到响应，表示ARP查询失败。本网段有机器中病毒或发生故障，不断发送查询导致网络拥塞RARP 逆地址解析协议 MAC解IP</p>
<h3 id="dhcp协议">DHCP协议</h3>
<p>动态主机配置协议。系统连接到网络上，并获取所需要的配置参数手段。通常被应用在大型的局域网络环境中，主要作用是集中的管理、分配IP地址，使网络环境中的<strong>主机动态的获得IP地址、Gateway地址、DNS服务器地址等信息，并能够提升地址的使用率。</strong></p>
<h3 id="网桥的作用">网桥的作用</h3>
<p>网桥是一个局域网与另一个局域网之间建立连接的桥梁</p>
<h3 id="icmp网络控制报文">ICMP网络控制报文</h3>
<p>Ping 检查两台主机是否网络联通 向目的主机发送<strong>ICMP Echo 请求报文，</strong>目的主机收到后回复<strong>Echo应答报文</strong>，根据时间和成功率计算出主机间的通信时间和丢包率。Traceout 从源主机到目的主机经过的节点路径，发送<strong>IP封装的无法交付的UDP用户数据包</strong>，并由目的主机发送<strong>终点不可达差错报告报文，</strong>TTL由1开始发送，每次累加1，直到收到差错报告报文，即可知从源到目的经过多少路由</p>
<h3 id="ttl-time-to-live-生存时间">TTL (time to live) 生存时间</h3>
<p>表示数据包在网络中的时间，经过一个路由该数据包TTL就减1，这是因为有些路由会形成环，如果没有TTL，那么数据包就会在网络中打转，拥塞网络</p>
<h3 id="网络层和传输层协议的区别">网络层和传输层协议的区别</h3>
<p>网络层用于主机之间的逻辑通信，传输层主要用于进程之间的逻辑通信</p>
<h3 id="应用层和传输层的keep-alive区别">应用层和传输层的keep alive区别</h3>
<p>传输层TCP的 keep alive 用于 探测连接的对端是否存活，如果对端因为网络，死机导致掉线 或者 处于半连接状态 那么都可以通过 保活报文来处理。</p>
<p>HTTP 的keep alive 打开 是指长连接 可以连续发送多个请求 而不用断开连接</p>
<h3 id="请你说一下阻塞非阻塞同步异步">请你说一下阻塞，非阻塞，同步，异步</h3>
<p>阻塞和非阻塞：调用者在事件没有发生的时候，一直在等待事件发生，不能去处理别的任务这是阻塞。调用者在事件没有发生的时候，可以去处理别的任务这是非阻塞。</p>
<p>同步和异步：调用者必须循环自去查看事件有没有发生，这种情况是同步。调用者不用自己去查看事件有没有发生，而是等待着注册在事件上的回调函数通知自己，这种情况是异步</p>
<h3 id="讲述一下socket编程的send-recv-accept-socket函数">讲述一下Socket编程的send() recv() accept() socket()函数</h3>
<ol type="1">
<li>socket 用于创建一个套接字，返回文件描述符。由于一个机器中可能有很多进程都需要使用相同的TCP 或者 UDP 协议发送接收数据，为了区分不同主机中不同进程，将IP 地址 端口号 绑定到 套接字中，就可以唯一区分互联网中两个主机中需要通信的两个进程。</li>
<li>send：用于向 TCP 连接的另一端发送数据，一般客户机用 send 将请求报文发送给服务器，服务器用 send 做应答。调用 send 的时候将用户空间中将要发送的数据写入发送缓冲区，然后使用协议发送。</li>
<li>recv：用于从 TCP 连接的另一端接收数据，等待接收缓冲区中数据接收完毕后，recv函数将缓冲区中的数据读给应用层。</li>
<li>accept：用于接收 TCP 连接，内部会维护一个 半连接队列 和 一个连接完成的队列，如果连接完成队列为空，则阻塞，否则返回队列第一个连接成功的文件描述符。</li>
</ol>
<h3 id="http协议会话结束标志怎么截出来">http协议会话结束标志怎么截出来</h3>
<p>看tcp连接是否有断开的四步挥手阶段</p>
<h3 id="tcpip数据链路层的交互过程">TCP/IP数据链路层的交互过程</h3>
<p>数据链路层通过 MAC 地址作为通信目标，数据包到达网络层准备往数据链路层的时候，首先查找自己的ARP表，查找局域网中的 ip-mac映射关系，如果找到了，就将目标IP的MAC地址封装到数据链路层的数据包的包头， 如果没找到就使用广播的方式在局域网中查找，对应IP地址的设备在收到广播后会以单拨的形式将自己的mac地址回复给请求的机器</p>
<h3 id="ip层怎么知道报文该给哪个应用程序它怎么区分udp报文还是tcp报文">IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文</h3>
<p>端口号 包头协标识字段</p>
<h3 id="server端监听端口但还没有客户端连接进来此时进程处于什么状态">server端监听端口，但还没有客户端连接进来，此时进程处于什么状态</h3>
<p>如果是阻塞式的方式，就处于阻塞状态，如果调用 epoll select poll 这样的 I/O 复用模型，因为需要轮询判断有无响应。是运行状态。</p>
<h3 id="ttl是什么">TTL是什么</h3>
<p>TTL是 Time To Live的缩写，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量</p>
<h3 id="https一定安全嘛">HTTPS一定安全嘛</h3>
<p>不是绝对安全的，可以通过中间人攻击。中间人攻击是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。HTTPS 使用了 SSL 加密协议，是一种非常安全的机制，目前并没有方法直接对这个协议进行攻击，一般都是在建立 SSL 连接时，拦截客户端的请求，利用中间人获取到 CA证书、非对称加密的公钥、对称加密的密钥；有了这些条件，就可以对请求和响应进行拦截和篡改。</p>
<h3 id="客户端断电或网络异常怎么处理">客户端断电或网络异常怎么处理</h3>
<p>TCP keep-alive 借助心跳机制来感知这种状况，一般的做法是，服务端往对端发送一个心跳包并启动一个超时定时器，如果能正确收到对端的回应，说明在线，如果超时，可以进行一系列操作，比如重试、关闭连接等等。</p>
<h3 id="cookies-和-seesion区别">cookies 和 seesion区别</h3>
<p>cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上，通常。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。主要功能是：</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）记录用户信息</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）浏览历史信息</li>
</ul>
<p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息，存储在服务端</p>
<p>Cookie 和 Session 有什么不同</p>
<ul>
<li>作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li>
<li>存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li>
<li>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li>
<li>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie</li>
</ul>
<h3 id="cookies-和-seesion-的关联">cookies 和 seesion 的关联</h3>
<p>SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统根据seesion和cookie来验证用户登录状态。</p>
<p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p>
<p>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p>
<h3 id="cookie-被禁用了怎么用seesion">cookie 被禁用了怎么用seesion</h3>
<p>可以在 URL 中携带 seesion 参数</p>
<h3 id="http接口的幂等性">HTTP接口的幂等性</h3>
<p>幂等性是系统服务对外一种承诺，承诺只要调用接口成功，外部多次调用对系统的影响是一致的。比如在 扣款中 用户如果点击了多次支付，应该只扣一次款。</p>
<p>解决幂等问题可以通过多个角度实现，在客户端 只允许按钮可以被按下一次。在服务端可以使用状态机等，还可以使用token机制，客户端请求时 添加 token 参数，重复的请求token相同，服务端就可以区分了。</p>
<p>https://segmentfault.com/a/1190000020172463</p>
<h3 id="三次握手后最后一次-ack-丢包了会怎样">三次握手后最后一次 ack 丢包了会怎样</h3>
<p>服务端 会根据超时重传机制重新发送 SYN+ACK报文，一定次数后 还没响应就关闭； 客户端在发送第三次响应包后 就进入了 链接状态，他感知不到服务端是否收到最后一次的握手响应，他会向服务端正常发送数据，Server端将以 RST包响应，方能感知到Server的错误。</p>
<h3 id="icmp网路控制报文">ICMP网路控制报文</h3>
<p>Ping 检查两台主机是否网络联通 向目的主机发送<strong>ICMP Echo 请求报文，</strong>目的主机收到后回复<strong>Echo应答报文</strong>，根据时间和成功率计算出主机间的通信时间和丢包率。</p>
<p>Traceout 从源主机到目的主机经过的节点路径，发送<strong>IP封装的无法交付的UDP用户数据包</strong>，并由目的主机发送<strong>终点不可达差错报告报文，</strong>TTL由1开始发送，每次累加1，直到收到差错报告报文，即可知从源到目的经过多少路由</p>
<h3 id="tcp-xxx-攻击">TCP xxx 攻击</h3>
<h3 id="ipv4-和-6-的区别">IPV4 和 6 的区别</h3>
<h3 id="dns解析过程">DNS解析过程</h3>
<h3 id="什么场景下机器产生大量的time_wait有什么影响">什么场景下机器产生大量的time_wait，有什么影响</h3>
<h3 id="dns解析过程以及dns劫持">DNS解析过程以及DNS劫持</h3>
<h3 id="阻塞socket和非阻塞socket的区别">阻塞socket和非阻塞socket的区别</h3>
<h3 id="从局域网访问一个url的整个过程">从局域网访问一个URL的整个过程，</h3>
<p>NAT技术，DNS，ARP协议等</p>
<h3 id="如果有一个包1m怎么分片">如果有一个包1M，怎么分片</h3>
<h3 id="把tcp的头部写出来看看">把TCP的头部写出来看看</h3>
<h3 id="tcp中有一个包丢了怎么重发接收端失序的包放在哪里">TCP中有一个包丢了怎么重发，接收端失序的包放在哪里</h3>
<h3 id="服务端怎么解析http请求">服务端怎么解析http请求</h3>
<h3 id="服务端怎么同时处理多个请求">服务端怎么同时处理多个请求</h3>
<h3 id="socket通信编程需要调用哪些api">socket通信编程需要调用哪些api</h3>
<h4 id="socket发送速度过快会发什么什么">socket发送速度过快会发什么什么</h4>
<h3 id="socket中的eagain错误码">socket中的EAGAIN错误码</h3>
<h3 id="ipv4和ipv6的区别">IPv4和IPv6的区别</h3>
<h3 id="除了selectpollepoll如果让你实现第四种io多路复用你会怎么设计">除了select，poll，epoll，如果让你实现第四种IO多路复用，你会怎么设计</h3>
<h3 id="为了进一步提高并发量客户端可以怎么做服务端可以怎么做">为了进一步提高并发量，<a href="https://www.nowcoder.com/jump/super-jump/word?word=客户端">客户端</a>可以怎么做，服务端可以怎么做</h3>
<h3 id="如果目标服务器被代理服务器劫持会怎么样">如果目标服务器被代理服务器劫持会怎么样</h3>
<h3 id="reactor模型组成">reactor模型组成</h3>
<h3 id="请自己设计一下如何采用单线程的方式处理高并发">请自己设计一下如何采用单线程的方式处理高并发</h3>
<h3 id="包丢了tcp的发送端措施除了重传机制还有别的吗">包丢了，tcp的发送端措施，除了重传机制，还有别的吗</h3>
<h3 id="第一次握手丢失了会怎么办第二次握手丢失了怎么办">第一次握手丢失了会怎么办？第二次握手丢失了怎么办？</h3>
<h3 id="设计可靠udp-效率要比tcp要高">设计可靠udp, 效率要比tcp要高</h3>
<h3 id="说说都了解哪些网络协议我们视频在网络层是怎么实现的">说说都了解哪些网络协议？我们视频在网络层是怎么实现的？</h3>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计算机网络</category>
      </categories>
  </entry>
</search>
