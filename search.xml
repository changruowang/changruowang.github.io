<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>多缓冲多线程代码阅读笔记</title>
    <url>/2021/05/05/C++/%E5%9B%BE%E5%83%8F%E9%A2%84%E5%A4%84%E7%90%86%E7%BB%84%E5%90%88%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>详细阅读了别人项目中的图像预处理pip line 的工程实现，使用到了多缓冲，多线程等知识点。</p>
<span id="more"></span>

<p>注意： 代码中所有的 拷贝构造和 赋值构造都每实现，因此应该避免使用它的场合。例如多线程类，不能使用值传递的方式 (重载 () 的方法)。</p>
<p><code>algorithm.h</code> 文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ALGORITH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALGORITH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////预处理方法////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">预处理方法使用 工厂模式，当要新增预处理方法时，</span></span><br><span class="line"><span class="comment">    1. 需要 继承 AbstractAlgorithm 类，并实现 run 函数，</span></span><br><span class="line"><span class="comment">    2. 在 AlgorithmFactory 中新增算法 id 和 实例化代码</span></span><br><span class="line"><span class="comment">图像预处理的算法参数在 创建对应算法类对象的时候传入类，由 param 保存</span></span><br><span class="line"><span class="comment">模板 T 代表 图像数据类型 例如 cv::Mat 测试的时候使用简单的 string 测试的。 </span></span><br><span class="line"><span class="comment">P 为算法参数的类型 默认 void* 指针。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> P&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractAlgorithm</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="built_in">AbstractAlgorithm</span>(): <span class="built_in">time</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">AbstractAlgorithm</span>(P p): <span class="built_in">param</span>(p), <span class="built_in">time</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">        <span class="built_in">AbstractAlgorithm</span>(P p, <span class="keyword">int</span> t): <span class="built_in">param</span>(p), <span class="built_in">time</span>(t)&#123;&#125;;</span><br><span class="line">        <span class="built_in">AbstractAlgorithm</span>(<span class="keyword">const</span> AbstractAlgorithm&amp; alg) = <span class="keyword">delete</span>;</span><br><span class="line">        AbstractAlgorithm&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> AbstractAlgorithm&amp; alg) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getRunTime</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> time;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> T <span class="title">run</span><span class="params">(T&amp; input)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Delay</span><span class="params">()</span></span>&#123; </span><br><span class="line">            <span class="keyword">clock_t</span> now = <span class="built_in">clock</span>(); </span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">clock</span>()-now &lt; time); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> time;</span><br><span class="line">        P param;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> P&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqReadAlgorithm</span>:</span> <span class="keyword">public</span> AbstractAlgorithm&lt;T, P&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> frame_cnt = <span class="number">0</span>;</span><br><span class="line">        vector&lt;T&gt; data_buff;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">SeqReadAlgorithm</span>(P p): AbstractAlgorithm&lt;T, P&gt;(p, <span class="number">5</span>)&#123;</span><br><span class="line">            frame_cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++)</span><br><span class="line">                data_buff.<span class="built_in">push_back</span>(<span class="string">&quot;frame: &quot;</span> + std::<span class="built_in">to_string</span>(i) + <span class="string">&quot; param: &quot;</span> + (<span class="keyword">char</span>*)<span class="keyword">this</span>-&gt;param);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function">T <span class="title">run</span><span class="params">(T&amp; input)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(frame_cnt &gt;= <span class="number">500</span>)  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">Delay</span>();</span><br><span class="line">            T ans = data_buff[frame_cnt++];</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> P&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnhanceAlgorithm</span>:</span> <span class="keyword">public</span> AbstractAlgorithm&lt;T,P&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">EnhanceAlgorithm</span>(P p): AbstractAlgorithm&lt;T,P&gt;(p, <span class="number">5</span>)&#123;&#125;;</span><br><span class="line">        <span class="function">T <span class="title">run</span><span class="params">(T&amp; input)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">Delay</span>();</span><br><span class="line">            T ans = input + <span class="string">&quot; Enhancement&quot;</span> + <span class="string">&quot; param: &quot;</span> + <span class="built_in">to_string</span>(*(<span class="keyword">int</span>*)<span class="keyword">this</span>-&gt;param);</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> P&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DenoiseAlgorithm</span>:</span> <span class="keyword">public</span> AbstractAlgorithm&lt;T,P&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">DenoiseAlgorithm</span>(P p): AbstractAlgorithm&lt;T,P&gt;(p,<span class="number">5</span>)&#123;&#125;;</span><br><span class="line">        <span class="function">T <span class="title">run</span><span class="params">(T&amp; input)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">Delay</span>();</span><br><span class="line">            T ans = input + <span class="string">&quot; Denoise&quot;</span> + <span class="string">&quot; param: &quot;</span> + <span class="built_in">to_string</span>(*(<span class="keyword">float</span>*)<span class="keyword">this</span>-&gt;param);</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> P&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlgorithmFactory</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">AlgorithmFactory</span>()&#123;&#125;;</span><br><span class="line">        AbstractAlgorithm&lt;T, P&gt;* createAlgorim(int type, P parma)&#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (type)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SeqReadAlgorithm&lt;T,P&gt;(parma);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> EnhanceAlgorithm&lt;T,P&gt;(parma);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> DenoiseAlgorithm&lt;T,P&gt;(parma);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>safeQueue.h</code> 文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SAFE_QUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAFE_QUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// ////////////////////////// 线程安全的数据队列 /////////////////////////////</span></span><br><span class="line"><span class="comment">// 只是简单的实现了线程安全的队列，可以优化的地方很多  例如缓冲区数据满后 自动休眠，取数据空后自动休眠</span></span><br><span class="line"><span class="comment">// T 是队列数据类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeMatList</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SafeMatList</span>(<span class="keyword">int</span> sz): <span class="built_in">max_sz</span>(sz)&#123;&#125;;</span><br><span class="line">    <span class="function">T <span class="title">getItem</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>; </span><br><span class="line">        T ans = m_queue.<span class="built_in">front</span>();</span><br><span class="line">        m_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushItem</span><span class="params">(T&amp; data)</span></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>; </span><br><span class="line">        m_queue.<span class="built_in">push</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>; </span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>() &gt;= max_sz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>; </span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>() &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> max_sz;</span><br><span class="line">    std::queue&lt;T&gt; m_queue;</span><br><span class="line">    std::mutex mtx_; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>prepocessThread.h</code> 文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PREPOCESS_THREAD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREPOCESS_THREAD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;safeQueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;algorithm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////使用多线程类对预处理算法包装////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将多个图像预处理算法封装在一个线程类中，按照穿行的方式执行这些算法。新增算法也无须修改该类的代码</span></span><br><span class="line"><span class="comment">类中有三个主要的数据结构，一个是 封装的预处理算法 基类指针 数组，一个是待处理图像队列，另一个是处理就绪的队列指针；</span></span><br><span class="line"><span class="comment">在 run 函数中首先从 待处理队列中获取一个图像，然后串行调用预处理算法，将最后一个算法生成的结果保存在就绪队列中。</span></span><br><span class="line"><span class="comment">由于一个系统中可能有多个多种预处理算法，例如图像去噪，增强，矫正等，每种算法耗时不同，如果每个算法一个线程，对于耗时很短的算法，</span></span><br><span class="line"><span class="comment">会常常在休眠和运行态切换，带来不必要的系统开销，因此我们采用分组多线的形式，即使用一个线程类包装一个或多个算法，尽可能使得每个</span></span><br><span class="line"><span class="comment">线程组的算法运行总耗时接近。</span></span><br><span class="line"><span class="comment">由于线程类对象的构建采用一个单例的生成器构建，使用这个单例生成器首先将算法id列表划分为多个算法组，并实例化线程类，每个线程类包装</span></span><br><span class="line"><span class="comment">一个算法组，实例化的所有线程类都由这个生成器统一管理。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> P&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstrctThreadAlg</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vector&lt;AbstractAlgorithm&lt;T, P&gt;*&gt; list_algs;</span><br><span class="line">        SafeMatList&lt;T&gt;* m_pFinishQueue;</span><br><span class="line">        <span class="comment">// 构造函数 给数据缓冲区分分配内存</span></span><br><span class="line">        <span class="built_in">AbstrctThreadAlg</span>(<span class="keyword">int</span> sz, SafeMatList&lt;T&gt;* pre_queue): <span class="built_in">m_pReadyQueue</span>(pre_queue)&#123;</span><br><span class="line">            m_pFinishQueue = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(sz &gt; <span class="number">0</span>)</span><br><span class="line">                m_pFinishQueue = <span class="keyword">new</span> SafeMatList&lt;T&gt;(sz);</span><br><span class="line">        &#125; </span><br><span class="line">        ~<span class="built_in">AbstrctThreadAlg</span>()&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list_algs.<span class="built_in">size</span>(); i++) <span class="keyword">delete</span> list_algs[i];</span><br><span class="line">            <span class="keyword">if</span>(m_pFinishQueue != <span class="literal">nullptr</span>)   <span class="keyword">delete</span> m_pFinishQueue;</span><br><span class="line">            m_pFinishQueue = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">AbstrctThreadAlg</span>(<span class="keyword">const</span> AbstrctThreadAlg&amp; threadAlg) = <span class="keyword">delete</span>;</span><br><span class="line">        AbstrctThreadAlg&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> AbstrctThreadAlg&amp; threadAlg) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果 输入数据缓冲队列指针为 空，则不读数据，这就需要列表的第一个 alg 为读图的程序</span></span><br><span class="line">            <span class="keyword">if</span>(!m_pReadyQueue)  cout &lt;&lt; <span class="string">&quot;This thread does&#x27;t have input data queue!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// 如果 输出数据缓冲队列指针为 空，则不往缓冲区中存储数据</span></span><br><span class="line">            <span class="keyword">if</span>(!m_pFinishQueue)  cout &lt;&lt; <span class="string">&quot;This thread does&#x27;t have out data queue!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                T input_data;</span><br><span class="line">                <span class="comment">// 输入缓冲区数据空，就等待，直到取出数据</span></span><br><span class="line">                <span class="keyword">if</span>(m_pReadyQueue)&#123;  </span><br><span class="line">                    <span class="keyword">while</span>(m_pReadyQueue-&gt;<span class="built_in">empty</span>());</span><br><span class="line">                    input_data = std::<span class="built_in">move</span>(m_pReadyQueue-&gt;<span class="built_in">getItem</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 串行执行该线程中的算法</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;it : list_algs)</span><br><span class="line">                    input_data = std::<span class="built_in">move</span>(it-&gt;<span class="built_in">run</span>(input_data));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 输出缓冲区数据满了 就等待，直到有存储的位置</span></span><br><span class="line">                <span class="keyword">if</span>(m_pFinishQueue)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(m_pFinishQueue-&gt;<span class="built_in">full</span>());</span><br><span class="line">                    m_pFinishQueue-&gt;<span class="built_in">pushItem</span>(input_data);</span><br><span class="line">                &#125;        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        SafeMatList&lt;T&gt;* m_pReadyQueue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程类的生成器  新增算法时 不需要修改该部分代码，不过可以考虑。这个类默认的算法参数是  void* 类型，以下方面可以优化</span></span><br><span class="line"><span class="comment">1. 优化build函数，使用均衡分组方法，保证每个线程上的任务耗时接近</span></span><br><span class="line"><span class="comment">2. 优化 模板类 使得 算法参数类型 不一定非得是 void* 类型  （现在的做法是在 算法函数中 将 void* 指针强转）</span></span><br><span class="line"><span class="comment">3. ...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrepocessTaskSingleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    ~<span class="built_in">PrepocessTaskSingleton</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;alg : m_pThreadAlgs)    <span class="keyword">delete</span> alg;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/* 增加  用到的预处理算法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_Algorm</span><span class="params">(<span class="keyword">int</span> alg_id, <span class="keyword">void</span>* p)</span></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        alg_pairs.<span class="built_in">push_back</span>(&#123;alg_id, (<span class="keyword">void</span>*)(p)&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/* 设置 某个线程的队列大小 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDataSize</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= thread_num) <span class="keyword">return</span>;</span><br><span class="line">        data_size[i] = n;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/* 获取 某个线程的队列大小 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDataSize</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= thread_num) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> data_size[i];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/* 获取 某个线程的结果队列地址 */</span></span><br><span class="line">    <span class="function">SafeMatList&lt;T&gt;* <span class="title">getResultQueue</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m_pThreadAlgs.<span class="built_in">size</span>())   <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> m_pThreadAlgs[i];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/*构建多线程对象 默认第一个线程的读取数据队列指针为 nullptr, 该线程的第一个算法需要是读取序列图像类似的算法</span></span><br><span class="line"><span class="comment">      也可以设置 输入数据缓冲队列地址。采用等数量划分算法组的方法， 不好 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(SafeMatList&lt;T&gt;* q_in = <span class="literal">nullptr</span>)</span></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>;</span><br><span class="line"></span><br><span class="line">        SafeMatList&lt;T&gt;* pQueue = q_in;  </span><br><span class="line">        <span class="keyword">int</span> N = alg_pairs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> per = N / thread_num + (N%thread_num ? <span class="number">1</span> :<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thread_num; i++)&#123;</span><br><span class="line">            vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">void</span>*&gt;&gt; p;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i*per; j &lt; <span class="built_in">min</span>((i+<span class="number">1</span>)*per, N); j++)</span><br><span class="line">                p.<span class="built_in">push_back</span>(alg_pairs[j]);</span><br><span class="line"></span><br><span class="line">            pQueue = <span class="built_in">per_threadContrust</span>(p, pQueue, data_size[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/* 开启多线程 运行*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        vector&lt;std::thread&gt; tasks;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; algs : m_pThreadAlgs)</span><br><span class="line">            tasks.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(AbstrctThreadAlg&lt;T, <span class="keyword">void</span>*&gt;::run, algs));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t : tasks)</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/*获取 构造器*/</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> PrepocessTaskSingleton&lt;T&gt;* <span class="title">getPrepocessBuilder</span><span class="params">(<span class="keyword">int</span> nth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleBuilder != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> singleBuilder;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(singleBuilder == <span class="literal">nullptr</span>)</span><br><span class="line">            singleBuilder = <span class="keyword">new</span> PrepocessTaskSingleton&lt;T&gt;(nth);</span><br><span class="line">        <span class="keyword">return</span> singleBuilder;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">PrepocessTaskSingleton</span>(<span class="keyword">int</span> n): <span class="built_in">thread_num</span>(n) &#123;</span><br><span class="line">        <span class="comment">/* 初始化的时候 默认 每个线程的数据缓冲队列大小为 3 最后一个线程的缓冲队列大小为 0，大小为 0 表明不存储生成的结果*/</span> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; thread_num<span class="number">-1</span>; i++)</span><br><span class="line">            data_size.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">        data_size.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">SafeMatList&lt;T&gt;* <span class="title">per_threadContrust</span><span class="params">(vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">void</span>*&gt;&gt;&amp; aps, SafeMatList&lt;T&gt;* data_queu, <span class="keyword">int</span> sz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = <span class="keyword">new</span> AbstrctThreadAlg&lt;T, <span class="keyword">void</span>*&gt;(sz, data_queu);</span><br><span class="line">        m_pThreadAlgs.<span class="built_in">push_back</span>(p);</span><br><span class="line">        AlgorithmFactory&lt;T, <span class="keyword">void</span>*&gt; algorithm_creator;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ap : aps)</span><br><span class="line">            p-&gt;list_algs.<span class="built_in">push_back</span>(algorithm_creator.<span class="built_in">createAlgorim</span>(ap.first, ap.second));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p-&gt;m_pFinishQueue;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> std::mutex mtx_;  <span class="comment">// 保证线程安全</span></span><br><span class="line">    <span class="keyword">static</span> PrepocessTaskSingleton&lt;T&gt;* singleBuilder;   <span class="comment">// 单例模式 返回实例化的对象 </span></span><br><span class="line">    vector&lt;AbstrctThreadAlg&lt;T, <span class="keyword">void</span>*&gt;*&gt; m_pThreadAlgs; <span class="comment">// 用于管理 实例化的所有线程类</span></span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">void</span>*&gt;&gt; alg_pairs;                <span class="comment">// 用于存储输入的算法 id 和 对应的参数地址</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; data_size;                             <span class="comment">// 用于存储 每个线程 的缓冲数据队列的 大小</span></span><br><span class="line">    <span class="keyword">int</span> thread_num;                                    <span class="comment">// 生成的线程数量 </span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>main.cpp</code> 测试文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;algorithm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;prepocessThread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员变量 这个初始化 必须有，因为静态成员变量在初始化的时候分配内存</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">PrepocessTaskSingleton&lt;T&gt;* PrepocessTaskSingleton&lt;T&gt;::singleBuilder = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::mutex PrepocessTaskSingleton&lt;T&gt;::mtx_;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> builder= PrepocessTaskSingleton&lt;string&gt;::<span class="built_in">getPrepocessBuilder</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* alg0_param = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="string">&quot;dir&quot;</span>);</span><br><span class="line">    builder-&gt;<span class="built_in">add_Algorm</span>(<span class="number">0</span>, alg0_param);   <span class="comment">//增加一个 预处理方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> alg1_param = <span class="number">0</span>;</span><br><span class="line">    builder-&gt;<span class="built_in">add_Algorm</span>(<span class="number">1</span>, &amp;alg1_param);  <span class="comment">//增加一个 预处理方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> alg2_param = <span class="number">2.1</span>;</span><br><span class="line">    builder-&gt;<span class="built_in">add_Algorm</span>(<span class="number">2</span>, &amp;alg2_param);  <span class="comment">//增加一个 预处理方法</span></span><br><span class="line"></span><br><span class="line">    builder-&gt;<span class="built_in">build</span>();  <span class="comment">// 构建  算法分组，并使用多个线程类包装  </span></span><br><span class="line">    builder-&gt;<span class="built_in">run</span>();    <span class="comment">// 运行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>应用</tag>
        <tag>多线程</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池代码解析</title>
    <url>/2021/05/01/C++/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>网上大佬用 C++11 写的线程池代码，和自己的阅读笔记</p>
<span id="more"></span>

<p>代码中有很多<code>c11</code>新增的高级操作， <a href="./%E5%BA%93%E5%87%BD%E6%95%B0/bind_function.md">配合笔记</a> 一起理解</p>
<p><code>ThreadPool</code>.h 头文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 版的 线程池</span></span><br><span class="line"><span class="keyword">namespace</span> zl</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadsGuard</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">ThreadsGuard</span>(std::vector&lt;std::thread&gt;&amp; v)</span><br><span class="line">            : <span class="built_in">threads_</span>(v)</span><br><span class="line">        &#123;      </span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">ThreadsGuard</span>()</span><br><span class="line">        &#123;   <span class="comment">// join 需要等到所有线程运行完毕，才能退出析构函数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != threads_.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (threads_[i].<span class="built_in">joinable</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    threads_[i].<span class="built_in">join</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">ThreadsGuard</span>(ThreadsGuard&amp;&amp; tg) = <span class="keyword">delete</span>;</span><br><span class="line">        ThreadsGuard&amp; <span class="keyword">operator</span> = (ThreadsGuard&amp;&amp; tg) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ThreadsGuard</span>(<span class="keyword">const</span> ThreadsGuard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        ThreadsGuard&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> ThreadsGuard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::vector&lt;std::thread&gt;&amp; threads_;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; task_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> n = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">ThreadPool</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stop</span>();</span><br><span class="line">            cond_.<span class="built_in">notify_all</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">            stop_.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Function</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">        std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="built_in">Function</span>(Args...)&gt;::type&gt; <span class="built_in">add</span>(Function&amp;&amp;, Args&amp;&amp;...);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">ThreadPool</span>(ThreadPool&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        ThreadPool&amp; <span class="keyword">operator</span> = (ThreadPool&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        <span class="built_in">ThreadPool</span>(<span class="keyword">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        ThreadPool&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> ThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::atomic&lt;<span class="keyword">bool</span>&gt; stop_;       <span class="comment">// 将值做了一遍封装，使得这个值的访问不会导致数据竞争</span></span><br><span class="line">        std::mutex mtx_;               <span class="comment">// 互斥锁用于对任务队列互斥访问</span></span><br><span class="line">        std::condition_variable cond_; <span class="comment">// 条件变量 在测试条件的时候要先加锁 确保完全进入 wait 状态后再释放锁，然后再安心接收条件，免得还没wait呢，发了一个唤醒信号，就丢了。</span></span><br><span class="line"></span><br><span class="line">        std::queue&lt;task_type&gt; tasks_;</span><br><span class="line">        std::vector&lt;std::thread&gt; threads_;</span><br><span class="line">        zl::ThreadsGuard tg_;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">        : stop_(false)</span></span><br><span class="line"><span class="function">        , tg_(threads_)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> nthreads = n;</span><br><span class="line">        <span class="keyword">if</span> (nthreads &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nthreads = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">            nthreads = (nthreads == <span class="number">0</span> ? <span class="number">2</span> : nthreads);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 1. 构造函数，n 设置线程池中的线程数目。构造函数中，首先开启了n个线程，线程池其实就是 std::vector&lt;std::thread&gt; 的一个数组，每个线程的函数都在干同一件事：等待条件，如果条件成立，就从任务队列中取出一个任务执行。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != nthreads; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            threads_.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>([<span class="keyword">this</span>]&#123;</span><br><span class="line">                <span class="keyword">while</span> (!stop_.<span class="built_in">load</span>(std::memory_order_acquire))</span><br><span class="line">                &#123;</span><br><span class="line">                    task_type task;</span><br><span class="line">                    &#123;   <span class="comment">// 这个 大括号至关重要，表明这是一个 操作临界区的部分代码，因为使用了 unique_lock，当退出这个临界区代码，unique_lock 会自动调用析构函数解锁。然后接着执行 task 任务，在执行task 任务期间并不需要上锁，只有从队列取出任务的过程需要上锁</span></span><br><span class="line">                        <span class="comment">// 使用 unique_lock 对互斥锁进行封装，有自动上锁和解锁的功能，析构函数中解锁。 task() 退出函数后自动解锁</span></span><br><span class="line">                        std::unique_lock&lt;std::mutex&gt; <span class="built_in">ulk</span>(<span class="keyword">this</span>-&gt;mtx_);</span><br><span class="line">                        <span class="comment">// 当任务队列为空的时候的等待  或者不是stop_模式的时候等待，如果是stop模式，不等待直接退出</span></span><br><span class="line">                        <span class="keyword">this</span>-&gt;cond_.<span class="built_in">wait</span>(ulk, [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> stop_.<span class="built_in">load</span>(std::memory_order_acquire) || !<span class="keyword">this</span>-&gt;tasks_.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">                        <span class="keyword">if</span> (stop_.<span class="built_in">load</span>(std::memory_order_acquire))</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        <span class="comment">// 函数的返回值是一个临时右值，使用 move 直接高效的转移给 task  （当调用的函数返回的是引用的时候，实际返回的是左值，当值返回时，返回的是右值。这里使用的move 无论 front() 返回的是左值还是右值都被转换成了右值）</span></span><br><span class="line">                        task = std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks_.<span class="built_in">front</span>());</span><br><span class="line">                        <span class="keyword">this</span>-&gt;tasks_.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">task</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 2. 增加任务的函数，任务队列 tasks_ 实际是一个 function 类型的队列。result_of 用于获取输入函数fcn的返回类型</span></span><br><span class="line"><span class="comment">// 3. future 是 创建packge_task后的返回值，用于异步获取调用结果 </span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Function</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">    std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="built_in">Function</span>(Args...)&gt;::type&gt;</span><br><span class="line">        ThreadPool::<span class="built_in">add</span>(Function&amp;&amp; fcn, Args&amp;&amp;... args)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 4. std::result_of&lt;Function(Args...)&gt;::type 中的 type 实际是类的一个成员，前面的 typename 告诉编译器将这个成员当作类型名称。所以 最终 return_type 就是一个类型名称。</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">Function</span>(Args...)&gt;::type return_type;</span><br><span class="line"><span class="comment">// 5. 加入 return_type 是 int 型 那么这句话相当于申明了一个  std::packaged_task&lt;int()&gt; 型的类，他就可以包装 返回值为 int 的可调用对象。进而使用它的返回值 future 实现异步读取执行结果的功能</span></span><br><span class="line">        <span class="keyword">typedef</span> std::packaged_task&lt;<span class="built_in">return_type</span>()&gt; task;</span><br><span class="line"><span class="comment">// 6. 由于前面申明的只是一个 int() 型的 package_task 类型，但是输入函数还有参数，因此先用 bind 绑定可执行对象和参数，形成一个不带输入参数的新的可调用对象，这里只是用智能指针管理。</span></span><br><span class="line">        <span class="comment">// 将可调用函数 fcn 和 对应的参数 args 绑定成一个仿函数。会隐式的转换成函数指针  std::forward用于完美转发</span></span><br><span class="line">        <span class="comment">// 将该函数指针用 share_ptr 智能指针管理 </span></span><br><span class="line">        <span class="keyword">auto</span> t = std::make_shared&lt;task&gt;(std::<span class="built_in">bind</span>(std::forward&lt;Function&gt;(fcn), std::forward&lt;Args&gt;(args)...));</span><br><span class="line"><span class="comment">// 7. 获取package_task的返回值，是 future对象 </span></span><br><span class="line">        <span class="keyword">auto</span> ret = t-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">// 8. 要向任务队列中添加任务的时候先上锁，这里用 lock_guard 来管理 互斥锁 在退出大括号的作用域后，可以自动解锁</span></span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (stop_.<span class="built_in">load</span>(std::memory_order_acquire))</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;thread pool has stopped&quot;</span>);</span><br><span class="line"><span class="comment">// 9. 这里之所以还要用 lambad函数封一层，是因为 t 是 package_task 类型的对象，可以执行，但是  不同的 输入fcn 可能有不同的 返回值类型，例如按照前面假设的这里就是 package_task&lt;int()&gt; 类型。因此 为了更通用，这里用 lambda 函数封一遍 统一都是 function&lt;void(void)&gt;类型了。但是这里不用 package_task封了，因为 这里的 lambda 没返回值，不用future来异步获取结果。   </span></span><br><span class="line">            tasks_.<span class="built_in">emplace</span>([t]&#123;(*t)(); &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        cond_.<span class="built_in">notify_one</span>();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">/* THREAD_POOL_H */</span></span></span><br></pre></td></tr></table></figure>

<p><code>main</code>文件使用例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ThreadPool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        zl::ThreadPool tp;</span><br><span class="line">        std::vector&lt;std::future&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">        std::vector&lt;std::future&lt;<span class="keyword">void</span>&gt;&gt; v1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> ans = tp.<span class="built_in">add</span>([](<span class="keyword">int</span> answer) &#123; <span class="keyword">return</span> answer; &#125;, i);</span><br><span class="line">            v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(ans));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">auto</span> ans = tp.<span class="built_in">add</span>([&amp;mtx](<span class="keyword">const</span> std::string&amp; str1, <span class="keyword">const</span> std::string&amp; str2)</span><br><span class="line">            &#123;</span><br><span class="line">                std::lock_guard&lt;std::mutex&gt; <span class="built_in">lg</span>(mtx);</span><br><span class="line">                std::cout &lt;&lt; (str1 + str2) &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;, <span class="string">&quot;hello &quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">            v1.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(ans));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lg</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            cout &lt;&lt; v[i].<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            v1[i].<span class="built_in">get</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (std::exception&amp; e)&#123;</span><br><span class="line">        std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>应用</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2021/04/24/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<span id="more"></span> 

<h2 id="Linux-环境设置问题"><a href="#Linux-环境设置问题" class="headerlink" title="Linux 环境设置问题"></a>Linux 环境设置问题</h2><h3 id="找不到动态库的问题"><a href="#找不到动态库的问题" class="headerlink" title="找不到动态库的问题"></a>找不到动态库的问题</h3><p>在编译或者运行的时候提示 找不到 xx.so库</p>
<ul>
<li>LD_LIBRARY_PATH  设置运行时查找动态库的路径</li>
<li>LIBRARY_PATH  设置编译时查找动态库的路径</li>
</ul>
<p>首先查找.so文件的位置  sudo find / -name libxx.so；将查找到的.so路径添加到   LD_LIBRARY_PATH  或者 LIBRARY_PATH  环境变量中即可。</p>
<p>永久的设置，可以在 home目录下的 .bashrc中 增加  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LIBRARY_PATH&#x3D;&#x2F;mnt&#x2F;Softwares&#x2F;fftw-3.3.8&#x2F;build&#x2F;lib</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;opencv2&#x2F;lib:&#x2F;mnt&#x2F;Softwares&#x2F;fftw-3.3.8&#x2F;build&#x2F;lib</span><br><span class="line"></span><br><span class="line">source .bashrc  </span><br></pre></td></tr></table></figure>

<h3 id="Linux文件编码转换"><a href="#Linux文件编码转换" class="headerlink" title="Linux文件编码转换"></a>Linux文件编码转换</h3><ol start="3">
<li>将当前目录下所有的 cpp 文件转化为utf-8 编码   enca -x utf-8 *.cpp    （linux 以及qt默认的编码是utf8）</li>
<li>将某路径下所有文件由 GBK 转码为 UTF-8<br> find $PWD -type f -exec sh -c “iconv -f GBK -t UTF-8 {}  &gt; ~/temp” ; -exec mv ~/temp {} ;</li>
</ol>
<h3 id="Linux进程操作"><a href="#Linux进程操作" class="headerlink" title="Linux进程操作"></a>Linux进程操作</h3><p>清除用户所有进程  pkill -u changruowang</p>
<h3 id="tensorflow可视化"><a href="#tensorflow可视化" class="headerlink" title="tensorflow可视化"></a>tensorflow可视化</h3><p>在本地主机查看远程服务器的tensorboard  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -L 16013:127.0.0.1:6013 changruowang@115.156.213.131   (115.156.213.131为远程服务器ip)</span><br></pre></td></tr></table></figure>

<p>linux下直接使用python启动tensorboard</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m tensorboard.main --logdir  /mnt2/changruowang/image_enhance/myKinD/log_dir</span><br></pre></td></tr></table></figure>

<p>查看tensorflow是否安装成功   import tensorflow as tf   tf.Session()</p>
<h3 id="conda-相关操作"><a href="#conda-相关操作" class="headerlink" title="conda 相关操作"></a>conda 相关操作</h3><ol>
<li>创建新环境  conda create -n name python=3.7</li>
<li>激活环境  source activate name</li>
<li>退回到base环境  conda deactivate </li>
<li>清除环境 conda remove -n name –all</li>
<li>查看所有的虚拟环境  conda info –env</li>
<li>查看当前环境下所有的包  conda list</li>
<li>清除缓存 conda clean -t     /   conda clean -p     /  ….</li>
<li>在用户home路径下的  .bashrc 中 添加conda安装的环境变量，以及CUDA的路径</li>
</ol>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p>查看gpu占用   nvidia -smi   </p>
<p>查看CUDA版本    nvcc -V</p>
<p>查看文件具体信息   ll</p>
<p>将qt-designer的 .ui文件转为py</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyuic5 -o mainwindow_.py mainwindow.ui    (.ui为qt设计师的文件)</span><br></pre></td></tr></table></figure>

<p>markdown转word</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pandoc -f markdown -t docx .&#x2F;其他.md -o test.docx</span><br></pre></td></tr></table></figure>

<h2 id="git-hub-使用"><a href="#git-hub-使用" class="headerlink" title="git hub  使用"></a>git hub  使用</h2><ol>
<li><p>首先在远程创建一个工程，按照工程下的提示在本地该工程的文件夹下打开git bash按顺序输入(其中有和远程库关联的步骤，必须输入)</p>
</li>
<li><p>git init         在当前文件夹下创建一个git 仓库管理该文件夹下的工程</p>
</li>
<li><p>git add .      表示将所有文件提交到监控区域  则有文件改动都会被记录</p>
</li>
<li><p>git commit -m “inform”   提交当前改动</p>
</li>
<li><p>git push        将代码提交到git hub 远程仓库     <strong>不要在浏览器上随意删除已经提交了的文件，否则本地的记录和云端的记录不一致再次提交会报错，所有对文件的修改最好只在本地修改让后上传云端</strong></p>
<p><strong>空文件夹不会被add添加 只有里面有文件才会被add   .gitignore文件可以选择push时忽略的文件</strong></p>
</li>
<li><p>在新的机子上生成 公钥  ssh-keygen -C“ <a href="mailto:&#x63;&#x68;&#x61;&#x6e;&#x67;&#114;&#x75;&#111;&#119;&#x61;&#x6e;&#103;&#x40;&#x71;&#113;&#46;&#99;&#111;&#109;">&#x63;&#x68;&#x61;&#x6e;&#x67;&#114;&#x75;&#111;&#119;&#x61;&#x6e;&#103;&#x40;&#x71;&#113;&#46;&#99;&#111;&#109;</a>” 然后在用户目录下 把生成的id_rsa.pub文件中的东西粘贴添加到 网页版github账户的列表中 这样本地可以访问远程github仓库了</p>
</li>
<li><p>使用 git clone https… 形式的连接，提示错误，要将 http /  https 代理关闭 </p>
<blockquote>
<p>fatal: unable to access ‘<a href="https://github.com/hexojs/hexo-starter.git/&#39;">https://github.com/hexojs/hexo-starter.git/&#39;</a>: Failed to connect to 127.0.0.1 port 1080: Connection refused</p>
<p>git config –global –unset http.proxy</p>
<p>git config –global –unset https.proxy</p>
</blockquote>
</li>
</ol>
<h2 id="Latex-语法"><a href="#Latex-语法" class="headerlink" title="Latex 语法"></a>Latex 语法</h2><p>\citeauthor{}     引用作者 xx at al<br>\cite{}                只显示序号<br>\part                 新的段落<br>\ref{}                 引用图片</p>
<h2 id="麒麟系统环境配置"><a href="#麒麟系统环境配置" class="headerlink" title="麒麟系统环境配置"></a>麒麟系统环境配置</h2><ol>
<li>源码安装 cmake  g++ </li>
<li>.run  </li>
<li>dus   <a href="https://blog.csdn.net/u010168781/article/details/89681674">https://blog.csdn.net/u010168781/article/details/89681674</a>   <a href="https://blog.csdn.net/weixin_41910427/article/details/82733265">https://blog.csdn.net/weixin_41910427/article/details/82733265</a></li>
<li>运行编译 提示  找不到GL库  <a href="https://blog.csdn.net/qq_27278957/article/details/100054043">https://blog.csdn.net/qq_27278957/article/details/100054043</a><br> sudo ln -s /usr/lib64/libGL.so.1 /usr/lib/libGL.so</li>
</ol>
<p>yum install libX11-devel –nogpg</p>
<p>libX11-devel   libXext-devel， libXtst-devel</p>
<p> sudo yum install freetype-devel fontconfig-devel  </p>
<p>./configure - fontconfig  // 支持自定义tff字体</p>
<p>make &amp;&amp; sudo make install </p>
<h2 id="qt相关"><a href="#qt相关" class="headerlink" title="qt相关"></a>qt相关</h2><p>解决打包的问题</p>
<p><a href="https://blog.csdn.net/weijifen000/article/details/102537640">https://blog.csdn.net/weijifen000/article/details/102537640</a></p>
]]></content>
      <categories>
        <category>其他笔记</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>python常用语法</title>
    <url>/2021/05/11/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/python%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<span id="more"></span> 

<h2 id="python-的用法"><a href="#python-的用法" class="headerlink" title="python *  ** 的用法"></a>python *  ** 的用法</h2><p><img src="figs/1566285511946.png" alt="1566285511946"></p>
<h3 id="用在函数的输入参数"><a href="#用在函数的输入参数" class="headerlink" title="用在函数的输入参数"></a>用在函数的输入参数</h3><p>​        在定义一个方法时，使用*表示输入参数列表不确定。会将输入的参数放入一个元组中，函数内可通过访问元组的方法访问里面的数据。使用**arg也可以表示不确定参数列表，但是会将输入参数打包为字典结构。因此函数内部可以通过访问字典结构的方法访问输入参数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myprint</span>(<span class="params">*arg</span>)</span></span><br><span class="line"><span class="function">	<span class="title">print</span> <span class="title">arg</span></span></span><br><span class="line"><span class="function"><span class="title">myprint</span>(<span class="params"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span>)</span></span><br><span class="line"><span class="function">#打印的结果是一个元组</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">myprint</span>(<span class="params">*arg</span>)</span></span><br><span class="line"><span class="function">	<span class="title">for</span> <span class="title">i</span> <span class="title">in</span> <span class="title">range</span>(<span class="params"><span class="built_in">len</span>(<span class="params">arg</span>)</span>)</span></span><br><span class="line"><span class="function">#输出1，2，3，4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myprint</span>(<span class="params">**arg</span>)</span></span><br><span class="line"><span class="function">	<span class="title">print</span>(<span class="params">arg</span>)</span></span><br><span class="line"><span class="function"><span class="title">myprint</span>(<span class="params">a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span></span>)</span></span><br><span class="line">#打印结果：&#123;&#x27;a&#x27;:1, &#x27;b&#x27;:2, &#x27;c&#x27;:3&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h3><p>​        与上述过程相反</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>（<span class="title">x</span>，<span class="title">y</span>）:</span></span><br><span class="line">    <span class="built_in">print</span> x+y</span><br><span class="line">para =  (<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">add(*para)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="built_in">print</span> x+y</span><br><span class="line">kkwd = &#123;<span class="string">&#x27;x&#x27;</span> :<span class="number">1</span>,<span class="string">&#x27;y&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line">add(**kkwd)</span><br></pre></td></tr></table></figure>



<h2 id="值传递，引用传递-，可变对象，不可变对象"><a href="#值传递，引用传递-，可变对象，不可变对象" class="headerlink" title="值传递，引用传递 ，可变对象，不可变对象"></a>值传递，引用传递 ，可变对象，不可变对象</h2><p>一般来说，将数字、字符串、元组是不可变对象，传入函数，相当于对内存进行了拷贝，在函数内修改其值不会改变函数外的值。但是对于列表、字典等可以增删的数据结构，传入函数后，相当于传递进去的是c语言中的指向地址的指针。所以在函数内对其进行有关地址的操作都可以修改函数外的变量的值。</p>
<p>参考链接：<a href="https://blog.csdn.net/qq_41987033/article/details/81675514">https://blog.csdn.net/qq_41987033/article/details/81675514</a></p>
<h2 id="使用tensorboard数据可视化"><a href="#使用tensorboard数据可视化" class="headerlink" title="使用tensorboard数据可视化"></a>使用tensorboard数据可视化</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>​        对于pytorch1.0 torch.utils.tensorboard中有这个文件，但是直接在程序中导入会报错，不考虑这个，自行安装tensorboardX。 需要安装tensorboardX为python代码执行，实现pytorch到tensorflow的转化生成一个日志文件，还需要安装tensorflow，才能调用tensorboard命令解析日志文件并上传到浏览器</p>
 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">pip install tensorboardX</span><br><span class="line">pip install tensorflow <span class="comment">#安装的gpu版本</span></span><br></pre></td></tr></table></figure>

<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>​        在程序调用一下api确保生成日志文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">writer &#x3D; SummaryWriter(&#39;runs&#x2F;fashion_mnist_experiment_1&#39;)  </span><br><span class="line">writer.add_image(&#39;four_fashion_mnist_images&#39;, img_grid)</span><br><span class="line">writer.close()   #必须有close 否则内容写不进去</span><br></pre></td></tr></table></figure>

<p>​        在系统命令行输入以下命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensorboard --logdir runs  </span><br></pre></td></tr></table></figure>

<p>​        上述的runs为刚才在py中生成日志文件的路径，得确保该路径下存放得有生成得日志文件<br>​        输入上述命令后，会产生如下输出，在google浏览器打开<a href="http://desktop-f3bbiio:6006/">http://DESKTOP-F3BBIIO:6006</a> 如果浏览被拒，改为 <a href="http://localhost:6006。如果是本机电脑链接远程服务器，则将服务器名字改为服务器的ip地址">http://localhost:6006。如果是本机电脑链接远程服务器，则将服务器名字改为服务器的ip地址</a></p>
<h2 id="pytorch的用法"><a href="#pytorch的用法" class="headerlink" title="pytorch的用法"></a>pytorch的用法</h2><h3 id="pytorch踩坑"><a href="#pytorch踩坑" class="headerlink" title="pytorch踩坑"></a>pytorch踩坑</h3><ul>
<li>load模型时，他会自动将其加载在这个模型训练时所在的gpu上  此时若这个gpu刚好满了就不能加载。所以最好每次加自增加 map_location=’cpu’  参数  load完毕后再to到需要的gpu上</li>
<li></li>
</ul>
<h3 id="cat-stack-unqueeze用法总结"><a href="#cat-stack-unqueeze用法总结" class="headerlink" title="cat stack unqueeze用法总结"></a>cat stack unqueeze用法总结</h3><p>​    相同： cat, stack 输入都为 1. tensor列表，2.另一个参数是维度 （n为输入tensor的维度数）</p>
<ul>
<li>cat : 将输入的tensor按照指定维度连接， 不要求输入的尺寸完全相同。dim的范围为 0~n-1  按照b, c, h, w的顺序对应dim从小到大。例如输入为二维矩阵，dim=0/1 =0表示在 h 维度拼接，即输出矩阵的行数为输入之和。</li>
<li>stack: 将输入tensor增加维度堆叠，要求输入的尺寸完全相同。dim范围0~n 也是按照bchw的顺序对应dim。输出的tensor dim=n+1。对于输二维矩阵，dim=0，在c维度堆叠；dim=1，提取每个输入的行向量按行堆叠构成输出的一个通道，输入矩阵有多少行就有多少通道；dim=2，提取每个输入的行向量按列堆叠构成输出的一个通道，输入矩阵有多少行就有多少通道。对于输入三维张量，同理。</li>
</ul>
]]></content>
      <categories>
        <category>其他笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/05/08/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/md%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul>
<li><input disabled="" type="checkbox"> 每次新建 md 文件需要自己手动添加 yaml 的头信息，如果能自动添加 ymal 头信息就好了，并且可以批量给没有 头信息的文件都自动添加。</li>
<li><input disabled="" type="checkbox"> 笔记 超链接 管理器来好麻烦，一旦一个文件夹中的某个文件名字变了，引用他的地方全都失效，希望辅助软件可以根据图形界面自动生成引用笔记的连接代码。并且管理，当修改某个笔记的时候，引用他的路径也改变。</li>
<li><input disabled="" type="checkbox"> 定时更新本地数据库，定时调用 hexo 命令更新网页界面</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先 需要一个后台数据缓存，首次运行遍历 当前目录下的所有 md 文件，查找文件中的  插入的超链接  和它连接到的文件；A 引用了 B , 从也 引用了 B ， 那么 {B: [A,  C]} 。需要一个类 管理解析md文件和缓冲区。</p>
<ol>
<li><p>扫描文件夹，建立缓冲文件，即预先存储所有的 笔记连接映射</p>
</li>
<li><p>将缓存文件读入内存，以键值对的形式保存</p>
</li>
<li><p>判断所有文件的修改日期，如果时间晚于 缓冲文件创建时间，那说明这个文件的修改没有记录在缓冲区中，需要查看该文件的 头文件类型和文件名是否改变</p>
</li>
<li><p>当单个文件名和路径修改时，需要找到原始的文件名，让后替换。（如果不是通过软件修改，怎么识别变动？）</p>
<ul>
<li>通过唯一的文件创建时间来建立 映射，初始遍历所有文件，如果有重复的创建时间，需要去重，并修改，然后建立 文件名和创建时间的映射。然后将这个映射写进 缓存文件。</li>
<li>后续如果有文件修改，修改时间一定晚于 缓存文件，找出这个最近修改了的文件名和唯一标识符。将缓存中的映射关系读出并判断这个唯一标志符是否存在。完成以下所有操作后 要更新缓冲文件修改时间，使得它为最新。<ul>
<li>唯一标志符存在，对应的文件名一致，说明是文件内容修改了，这种情况不用操作<ul>
<li>新增了连接呢   ?  </li>
</ul>
</li>
<li>唯一标志符存在，对应的文件路径不一致，说明要么是移动了路径，要么是修改了文件名，需要修改 标识符对应的文件名映射关系，同时找到引用它的所有文件，修改其中的引用。</li>
<li>唯一标志符不存在，说明是新建立的文件，将它的文件名和唯一标志符添加到缓存中</li>
</ul>
</li>
</ul>
<p> 找到修改文件名字或者 移动路径了的 文件  将引用的它的文档中的路径修改  </p>
<p> 重新扫描文件夹建立 缓存</p>
</li>
</ol>
<p>交互设计</p>
<ul>
<li><input disabled="" type="checkbox"> 最顶端功能按钮，设置 yaml 信息的默认参数。</li>
<li><input disabled="" type="checkbox"> hexo 编译上传的快捷按钮</li>
</ul>
<p>在文件上右键  弹出功能按钮。</p>
<ol>
<li><p>如果没有 yaml 头 生成 yaml 头信息</p>
</li>
<li><p>插入 引用，选中之后，开始选择要引用的文件，选中之后，在底部框中显示生成的引用链接</p>
</li>
<li><p>新建文件</p>
</li>
</ol>
<p>点击文件新建文件夹？</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>ifstream 要统一用 GBK 编码，中文路径才能打开</p>
]]></content>
  </entry>
  <entry>
    <title>pytorch扩展C</title>
    <url>/2021/05/11/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/pytorch%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h3 id="c-测试文件："><a href="#c-测试文件：" class="headerlink" title="c++测试文件："></a>c++测试文件：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include &lt;torch/script.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;torch/extension.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">torch::Tensor <span class="title">extend_gray</span><span class="params">(torch::Tensor image, torch::Tensor warp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BEGIN image_mat</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">image_mat</span><span class="params">(<span class="comment">/*rows=*/</span>image.size(<span class="number">0</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="comment">/*cols=*/</span>image.size(<span class="number">1</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="comment">/*type=*/</span>CV_32FC1,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="comment">/*data=*/</span>image.data_ptr&lt;<span class="keyword">float</span>&gt;())</span></span>;</span><br><span class="line">    <span class="comment">// END image_mat</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BEGIN warp_mat</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">warp_mat</span><span class="params">(<span class="comment">/*rows=*/</span>warp.size(<span class="number">0</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="comment">/*cols=*/</span>warp.size(<span class="number">1</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="comment">/*type=*/</span>CV_32FC1,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="comment">/*data=*/</span>warp.data_ptr&lt;<span class="keyword">float</span>&gt;())</span></span>;</span><br><span class="line">    <span class="comment">// END warp_mat</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BEGIN output_mat</span></span><br><span class="line">    cv::Mat output_mat;</span><br><span class="line">    cv::<span class="built_in">warpPerspective</span>(image_mat, output_mat, warp_mat, <span class="comment">/*dsize=*/</span>&#123;<span class="number">8</span>, <span class="number">8</span>&#125;);</span><br><span class="line">    <span class="comment">// END output_mat</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BEGIN output_tensor</span></span><br><span class="line">    torch::Tensor output = torch::<span class="built_in">from_blob</span>(output_mat.ptr&lt;<span class="keyword">float</span>&gt;(), <span class="comment">/*sizes=*/</span>&#123;<span class="number">8</span>, <span class="number">8</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> output.<span class="built_in">clone</span>();</span><br><span class="line">    <span class="comment">// END output_tensor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pybind11 绑定</span></span><br><span class="line"><span class="built_in">PYBIND11_MODULE</span>(TORCH_EXTENSION_NAME, m) &#123;</span><br><span class="line">    m.<span class="built_in">def</span>(<span class="string">&quot;extend_gray&quot;</span>, &amp;extend_gray, <span class="string">&quot;extend gray&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="同目录下的-setup-py文件"><a href="#同目录下的-setup-py文件" class="headerlink" title="同目录下的 setup.py文件"></a>同目录下的 setup.py文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">from</span> torch.utils.cpp_extension <span class="keyword">import</span> BuildExtension, CppExtension</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件目录</span></span><br><span class="line">include_dirs = os.path.dirname(os.path.abspath(__file__))  <span class="comment">## 头文件路径</span></span><br><span class="line"><span class="comment"># 源代码目录</span></span><br><span class="line">source_cpu = glob.glob(os.path.join(include_dirs, <span class="string">&#x27;*.cpp&#x27;</span>))  <span class="comment">## cpp文件列表 [&#x27;&#x27;, &#x27;&#x27;]</span></span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">&#x27;extend_gray&#x27;</span>,  <span class="comment"># 模块名称，需要在python中调用  </span></span><br><span class="line">    version=<span class="string">&quot;0.1&quot;</span>,</span><br><span class="line">    ext_modules=[</span><br><span class="line">        CppExtension(<span class="string">&#x27;extend_gray&#x27;</span>, </span><br><span class="line">        sources=source_cpu,   </span><br><span class="line">        library_dirs=[<span class="string">&#x27;/usr/local/lib&#x27;</span>], <span class="comment"># &#x27;/usr/local/lib&#x27;为opencv的动态库路径 -L/usr/...</span></span><br><span class="line">        include_dirs=[include_dirs, <span class="string">&#x27;/usr/local/include/opencv&#x27;</span>, <span class="string">&#x27;/usr/local/include&#x27;</span>], <span class="comment">## 头文件路径后两个为 opencv的</span></span><br><span class="line">        libraries=[<span class="string">&quot;opencv_core&quot;</span>, <span class="string">&quot;opencv_imgproc&quot;</span>, <span class="string">&quot;opencv_imgcodecs&quot;</span>, <span class="string">&quot;opencv_highgui&quot;</span>]),</span><br><span class="line">        <span class="comment">## 相当于g++ 编译的 -lopencv_core 一定要写全, 否则不写全编译不会报错但是运行会出错，必要时可以直接g++编译测试看用到哪些动态库</span></span><br><span class="line">    ],</span><br><span class="line">    cmdclass=&#123;</span><br><span class="line">        <span class="string">&#x27;build_ext&#x27;</span>: BuildExtension.with_options(no_python_abi_suffix=<span class="literal">True</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> extend_gray</span><br><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(extend_gray.extend_gray(torch.randn(<span class="number">32</span>, <span class="number">32</span>), torch.rand(<span class="number">3</span>, <span class="number">3</span>)))</span><br></pre></td></tr></table></figure>

<p>​    遇到提示 .so 库找不到  使用 find 命令在环境中搜，然后 添加到 LD_LIBRARY_PATH 变量中 写入 .bashrc 文件后面</p>
]]></content>
      <categories>
        <category>其他笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch扩展C</title>
    <url>/2021/05/13/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/pytorch%E6%89%A9%E5%B1%95c/</url>
    <content><![CDATA[<h3 id="c-测试文件："><a href="#c-测试文件：" class="headerlink" title="c++测试文件："></a>c++测试文件：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include &lt;torch/script.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;torch/extension.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">torch::Tensor <span class="title">extend_gray</span><span class="params">(torch::Tensor image, torch::Tensor warp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BEGIN image_mat</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">image_mat</span><span class="params">(<span class="comment">/*rows=*/</span>image.size(<span class="number">0</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="comment">/*cols=*/</span>image.size(<span class="number">1</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="comment">/*type=*/</span>CV_32FC1,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="comment">/*data=*/</span>image.data_ptr&lt;<span class="keyword">float</span>&gt;())</span></span>;</span><br><span class="line">    <span class="comment">// END image_mat</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BEGIN warp_mat</span></span><br><span class="line">    <span class="function">cv::Mat <span class="title">warp_mat</span><span class="params">(<span class="comment">/*rows=*/</span>warp.size(<span class="number">0</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="comment">/*cols=*/</span>warp.size(<span class="number">1</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="comment">/*type=*/</span>CV_32FC1,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="comment">/*data=*/</span>warp.data_ptr&lt;<span class="keyword">float</span>&gt;())</span></span>;</span><br><span class="line">    <span class="comment">// END warp_mat</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BEGIN output_mat</span></span><br><span class="line">    cv::Mat output_mat;</span><br><span class="line">    cv::<span class="built_in">warpPerspective</span>(image_mat, output_mat, warp_mat, <span class="comment">/*dsize=*/</span>&#123;<span class="number">8</span>, <span class="number">8</span>&#125;);</span><br><span class="line">    <span class="comment">// END output_mat</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BEGIN output_tensor</span></span><br><span class="line">    torch::Tensor output = torch::<span class="built_in">from_blob</span>(output_mat.ptr&lt;<span class="keyword">float</span>&gt;(), <span class="comment">/*sizes=*/</span>&#123;<span class="number">8</span>, <span class="number">8</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> output.<span class="built_in">clone</span>();</span><br><span class="line">    <span class="comment">// END output_tensor</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pybind11 绑定</span></span><br><span class="line"><span class="built_in">PYBIND11_MODULE</span>(TORCH_EXTENSION_NAME, m) &#123;</span><br><span class="line">    m.<span class="built_in">def</span>(<span class="string">&quot;extend_gray&quot;</span>, &amp;extend_gray, <span class="string">&quot;extend gray&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="同目录下的-setup-py文件"><a href="#同目录下的-setup-py文件" class="headerlink" title="同目录下的 setup.py文件"></a>同目录下的 setup.py文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">from</span> torch.utils.cpp_extension <span class="keyword">import</span> BuildExtension, CppExtension</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件目录</span></span><br><span class="line">include_dirs = os.path.dirname(os.path.abspath(__file__))  <span class="comment">## 头文件路径</span></span><br><span class="line"><span class="comment"># 源代码目录</span></span><br><span class="line">source_cpu = glob.glob(os.path.join(include_dirs, <span class="string">&#x27;*.cpp&#x27;</span>))  <span class="comment">## cpp文件列表 [&#x27;&#x27;, &#x27;&#x27;]</span></span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">&#x27;extend_gray&#x27;</span>,  <span class="comment"># 模块名称，需要在python中调用  </span></span><br><span class="line">    version=<span class="string">&quot;0.1&quot;</span>,</span><br><span class="line">    ext_modules=[</span><br><span class="line">        CppExtension(<span class="string">&#x27;extend_gray&#x27;</span>, </span><br><span class="line">        sources=source_cpu,   </span><br><span class="line">        library_dirs=[<span class="string">&#x27;/usr/local/lib&#x27;</span>], <span class="comment"># &#x27;/usr/local/lib&#x27;为opencv的动态库路径 -L/usr/...</span></span><br><span class="line">        include_dirs=[include_dirs, <span class="string">&#x27;/usr/local/include/opencv&#x27;</span>, <span class="string">&#x27;/usr/local/include&#x27;</span>], <span class="comment">## 头文件路径后两个为 opencv的</span></span><br><span class="line">        libraries=[<span class="string">&quot;opencv_core&quot;</span>, <span class="string">&quot;opencv_imgproc&quot;</span>, <span class="string">&quot;opencv_imgcodecs&quot;</span>, <span class="string">&quot;opencv_highgui&quot;</span>]),</span><br><span class="line">        <span class="comment">## 相当于g++ 编译的 -lopencv_core 一定要写全, 否则不写全编译不会报错但是运行会出错，必要时可以直接g++编译测试看用到哪些动态库</span></span><br><span class="line">    ],</span><br><span class="line">    cmdclass=&#123;</span><br><span class="line">        <span class="string">&#x27;build_ext&#x27;</span>: BuildExtension.with_options(no_python_abi_suffix=<span class="literal">True</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> extend_gray</span><br><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(extend_gray.extend_gray(torch.randn(<span class="number">32</span>, <span class="number">32</span>), torch.rand(<span class="number">3</span>, <span class="number">3</span>)))</span><br></pre></td></tr></table></figure>

<p>​    遇到提示 .so 库找不到  使用 find 命令在环境中搜，然后 添加到 LD_LIBRARY_PATH 变量中 写入 .bashrc 文件后面</p>
]]></content>
      <categories>
        <category>其他笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>typoral个人云笔记设置</title>
    <url>/2021/05/11/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/typoral%E4%BA%91%E7%AC%94%E8%AE%B0%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="fee663fffeda8dda880e0f8df59a5b72c3209467d8a571cdf574453aafb560dd">995e50c340763ee1a325e8c3b289bb94042f5aabaa770bc0112db74bfe3b3d8bcf0171a02d8c4b6eedae4b4b26a8616157c1bed1204992695e5cb8a5dadbf4a57629ef57cb56fd9f544387cbd331fe5f71916bbe2cd574150bf596190c8292eb66ba7c907acf9cb9fa3ff89fc2ac768987d49cb71348f2f0f1d3b3cc8ee781dba818dbed14fbfddf661e30e360f5ad470dbed249343c7c42471f422ea3f425274d65466460503dee852b2655e7e2b85877934f8a4c228635de7353f3903f20db4c3b5e28b15eb50fe88d6c165bf9aad451ba193df9fb8aab27fd4bb8b6da72f0fb69c6383bb6a7f3268a22dfc70cd0f832624543e8ee2c470d095ce9c0eb90b1da4a4fccc41399cbb20c80be62ef02534b8ac6af8e81bbf8d8df9bf74784c1dc06e6bb6e0df951d96d07b40b8c9c8be3b96807910ab01810be163cd046f23c64b21c8c278a56a61fbab2594a36b575d8279f41e0c747ae5c9e4435c7ff075bc3c9d3e02c0c744f69c81dac68a8a1174d14f0bd611fd121b7695afe946254afe2308c3f0dd4dd8d851d21bd5c19ea4afef6908d25a30e0e499b6457ddab12004eb81454756b291b6a14ca858b29563ae228cd4241072ac4e25cc327c13ef9bc31ed70df3f3a66f5e6eb0415cb11376267f0d718545e19dd32af4576e0132f57e7a6e7e2bbe8d91f768501b4edd75342bd1bbe2423373b8bec9ebbcbbcccef440d38171be285428ef39fa127a75af8de33e11bd86a7f34d8cb462af05c2c121f4a02379c687ce4a596498eae233767d1eb37def86aad70474f3c43532edc16048ef37a33e9621e1df6e0df09eda2d242584d7fb19fb49d65cc3a346522b37a675e57b33b749e0e032a10148e9f7aa7cd06c466c5a1910233d8b8693a3103c439c814df307c17d7ab8ef39aaab82a24d0c7c0fa513d033b2449f0f5365d3c4ba8c1375fbbc52a49bfc86a636ccfbe16bf253731e1bfa53dfeac6965256d230a9c557d728cbd75034ca44df9166f107da149f637cc5db66c0f2bf0e14f7c911dfafd6d7be3f0b5203b3d0f3f365b9c8d3b15ed5025b70c0a2ec7d636f71b7724da114384778ff46758f4ab974ae22fb4b0ac7ed72193159b39790a62a4fa27f3993ca804476aa2208564dc6870fc6436a41202598e968fce4603b2119eb43783ea879e0dc3c50dd71db5c9de780857888407fad5424f94bef5dbcca055f8e19712f338f7a30c50a07d785d4f4421285ecc0a9117859f20e9638d4138d73d67d31a85f97b2484d64aaa6c4b27ee2d31d3de038c74785ed673952e0d50e42af148cebc74c5f089c287aad5bf4238da4e8345f85be8acecd6c37fe4dc1155cec5977c362093051ed210214329e9fb9cb0171a85f1caf2ba168acec1602284ca055592560e26e96bb041d7a3809efb4dfe0a0e8377261e3ea6f3e39c066e47b8330cb76157c21c084fac571357a12f1f7d66620adffc8a3bd1b01a1f5be266ed43befba236b5c57c1c32e397a0586587a9c5f1a5afa59ff3226957dc2978eeac75df3060abfc0aa9e7d22b205663e20160e2b310f449f48042ab7c77a330dd6739856cf94a972a182ca0e92fe708bd566182e4ccf06986ab1d9856df98332603d0f02660c103054719ee90ff1476fecebf0e5298f04e7f20adb5dc9f80a766299c3db297f0452ecbac9e523bd2a56cb2ccab31be7e39139029df12290b13cde2cd2e35a946f36d66caa4df8b2f15209e8c80cb52de04c549742d537c49ab8eaf8a6664042fcacd1985979806f3f1c8f4b13e66d0fc64764d4af5d589a1aff5071d17307ee0ce616d3154c2c04ee4b92b02b3a9a1e562ca665fd05ab9f8d69a902cf6d0ec84bef2a8a6fc5f6df5ce8274751a634467477c2d120fd7cddd99b42de2f1fbfb982e37ee1e59263ce6ade401a0d2e3bcbb90a730352cb1f5c2ef0083cf79223e8c5c75da0b7788158a1b6768f5b268049edf25ff60d4cbd6ff8ab2445ce3a30da97121d4175a977baa04f0e15ca2a612d72f04e2c4719b4143f9698355f0e31615205f751881e188e07b4e19d6014ddd13d94d11dbfb1a04bee571b3737394f627395ebe3ab68c3e0a3715d3f3ac67329a9948da60b9ba3266e0b6545e493668aa7fcb191cad1b3d458ec6e1f8d21121f2d1746b3be0cd85f16d2f2344a569a34de5147be97565b20eac3c442306acebcc530c25e59b10a485e18dedbc2d3a2a5a77af4f473fd1d289eb24f2ccbb5a88f9d402da97ab66557c26ab02d8e98834e76e1eab4af204d0b0934a1b4912df99197e4f7231f691743e8789ed5c52d3be155b12b52ee0751e345cb745b2db60a07bcca2e942a5f5d2e6ea985603226b6dd86caff8a7a42eea246051bc6a1ba303183d9315157a6df2267b3b31d92f575166268e94599e92f42e083a559459f50dffbad3933335a5e234cf08d28aaa36d48fd07213ce1691c98bb57d2fbe4d51a57d2cee9d03f3e9f5100bf258016356e9d5eb2a342f40e692ea35ed862a2abcb37d2a9fac3bb8975c86c6451d7763ae2b4c0343cee68af9ae0e3cbd0e7def04a71c79e8f35a84982f7876984582b84399a49fffecd121d585c2058ed5d8ca0581fff7912dba48d02253ddcbbadbb552ac071353206ef6e8731c91e14d4b5b5cc9642aa17f7e0cde92556fb54922af8aeff4dc3b332bd34597782155295f8119cbe7f738ac27f9bc4175d810d1f8448c21494d53d6453f1faee466d2d6d65f06a7</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>其他笔记</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
        <tag>加密内容</tag>
      </tags>
  </entry>
  <entry>
    <title>个人conda配置</title>
    <url>/2021/05/11/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E4%B8%AA%E4%BA%BA%E7%94%A8%E6%88%B7conda%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 添加conda环境变量</span><br><span class="line">  sudo gedit ~&#x2F;.bashrc</span><br><span class="line"></span><br><span class="line">在文件中添加如下配置：</span><br><span class="line"># &gt;&gt;&gt; conda initialize &gt;&gt;&gt;</span><br><span class="line"># !! Contents within this block are managed by &#39;conda init&#39; !!</span><br><span class="line">__conda_setup&#x3D;&quot;$(&#39;&#x2F;home&#x2F;hust1008&#x2F;anaconda3&#x2F;bin&#x2F;conda&#39; &#39;shell.bash&#39; &#39;hook&#39; 2&gt; &#x2F;dev&#x2F;null)&quot;</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">    eval &quot;$__conda_setup&quot;</span><br><span class="line">else</span><br><span class="line">    if [ -f &quot;&#x2F;home&#x2F;hust1008&#x2F;anaconda3&#x2F;etc&#x2F;profile.d&#x2F;conda.sh&quot; ]; then</span><br><span class="line">        . &quot;&#x2F;home&#x2F;hust1008&#x2F;anaconda3&#x2F;etc&#x2F;profile.d&#x2F;conda.sh&quot;</span><br><span class="line">    else</span><br><span class="line">        export PATH&#x3D;&quot;&#x2F;home&#x2F;hust1008&#x2F;anaconda3&#x2F;bin:$PATH&quot;</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line">unset __conda_setup</span><br><span class="line"># &lt;&lt;&lt; conda initialize &lt;&lt;&lt;</span><br><span class="line"># export PYTHONPATH&#x3D;&#x2F;mnt2&#x2F;zhangjinpu&#x2F;CODE&#x2F;CenSiam:$PYTHONPATH</span><br><span class="line"></span><br><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda&#x2F;bin$&#123;PATH:+:$&#123;PATH&#125;&#125;</span><br><span class="line">export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;cuda&#x2F;lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;</span><br><span class="line"></span><br><span class="line">2. 修改conda环境保存路径  换源</span><br><span class="line">sudo gedit ~&#x2F;.condarc</span><br><span class="line"></span><br><span class="line">添加：</span><br><span class="line">channels:</span><br><span class="line"></span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: true</span><br><span class="line">default_channels:</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;main</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free</span><br><span class="line">  - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;r</span><br><span class="line">custom_channels:</span><br><span class="line">    conda-forge: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud</span><br><span class="line">    msys2: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud</span><br><span class="line">    bioconda: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud</span><br><span class="line">    menpo: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud</span><br><span class="line">    pytorch: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud</span><br><span class="line">    simpleitk: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud</span><br><span class="line">envs_dirs:</span><br><span class="line">  - &#x2F;home&#x2F;changruowang&#x2F;.conda&#x2F;envs</span><br><span class="line">pkgs_dirs:</span><br><span class="line">  - &#x2F;home&#x2F;changruowang&#x2F;.conda&#x2F;pkgs</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>其他笔记</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>项目知识点衍生</title>
    <url>/2021/05/11/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E9%A1%B9%E7%9B%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%8D%E7%94%9F/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="噪声回归项目"><a href="#噪声回归项目" class="headerlink" title="噪声回归项目"></a>噪声回归项目</h2><p>面试官都对这个项目很感兴趣</p>
<ol>
<li><p>mobile-net-v3的结构</p>
</li>
<li><p>知道的分类网络</p>
</li>
</ol>
<h2 id="图像提亮任务"><a href="#图像提亮任务" class="headerlink" title="图像提亮任务"></a>图像提亮任务</h2><h3 id="直方图均衡化-和-匹配"><a href="#直方图均衡化-和-匹配" class="headerlink" title="直方图均衡化 和 匹配"></a>直方图均衡化 和 匹配</h3><p><a href="../%E5%9B%BE%E5%83%8F%E9%A2%84%E5%A4%84%E7%90%86/%E4%BC%A0%E7%BB%9F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96.md">直方图均衡化</a></p>
<h3 id="BN-LN"><a href="#BN-LN" class="headerlink" title="BN, LN"></a>BN, LN</h3><p>计算一个batch 样本的均值方差，然后将样本根据均值方差归一化，最后乘上 缩放和平移因子，这两个就是BN层的参数。测试的时候直接使用训练的时候记录的均值方差。</p>
<p>优点：BN层可以将分布拉到 非饱和区域，减少了梯度弥散；  Batchnorm本身上也是一种正则的方式（主要缓解了梯度消失），可以代替其他正则方式如dropout等。</p>
<p>缺点：batch太小 计算的均值和方差不稳定</p>
<ol>
<li>UNET 的结构，以及是否有改动</li>
<li>增强的损失函数</li>
</ol>
<p>BN的性能很依赖于batch size的大小，而IN的原理则是将某一层的激活值归一化后缩放，如果btch_size是4 那么平均和方差就应该是一个4维的向量。因此LN的性能与bz无关。LN的均值方差在训练个测试的时候都会用到。同理 IN 就是对一个batch中的一个通道的特征图计算均值方差然后归一化，GN是介于IN和LN之间的操作，将通道分组归一化。</p>
<h3 id="SSIM"><a href="#SSIM" class="headerlink" title="SSIM"></a>SSIM</h3><p>分别以局部窗口中 的 均值 代表亮度 方差 代表对比度，协方差 代表结构相似性，三个方面来衡量两幅图的相似性。</p>
<ol start="3">
<li>根据mask的分割，还问了分割算法</li>
<li>GAN有没有采用特殊的训练技巧</li>
<li>知道的注意力机制</li>
<li>了解过transformer嘛</li>
</ol>
<h2 id="红外图像增强任务"><a href="#红外图像增强任务" class="headerlink" title="红外图像增强任务"></a>红外图像增强任务</h2><h3 id="知道的图像去噪方法"><a href="#知道的图像去噪方法" class="headerlink" title="知道的图像去噪方法"></a>知道的图像去噪方法</h3><p>空域特征去噪：双边滤波，均值滤波，指导滤波，非局部均值滤波，NLTV，TV</p>
<p>变换域：BM3D</p>
<h3 id="知道的图像模糊的方法"><a href="#知道的图像模糊的方法" class="headerlink" title="知道的图像模糊的方法"></a>知道的图像模糊的方法</h3><h3 id="双边滤波的原理"><a href="#双边滤波的原理" class="headerlink" title="双边滤波的原理"></a>双边滤波的原理</h3><h3 id="代码C-实现的时候用了什么"><a href="#代码C-实现的时候用了什么" class="headerlink" title="代码C++实现的时候用了什么"></a>代码C++实现的时候用了什么</h3><h3 id="开闭操作"><a href="#开闭操作" class="headerlink" title="开闭操作"></a>开闭操作</h3><h3 id="泊松方程"><a href="#泊松方程" class="headerlink" title="泊松方程"></a>泊松方程</h3><p>泊松方程的本质就是 通过二阶微分值求解每个点的原始像素值，前提是边界值已知，求解问题就是一个线性方程组。二阶微分的计算可以通过拉普拉斯算子计算，中间为-4，上下左右分别为1的一个卷积核。</p>
<p>泊松方程的求解是使用的 DCT 离散正弦变换加速的，c++代码使用了 fftw3库，自带多线程的api</p>
<h2 id="基于YOLO-V3的军用车辆检测任务"><a href="#基于YOLO-V3的军用车辆检测任务" class="headerlink" title="基于YOLO V3的军用车辆检测任务"></a>基于YOLO V3的军用车辆检测任务</h2><h3 id="量化的基本原理"><a href="#量化的基本原理" class="headerlink" title="量化的基本原理"></a>量化的基本原理</h3><p><a href="../%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2/%E6%A8%A1%E5%9E%8Bint8%E9%87%8F%E5%8C%96.md">int8量化原理</a></p>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><ol>
<li><p>重载和继承</p>
</li>
<li><p>知道哪些智能指针</p>
</li>
</ol>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><ol>
<li>线程和进程区别</li>
<li>知道进程通信的方法嘛，线程通信呢</li>
<li>互斥锁和同步锁</li>
</ol>
<h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><p>包含正数和负数的数组，求乘积最大连续子数组</p>
<h2 id="研究的领域"><a href="#研究的领域" class="headerlink" title="研究的领域"></a>研究的领域</h2><h3 id="对图像增强这项任务的理解"><a href="#对图像增强这项任务的理解" class="headerlink" title="对图像增强这项任务的理解"></a>对图像增强这项任务的理解</h3><h3 id="和其他-low-level-有什么区别"><a href="#和其他-low-level-有什么区别" class="headerlink" title="和其他 low-level 有什么区别"></a>和其他 low-level 有什么区别</h3>]]></content>
      <categories>
        <category>其他笔记</category>
      </categories>
  </entry>
  <entry>
    <title>STL容器原理</title>
    <url>/2021/04/24/C++/%E5%BA%93%E5%87%BD%E6%95%B0/STL%E5%AE%B9%E5%99%A8%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>总结了STL容器的原理</p>
<span id="more"></span>

<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>C++ 提供的容器有 vector , map ,  unordered_map , set , list , dequeue等</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="set-和-map"><a href="#set-和-map" class="headerlink" title="set 和 map"></a>set 和 map</h3><ol>
<li><p>共同点：都是C++的关联容器,只是通过它提供的接口对里面的元素进行访问，底层都是采用<strong>红黑树</strong>实现。</p>
</li>
<li><p>不同点： </p>
<ul>
<li>set：用来判断某一个元素是不是在一个组里面，使用的比较少；</li>
<li>map：映射，相当于字典，把一个值映射成另一个值，可以创建字典</li>
</ul>
</li>
<li><p>优点：查找某一个数的时间为**O(log n)**；遍历时采用 iterator，效果不错</p>
</li>
<li><p>缺点：每次插入值的时候，都需要调整红黑树，效率有一定影响</p>
</li>
</ol>
<h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><p>Hash表实现，虽然功能上 和 map 有点像，但是由于原理上本质的区别，它是不能遍历迭代的，即无序。速度快 查找时间复杂度 <strong>O(1)</strong></p>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>是<strong>动态数组</strong>，在堆中分配内存，元素连续存放，有保留内存，如果减少大小后，内存也不会释放；如果新值大于当前大小时才会重新分配内存。</p>
<ol>
<li>优点：拥有一段连续的内存空间，并且起始地址不变，因此能够非常好的支持随机存取，即[]操作符；<strong>O(1)</strong></li>
<li>缺点：对头部和中间进行添加删除元素操作需要移动内存，如果元素是结构或类，那么移动的同时还会进行构造和析构操作，所以性能不高</li>
</ol>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p><strong>双向链表</strong>，元素也存放在堆中，每个元素都是放在一块内存中，他的内存空间可以是不连续的，通过指针来进行数据的访问。</p>
<ol>
<li>缺点：这个特点使得它的随机存取变得非常没有效率，因此它没有提供[]操作符的重载。访问元素的时间复杂度 **O(N)**。</li>
<li>优点：它可以很有效率的支持任意地方的删除和插入操作。所以常用来做<strong>随机插入和删除</strong>操作容器。</li>
</ol>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>deque是一种优化了的对序列两端元素进行添加和删除操作的基本序列容器。通常由<strong>一些独立的区块组成，第一区块朝某方向扩展，最后一个区块朝另一方向扩展</strong>。它允许较为快速地随机访问但它不像vector一样把所有对象保存在一个连续的内存块，而是多个连续的内存块。并且在一个映射结构中保存对这些块以及顺序的跟踪。（因此在任意位置插入元素，不需要移动后面所有的元素，只用修改一页的内容）</p>
<ul>
<li>优点：随机插入删除元素的速度 介于 vector  和 list 之间，因为不需要复制所有元素</li>
<li>缺点：随机读取元素的速度 也是 介于 list  和  vector之间，因为deque需要处理内部跳转，读取速度没vector快，不支持resize 和 reserve 操作即不能自己显式的控制内存的大小。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210404172935.png" alt="image-20210404172337830" style="zoom:50%;" />

<h2 id="迭代失效问题"><a href="#迭代失效问题" class="headerlink" title="迭代失效问题"></a>迭代失效问题</h2><table>
<thead>
<tr>
<th></th>
<th align="center"><strong>vector</strong></th>
<th><strong>deque</strong></th>
<th><strong>list</strong></th>
<th><strong>set、map</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>内部数据结构</strong></td>
<td align="center"><strong>数组(一段连续内存空间)</strong></td>
<td><strong>数组(多段连续内存空间)</strong></td>
<td><strong>双向环状链表</strong></td>
<td><strong>红黑树</strong></td>
</tr>
<tr>
<td><strong>插入操作</strong></td>
<td align="center">插入后元素总数不大于capacity，插入位置之后的迭代器会失效；大于capacity,所有迭代器都会失效</td>
<td>两端插入, 不会引起迭代器失效；中间插入, 所有迭代器失效</td>
<td>不会出现迭代器失效</td>
<td>不会出现迭代器失效</td>
</tr>
<tr>
<td><strong>删除操作</strong></td>
<td align="center">删除位置之后的迭代器都会失效,但是erase会返回下一个有效的迭代器</td>
<td>两端删除, 被删除元素的迭代器失效中间删除, 所有迭代器失效</td>
<td>被删除节点的迭代器失效</td>
<td>被删除节点的迭代器失效</td>
</tr>
<tr>
<td><strong>解决方法</strong></td>
<td align="center">iter =cont.erase(iter)</td>
<td></td>
<td>m.erase(iter++)</td>
<td>m.erase(iter++)</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要求删除键值为偶数的键值对</span></span><br><span class="line"> map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//错误实现：</span></span><br><span class="line"> <span class="keyword">while</span> (it != m.<span class="built_in">end</span>())&#123;</span><br><span class="line">   <span class="keyword">if</span>(it-&gt;second % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">     m.<span class="built_in">erase</span>(it);</span><br><span class="line">   &#125;</span><br><span class="line">   it++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//正确实现：</span></span><br><span class="line"> <span class="keyword">while</span> (it != m.<span class="built_in">end</span>())&#123;</span><br><span class="line">   <span class="keyword">if</span>(it-&gt;second % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">     m.<span class="built_in">erase</span>(it++); <span class="comment">//重点！！！  it++的写法才行不能  m.rease(it); it++;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">     it++;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>库函数</category>
      </categories>
      <tags>
        <tag>STL库</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title>STL库常用API汇总</title>
    <url>/2021/05/11/C++/%E5%BA%93%E5%87%BD%E6%95%B0/STL%E5%BA%93%E5%B8%B8%E7%94%A8API/</url>
    <content><![CDATA[<p>汇总了c++ STL 库中常用的API用法</p>
<span id="more"></span>

<h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">a.<span class="built_in">resize</span>(N);						  <span class="comment">// 扩容</span></span><br><span class="line"><span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());  		    <span class="comment">//倒序</span></span><br><span class="line"><span class="built_in">swap</span>(a[<span class="number">0</span>], a[<span class="number">1</span>]);  					   <span class="comment">//交换位置0 和 1的元素</span></span><br><span class="line">a.<span class="built_in">assign</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());            <span class="comment">// b 拷贝到 a</span></span><br><span class="line">a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>);				    <span class="comment">//删除第一个元素</span></span><br></pre></td></tr></table></figure>



<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> idx_, <span class="keyword">int</span> w_, <span class="keyword">int</span> p1_, <span class="keyword">int</span> p2_)&#123;</span><br><span class="line">        idx = idx_; w = w_; p1 = p1_; p2 = p2_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node&amp; data)&#123;     <span class="comment">// 升序排列</span></span><br><span class="line">        <span class="keyword">return</span> w &lt; data.w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> p1;</span><br><span class="line">    <span class="keyword">int</span> p2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Node&gt; test;</span><br><span class="line"><span class="built_in">sort</span>(test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>());            <span class="comment">//结构体中重载 &lt; 符号 来对自定义的 vector升序排序，要实现逆序排列 可以重载</span></span><br></pre></td></tr></table></figure>



<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string a = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">string b = a.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">1</span>);   <span class="comment">//第一个参数代表起始位置，第二个为长度 提取子串</span></span><br><span class="line">a.<span class="built_in">at</span>(<span class="number">0</span>);                 	<span class="comment">//访问0位置的字符</span></span><br><span class="line">a.<span class="built_in">resize</span>(N); 			   <span class="comment">//和vector一样的扩容方法</span></span><br><span class="line">a.<span class="built_in">erase</span>(<span class="number">10</span>, <span class="number">4</span>)              <span class="comment">//从位置=10的字符开始 删除4个；不带第二个参数 表示删到结尾</span></span><br><span class="line">a.<span class="built_in">insert</span>(<span class="number">14</span>,<span class="number">6</span>,<span class="string">&#x27;*&#x27;</span>)		   <span class="comment">//向 位置14前面 插入 6 个 &quot;*&quot;</span></span><br><span class="line">a.<span class="built_in">find</span>(<span class="string">&quot;b&quot;</span>,<span class="number">5</span>)               <span class="comment">//从下标5开始查找 字符串“b”出现的位置  用if(pos == string::npos) 用来判断是否找到子串。</span></span><br><span class="line"></span><br><span class="line">a.<span class="built_in">erase</span>(<span class="number">0</span>,a.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; &quot;</span>));   <span class="comment">//去掉字符串左右两端的空格</span></span><br><span class="line">a.<span class="built_in">erase</span>(a.<span class="built_in">find_last_not_of</span>(<span class="string">&quot; &quot;</span>) + <span class="number">1</span>);</span><br><span class="line"><span class="comment">/// 用 stringstream 分割 指定字符 分开的 字符串</span></span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(a)</span></span>;</span><br><span class="line">string item;</span><br><span class="line"><span class="keyword">while</span>(ss &gt;&gt; item)	cout &lt;&lt; item &lt;&lt; endl;   <span class="comment">//获取 字符串中的单词 按空格分割</span></span><br><span class="line"><span class="keyword">while</span> (std::<span class="built_in">getline</span>(ss, item, <span class="string">&#x27;_&#x27;</span>))&#123;</span><br><span class="line">    cout &lt;&lt; item &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 字符串按照 特定字符分割   “11*11+12”</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">split_string</span><span class="params">(string&amp; s)</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; p2 &lt; s.<span class="built_in">size</span>(); p2++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[p2] == <span class="string">&#x27;+&#x27;</span> || s[p2] == <span class="string">&#x27;-&#x27;</span> || s[p2] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                re.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(p1, p2-p1)));</span><br><span class="line">                re.<span class="built_in">push_back</span>(s[p2]);</span><br><span class="line">                p1 = p2+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        re.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(p1, p2-p1)));</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="stringstream用法"><a href="#stringstream用法" class="headerlink" title="stringstream用法"></a>stringstream用法</h3><p>头文件 <code>include&lt;sstream&gt;</code> </p>
<h3 id="字符串分割函数"><a href="#字符串分割函数" class="headerlink" title="字符串分割函数"></a>字符串分割函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">const</span> string s, vector&lt;string&gt;&amp; vs, <span class="keyword">const</span> <span class="keyword">char</span> delim= <span class="string">&#x27; &#x27;</span>)</span></span>&#123;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(s)</span></span>;</span><br><span class="line">    string temp;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(iss,temp,delim))&#123;</span><br><span class="line">        vs.<span class="built_in">emplace_back</span>(<span class="built_in">move</span>(temp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">back</span>() == delim) vs.<span class="built_in">push_back</span>(&#123;&#125;);<span class="comment">//加这句的原因是getline不会识别最后一个delim,避免误判&quot;172.16.254.1.&quot;,&quot;2001:0db8:85a3:0:0:8A2E:0370:7334:&quot;之类的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;string, <span class="keyword">int</span>&gt;  dict; <span class="comment">// 声明unordered_map对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据的三种方式</span></span><br><span class="line">dict.<span class="built_in">insert</span>(pair&lt;string,<span class="keyword">int</span>&gt;(<span class="string">&quot;apple&quot;</span>,<span class="number">2</span>));</span><br><span class="line">dict.<span class="built_in">insert</span>(unordered_map&lt;string, <span class="keyword">int</span>&gt;::<span class="built_in">value_type</span>(<span class="string">&quot;orange&quot;</span>,<span class="number">3</span>));</span><br><span class="line">dict[<span class="string">&quot;banana&quot;</span>] = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 判断是否有元素</span></span><br><span class="line"><span class="keyword">if</span>(dict.<span class="built_in">empty</span>())</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;该字典无元素&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;该字典共有&quot;</span>&lt;&lt;dict.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;个元素&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line">unordered_map&lt;string, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line"><span class="keyword">for</span>(iter=dict.<span class="built_in">begin</span>();iter!=dict.<span class="built_in">end</span>();iter++)</span><br><span class="line">    cout&lt;&lt;iter-&gt;first&lt;&lt;ends&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">dict.<span class="built_in">erase</span>(<span class="string">&#x27;a&#x27;</span>); </span><br></pre></td></tr></table></figure>



<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*队列*/</span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*优先队列*/</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, std::less&lt;<span class="keyword">int</span>&gt; &gt; maxHeap;    <span class="comment">// 大顶堆 堆顶的元素最大</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, std::greater&lt;<span class="keyword">int</span>&gt; &gt; minHeap; <span class="comment">// 小顶堆 堆顶元素最小</span></span><br><span class="line"><span class="comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</span></span><br><span class="line"><span class="keyword">int</span> a = maxHeap.<span class="built_in">top</span>();  <span class="comment">//获取堆顶最大元素</span></span><br><span class="line">maxHeap.<span class="built_in">pop</span>();          <span class="comment">//弹出堆顶元素</span></span><br><span class="line">maxHeap.<span class="built_in">push</span>();         <span class="comment">//向堆中增加元素 堆顶元素永远最大</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*双端队列*/</span></span><br><span class="line">deque&lt;<span class="keyword">int</span>&gt; a;     			<span class="comment">// 双端队列 结合了栈和队列的性质，既可以从头部插入 也可以从尾部插入 </span></span><br><span class="line"><span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(a)</span></span>;  			<span class="comment">// 定义并用双端队列a初始化双端队列b</span></span><br><span class="line"><span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(&amp;n[<span class="number">1</span>], &amp;n[<span class="number">4</span>])</span></span>;  <span class="comment">// 将n[1]、n[2]、n[3]作为双端队列a的初值</span></span><br><span class="line">deq.<span class="built_in">size</span>();</span><br><span class="line">deq.<span class="built_in">resize</span>();</span><br><span class="line">deq.<span class="built_in">push_front</span>(<span class="keyword">const</span> T&amp; x);  <span class="comment">// 头部添加元素</span></span><br><span class="line">deq.<span class="built_in">push_back</span>(<span class="keyword">const</span> T&amp; x);   <span class="comment">//尾部添加元素</span></span><br><span class="line">deq.<span class="built_in">insert</span>(iterator it, <span class="keyword">const</span> T&amp; x);  <span class="comment">//任意位置插入一个元素</span></span><br><span class="line">deq.<span class="built_in">pop_front</span>(); 			<span class="comment">// 头部删除元素</span></span><br><span class="line">deq.<span class="built_in">pop_back</span>();				<span class="comment">//末尾删除元素</span></span><br><span class="line">deq.<span class="built_in">front</span>();				<span class="comment">//访问第一个元素</span></span><br><span class="line">deq.<span class="built_in">back</span>();					<span class="comment">//访问最后一个元素</span></span><br></pre></td></tr></table></figure>



<h3 id="优先队列-priority-queue"><a href="#优先队列-priority-queue" class="headerlink" title="优先队列 priority_queue"></a>优先队列 priority_queue</h3><p>头文件<code>#include &lt;queue&gt;</code>, 可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队。本质是通过大小顶堆这种数据结构实现。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>priority_queue&lt;Type, Container, Functional&gt;</p>
<p><em>Type</em> 就是数据类型，<em>Container</em> 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），<em>Functional</em> 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆</p>
<p>基本操作:</p>
<ul>
<li>top 访问队头元素</li>
<li>empty 队列是否为空</li>
<li>size 返回队列内元素个数</li>
<li>push 插入元素到队尾 (并排序)</li>
<li>emplace 原地构造一个元素并插入队列</li>
<li>pop 弹出队头元素</li>
<li>swap 交换内容</li>
</ul>
<h4 id="自定义类型用法"><a href="#自定义类型用法" class="headerlink" title="自定义类型用法"></a>自定义类型用法</h4>]]></content>
      <categories>
        <category>C++</category>
        <category>库函数</category>
      </categories>
      <tags>
        <tag>STL库</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title>streamstream用法</title>
    <url>/2021/05/11/C++/%E5%BA%93%E5%87%BD%E6%95%B0/stringstream%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>总结了 streamstream 用法</p>
<span id="more"></span>

<h1 id="stringstream用法"><a href="#stringstream用法" class="headerlink" title="stringstream用法"></a>stringstream用法</h1><p>参考链接 <a href="https://www.cnblogs.com/gamesky/archive/2013/01/09/2852356.html">https://www.cnblogs.com/gamesky/archive/2013/01/09/2852356.html</a></p>
<p>需要在源程序文件中包含头文件<code> include&lt;sstream&gt;</code></p>
<p>包含的类 有  <strong>stringstream、istringstream、ostringstream</strong> </p>
<h2 id="数组转字符串"><a href="#数组转字符串" class="headerlink" title="数组转字符串"></a>数组转字符串</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> pi = <span class="number">3.141592653589793</span>;</span><br><span class="line">    <span class="keyword">float</span> dollar = <span class="number">1.00</span>;</span><br><span class="line">    <span class="keyword">int</span> dozen = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">35</span>;</span><br><span class="line">    </span><br><span class="line">    stringstream ss;</span><br><span class="line">    </span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;dozen: &quot;</span> &lt;&lt; dozen &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示小数</span></span><br><span class="line">    ss.<span class="built_in">setf</span>(ios::fixed);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示2位小数</span></span><br><span class="line">    ss.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;dollar: &quot;</span> &lt;&lt; dollar &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示10位小数</span></span><br><span class="line">    ss.<span class="built_in">precision</span>(<span class="number">10</span>);</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;pi: &quot;</span> &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//按十六进制显示整数</span></span><br><span class="line">    ss.<span class="built_in">unsetf</span>(ios_base::dec);</span><br><span class="line">    ss.<span class="built_in">setf</span>(ios::hex);</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;number: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    string text = ss.<span class="built_in">str</span>();</span><br><span class="line">    cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20180413072211763?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbmppbmdfY3Nkbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p><strong>这个示例的本质是：数字 -&gt; stringstream对象 -&gt; string</strong></p>
<h2 id="字符串-gt-数字"><a href="#字符串-gt-数字" class="headerlink" title="字符串-&gt;数字"></a>字符串-&gt;数字</h2><p>string -&gt; double/int</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">double</span>  dVal;    </span><br><span class="line">    <span class="keyword">int</span>     iVal;</span><br><span class="line">    string  str;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// string -&gt; double</span></span><br><span class="line">    str = <span class="string">&quot;123.456789&quot;</span>;  </span><br><span class="line">    ss &lt;&lt; str;</span><br><span class="line">    ss &gt;&gt; dVal;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;dVal: &quot;</span> &lt;&lt; dVal &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// string -&gt; int</span></span><br><span class="line">    str = <span class="string">&quot;654321&quot;</span>;  </span><br><span class="line">    ss.<span class="built_in">clear</span>();</span><br><span class="line">    ss &lt;&lt; str;</span><br><span class="line">    ss &gt;&gt; iVal;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iVal: &quot;</span> &lt;&lt; iVal &lt;&lt; endl;  </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>这个示例的本质是：string -&gt; stringstream对象 -&gt; 数字</strong></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>库函数</category>
      </categories>
      <tags>
        <tag>STL库</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-创建型-单例</title>
    <url>/2021/05/04/C++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B/</url>
    <content><![CDATA[<p><strong>单例模式</strong>是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p>
<span id="more"></span>

<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>单例模式（Singleton）是一种创建型设计模式， 让你<strong>能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</strong></p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>使用下三部分来实现：</p>
<ul>
<li>私有构造函数：私有构造函数保证了不能通过构造函数来创建对象实例</li>
<li>一个私有静态变量：私有静态变量用于指向实例化的对象，全局唯一</li>
<li>一个公有静态函数：只能通过公有静态函数返回<strong>唯一的私有静态变量</strong></li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>主要分为懒汉式 和 饿汉式 两种实现方式。区别就是实例化唯一的对象的位置。而懒汉式又有两种实现，一个线程安全，一个线程不安全</p>
<ul>
<li>懒汉式：延迟实现，只有当调用公用静态函数，且静态指针为空的时候才实例化对象，存在线程不安全问题<ul>
<li>线程安全的修改</li>
</ul>
</li>
<li>饿汉式：当程序运行的时候就 初始化 私有静态指针，因此线程安全</li>
</ul>
<p>C++ 代码实现</p>
<h3 id="饿汉式-懒汉式"><a href="#饿汉式-懒汉式" class="headerlink" title="饿汉式  /  懒汉式"></a>饿汉式  /  懒汉式</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> std::string value): <span class="built_in">value_</span>(value)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Singleton* singleton_;</span><br><span class="line">    std::string value_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(Singleton &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// 全局静态函数 用于实例化唯一的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton *<span class="title">GetInstance</span><span class="params">(<span class="keyword">const</span> std::string&amp; value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton_==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            singleton_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton_;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">string <span class="title">value</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> value_;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 如果是饿汉模式，在初始化的时候就 用 new 分配内存，如果懒汉模式，初始静态指针设置为 null 只有调用静态函数的时候才new</span></span><br><span class="line"><span class="comment">// 由于 singleton_ 指针是 私有静态变量，因此只能在函数外部，全局初始化，而不能放在任何一个函数里 去修改（包括mian函数），会编译报错</span></span><br><span class="line">Singleton* Singleton::singleton_= <span class="keyword">new</span> <span class="built_in">Singleton</span>(<span class="string">&quot;Init&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFoo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Following code emulates slow initialization.</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">    Singleton* singleton = Singleton::<span class="built_in">GetInstance</span>(<span class="string">&quot;FOO&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; singleton-&gt;<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadBar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Following code emulates slow initialization.</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">    Singleton* singleton = Singleton::<span class="built_in">GetInstance</span>(<span class="string">&quot;BAR&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; singleton-&gt;<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当两个线程输出的 结果 不一样时，说明产生了线程不安全的问题</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(ThreadFoo)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(ThreadBar)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 同过上述代码可以看出，懒汉式饿汉式的区别：</p>
<ul>
<li>饿汉式：在 main 函数的执行之前，就调用了 new 实例化了对象，因此是线程安全的；缺点是由于一开始就申请了空间，会有资源浪费的问题。</li>
<li>懒汉式：只有在程序 调用 公有静态函数，需要获取对象时，才会判断该对象有没有实例化，没的话再实例化。优点是  延迟实例化带来的节约资源的好处。缺点是 这是线程不安全的。<ul>
<li>例如当两个线程同时 调用 <code>GetInstance </code>函数，并且都同时通过了 <code>singleton_</code>指针空的判断，就会实例化出两个对象，所以上述代码输出的现象就是，两个线程输出的value值不一样。</li>
</ul>
</li>
</ul>
<h3 id="懒汉式-线程安全"><a href="#懒汉式-线程安全" class="headerlink" title="懒汉式-线程安全"></a>懒汉式-线程安全</h3><p>为了解决上述 懒汉式 线程不安全的问题就是 对 <code>GetInstance</code> 函数加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次。但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 <code>Singleton </code>已经被实例化了(即 <code>singleton_ </code>指针不为空)。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。可以使用 <strong>双重校验锁</strong> 的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单的加锁</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::GetInstance</span><span class="params">(<span class="keyword">const</span> std::string&amp; value)</span></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(singleton_==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        singleton_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 双重校验锁</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::GetInstance</span><span class="params">(<span class="keyword">const</span> std::string&amp; value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(singleton_！=<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> singleton_;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; <span class="built_in">lock</span>(mutex_);</span><br><span class="line">        <span class="keyword">if</span>(singleton_==<span class="literal">nullptr</span>)</span><br><span class="line">            singleton_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>(value);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从上述代码实现可以看出，双重校验锁的原理是，只有当判断 <code>singleton_ </code>为空，即还未实例化的时候，才需要加锁操作，因为这时候肯定是要进行对象实例化操作，即写操作。如果已经实例化了，直接返回地址即可，不用加锁读。但是加锁后又判断了一遍是否指针空，因为还是可能存在两个线程同时进入了第一个 指针判断 空的语句，由于有锁，一个线程实例化对象，并修改指针为非空，完毕后释放锁。此时如果另一个线程不再判断一次为空就会 再次 new 实例化，还是存在线程不安全的问题。</p>
<p>或者直接这么理解，双重校验就是在  原本的基础上 先判断指针是否为空，空的化直接返回指针，不必校验。而不为空，才加锁判断。</p>
<p><strong>优点：</strong>双重校验锁，即是延迟实例化的，可以节省资源，还是线程安全的，且不会因为锁的存在使得线程阻塞时间过长。</p>
<h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><p>singleton_ 采用 volatile 关键字修饰也是很有必要的，<code>singleton_ = new Singleton(value)</code>  这段代码其实是分为三步执行：</p>
<ol>
<li>为 <code>Singleton </code>分配内存空间</li>
<li>初始化 <code>Singleton</code></li>
<li>将 <code>singleton_  </code>指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行</p>
<p><a href="../%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/volatile%E5%85%B3%E9%94%AE%E5%AD%97.md">C++ volatile关键字作用</a></p>
]]></content>
      <categories>
        <category>C++</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-创建型-工厂方法</title>
    <url>/2021/05/05/C++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><strong>工厂方法</strong>是一种创建型设计模式，是基于简单工厂的改进</p>
<span id="more"></span>

<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>简单工厂中，一个工厂类统一实例化所有的产品，而工厂方法，每个产品用特定的工厂子类实例化。定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。</p>
<h3 id="和简单工厂对比"><a href="#和简单工厂对比" class="headerlink" title="和简单工厂对比"></a>和简单工厂对比</h3><p>在简单工厂方法中，同一接口的不同产品对象都由一个工厂创建出来。这种做法存在两个问题：</p>
<ul>
<li>当产品对象很多时，工厂就会成为一个“过大类”</li>
<li>当新增产品对象时，需要在工厂中增加一个分支。这就违反了“开闭原则”</li>
</ul>
<p>第一条很好理解，一个工厂负责生产所有的产品，不断增加产品的种类，工厂中的 if 语句也就越多。同时，由于增加一个新的产品种类，就要修改工厂的代码，因此违反了开闭原则，开闭原则希望当增加新功能时不用修改原有的代码，只用通过新增代码就完成。</p>
<p>所以工厂方法，特定的 产品使用特定的 工厂方法生产，当新增一个方法时，只用新增一个生产它的工厂子类即可。因此针对产品不会频繁变化，且产品种类较少的情景下 使用简单工厂反而好些。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>从代码可以看出实现的核心是：</p>
<ul>
<li>不同子类重写不同的new 产品的函数，主工厂中首先调用 获取产品的函数获取产品，再执行功能。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产品抽象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Product</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">Operation</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 子类产品1 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> :</span> <span class="keyword">public</span> Product &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::string <span class="title">Operation</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;Result of the ConcreteProduct1&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 子类产品2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> :</span> <span class="keyword">public</span> Product &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::string <span class="title">Operation</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;Result of the ConcreteProduct2&#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂主类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Creator</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Product* <span class="title">FactoryMethod</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">SomeOperation</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在工厂主类中 生产 产品，FactoryMethod 是由对应的子类重写了，因此不同的子类会返回不同的产品</span></span><br><span class="line">    <span class="comment">// 然后再 调用产品完成特定的功能</span></span><br><span class="line">    Product* product = <span class="keyword">this</span>-&gt;<span class="built_in">FactoryMethod</span>();</span><br><span class="line">   </span><br><span class="line">    std::string result = <span class="string">&quot;Creator: The same creator&#x27;s code has just worked with &quot;</span> + product-&gt;<span class="built_in">Operation</span>();</span><br><span class="line">    <span class="keyword">delete</span> product;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂1 用于生产产品1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCreator1</span> :</span> <span class="keyword">public</span> Creator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Product* <span class="title">FactoryMethod</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProduct1</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 工厂2 用于生产产品2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCreator2</span> :</span> <span class="keyword">public</span> Creator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Product* <span class="title">FactoryMethod</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteProduct2</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClientCode</span><span class="params">(<span class="keyword">const</span> Creator&amp; creator)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Client: I&#x27;m not aware of the creator&#x27;s class, but it still works.\n&quot;</span></span><br><span class="line">            &lt;&lt; creator.<span class="built_in">SomeOperation</span>() &lt;&lt; std::endl;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;App: Launched with the ConcreteCreator1.\n&quot;</span>;</span><br><span class="line">  Creator* creator = <span class="keyword">new</span> <span class="built_in">ConcreteCreator1</span>();</span><br><span class="line">  <span class="built_in">ClientCode</span>(*creator);</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;App: Launched with the ConcreteCreator2.\n&quot;</span>;</span><br><span class="line">  Creator* creator2 = <span class="keyword">new</span> <span class="built_in">ConcreteCreator2</span>();</span><br><span class="line">  <span class="built_in">ClientCode</span>(*creator2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> creator;</span><br><span class="line">  <span class="keyword">delete</span> creator2;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-创建型-简单工厂</title>
    <url>/2021/05/05/C++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/</url>
    <content><![CDATA[<p><strong>简单工厂</strong>是一种创建型设计模式，在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p>
<span id="more"></span>

<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><strong>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化</strong>。这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>根据下面代码可以看出，简单工厂的实现要点</p>
<ul>
<li>用户并不需要指导具体的子类的名称，只需要根据参数来向工厂获取 产品。而用户只用使用 基类指针来指向 工厂创建的子类对象，即多态机制，来完成子类的特定功能。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Phone</span>() &#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoMi</span>:</span> <span class="keyword">public</span> Phone&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">XiaoMi</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;This is xiao mi phone&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span>:</span> <span class="keyword">public</span> Phone&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Apple</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;This is apple phone&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 简单工厂类，客户使用简单工厂来获取对应的产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">SimpleFactory</span>()&#123;&#125;;</span><br><span class="line">        <span class="function">Phone* <span class="title">create</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;   <span class="comment">// 注意返回类型为 基类 指针</span></span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (type)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">XiaoMi</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Apple</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SimpleFactory factory = <span class="built_in">SimpleFactory</span>();</span><br><span class="line">    Phone* ptr = factory.<span class="built_in">create</span>(<span class="number">0</span>);</span><br><span class="line">    ptr-&gt;<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    ptr = factory.<span class="built_in">create</span>(<span class="number">1</span>);</span><br><span class="line">    ptr-&gt;<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>C++Lambda表达式</title>
    <url>/2021/05/11/C++/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/c11_Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>C11Lambda表达式</p>
<span id="more"></span>

<h1 id="C-11-Lambda表达式"><a href="#C-11-Lambda表达式" class="headerlink" title="C++ 11 Lambda表达式"></a>C++ 11 Lambda表达式</h1><p>C++11的一大亮点就是引入了Lambda表达式。利用Lambda表达式，可以方便的定义和创建匿名函数。</p>
<h2 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h2><p>Lambda表达式完整的声明格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[capture list] (params list) mutable exception-&gt; return type &#123; function body &#125;</span><br></pre></td></tr></table></figure>

<p>各项具体含义如下</p>
<ol>
<li>capture list：捕获外部变量列表</li>
<li>params list：形参列表</li>
<li>mutable指示符：用来说用是否可以修改捕获的变量</li>
<li>exception：异常设定</li>
<li>return type：返回类型</li>
<li>function body：函数体</li>
</ol>
<p>此外，我们还可以省略其中的某些成分来声明“不完整”的Lambda表达式，常见的有以下几种：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>格式</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>[capture list] (params list) -&gt; return type {function body}</td>
</tr>
<tr>
<td>2</td>
<td>[capture list] (params list) {function body}</td>
</tr>
<tr>
<td>3</td>
<td>[capture list] {function body}</td>
</tr>
</tbody></table>
<p>其中：</p>
<ul>
<li>格式1声明了const类型的表达式，这种类型的表达式不能修改捕获列表中的值。</li>
<li><strong>格式2省略了返回值类型，但编译器可以根据以下规则推断出Lambda表达式的返回类型：</strong> （1）：如果function body中存在return语句，则该Lambda表达式的返回类型由return语句的返回类型确定； （2）：如果function body中没有return语句，则返回值为void类型。</li>
<li>格式3中省略了参数列表，类似普通函数中的无参函数。</li>
</ul>
<h2 id="基本例子"><a href="#基本例子" class="headerlink" title="基本例子"></a>基本例子</h2><p>在C++11之前，我们使用STL的sort函数，需要提供一个谓词函数。如果使用C++11的Lambda表达式，我们只需要传入一个匿名函数即可，方便简洁，而且代码的可读性也比旧式的做法好多了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; myvec&#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">lbvec</span><span class="params">(myvec)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(myvec.<span class="built_in">begin</span>(), myvec.<span class="built_in">end</span>(), cmp); <span class="comment">// 旧式做法</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;predicate function:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> it : myvec)</span><br><span class="line">        cout &lt;&lt; it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(lbvec.<span class="built_in">begin</span>(), lbvec.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">bool</span> &#123; <span class="keyword">return</span> a &lt; b; &#125;);   <span class="comment">// Lambda表达式</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda expression:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> it : lbvec)</span><br><span class="line">        cout &lt;&lt; it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="捕获外部变量"><a href="#捕获外部变量" class="headerlink" title="捕获外部变量"></a>捕获外部变量</h2><p>Lambda表达式通过在最前面的方括号[]来明确指明其内部可以访问的外部变量。可以使用其可见范围内的外部变量，但必须明确声明（明确声明哪些外部变量可以被该Lambda表达式使用），圆括号里的属于输出参数，是调用的时候输入函数的参数列表。</p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：123</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//或通过“函数体”后面的‘()’传入参数</span></span><br><span class="line">    <span class="keyword">auto</span> x = [](<span class="keyword">int</span> a)&#123;cout &lt;&lt; a &lt;&lt; endl;&#125;(<span class="number">123</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个例子对比了 使用捕获变量 和 参数传递的方式 两种用法。第一个捕获了外部的变量a，可以在匿名函数中直接使用，第二个，则是在调用函数x的时候，通过()传递的123给匿名函数的入口参数，和前面申明的a没有任何关系。</p>
<h3 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h3><p>顾名思义，就是直接捕获外部变量的值，在申明匿名函数的时候捕获到值后，如果该变量值被修改，然后再调用匿名函数，那么匿名函数使用的值还是原先的值，这就是值捕获的特定，只是在捕获的那一刻对值进行了拷贝，类似于函数值传递的特点一样。如下例子。<strong>值捕获的变量，在函数内部不能修改该外部变量的值，会出发编译错误</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用捕获"><a href="#引用捕获" class="headerlink" title="引用捕获"></a>引用捕获</h3><p>使用引用捕获一个外部变量，只需要在捕获列表变量前面加上一个引用说明符。同理，引用捕获的变量使用的实际上就是该引用所绑定的对象，因此随后对被捕获变量的修改会影响影响Lambda表达式中的值。（可以修改外部变量）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;a] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;; </span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：321</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h3><p>上面的值捕获和引用捕获都需要我们在捕获列表中显示列出Lambda表达式中使用的外部变量。除此之外，我们还可以让编译器根据函数体中的代码来推断需要捕获哪些变量，这种方式称之为隐式捕获。隐式捕获有两种方式，分别是[=]和[&amp;]。[=]表示以值捕获的方式捕获外部变量，[&amp;]表示以引用捕获的方式捕获外部变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [=] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    <span class="comment">// 值捕获</span></span><br><span class="line">    a = <span class="number">342</span>;</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：123</span></span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;] &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;;    <span class="comment">// 引用捕获</span></span><br><span class="line">    a = <span class="number">321</span></span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：321</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="混合方式"><a href="#混合方式" class="headerlink" title="混合方式"></a>混合方式</h3><table>
<thead>
<tr>
<th>捕获形式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>不捕获任何外部变量</td>
</tr>
<tr>
<td>[变量名, …]</td>
<td>默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp;说明符）</td>
</tr>
<tr>
<td>[this]</td>
<td>以值的形式捕获this指针</td>
</tr>
<tr>
<td>[=]</td>
<td>以值的形式捕获所有外部变量</td>
</tr>
<tr>
<td>[&amp;]</td>
<td>以引用形式捕获所有外部变量</td>
</tr>
<tr>
<td>[=, &amp;x]</td>
<td>变量x以引用形式捕获，其余变量以传值形式捕获</td>
</tr>
<tr>
<td>[&amp;, x]</td>
<td>变量x以值的形式捕获，其余变量以引用形式捕获</td>
</tr>
</tbody></table>
<h2 id="修改捕获变量的值"><a href="#修改捕获变量的值" class="headerlink" title="修改捕获变量的值"></a>修改捕获变量的值</h2><p>又想用值捕获，又想用值捕获的方式，就需要使用mutable关键字，该关键字用以说明表达式体内的代码可以修改值捕获的变量。(引用捕获就可以修改外部变量的值，mutable方式可能是针对指针变量使用的吧)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [a]()<span class="keyword">mutable</span> &#123; cout &lt;&lt; ++a; &#125;; <span class="comment">// 不会报错</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 输出：123</span></span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：124</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Lambda表达式的参数"><a href="#Lambda表达式的参数" class="headerlink" title="Lambda表达式的参数"></a>Lambda表达式的参数</h2><p>Lambda表达式的参数和普通函数的参数类似，单是在Lambda表达式中传递参数还有一些限制，主要有以下几点：</p>
<ol>
<li>参数列表中不能有默认参数</li>
<li>不支持可变参数</li>
<li>所有参数必须有参数名</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++可变参数模板</title>
    <url>/2021/05/11/C++/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/c11_%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>C11可变参数模板</p>
<span id="more"></span>

<h1 id="C-11可变参数模板"><a href="#C-11可变参数模板" class="headerlink" title="C++11可变参数模板"></a>C++11可变参数模板</h1><p>C++11的新特性–可变模版参数（variadic templates）是C++11新增的最强大的特性之一，它对参数进行了高度泛化，它能表示0到任意个数、任意类型的参数   <a href="https://www.cnblogs.com/qicosmos/p/4325949.html">https://www.cnblogs.com/qicosmos/p/4325949.html</a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>可变参数模板和普通模板的语义是一样的，只是写法上稍有区别，声明可变参数模板时需要在typename或class后面带上省略号“…”。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T... args)</span></span>;</span><br></pre></td></tr></table></figure>

<p>上面的可变模版参数的定义当中，省略号的作用有两个：</p>
<ol>
<li>声明一个<strong>模板参数包</strong>T… args，这个参数包中可以包含 0 到任意个模板参数；</li>
<li>在模板定义的右边，可以将<strong>参数包 即 args</strong>展开成一个一个独立的参数。</li>
</ol>
<p>上面的参数args前面有省略号，所以它就是一个可变模版参数，我们把带省略号的参数称为“参数包”，它里面包含了0到N（N&gt;=0）个模版参数。我们无法直接获取参数包args中的每个参数的，只能通过展开参数包的方式来获取参数包中的每个参数，这是使用可变模版参数的一个主要特点。</p>
<p>可变模版参数和普通的模版参数语义是一致的，所以可以应用于函数和类，即可变模版参数函数和可变模版参数类</p>
<h2 id="可变参数函数模版"><a href="#可变参数函数模版" class="headerlink" title="可变参数函数模版"></a>可变参数函数模版</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl; <span class="comment">//打印变参的个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>();        <span class="comment">//0</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>, <span class="number">2</span>);    <span class="comment">//2</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>, <span class="number">2.5</span>, <span class="string">&quot;&quot;</span>);    <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<h3 id="递归函数方式展开参数包"><a href="#递归函数方式展开参数包" class="headerlink" title="递归函数方式展开参数包"></a>递归函数方式展开参数包</h3><p>通过递归函数展开参数包，需要提供一个<strong>参数包展开的函数</strong>和一个<strong>递归终止函数</strong>，递归终止函数正是用来终止递归的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//递归终止函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//展开函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> ...<span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T head, Args... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;parameter &quot;</span> &lt;&lt; head &lt;&lt; endl;</span><br><span class="line">   <span class="built_in">print</span>(rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例会输出每一个参数，直到为空时输出empty。展开参数包的函数有两个，一个是递归函数，另外一个是递归终止函数，参数包Args…在展开的过程中递归调用自己，每调用一次参数包中的参数就会少一个，直到所有的参数都展开为止，当没有参数时，则调用非模板函数print终止递归过程。</p>
<p>递归调用的过程是这样的:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//print(1,2,3,4);</span></span><br><span class="line"><span class="comment">//print(2,3,4);</span></span><br><span class="line"><span class="comment">//print(3,4);</span></span><br><span class="line"><span class="comment">//print(4);</span></span><br><span class="line"><span class="comment">//print();</span></span><br></pre></td></tr></table></figure>

<p>上面的递归终止函数还可以写成这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//print(1,2,3,4);</span></span><br><span class="line"><span class="comment">//print(2,3,4);</span></span><br><span class="line"><span class="comment">//print(3,4);</span></span><br><span class="line"><span class="comment">//print(4);</span></span><br></pre></td></tr></table></figure>

<h3 id="逗号表达式展开参数包"><a href="#逗号表达式展开参数包" class="headerlink" title="逗号表达式展开参数包"></a>逗号表达式展开参数包</h3><h2 id="可变模版参数类"><a href="#可变模版参数类" class="headerlink" title="可变模版参数类"></a>可变模版参数类</h2>]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++inline关键字</title>
    <url>/2021/04/27/C++/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/inlline%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>inline  关键字</p>
<span id="more"></span>

<p>参考链接：<a href="https://zhuanlan.zhihu.com/p/151995167">https://zhuanlan.zhihu.com/p/151995167</a></p>
<p>当程序执行函数调用指令时，CPU将存储该函数调用后指令的内存地址，将函数的参数复制到堆栈上，最后将控制权转移到指定的函数。然后，CPU执行函数代码，将函数返回值存储在预定义的内存位置/寄存器中，并将控制权返回给调用函数。如果函数的执行时间少于从调用者函数到被调用函数（被调用者）的切换时间，则这可能会成为开销。对于大型函数和/或执行复杂任务的函数，与函数运行所花费的时间相比，函数调用的开销通常微不足道。但是，对于小型的常用功能，进行函数调用所需的时间通常比实际执行函数代码所需的时间多得多。对于小功能，由于小功能的执行时间少于切换时间，因此会产生开销。</p>
<p><strong>C++提供了inline函数，以减少函数调用的开销。内联函数是在调用时在行中扩展的函数。调用内联函数时，将在内联函数调用时插入或替换内联函数的整个代码。替换由C++编译器在编译时执行。如果内联函数很小，则可以提高效率。</strong></p>
<p>inline函数看起来像函数，动作像函数，但是又比宏方便很多，调用inline函数省去了参数压栈、生成汇编语言的 CALL调用、返回参数、执行return等过程所花费的额外开销。不过inline函数也有缺点：增加目标码的大小。因为inline函数的设计思想是对该函数的所有调用都用函数本身替换掉，和宏定义一样，但是比宏定义用起来要简单很多。而且inline的调试同样很难。所以，inline函数对于函数体积很小，却又频繁调用这样的函数来说，可能比函数调用产生的代码更少，但是效率却不可同日而语。有一点需要注意的是：<strong>inline只是对编译器提出一个申请，并不是强制命令。编译器可以忽略内联请求。</strong> 在以下情况下，编译器可能不会执行内联：</p>
<ul>
<li>如果函数包含循环。（对于while，do-while）</li>
<li>如果函数包含静态变量。</li>
<li>如果函数是递归的。</li>
<li>如果函数的返回类型不是void，并且函数主体中不存在return语句。</li>
<li>如果函数包含switch或goto语句。</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>inline可以显示声明，也可以隐式声明。<strong>隐式声明方式是将函数定义在类定义之中</strong>（函数定义时没有inline关键字），编译器也会当作inline函数。另外，定义在类中的friend函数也会被隐式声明为inline函数。</p>
<p>显式声明的时候必须<strong>与函数定义体放在一起才能使函数成为内联</strong>，仅将inline放在函数声明前面不起任何作用。定义函数内联的语法为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">return</span>-type function-<span class="built_in">name</span>(parameters)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// function code</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此外，inline函数通常放在头文件中，因为大多数 build environments 在<strong>编译期进行inlining</strong>，编译器必须知道函数什么样子才能把<em>函数调用</em>替换成<em>函数本体</em>。大多数virtual函数不能inlining：因为virtual直到<em>运行时</em>才知道调用哪个函数，而inline是在执行前进行替换。此外，对于<em>通过函数指针进行的调用</em>编译器通常不会inlining</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点</p>
<ol>
<li>不会发生函数调用开销。</li>
<li>调用函数时，还节省了push / pop变量在栈上的开销。</li>
<li>它还节省了从函数返回调用的开销。</li>
<li>内联函数时，可以使编译器对函数主体执行特定于上下文的优化。对于正常的函数调用，这种优化是不可能的。通过考虑调用上下文和被调用上下文的流程可以获得其他优化。</li>
<li>内联函数可能对于嵌入式系统有用（如果很小），因为内联函数所产生的代码少于函数调用的前导和返回。</li>
</ol>
<p>缺点：</p>
<ol>
<li>内联函数中添加的变量消耗了额外的寄存器，在内联函数之后，如果要使用寄存器的变量编号增加，则它们可能会增加寄存器变量资源利用的开销。这意味着当在函数调用点替换内联函数主体时，该函数使用的变量总数也会被插入。因此，将用于变量的寄存器数量也将增加。因此，如果函数内联后的变量数急剧增加，则肯定会导致寄存器利用率增加。</li>
<li>如果使用太多的内联函数，则由于重复执行相同的代码，二进制可执行文件的大小将很大。</li>
<li>过多的内联也会降低指令Cache命中率，从而降低了从高速缓存到主存储器的指令获取速度。</li>
<li>如果有人更改了内联函数中的代码，则内联函数可能会增加编译时间开销，然后必须重新编译所有调用位置，这是因为编译器将需要再次替换所有代码以反映更改，否则它将继续使用旧功能。</li>
<li>内联函数对于许多嵌入式系统可能没有用。因为在嵌入式系统中，代码大小比速度更重要。</li>
<li>内联函数可能会导致崩溃，因为内联可能会增加二进制可执行文件的大小。内存溢出会导致计算机性能下降。</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++static关键字</title>
    <url>/2021/05/11/C++/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>C++static关键字</p>
<span id="more"></span>

<h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><ul>
<li>面向对象  （变量、函数）<ul>
<li>静态成员变量</li>
<li>静态成员函数</li>
</ul>
</li>
<li>面向过程<ul>
<li>静态全局变量</li>
<li>静态局部变量</li>
<li>静态函数</li>
</ul>
</li>
</ul>
<h2 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h2><p>在类内成员变量的声明前加上关键字static，该数据成员就是类内的静态数据成员。</p>
<h3 id="静态成员变量特点："><a href="#静态成员变量特点：" class="headerlink" title="静态成员变量特点："></a>静态成员变量特点：</h3><ol>
<li><strong>静态成员变量是该类的所有对象所共有的</strong>。对于普通成员变量，每个类对象都有自己的一份拷贝。而静态成员变量一共就一份，无论这个类的对象被定义了多少个，静态成员变量只分配一次内存，由该类的所有对象共享访问。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；</li>
<li>因为<strong>静态数据成员在全局数据区分配内存</strong>，由本类的所有对象共享，所以，它不属于特定的类对象，<strong>不占用对象的内存</strong>，而是在所有对象之外开辟内存，在没有产生类对象时其作用域就可见。因此，<strong>在没有类的实例存在时，静态成员变量就已经存在，我们就可以操作它；</strong></li>
<li>因为静态成员变量 不随 一个类的实例化 而重新开辟内存。所以 <strong>静态成员变量，必须在类外定义</strong>，如例子中的 <code>int Myclass::Sum;</code> 在这儿定义了之后，<strong>才会被分配内存</strong>，因此不定义的话就会报错。但是可以不初始化，<strong>静态成员变量存储在全局数据区</strong>，编译器就默认0. </li>
<li>static 成员变量和普通 static 变量一样，<strong>编译时在静态数据区分配内存，到程序结束时才释放</strong>，不随对象的销毁而释放内存。</li>
<li>静态成员变量定义 初始化  可以不加 static  关键字 如例子。<code>＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞</code></li>
<li>静态成员变量可以不通过 类对象 访问</li>
<li><strong><code>sizeof</code> 运算符不会计算 静态成员变量</strong></li>
<li>静态数据成员和普通数据成员一样遵从public,protected,private访问规则；</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>如果想在同类的多个对象之间实现数据共享，又不要用全局变量，那么就可以使用静态成员变量。静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处：</p>
<ol>
<li>不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，节省存储空间。</li>
<li>一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了。</li>
</ol>
<h3 id="相对全局变量的优点"><a href="#相对全局变量的优点" class="headerlink" title="相对全局变量的优点"></a>相对全局变量的优点</h3><ol>
<li>静态成员变量没有进入程序的全局命名空间，因此不存在与程序中其它全局命名冲突的可能。</li>
<li>可以实现信息隐藏。静态成员变量可以是private成员，而全局变量不能。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyclass</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s;</span><br><span class="line">&#125;;    <span class="comment">//则sizeof（CMyclass）等于4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Myclass</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a=a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b=b;</span><br><span class="line">        <span class="keyword">this</span>-&gt;c=c;</span><br><span class="line">        Sum+=a+b+c;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">GetSum</span><span class="params">()</span></span>&#123;    </span><br><span class="line">	    cout&lt;&lt;<span class="string">&quot;Sum=&quot;</span>&lt;&lt;Sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a,b,c;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> Sum;<span class="comment">//声明静态数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Myclass::Sum=<span class="number">10</span>;    <span class="comment">//定义并初始化静态数据成员  不初始化的话 编译链接通不过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Myclass <span class="title">M</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">	M.<span class="built_in">GetSum</span>();</span><br><span class="line">	<span class="function">Myclass <span class="title">N</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line">	N.<span class="built_in">GetSum</span>();</span><br><span class="line">	M.<span class="built_in">GetSum</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">Sum=16</span></span><br><span class="line"><span class="comment">Sum=31</span></span><br><span class="line"><span class="comment">Sum=31</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><p>与静态成员变量类似，我们也可以声明一个静态成员函数。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>出现在类体外的函数定义不能指定关键字static； (就是static关键字只能出现在类里)</li>
<li><strong>静态成员之间可以相互访问，即静态成员函数（仅）可以访问静态成员变量、静态成员函数；</strong></li>
<li><strong>静态成员函数不能访问非静态成员函数和非静态成员变量；</strong></li>
<li>非静态成员函数可以任意地访问静态成员函数和静态数据成员；</li>
<li><strong>由于没有this指针的额外开销，静态成员函数与类的全局函数相比速度上会稍快；</strong> （也正是因为没有this指针，静态成员函数不能访是虚函数，也不能访问非静态成员）</li>
<li>调用静态成员函数，两种方式  通过对象 和 不通过对象 调用</li>
</ol>
<h3 id="拷贝构造函数的问题"><a href="#拷贝构造函数的问题" class="headerlink" title="拷贝构造函数的问题"></a>拷贝构造函数的问题</h3><p>例如下面的例子中，调用拷贝构造函数生成临时隐藏类对象时，这个临时对象在消亡时会调用析构函数 会 执行 totle_num–。简言之，就是在使用 拷贝构造时 对静态成员变量的操作要注意时 成对的 否则会出bug</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Example 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">char</span> *name;</span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">float</span> score;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> num;  	<span class="comment">//学生人数</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">float</span> total;  <span class="comment">//总分</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Student</span>(<span class="keyword">char</span> *, <span class="keyword">int</span>, <span class="keyword">float</span>);</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getAverage</span><span class="params">()</span></span>;  <span class="comment">//静态成员函数，用来获得平均成绩</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Student::num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> Student::total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">float</span> score)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">   <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">   <span class="keyword">this</span>-&gt;score = score;</span><br><span class="line">   num++;</span><br><span class="line">   total += score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::say</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout&lt;&lt;name&lt;&lt;<span class="string">&quot;的年龄是 &quot;</span>&lt;&lt;age&lt;&lt;<span class="string">&quot;，成绩是 &quot;</span>&lt;&lt;score&lt;&lt;<span class="string">&quot;（当前共&quot;</span>&lt;&lt;num&lt;&lt;<span class="string">&quot;名学生）&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Student::getAverage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> total / num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   (<span class="keyword">new</span> <span class="built_in">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">15</span>, <span class="number">90</span>))-&gt;<span class="built_in">say</span>();</span><br><span class="line">   (<span class="keyword">new</span> <span class="built_in">Student</span>(<span class="string">&quot;李磊&quot;</span>, <span class="number">16</span>, <span class="number">80</span>))-&gt;<span class="built_in">say</span>();</span><br><span class="line">   (<span class="keyword">new</span> <span class="built_in">Student</span>(<span class="string">&quot;张华&quot;</span>, <span class="number">16</span>, <span class="number">99</span>))-&gt;<span class="built_in">say</span>();</span><br><span class="line">   (<span class="keyword">new</span> <span class="built_in">Student</span>(<span class="string">&quot;王康&quot;</span>, <span class="number">14</span>, <span class="number">60</span>))-&gt;<span class="built_in">say</span>();</span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;平均成绩为 &quot;</span>&lt;&lt;Student::<span class="built_in">getAverage</span>()&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">小明的年龄是 <span class="number">15</span>，成绩是 <span class="number">90</span>（当前共<span class="number">1</span>名学生）</span><br><span class="line">李磊的年龄是 <span class="number">16</span>，成绩是 <span class="number">80</span>（当前共<span class="number">2</span>名学生）</span><br><span class="line">张华的年龄是 <span class="number">16</span>，成绩是 <span class="number">99</span>（当前共<span class="number">3</span>名学生）</span><br><span class="line">王康的年龄是 <span class="number">14</span>，成绩是 <span class="number">60</span>（当前共<span class="number">4</span>名学生）</span><br><span class="line">平均成绩为 <span class="number">82.25</span></span><br></pre></td></tr></table></figure>



<h2 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol>
<li>该<strong>变量在全局数据区分配内存；</strong></li>
<li>未经初始化的静态全局变量会被程序自动初始化为0（自动变量的自动初始化值是随机的）；</li>
<li><strong>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的；</strong> 　</li>
</ol>
<p>对于一个完整的程序，在内存中的分布情况如下：</p>
<blockquote>
<p>【代码区】【全局数据区】【堆区】【栈区】</p>
<p>堆区：一般程序的由new产生的动态数据存放在<br>栈区：函数内部的自动变量存放在栈区，自动变量一般会随着函数的退出而释放空间<br>全局数据区：静态数据（即使是函数内部的静态局部变量）存放在全局数据区。而全局数据区的数据并不会因为函数的退出而释放空间。</p>
</blockquote>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>静态全局变量不能被其它文件所用；（即使在其它文件中使用extern 进行声明也不行）</li>
<li>其它文件中可以定义相同名字的变量，不会发生冲突；</li>
</ol>
<h2 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h2><p>在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。</p>
<p>通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，这给程序的维护带来不便。静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。</p>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ol>
<li>静态局<strong>部变量在全局数据区分配内存；</strong></li>
<li>静态局部<strong>变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化</strong>；</li>
<li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；</li>
<li>静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；</li>
<li></li>
</ol>
<h2 id="静态函数"><a href="#静态函数" class="headerlink" title="静态函数"></a>静态函数</h2><p>在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。</p>
<ol>
<li>静态函数不能被其它文件所用；</li>
<li>其它文件中可以定义相同名字的函数，不会发生冲突；</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ volatile关键字</title>
    <url>/2021/05/04/C++/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>C++volatile关键字</p>
<span id="more"></span>

<p>参考链接：<a href="https://zhuanlan.zhihu.com/p/62060524">https://zhuanlan.zhihu.com/p/62060524</a></p>
<h2 id="volatile-的作用"><a href="#volatile-的作用" class="headerlink" title="volatile 的作用"></a>volatile 的作用</h2><p>volatile 关键字是一种类型修饰符，<strong>用它声明的类型变量表示可以被某些编译器未知的因素更改</strong>。比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，<strong>编译器对访问该变量的代码就不再进行优化，系统总是重新从它所在的内存读取数据</strong>，从而可以提供对特殊地址的稳定访问。</p>
<h3 id="为什么可以提供特殊地址的稳定访问？"><a href="#为什么可以提供特殊地址的稳定访问？" class="headerlink" title="为什么可以提供特殊地址的稳定访问？"></a>为什么可以提供特殊地址的稳定访问？</h3><p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a = i;</span><br><span class="line"><span class="keyword">int</span> b = i; </span><br></pre></td></tr></table></figure>

<p>volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。而优化做法是，<strong>由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i是一个寄存器变量或者表示一个端口数据就容易出错</strong>，所以说 volatile 可以保证对特殊地址的稳定访问。</p>
<blockquote>
<p>更多的可能是多线程并发访问共享变量时，一个线程改变了变量的值，怎样让改变后的值对其它线程 visible</p>
</blockquote>
<p>下面通过插入汇编代码，测试有无 volatile 关键字，对程序最终代码的影响：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> a = i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面汇编语句的作用就是改变内存中 i 的值</span></span><br><span class="line">    <span class="comment">// 但是又不让编译器知道</span></span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov dword ptr [ebp<span class="number">-4</span>], <span class="number">20</span>h</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b = i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i = %d&quot;</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后，在 Debug 版本模式运行程序，输出结果如下： i = 10   i = 32</span></span><br><span class="line"><span class="comment">// 然后，然后，在 Release 版本模式运行程序 输出结果如下： i = 10   i = 10  加上 volatile 关键字 就不会这样了</span></span><br></pre></td></tr></table></figure>

<p>输出的结果明显表明，Release 模式下，编译器对代码进行了优化，第二次没有输出正确的 i 值。</p>
<blockquote>
<p>内嵌汇编操纵栈”这种方式属于编译无法识别的变量改变</p>
</blockquote>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>一般说来，volatile用在如下的几个地方：</p>
<ul>
<li><strong>中断服务程序中修改的供其它程序检测的变量需要加volatile；</strong></li>
<li><strong>多任务环境下各任务间共享的标志应该加volatile；</strong></li>
<li><strong>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</strong></li>
</ul>
<h2 id="volatile指针"><a href="#volatile指针" class="headerlink" title="volatile指针"></a>volatile指针</h2><p>和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cpch;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">char</span>* vpch;  <span class="comment">// 修饰由指针指向的对象、数据是 const 或 volatile 的：</span></span><br><span class="line"><span class="keyword">char</span>* pch;</span><br><span class="line"><span class="keyword">volatile</span> a = <span class="number">1</span>;</span><br><span class="line">pch = &amp;a       <span class="comment">// 错误</span></span><br><span class="line">vpch = &amp;a      <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> pchc;</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">volatile</span> pchv;  <span class="comment">// 指针自身的值——一个代表地址的整数变量，是 const 或 volatile 的：</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>可以把一个非volatile int赋给volatile int，<strong>但是不能把非volatile对象赋给一个volatile对象</strong>。</li>
<li>除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。</li>
<li>用户只能用const_cast来获得对类型接口的完全访问。此外，<strong>volatile像const一样会从类传递到它的成员</strong>。</li>
<li><strong>和 const 类似， 只能将 volatile 的对象的地址 赋给  可以指向volitatlie对象的指针，只能将volatile 对象绑定到 volatile 引用上</strong>。</li>
<li><strong>一个对象即可以是 volatile 属性的 同时 也是 const 属性，不冲突，例如只读的寄存器值</strong>。</li>
<li><strong>和 const 的重要的区别是，不能使用 合成的 拷贝构造函数及赋值运算符初始化  volatitle 对象或从 volatile 对象赋值</strong>，需要重新实现。</li>
</ol>
<h2 id="多线程下的-volatile"><a href="#多线程下的-volatile" class="headerlink" title="多线程下的 volatile"></a>多线程下的 volatile</h2><p>有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，该关键字的作用是<strong>防止优化编译器把变量从内存装入CPU寄存器中。</strong>如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是<strong>让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值，</strong>如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> BOOL bStop = FALSE;</span><br><span class="line"><span class="comment">// 在一个线程中</span></span><br><span class="line"><span class="keyword">while</span>( !bStop ) &#123; ... &#125; </span><br><span class="line">bStop = FALSE; </span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line"><span class="comment">//在另一个线程中 要终止上面的线程循环。</span></span><br><span class="line">bStop  =  TRUE;  </span><br><span class="line"><span class="keyword">while</span>(  bStop  ); </span><br></pre></td></tr></table></figure>

<p>等待上面的线程终止，如果bStop不使用volatile声明，那么这个循环将是一个死循环，因为bStop已经读取到了寄存器中，寄存器中bStop的值永远不会变成FALSE，加上volatile，程序在执行时，每次均从内存中读出bStop的值，就不会死循环了。</p>
<h2 id="volatile与多线程"><a href="#volatile与多线程" class="headerlink" title="volatile与多线程"></a>volatile与多线程</h2><ul>
<li><input disabled="" type="checkbox"> 详细见参考博文，感觉这块水挺深 以后再说</li>
<li><input disabled="" type="checkbox"> CPU 的乱序执行，为了提高效率，CPU会乱序执行。例如如果当前需要从内存中读取变量的a的值，但是这个要等，为了效率，CPU可能会将后面不需要等待的，且和a变量完全不相关的指令先执行（这个不相关，不仅仅指依赖关系）。单核单线程下，不会存在这种操作没问题，最终结果看起来也像串行的。但是如果是多线程，乱序就会有问题，通常来说，多线程下，不能寄希望于使用 volatile 来解决 并发引起的冲突问题。要使用原子操作。</li>
<li><input disabled="" type="checkbox"> CPU乱序执行的证明？肯定要用多线程证明 <a href="https://hihen.github.io/posts/cpu-exec-out-of-order/">https://hihen.github.io/posts/cpu-exec-out-of-order/</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++仿函数</title>
    <url>/2021/05/11/C++/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E4%BB%BF%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>C++中的仿函数介绍</p>
<span id="more"></span>

<h1 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h1><h2 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h2><p>当需要将函数作为一个参数传递进另一个函数时，可以使用函数指针。例如下面的例子：</p>
<blockquote>
<p>假设我们现在有一个数组，数组中存有任意数量的数字，我们希望能够统计出这个数组中大于 10 的数字的数量，你的代码很可能是这样的：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RecallFunc</span><span class="params">(<span class="keyword">int</span> *start, <span class="keyword">int</span> *end, <span class="keyword">bool</span> (*pf)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> *i=start;i!=end+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	count = <span class="built_in">pf</span>(*i) ? count+<span class="number">1</span> : count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsGreaterThanTen</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num&gt;<span class="number">10</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">10</span>,<span class="number">100</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">19</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">RecallFunc</span>(a,a+<span class="number">4</span>,IsGreaterThanTen);</span><br><span class="line">    cout&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，如果此时希望将判定的阈值也作为一个变量传入，变为如下函数就不可行了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsGreaterThanThreshold</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> threshold)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num&gt;threshold ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这个函数看起来比前面一个版本更具有一般性，但是它不能满足已经定义好的函数指针参数的要求，因为函数指针参数的类型是<code>bool (*)(int)</code>，与函数<code>bool IsGreaterThanThreshold(int num, int threshold)</code>的类型不相符。如果一定要完成这个任务，按照以往的经验，我们可以考虑如下可能途径：</p>
<p>（1）阈值作为函数的局部变量。局部变量不能在函数调用中传递，故不可行；<br>（2）函数传参。这种方法我们已经讨论过了，多个参数不适用于已定义好的 RecallFunc() 函数。<br>（3）全局变量。我们可以将阈值设置成一个全局变量。这种方法虽然可行，但是不优雅，且非常容易引入 Bug，比如全局变量容易同名，造成命名空间污染。</p>
<p>那么有什么好的处理方法呢？仿函数应运而生。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>编程者要将某种“操作”当做算法的参数，一般有两种方法：</p>
<p>（1）一个办法就是先将该“操作”设计为一个函数，再将函数指针当做算法的一个参数。上面的实例就是该做法；<br>（2）将该“操作”设计为一个仿函数（就语言层面而言是个 class），再以该仿函数产生一个对象，并以此对象作为算法的一个参数。</p>
<p>仿函数写法： 写一个简单类，除了维护类的基本成员函数外（<code>struct</code>也可），<strong>只需要重载 operator() 运算符</strong> 。这样既可以免去对一些公共变量的维护，也可以使重复使用的代码独立出来，以便下次复用。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mycmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;a, vector&lt;<span class="keyword">int</span>&gt; &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsGreaterThanThresholdFunctor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">IsGreaterThanThresholdFunctor</span><span class="params">(<span class="keyword">int</span> t)</span>:threshold(t)&#123;</span>&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> num)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num &gt; threshold ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> threshold;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RecallFunc</span><span class="params">(<span class="keyword">int</span> *start, <span class="keyword">int</span> *end, IsGreaterThanThresholdFunctor myFunctor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> *i = start; i != end + <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		count = <span class="built_in">myFunctor</span>(*i) ? count + <span class="number">1</span> : count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">10</span>,<span class="number">100</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">19</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="built_in">RecallFunc</span>(a, a + <span class="number">4</span>, <span class="built_in">IsGreaterThanThresholdFunctor</span>(<span class="number">10</span>));</span><br><span class="line">	cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++字节对齐</title>
    <url>/2021/05/11/C++/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<p>C++字节对齐</p>
<span id="more"></span>

<h3 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h3><p>​        有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那 么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数 据。显然在读取效率上下降很多。为了保证读取效率，c/c++变量地址要保证字节对齐。</p>
<ol>
<li>结构中变量的起始地址 要为该变量类型 大小的整数倍，例如 sizeof(int) = 4 那么结构体中这个变量的存储起始地址 % 4 == 0才行。如果不行，会在前方自动填充0。</li>
<li>最后即便前面所有都填充完了，最后总的占用的字节数 要是 结构中最大类型数据所占用字节数的倍数，如果不是，最后再填充一次。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">char</span> dda;　　　　　　　　　　　　　　<span class="comment">//偏移量为0，满足对齐方式，dda占用1个字节； </span></span><br><span class="line"><span class="keyword">double</span> dda1;　　　　　　　　　　　　<span class="comment">//下一个可用的地址的偏移量为1，不是sizeof(double)=8的倍数，需要补足7个字节才能使偏移量变为8（满足对齐方式），因此VC自动填充7个字节，dda1存放在偏移量为8的地址上，它占用8个字节。 </span></span><br><span class="line"><span class="keyword">int</span> type；　　　　　　　　　　　　　<span class="comment">//下一个可用的地址的偏移量为16，是sizeof(int)=4的倍数，满足int的对齐方式，所以不需要VC自动填充，type存放在偏移量为16的地址上，它占用4个字节。 </span></span><br><span class="line">&#125;；　　　　　　　　　　　　　　　　　<span class="comment">//所有成员变量都分配了空间，空间总的大小为1+7+8+4=20，不是结构的节边界数（即结构中占用最大空间的类型所占用的字节数sizeof(double)=8）的倍数，所以需要填充4个字节，以满足结构的大小为sizeof(double)=8的倍数。 </span></span><br><span class="line"><span class="comment">////  24 </span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
        <category>语言特性</category>
        <category>��������</category>
        <category>��������</category>
        <category>��������</category>
        <category>��������</category>
        <category>��������</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++右值和左值</title>
    <url>/2021/05/11/C++/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</url>
    <content><![CDATA[<p>C++右值和左值</p>
<span id="more"></span>

<h1 id="左值-右值-右值引用"><a href="#左值-右值-右值引用" class="headerlink" title="左值/右值/右值引用"></a>左值/右值/右值引用</h1><p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406214837.png" alt="image-20210406214830548"></p>
<h2 id="左值右值的区别"><a href="#左值右值的区别" class="headerlink" title="左值右值的区别"></a>左值右值的区别</h2><h3 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h3><p>左值：有名字的，可以取地址的就是左值。</p>
<ul>
<li>函数名和变量名</li>
<li>返回左<strong>值引用</strong>的函数调用</li>
<li><strong>前置自增/自减运算符连接的表达式++i/–i</strong></li>
<li>由赋值运算符或复合赋值运算符连接的表达式(a=b、a+=b、a%=b）</li>
<li>解引用表达式*p</li>
<li><strong>字符串字面值”abc”</strong></li>
</ul>
<h3 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h3><p>右值：不是左值，就一定是右值。右值又分为纯右值 和 将亡值。</p>
<ol>
<li><p>纯右值：指的是临时变量值、不跟对象关联的字面量值，这是C98中的定义。</p>
<ul>
<li><p><strong>除字符串字面值以外的字面值</strong></p>
</li>
<li><p>返回非引用类型的函数调用</p>
</li>
<li><p>后置自增/自减运算符连接的表达式i++/i–  (<strong>可以理解为在 cpu 中运算产生的临时值，左值一定在内存中，右值有可能在内存中也有可能在寄存器中</strong>）</p>
</li>
<li><p>算术表达式（a+b、a&amp;b、a&lt;&lt;b）,  逻辑表达式（a&amp;&amp;b、a||b、~a）取地址表达式（&amp;a）</p>
</li>
</ul>
</li>
<li><p>将亡值：这是 C11 扩充的概念，新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用）。将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通<strong>过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期</strong>。</p>
<ul>
<li>返回右值引用的函数的调用表达式</li>
<li>转换为右值引用的转换函数的调用表达</li>
<li>举例：std::move()、static_cast&lt;X&amp;&amp;&gt;(x) （X是自定义的类，x是类对象），这两个函数常用来将左值强制转换成右值，从而使拷贝变成移动（就是浅拷贝），提高效率。</li>
</ul>
</li>
</ol>
<h2 id="左-右值引用"><a href="#左-右值引用" class="headerlink" title="左/右值引用"></a>左/右值引用</h2><p>左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。</p>
<p>左值引用通常只能绑定到左值，不能绑定到右值，但是<strong>常量左值引用</strong> 是个万能的应用类型，它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的，因此优先使用右值引用去绑定右值，这样被绑定的右值也可以被修改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;a = <span class="number">2</span>;       <span class="comment">// 左值引用绑定到右值，编译失败</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;        <span class="comment">// 非常量左值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c = b; <span class="comment">// 常量左值引用绑定到非常量左值，编译通过</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> d = <span class="number">2</span>;  <span class="comment">// 常量左值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;e = c; <span class="comment">// 常量左值引用绑定到常量左值，编译通过</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b =<span class="number">2</span>;  <span class="comment">// 常量左值引用绑定到右值，编程通过</span></span><br></pre></td></tr></table></figure>

<p>右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r1 = c;             <span class="comment">// 编译失败</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r2 = std::<span class="built_in">move</span>(a);  <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure>

<h2 id="引用重载优先级"><a href="#引用重载优先级" class="headerlink" title="引用重载优先级"></a>引用重载优先级</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Data&amp;  data)</span></span>;  <span class="comment">// 1, data is l-ref</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Data&amp;&amp; data)</span></span>;  <span class="comment">// 2, data is r-ref</span></span><br><span class="line">Data   data;</span><br><span class="line"></span><br><span class="line">Data&amp;  data1 = data;             <span class="comment">// OK</span></span><br><span class="line">Data&amp;  data1 = Data&#123;&#125;;           <span class="comment">// not compile: invalid binding</span></span><br><span class="line">Data&amp;&amp; data2 = Data&#123;&#125;;           <span class="comment">// OK</span></span><br><span class="line">Data&amp;&amp; data2 = data;             <span class="comment">// not compile: invalid binding</span></span><br><span class="line">Data&amp;&amp; data2 = std::<span class="built_in">move</span>(data);  <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(data);    <span class="comment">// 1, data is lvalue</span></span><br><span class="line"><span class="built_in">f</span>(Data&#123;&#125;);  <span class="comment">// 2, data is rvalue</span></span><br><span class="line"><span class="built_in">f</span>(data1);   <span class="comment">// 1, data1 is l-ref type and lvalue</span></span><br><span class="line"><span class="built_in">f</span>(data2);   <span class="comment">// 2, data2 is r-ref type but lvalue</span></span><br></pre></td></tr></table></figure>

<p>同理，由于常引用既可以绑定到左值，又可以绑定到右值 （但是不能修改绑定的右值），因此：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">const</span> Data&amp; data)</span></span>;  <span class="comment">// data is c-ref  即可以接受左值 又可以接受右值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">g</span>(data);    <span class="comment">// ok, data is lvalue</span></span><br><span class="line"><span class="built_in">g</span>(Data&#123;&#125;);  <span class="comment">// ok, data is rvalue</span></span><br></pre></td></tr></table></figure>

<p>但是C++ 对引用参数的重载也有优先级，在 对于传入的右值，优先选择右值引用的形参列表，而不是常引用，具体如下： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Data&amp; data)</span></span>;  <span class="comment">// 1, data is c-ref</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Data&amp;&amp; data)</span></span>;       <span class="comment">// 2, data is r-ref</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(Data&#123;&#125;);  <span class="comment">// 2, prefer 2 over 1 for rvalue</span></span><br></pre></td></tr></table></figure>

<p>针对不同左右值 <strong>实参</strong> <em>(argument)</em> 重载 引用类型 <strong>形参</strong> <em>(parameter)</em> 的优先级如下。(数值越小，优先级越高；如果不存在，则重载失败)</p>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406220917.jpeg" alt="preview" style="zoom:50%;" />

<h2 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h2><p>既然有了 左值引用 和 右值 引用，那么 将两种引用排列组后 就可以得到四种组合，但是最终确定变量的引用类型只可能是左值引用或右值引用，所以引用折叠的目的就是根据  一定的规则 将引用简化。</p>
<ul>
<li>规则：如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 左值-左值 T&amp; &amp; </span><br><span class="line">- 左值-右值 T&amp; &amp;&amp;</span><br><span class="line">- 右值-左值 T&amp;&amp; &amp;</span><br><span class="line">- 右值-右值 T&amp;&amp; &amp;&amp;</span><br></pre></td></tr></table></figure>

<p>但是， 在编译器中编写以下代码，是会报错的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;ra = a;</span><br><span class="line"><span class="keyword">int</span> &amp; &amp;rra = ra;  <span class="comment">// 编译器报错：不允许使用引用的引用！</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>编译器不允许我们写下类似<code>int &amp; &amp;&amp;</code>这样的代码，但是它自己却可以推导出<code>int &amp; &amp;&amp;</code>代码出来。它的理由就是：我(编译器)虽然推导出<code>T</code>为<code>int&amp;</code>，但是我在最终生成的代码中，<strong>利用引用折叠规则</strong>，将<code>int &amp; &amp;&amp;</code>等价生成了<code>int &amp;</code>。推导出来的<code>int &amp; &amp;&amp;</code>只是过渡阶段，最终版本并不存在。所以也不算破坏规定咯。</p>
<h3 id="通用引用"><a href="#通用引用" class="headerlink" title="通用引用"></a>通用引用</h3><p>所谓的<strong>万能引用</strong>并不是C++的语法特性，而是我们利用现有的C++语法，自己实现的一个功能。因为这个功能既能接受左值类型的参数，也能接受右值类型的参数。所以叫做万能引用。有两个必要的条件：</p>
<ol>
<li>必须满足<code>T&amp;&amp;</code>这种形式</li>
<li><strong>类型<code>T</code>必须是通过推断得到的</strong></li>
</ol>
<p>所以，在我们完美转发这个部分的例子当中，我们所使用的这种引用，其实是通用引用，而不是所谓的单纯的右值引用。因为我们的函数是模板函数，<code>T</code>的类型是推断出来的，而不是指定的。那么相应的，如果有一段这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;&#125; <span class="comment">//这个T&amp;&amp;  不是一个通用引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的这个<code>T</code>是不是通用引用呢？答案是不是。因为当这个类初始化的时候这个<code>T</code>就已经被确定了，不需要推断。所以，可以构成通用引用的有如下几种可能：</p>
<ol>
<li>函数模板参数（function template parameters）</li>
<li><code>auto</code>声明（auto declaration）</li>
<li><code>typedef</code>声明（typedef declaration）</li>
<li><code>decltype</code>声明（decltype declaration）</li>
</ol>
<p>通用引用的特点是 ： <strong>传进来的如果是左值引用那就是左值引用，如果是右值引用那就是右值引用</strong>。</p>
<h3 id="通用引用原理"><a href="#通用引用原理" class="headerlink" title="通用引用原理"></a>通用引用原理</h3><p>总结上面的结论。编程的时候，编译器不允许显式的出现重叠的引用情况，但是在需要编译器推断类型的场景，可以重叠引用，编译器会根据折叠引用规则简化为最终的 左/右值引用。应用这个特性，从而可以实现通用引用的功能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// 一个通用引用的例子</span></span><br><span class="line"><span class="function">ReturnType <span class="title">Function</span><span class="params">(T&amp;&amp; parem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 函数功能实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintType</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 利用Boost库打印模板推导出来的 T 类型</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;T type：&quot;</span> &lt;&lt; type_id_with_cvr&lt;T&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; endl; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用Boost库打印形参的类型</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;param type:&quot;</span> &lt;&lt; type_id_with_cvr&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;                              <span class="comment">// 左值</span></span><br><span class="line">	<span class="built_in">PrintType</span>(a);                           <span class="comment">// 传入左值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> &amp;lvalue_refence_a = a;              <span class="comment">// 左值引用</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * T type      : int &amp;</span></span><br><span class="line"><span class="comment"> * T &amp;&amp;        : int &amp; &amp;&amp;</span></span><br><span class="line"><span class="comment"> * param type  : int &amp;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="built_in">PrintType</span>(lvalue_refence_a);            <span class="comment">// 传入左值引用</span></span><br><span class="line">	<span class="built_in">PrintType</span>(<span class="built_in"><span class="keyword">int</span></span>(<span class="number">2</span>));                      <span class="comment">// 传入右值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * T type      : int</span></span><br><span class="line"><span class="comment"> * T &amp;&amp;        : int &amp;&amp;</span></span><br><span class="line"><span class="comment"> * param type  : int &amp;&amp;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例子中，当传入左值时，param 最终为左值引用，编译器会将 T 推导为左值引用的类型（详情模板推导的规则），替换后 变为 int&amp;  &amp;&amp; 最终就是左值引用，所以它能接受一个左值。当传入的就是左值引用类型时，int&amp; &amp;&amp; 还是左值引用，当传入的是右值  int &amp;&amp;  &amp;&amp; 最终还是右值引用，即万能引用，既可以传入 左值/右值/左值引用/右值引用（右值引用实际就是左值了，所以如果传入的是右值引用，因为右值引用有了具体的名字，它实际也是一个左值了，在传入这个函数，进来就是左值了，这就不符合完美转发的要求）</p>
<h2 id="右值引用的目的"><a href="#右值引用的目的" class="headerlink" title="右值引用的目的"></a>右值引用的目的</h2><h3 id="语义移动"><a href="#语义移动" class="headerlink" title="语义移动"></a>语义移动</h3><p>传统的拷贝构造函数的入口参数为 常左值引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">string</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span>(<span class="keyword">const</span> string&amp; other);  <span class="comment">// 拷贝构造函数, exists pre C++11</span></span><br><span class="line">    <span class="built_in">string</span>(string&amp;&amp; other)&#123;       <span class="comment">// 移动构造函数, new in C++11</span></span><br><span class="line">        length = other.length;</span><br><span class="line">        capacity = other.capacity;</span><br><span class="line">        data = other.data;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> string&amp; other); <span class="comment">// Copy assn operator, pre C++11</span></span><br><span class="line">  	string&amp; <span class="keyword">operator</span>=(string&amp;&amp; other) &#123;     <span class="comment">// Move assn operator, new in C++11</span></span><br><span class="line">        length = other.length;</span><br><span class="line">        capacity = other.capacity;</span><br><span class="line">        <span class="keyword">delete</span> data;                        <span class="comment">// OK even if data is null</span></span><br><span class="line">        data = other.data;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>;</span><br><span class="line">   	    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> length;</span><br><span class="line">    <span class="keyword">size_t</span> capacity;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">string <span class="title">a</span><span class="params">(get_string())</span></span>;  <span class="comment">// move constructor</span></span><br><span class="line"><span class="function">string <span class="title">b</span><span class="params">(a)</span></span>;             <span class="comment">// copy constructor</span></span><br><span class="line"><span class="function">string <span class="title">c</span><span class="params">(std::move(b))</span></span>;  <span class="comment">// move constructor</span></span><br></pre></td></tr></table></figure>

<p>问题：上述例子中 get_string 返回的是临时右值，如果不存在 移动构造函数，会调用类别的拷贝构造函数，将临时右值中内存区域的东西在内内拷贝出另一份，然后再把临时右值的内存释放掉。但是如果存在 移动构造函数，会被优先重载（入口参数为右值引用），那么在移动构造函数中，只是将临时右值的内存转给了类管理。这样并没有重新拷贝内存，实际也没有释放掉临时右值，它被右值引用延长了生命周期。这两种函数的对比如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406223806.png" alt="image-20210406223806748" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406223821.png" alt="image-20210406223821469" style="zoom:67%;" /></p>
<h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relay</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in relay&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">relay</span>(<span class="built_in">Test</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子当中，我们的期待是，我们在<code>main</code>当中调用<code>relay</code>，<code>Test</code>的临时对象作为一个右值传入<code>relay</code>，在<code>relay</code>当中又被转发给了<code>func</code>，那这时候转发给<code>func</code>的参数<code>t</code>也应当是一个右值。也就是说，我们希望：<strong>当<code>relay</code>的参数是右值的时候，<code>func</code>的参数也是右值；当<code>relay</code>的参数是左值的时候，<code>func</code>的参数也是左值</strong>。</p>
<p>但是结果与我们预想的似乎并不相同：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">default constructor</span><br><span class="line">in relay</span><br><span class="line">copy constructor</span><br><span class="line">in func</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br></pre></td></tr></table></figure>

<p>我们看到，在<code>relay</code>当中转发的时候，调用了复制构造函数，也就是说编译器认为这个参数<code>t</code>并不是一个右值，而是左值，<strong>因为它有一个名字</strong>。<strong>那么如果我们想要实现我们所说的，如果传进来的参数是一个左值，则将它作为左值转发给下一个函数；如果它是右值，则将其作为右值转发给下一个函数</strong>。</p>
<p>这时，我们需要<code>std::forward&lt;T&gt;()</code>。与<code>std::move()</code>相区别的是，<code>move()</code>会无条件的将一个参数转换成右值，而<code>forward()</code>则会保留参数的左右值类型。所以我们的代码应该是这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in func &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relay</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in relay &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">default constructor</span><br><span class="line">in relay</span><br><span class="line">move constructor</span><br><span class="line">in func</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br></pre></td></tr></table></figure>

<p>而如果我们的调用方法变成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="built_in">relay</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么输出就会变成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default constructor</span><br><span class="line">in relay</span><br><span class="line">copy constructor</span><br><span class="line">in func</span><br><span class="line">destructor</span><br><span class="line">destructor</span><br></pre></td></tr></table></figure>

<p>完美地实现了我们所要的转发效果。但是这个例子中，t 明明是左值，为何可以传入右值引用的函数中？这里的 <code>void relay(T&amp;&amp; t) </code>其实是通用引用，即通过上面的引用折叠规则 由编译器推断得出的。</p>
<h4 id="完美转发原理"><a href="#完美转发原理" class="headerlink" title="完美转发原理"></a>完美转发原理</h4><p><code>std::forward</code>的源码形式大致是这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  精简了标准库的代码，在细节上可能不完全正确，但是足以让我们了解转发函数 forward 的了</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(T &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++智能指针</title>
    <url>/2021/05/11/C++/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>C++智能指针</p>
<span id="more"></span>

<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>智能指针的设计目的  是因为  当 new 一个指针时 如果忘记释放就会带来内存泄漏的问题。因此C++提供了智能指针的方法来“智能地”管理指针所指的内存，自动给你释放。通过new 申请返回的是指向 内存的 指针，智能指针是通过类 来对 这个指针进行管理。当超出了类的作用域，就会自动触发类的析构函数完成该指针指向的内存的释放功能。</p>
<p>综上所述，智能指针是通过类 来  对指针进行管理，当超过类的作用域 类的析构函数自动完成指针所指向的内存的释放功能。而为了使智能指针的表达具有 “指针变量” 类似的形式，需要对 指针变量常用的操作符  例如 “-&gt;  *  = ” 等重定义。</p>
<ul>
<li>auto_ptr   (c++11弃用)</li>
<li>share_ptr  (c++11)</li>
<li>weak_ptr  (c++11)</li>
<li>unique_ptr  (c++11)</li>
</ul>
<h2 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a><strong>auto_ptr</strong></h2><p>auto_ptr 就是对开头的思想进行了实现，是c98里的东西，由于有很多缺陷，c11中已经被弃用。</p>
<ol>
<li>所有权问题。当把 一个auto_ptr 对象 A 通过拷贝构造给了 对象 B 此时A就是个空类，你再试图访问A所指向的空间就会越界。</li>
<li>不支持组管理 就是 通过 <code>new int[ 500]</code> 这种分配的数组 ，它无法管理，因为这时候释放应该使用 <code>delete  []  A </code>而 auto_ptr中只支持 delete A直接释放内存。</li>
<li>不支持容器</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> a = <span class="number">0</span> ) : <span class="built_in">m_a</span>(a) &#123; &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>( )</span><br><span class="line">    &#123; </span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;Calling destructor&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>: <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">std::auto_ptr&lt;Test&gt; <span class="title">p</span><span class="params">( <span class="keyword">new</span> Test(<span class="number">5</span>) )</span></span>; </span><br><span class="line">    cout &lt;&lt; p-&gt;m_a &lt;&lt; endl;  <span class="comment">//当退出  test 函数时 会自动释放 new 的内存</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//// 缺陷1 举例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">(auto_ptr&lt;Test&gt; p1 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;p1-&gt;m_a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::auto_ptr&lt;Test&gt; <span class="title">p</span><span class="params">( <span class="keyword">new</span> Test(<span class="number">5</span>) )</span></span>; </span><br><span class="line">    <span class="built_in">Fun</span>(p);  </span><br><span class="line">    cout&lt;&lt;p-&gt;m_a&lt;&lt;endl;  </span><br><span class="line"><span class="comment">// 此时再访问  P  就越界 因为 在调用 Fun 函数时，实际完成了一次拷贝构造 将指针所有权交给了 函数Fun中的局部变量并随着函数的退出而释放。所以 此时 p就是野指针了。</span></span><br><span class="line">	<span class="function">std::auto_ptr&lt;Test&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">5</span>])</span></span>;  <span class="comment">// 不能管理申请的数组指针</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p><strong><code>unique_ptr</code>也是对<code>auto_ptr</code>的替换</strong>。<code>unique_ptr</code>遵循着独占语义。在任何时间点，资源只能唯一地被一个<code>unique_ptr</code>占有。当<code>unique_ptr</code>离开作用域，所包含的资源被释放。如果资源被其它资源重写了，之前拥有的资源将被释放。所以它保证了他所关联的资源总是能被释放。但是如果程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;hello world&quot;</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;string&gt; pu2;</span><br><span class="line">pu2 = pu1;                                      <span class="comment">// #1 not allowed</span></span><br><span class="line">unique_ptr&lt;string&gt; pu3;</span><br><span class="line">pu3 = unique_ptr&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;You&quot;</span>));   <span class="comment">// #2 allowed</span></span><br><span class="line">pu2 = <span class="built_in">move</span>(pu1);                                <span class="comment">// #3 allowed</span></span><br></pre></td></tr></table></figure>



<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol>
<li><code>unique_ptr</code>的创建方法和<code>shared_ptr</code>一样，除非创建一个指向数组类型的<code>unique_ptr</code>。</li>
<li><code>unique_ptr</code>提供了创建数组对象的特殊方法，当指针离开作用域时，调用<code>delete[]</code>代替<code>delete</code>。当创建<code>unique_ptr</code>时，这一组对象被视作模板参数的部分。这样，程序员就不需要再提供一个指定的析构方法</li>
<li><code>unique_ptr</code>拷贝赋值和拷贝构造都不可以（编译报错），只支持移动语义(<code>move semantics</code>).</li>
</ol>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>unique_ptr提供的接口和传统指针差不多，但是不支持指针运算。</p>
<p><code>unique_ptr</code>提供一个<code>release()</code>的方法，释放所有权。<code>release</code>和<code>reset</code>的区别在于，<code>release</code>仅仅释放所有权但不释放资源，<code>reset</code>也释放资源。</p>
<h2 id="share-ptr"><a href="#share-ptr" class="headerlink" title="share_ptr"></a>share_ptr</h2><p>对于上面 auto_ptr 最基本的  当拷贝构造后 指针的所有权被剥离  只剩野指针的问题，share_ptr 通过共享所有权的概念解决。share_ptr通过计数的机制实现 共享。</p>
<ul>
<li>多个智能指针可以共同拥有/指向同一个 申请的内存/对象，当最后个智能指针离开作用域的时候，内存才会自动释放</li>
<li>包含两种计数 ：  强引用计数   弱引用计数  </li>
</ul>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sptr1</span><span class="params">( <span class="keyword">new</span> <span class="keyword">int</span> )</span></span>;   </span><br><span class="line">    shared_ptr&lt;<span class="keyword">int</span>&gt; sptr2 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>);  <span class="comment">// 使用 make_shared 加速创建过程</span></span><br><span class="line">    shared_ptr&lt;<span class="keyword">int</span>&gt; sptr3 = sptr1;   <span class="comment">//  此时 sptr1 和 3 同时指向同一片内存 强引用计数 值 加 1</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; sptr3.<span class="built_in">use_count</span>();  <span class="comment">// 可以获得 强引用计数值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="析构"><a href="#析构" class="headerlink" title="析构"></a>析构</h3><p><code>shared_ptr</code>默认调用<code>delete</code>释放关联的资源。如果用户采用一个不一样的析构策略时，他可以自由指定构造这个<code>shared_ptr</code>的策略。应该调用<code>delete[]</code>来销毁这个数组。用户可以通过调用一个函数，例如一个<code>lamda</code>表达式，来指定一个通用的释放步骤</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Class Test</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">shared_ptr&lt;Test&gt; <span class="title">sptr1</span><span class="params">( <span class="keyword">new</span> Test[<span class="number">5</span>] )</span></span>;  <span class="comment">// 默认析构无法释放 数组</span></span><br><span class="line">    <span class="comment">// 正确的方法  指定析构函数</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">sptr1</span><span class="params">( <span class="keyword">new</span> Test[<span class="number">5</span>], [ ](Test* p) &#123; <span class="keyword">delete</span>[ ] p; &#125; )</span></span>;   <span class="comment">// 参见 lambda 用法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h3><p>除了 指针常用的 操作 符<code>*</code>,<code>-&gt;</code> 之外  它还提供了一些有用的接口</p>
<ul>
<li><code>get()</code>: 获取<code>shared_ptr</code>绑定的资源</li>
<li>swap()：交换两个 share_ptr 对象  交换所有权</li>
<li><code>reset()</code>: 释放关联内存块的所有权，如果是最后一个指向该资源的<code>shared_ptr</code>,就释放这块内存</li>
<li> <code>unique</code>: 判断是否是唯一指向当前内存的 <code>shared_ptr</code></li>
<li><code>operator bool</code> : 判断当前的<code>shared_ptr</code>是否指向一个内存块，可以用 if 表达式判断</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li>对同一个裸指针使用两个 shared_ptr初始化管理。应该尽量避免这种情况。当其中一个智能指针离开作用域后释放该指针 另一个再用就出问题。尽量不要从一个裸指针<code>(naked pointer)</code>创建<code>shared_ptr</code>.</li>
<li>循环引用问题。如下面的例子，当离开main函数时，<code>sptrB</code> 和  <code>sptrA</code>离开了作用域 （他们俩是在main函数中申请的一个类）就会导致计数值减一，但是不会释放内存，因为此时 new 的 结构 A 和 B 中包含的智能指针还在相互引用呢</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210331213732.png" alt="image-20210103170722316"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sptr1</span><span class="params">( p)</span></span>;  <span class="comment">//  sptr1 和 sptr2 此时属于不同组 但是指向了同一个资源。不同组的智能指针的计数值不共享</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sptr2</span><span class="params">( p)</span></span>;  <span class="comment">// 尽量不要从一个裸指针`(naked pointer)`创建`shared_ptr`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题2 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">A</span>(  ) : <span class="built_in">m_sptrB</span>(<span class="literal">nullptr</span>) &#123; &#125;;</span><br><span class="line">     ~<span class="built_in">A</span>( )</span><br><span class="line">     &#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot; A is destroyed&quot;</span>&lt;&lt;endl;</span><br><span class="line">     &#125;</span><br><span class="line">     shared_ptr&lt;B&gt; m_sptrB;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(  ) : <span class="built_in">m_sptrA</span>(<span class="literal">nullptr</span>) &#123; &#125;;</span><br><span class="line">    ~<span class="built_in">B</span>( )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; B is destroyed&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    shared_ptr&lt;A&gt; m_sptrA;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//*************当sptrA和sptrB离开作用域时，它们的引用计数都只减少到1，所以它们指向的资源并没有释放！！！！</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">sptrB</span><span class="params">( <span class="keyword">new</span> B )</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">sptrA</span><span class="params">( <span class="keyword">new</span> A )</span></span>;</span><br><span class="line">    sptrB-&gt;m_sptrA = sptrA;</span><br><span class="line">    sptrA-&gt;m_sptrB = sptrB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// 注意模板类的使用方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPointer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* p_;</span><br><span class="line">	<span class="keyword">size_t</span>* count_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数   注意初始值的设置方法</span></span><br><span class="line">	<span class="built_in">SmartPointer</span>(T* ptr = <span class="literal">nullptr</span>) : <span class="built_in">p_</span>(ptr) &#123;</span><br><span class="line">        <span class="comment">// 构造函数代表新定义了一个 管理某指针的 类，所以要分配 计数变量并初始化为0  从无到有</span></span><br><span class="line">		<span class="keyword">if</span> (p_) &#123;</span><br><span class="line">			count_ = <span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			count_ = <span class="keyword">new</span> <span class="built_in">size_t</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="comment">// 拷贝构造函数  就是类似值传递这种场合会使用的情形 所以输入是 const 引用</span></span><br><span class="line">    <span class="comment">// 拷贝构造其实是由 多到跟多的过程 多以 计数值加 1 即刻</span></span><br><span class="line">	<span class="built_in">SmartPointer</span>(<span class="keyword">const</span> SmartPointer&amp; ptr) &#123;</span><br><span class="line">		p_ = ptr.p_;</span><br><span class="line">		count_ = ptr.count_;</span><br><span class="line">		(*count_)++;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="comment">// 赋值构造函数重载 注意 = 是有返回值的 返回的是本身 因为有这种用法 int b = 0; c = b = a;连续赋值</span></span><br><span class="line">	SmartPointer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPointer&amp; ptr) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p_ == ptr.p_) &#123;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		&#125; </span><br><span class="line">    <span class="comment">//赋值构造函数要考虑以下情况：是不是自己给自己赋值，被赋值对象是不是已经有管理的对象了，那么要先释放之前管理的指针</span></span><br><span class="line">    <span class="comment">// 最后变更指针指向的地址，计数值增加</span></span><br><span class="line">		<span class="keyword">if</span> (p_) &#123;</span><br><span class="line">			<span class="keyword">if</span> (--(*count_) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">delete</span> p_;</span><br><span class="line">				<span class="keyword">delete</span> count_;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p_ = ptr.p_;</span><br><span class="line">		count_ = ptr.count_;</span><br><span class="line">		(*count_)++;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="comment">//析构函数 计数值减1后是否到0 </span></span><br><span class="line">	~<span class="built_in">SmartPointer</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (--(*count_) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> p_;</span><br><span class="line">			<span class="keyword">delete</span> count_;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">size_t</span> <span class="title">use_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> *count_;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>根据上面的分析，导致相互引用内存无法释放的主要原因是 两个类内部的<code>share_ptr</code>之间的相互引用。导致管理该类的智能指针无法释放内存。因此提出 通过 <code>weak_ptr </code>来 替代 类内部的 <code>shared_ptr</code>。<code>weak_ptr </code>只能由 <code>shared_ptr </code>拷贝初始化，并且只增加 <code>shared_ptr</code>的弱引用计数值，而在释放内存时只考虑强引用计数值，不管弱引用计数值为多少都不影响内存的释放。</p>
<p>基于以上思路，完善一下  weak_ptr 的定义和性质。</p>
<ul>
<li><code>weak_ptr</code> 只能由 <code>share_ptr </code>指针创建初始化，只增加 弱引用计数。将一个<code>weak_ptr</code>赋给另一个<code>weak_ptr</code>会增加弱引用计数(<code>weak reference count</code>)</li>
<li><code>weak_ptr</code> 没有  <code>*</code> <code>-&gt;</code>操作，它并不包含资源所以也不允许程序员操作资源。但是 在需要访问资源的时候，可以先将它转换为shared_ptr 再访问 如下：<ol>
<li>调用<code>expired()</code>方法 判断<code>weak_ptr</code>是否指向有效资源</li>
<li>从<code>weak_ptr</code>调用<code>lock()</code>可以得到<code>shared_ptr</code>  或者直接将<code>weak_ptr</code>转型为<code>shared_ptr</code>  </li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">A</span>(  ) : <span class="built_in">m_a</span>(<span class="number">5</span>)  &#123; &#125;;</span><br><span class="line">     ~<span class="built_in">A</span>( )</span><br><span class="line">     &#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot; A is destroyed&quot;</span>&lt;&lt;endl;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">PrintSpB</span><span class="params">( )</span></span>;</span><br><span class="line">     weak_ptr&lt;B&gt; m_sptrB;   <span class="comment">/// 类中使用了 弱 智能指针  不会强行占用资源  在使用时转换为 shared_ptr才会增加强引用计数，但是此时因为还在调用类的变量，说明这个类正在被使用就不可能是离开了作用域</span></span><br><span class="line">     <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">B</span>(  ) : <span class="built_in">m_b</span>(<span class="number">10</span>) &#123; &#125;;</span><br><span class="line">     ~<span class="built_in">B</span>( )</span><br><span class="line">     &#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot; B is destroyed&quot;</span>&lt;&lt;endl;</span><br><span class="line">     &#125;</span><br><span class="line">     weak_ptr&lt;A&gt; m_sptrA;</span><br><span class="line">     <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::PrintSpB</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>( !m_sptrB.<span class="built_in">expired</span>() )</span><br><span class="line">     &#123;  </span><br><span class="line">      cout&lt;&lt; m_sptrB.<span class="built_in">lock</span>( )-&gt;m_b&lt;&lt;endl;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="function">shared_ptr&lt;B&gt; <span class="title">sptrB</span><span class="params">( <span class="keyword">new</span> B )</span></span>;</span><br><span class="line">     <span class="function">shared_ptr&lt;A&gt; <span class="title">sptrA</span><span class="params">( <span class="keyword">new</span> A )</span></span>;</span><br><span class="line">     sptrB-&gt;m_sptrA = sptrA;</span><br><span class="line">     sptrA-&gt;m_sptrB = sptrB;</span><br><span class="line">     sptrA-&gt;<span class="built_in">PrintSpB</span>( ); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
        <category>语言特性</category>
        <category>��������</category>
        <category>��������</category>
        <category>��������</category>
        <category>��������</category>
        <category>��������</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++强制类型转换</title>
    <url>/2021/05/11/C++/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>C++强制类型转换</p>
<span id="more"></span>

<h1 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h1><p>C 风格的强制类型转换 如下，不管什么类型的转换都可以使用使用下面的方式。</p>
<blockquote>
<p>TypeName b = (TypeName)a;</p>
</blockquote>
<p>C++也是支持C风格的强制转换,但是C风格的强制转换可能带来一些隐患,让一些问题难以察觉.所以C++提供了一组可以用在不同场合的强制转换的函数 包含：</p>
<ul>
<li>const_cast </li>
<li>static_cast </li>
<li>dynamic_cast</li>
<li>reinterpret_cast</li>
</ul>
<h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>主要用于 去掉 指针和引用的 的 const 属性。</p>
<ol>
<li>常量指针 / 引用 被转化成非常量的指针，并且仍然指向原来的对象；</li>
<li>const_cast一般用于修改指针。如const char *p形式</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*c_ptr = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *ptr = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(c_ptr);  <span class="comment">// 通过const_cast&lt;Ty&gt; 去常量 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下的情况 对定义的常变量直接转换的方法  最好不要用  在不同编译器下可能会有不同的结果  </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_val = <span class="number">233</span>;  <span class="comment">//声明为常量类型</span></span><br><span class="line"><span class="keyword">int</span> &amp;use_val = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(c_val); <span class="comment">//使用去const 引用</span></span><br><span class="line"><span class="keyword">int</span> *ptr_val = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;c_val);<span class="comment">//使用去const 指针</span></span><br></pre></td></tr></table></figure>



<h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><ol>
<li>static_cast 作用和C语言风格强制转换的效果基本一样  <strong>这个和C相同 是指 ，可能会修改二进制的数据</strong><ul>
<li><strong>用于基本数据类型之间的转换</strong>（int  char bool 等），如把int转换成char，把int转换成enum。这种转换的安全性需要开发者来维护。</li>
</ul>
</li>
<li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。注意：<strong>进行上行转换</strong>（把派生类的指针或引用转换成基类表示）<strong>是安全的</strong>；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的</li>
<li>不能去掉原有的 属性 如  const voliate</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 常规的使用方法 */</span></span><br><span class="line"><span class="keyword">float</span> f_pi=<span class="number">3.141592f</span></span><br><span class="line"><span class="keyword">int</span>   i_pi=<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(f_pi); <span class="comment">/// i_pi 的值为 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* class 的上下行转换 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  上行 Sub -&gt; Base</span></span><br><span class="line"><span class="comment">//编译通过，安全</span></span><br><span class="line">Sub sub;</span><br><span class="line">Base *base_ptr = <span class="keyword">static_cast</span>&lt;Base*&gt;(&amp;sub);  </span><br><span class="line"><span class="comment">//下行 Base -&gt; Sub</span></span><br><span class="line"><span class="comment">//编译通过，不安全</span></span><br><span class="line">Base base;</span><br><span class="line">Sub *sub_ptr = <span class="keyword">static_cast</span>&lt;Sub*&gt;(&amp;base);  </span><br></pre></td></tr></table></figure>



<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>c++ 多态性，例如在基类中定义一个虚函数，然后 子类 继承这个类并 实现虚函数，不同的子类可以有不同的虚函数实现。当我们将基类的指针指向子类的对象时，就会自动调用 对应子类的 虚函数的实现，这就体现出了多态性。</p>
<p>这个类型转换是 C 语言替代不了的 因为涉及到 C++ 的多态特性。对于C++ 中的类  的子类 和 基类 之间的指针或引用的转换，因该用dynamic 或者 static 转换。</p>
<ol>
<li>当 将基类指针转换为 子类指针时，不能直接强转，也不能用static_cast。这是因为子类除了继承基类的变量和方法之外，还可能有自己新的扩充的定义，即 基类 &lt;  子类，强转就可能出现指针越界。应该使用 dynamic_cast 来完成，因为dynamic 可以在程序运行过程中 对转换的可行性进行检查，如果无法完成，会返回空指针。</li>
<li>dynamic_cast 的检查依赖于RTTI 实现，需要类中含有虚函数，没有虚函数 编译不通过。</li>
<li>dynamic_cast 运行检查是有开销的  所以 如果是 子类 像  基类的  上行转换 用 staic_cast 比较快。  </li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I&#x27;m Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">i_am_virtual_foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sub</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Sub</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;I&#x27;m Sub&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">i_am_virtual_foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sub-&gt;Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Sub * sub = <span class="keyword">new</span> <span class="built_in">Sub</span>();</span><br><span class="line">    sub-&gt;<span class="built_in">print</span>();</span><br><span class="line">    Base* sub2base = <span class="keyword">dynamic_cast</span>&lt;Base*&gt;(sub);</span><br><span class="line">    <span class="keyword">if</span> (sub2base != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        sub2base-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&lt;sub-&gt;base&gt; sub2base val is: &quot;</span> &lt;&lt; sub2base &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Base-&gt;Sub&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Base *base = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    base-&gt;<span class="built_in">print</span>();</span><br><span class="line">    Sub  *base2sub = <span class="keyword">dynamic_cast</span>&lt;Sub*&gt;(base);</span><br><span class="line">    <span class="keyword">if</span> (base2sub != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        base2sub-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;&lt;base-&gt;sub&gt; base2sub val is: &quot;</span>&lt;&lt; base2sub &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> sub;</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* vs2017 输出为下</span></span><br><span class="line"><span class="comment">Sub-&gt;Base</span></span><br><span class="line"><span class="comment">I&#x27;m Sub</span></span><br><span class="line"><span class="comment">I&#x27;m Base</span></span><br><span class="line"><span class="comment">&lt;sub-&gt;base&gt; sub2base val is: 00B9E080   // 注:这个地址是系统分配的,每次不一定一样</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Base-&gt;Sub</span></span><br><span class="line"><span class="comment">I&#x27;m Base</span></span><br><span class="line"><span class="comment">&lt;base-&gt;sub&gt; base2sub val is: 00000000   // VS2017的C++编译器,对此类错误的转换赋值为nullptr</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><ul>
<li>强制类型转换符用来<strong>处理无关类</strong>型转换的  (例如指针 和 long long（64位机器指针是八字节） 的转换)</li>
<li>为操作数的位模式提供较低层次的重新解释！但是他仅仅是重新解释了给出的对象的比特模型，并没有进行二进制的转换！</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *ptr = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">233</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> ptr_addr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(ptr);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr 的地址: &quot;</span> &lt;&lt; hex &lt;&lt; ptr &lt;&lt; endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;ptr_addr 的值(hex): &quot;</span> &lt;&lt; hex &lt;&lt; ptr_addr &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++模板和泛型编程</title>
    <url>/2021/04/30/C++/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>面向对象编程 （<code>OOP</code>）和泛型编程都能处理 <strong>在编写程序不知道类型的情况</strong>。不同之处在于 ，<code>OOP</code>能处理类型在<strong>程序运行之前都未知的情况</strong>，而泛型编程中，在编译时就能获知类型了。而模板是C++泛型编程的基础。 </p>
<span id="more"></span>

<p>C++是一门强类型语言，所以无法做到像动态语言（<code>python javascript</code>）那样子，编写一段通用的逻辑，可以把任意类型的变量传进去处理。泛型编程弥补了这个缺点，通过把通用逻辑设计为模板，摆脱了类型的限制，提供了继承机制以外的另一种抽象机制，极大地提升了代码的可重用性。</p>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>如果希望编写一个函数比较两个值，在实际中由于比较的类型不知道，可以通过函数重载的方式写多个同名的函数，编译器会根据不同的调用参数选择对应的函数执行。但是这样编码很麻烦。我们可以通过定义一个通用的函数模板，来简化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 &lt; v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><input disabled="" type="checkbox">  模板有关的其他知识</p>
</li>
<li><p><input disabled="" type="checkbox">  模板偏特化</p>
</li>
<li><p><input disabled="" type="checkbox">  模板全特化</p>
</li>
<li><p><input disabled="" type="checkbox">  实参推断</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++模板</title>
    <url>/2021/05/11/C++/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E6%A8%A1%E6%9D%BF%E6%8E%A8%E5%AF%BC%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>C++模板推导规则</p>
<span id="more"></span>

<h1 id="模板推导规则"><a href="#模板推导规则" class="headerlink" title="模板推导规则"></a>模板推导规则</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(expr); <span class="comment">// deduce T and ParamType from expr</span></span><br></pre></td></tr></table></figure>

<p> 在编译期间，编译器通过expr推导T和ParamType的类型。直觉上，T的类型总是与expr一致，然而实际上，T的类型推到结果，不仅仅依赖于expr的类型，还取决于ParamType的形式。</p>
<p>ParamType 可以写为 <code>T&amp;  /  T&amp;&amp;  / T*</code> 分为为 引用/万能引用/指针</p>
<h2 id="指针或引用"><a href="#指针或引用" class="headerlink" title="指针或引用"></a>指针或引用</h2><p>若expr是引用（左值引用或右值引用），则先将引用部分忽略；然后，对expr的类型和ParamType的类型进行模式匹配，来决定T的类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>; <span class="comment">// ParamType 为左值引用的形参</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;rx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;crx = x;</span><br><span class="line"><span class="built_in">f</span>(x); <span class="comment">// T is int, param&#x27;s type is const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx); <span class="comment">// T is int, param&#x27;s type is const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(crx); <span class="comment">// T is int, param&#x27;s type is const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> y = <span class="number">28</span>;</span><br><span class="line"><span class="built_in">f</span>(y); <span class="comment">// T is int, param&#x27;s type is const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr = <span class="number">27</span>;</span><br><span class="line"><span class="built_in">f</span>(rr); <span class="comment">// T is int, param&#x27;s type is const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;&amp;crr = <span class="number">28</span>;</span><br><span class="line"><span class="built_in">f</span>(crr); <span class="comment">// T is int, param&#x27;s type is const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = &amp;x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *cp = &amp;x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> ccp = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="built_in">f</span>(p); <span class="comment">// T is int*, param&#x27;s type is int* const &amp;</span></span><br><span class="line"><span class="built_in">f</span>(cp); <span class="comment">// T is const int*, param&#x27;s type is const int* const &amp;</span></span><br><span class="line"><span class="built_in">f</span>(ccp); <span class="comment">// T is const char*, param&#x27;s type is const char* const &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>); <span class="comment">// T is int, param&#x27;s type is const int &amp;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++虚函数</title>
    <url>/2021/05/11/C++/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E8%99%9A%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>C++虚函数</p>
<span id="more"></span>



<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态 包含 静态多态 和  动态多态，前者是在编译时确定的，通过函数重载实现。后者是通过虚函数实现的，是运行时类指针或引用和它所绑定的对象不同所体现的。</p>
<p>虚函数 原理： <a href="https://www.jianshu.com/p/d07e0ac0ba3c?from=singlemessage">https://www.jianshu.com/p/d07e0ac0ba3c?from=singlemessage</a><br>虚函数 实现原理： <a href="https://blog.twofei.com/496/">https://blog.twofei.com/496/</a><br>虚函数总结： <a href="https://blog.csdn.net/qq_39477053/article/details/80322260">https://blog.csdn.net/qq_39477053/article/details/80322260</a></p>
<h2 id="虚拟函数"><a href="#虚拟函数" class="headerlink" title="虚拟函数"></a>虚拟函数</h2><p>虚函数的实现是由两个部分组成的，虚函数指针与虚函数表。</p>
<h3 id="虚函数指针，和表"><a href="#虚函数指针，和表" class="headerlink" title="虚函数指针，和表"></a>虚函数指针，和表</h3><p>虚函数指针是确实存在的数据类型，在一个被实例化的对象中，它总是被存放在该对象的地址首位。某一个基类（没有继承别人），它其中有好几个虚函数，那么这几个虚函数的地址组成了一个表。当示例化这个类后，称为该类的对象，那么对象只是新增了一个虚函数指针，该虚函数指针指向了虚表的首地址。对于继承该类的派生类的对象，它也有一个虚函数指针，如果它的派生类的虚函数重写了，那么它的虚表和基类的虚表不同。因此虚函数指针的指向地址也不同。</p>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>纯虚函数 就是 后面加 0 的虚函数，它没有对虚函数进行实现，包含纯虚函数的类称为抽象类，它不能被实例化因为它虚函数没实现，一般用于接口的定义。只有它的派生类并实现了虚函数的 才能实例化。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
        <category>语言特性</category>
        <category>��������</category>
        <category>��������</category>
        <category>��������</category>
        <category>��������</category>
        <category>��������</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++隐式类型转换</title>
    <url>/2021/05/11/C++/%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>C++隐式类型转换</p>
<span id="more"></span>

<h1 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h1><p>在C++语言中，类型转换有两种方式，隐式类型转换和显示类型转换。在有隐式类型转换的表达式中，使用者不需要明确指定一个类型的对象该转换为另外哪一个类型，这个工作将隐含地由编译器来完成，编译器将分析表达式的含义，进行类型转换。隐式类型转换针对不同的类型有不同的转换方式，总体可以分为两种类型：（显示类型转换即为 static_cast …这些关键字）</p>
<ul>
<li>算术类型</li>
<li>类类型</li>
</ul>
<h2 id="算术类型转换"><a href="#算术类型转换" class="headerlink" title="算术类型转换"></a>算术类型转换</h2><p>低精度的变量给高精度变量赋值会发生隐式类型转换。算术类型转换的设计原则就是尽可能避免损失精度。</p>
<h2 id="类类型转换"><a href="#类类型转换" class="headerlink" title="类类型转换"></a>类类型转换</h2><p>在类类型转换中，我们通常有两个需求，<strong>一个是将其他类型的数据转换为我们自定义类的类型，另一个是将自定义类的类型在需要的时候转换为其他的数据类型</strong>。在C++中，可以前者可以通过定义<strong>单参数构造函</strong>数实现，后者通过定义<strong>转换函数</strong>来进行类类型转换。这种方式也称为用户定义的转换（User-Defined Conversion）。这种方式在使用的时候不需要指明转换类型，而是由编译器自动进行选择转换函数，所以也是一种隐式类型转换。</p>
<p>编译器每次只能执行一种类类型的转换。如果一个对象需要从类型A自动转换为类型C，则类型A必须有直接转换为类型C的函数。</p>
<h3 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h3><p>如果一个类的某个构造函数只接受一个参数，且没有被声明为explicit，则它实际上定义了将这个参数的类型转换为此类类型的隐式转换机制，我们把这种构造函数称为转换构造函数。在转换构造函数中只允许一步类类型的转换。可以通过将构造函数声明为explicit来阻止隐式转换。</p>
<p>最常见的例子就是将C类型字符串转换为string类型。string(const char *s)。自定义类的转换 如下例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BOOK</span>  //定义了一个书类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        string _bookISBN ;  <span class="comment">//书的ISBN号</span></span><br><span class="line">        <span class="keyword">float</span> _price ;    <span class="comment">//书的价格</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//定义了一个成员函数，这个函数即是那个“期待一个实参为类类型的函数”</span></span><br><span class="line">        <span class="comment">//这个函数用于比较两本书的ISBN号是否相同</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isSameISBN</span><span class="params">(<span class="keyword">const</span> BOOK &amp; other )</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> other._bookISBN==_bookISBN;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//类的构造函数，即那个“能够用一个参数进行调用的构造函数”（虽然它有两个形参，但其中一个有默认实参，只用一个参数也能进行调用）</span></span><br><span class="line">        <span class="built_in">BOOK</span>(string ISBN,<span class="keyword">float</span> price=<span class="number">0.0f</span>):_bookISBN(ISBN),_price(price)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BOOK <span class="title">A</span><span class="params">(<span class="string">&quot;A-A-A&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">BOOK <span class="title">B</span><span class="params">(<span class="string">&quot;B-B-B&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;A.<span class="built_in">isSameISBN</span>(B)&lt;&lt;endl;   <span class="comment">//正经地进行比较，无需发生转换</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;A.<span class="built_in">isSameISBN</span>(<span class="built_in">string</span>(<span class="string">&quot;A-A-A&quot;</span>))&lt;&lt;endl; <span class="comment">//此处即发生一个隐式转换：string类型--&gt;BOOK类型，借助BOOK的构造函数进行转换，以满足isSameISBN函数的参数期待。</span></span><br><span class="line">    cout&lt;&lt;A.<span class="built_in">isSameISBN</span>(<span class="built_in">BOOK</span>(<span class="string">&quot;A-A-A&quot;</span>))&lt;&lt;endl;    <span class="comment">//显式创建临时对象，也即是编译器干的事情。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h3><p>类型转换函数一般形式，虽然实现这种方式，可以通过系定义函数来返回对应的值，但是也可以像下面这样写。另外</p>
<blockquote>
<p>输入操作符 &gt;&gt; 是二元操作符，返回做操作数作为其表达式结果，因此cin &gt;&gt; num返回cin,然而cin是输入流istream的对象，该对象能出现在条件表达式中，是因为在istream中定义了类型转换函数 operator bool()</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">operator</span> 目标类型()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> 目标类型数据;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> <span class="keyword">int</span> x) : _x(x) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _x; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> res = a + <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; std::endl;  <span class="comment">// 输出结果为30.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>C++</category>
        <category>语言特性</category>
        <category>语言特性</category>
        <category>��������</category>
        <category>��������</category>
        <category>��������</category>
        <category>��������</category>
        <category>��������</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
      </tags>
  </entry>
  <entry>
    <title>面经C++基础知识2</title>
    <url>/2021/05/11/C++/%E9%9D%A2%E7%BB%8FC++%E6%B1%87%E6%80%BB/%E9%9D%A2%E7%BB%8F-c++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/</url>
    <content><![CDATA[<p> 面经 C++ 基础知识</p>
<span id="more"></span>

<h3 id="介绍fork函数"><a href="#介绍fork函数" class="headerlink" title="介绍fork函数"></a>介绍fork函数</h3><p>创建一个和当前进程映像一样的<strong>进程</strong>可以通过fork( )系统调用。成功调用fork 会返回一个大于等于0 的数，对于主进程，返回的是子进程的pid，子进程中返回的是0；可以通过if判断来确定是在子进程还是父进程中，然后执行不同的功能，两个进程执行的先后顺序完全由系统调度决定。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#inclde<span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="fork-wait-exec函数"><a href="#fork-wait-exec函数" class="headerlink" title="fork wait  exec函数"></a>fork wait  exec函数</h3><h3 id="select-函数"><a href="#select-函数" class="headerlink" title="select 函数"></a>select 函数</h3>]]></content>
      <categories>
        <category>C++</category>
        <category>面经C++汇总</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>面经C++11新特性</title>
    <url>/2021/05/11/C++/%E9%9D%A2%E7%BB%8FC++%E6%B1%87%E6%80%BB/%E9%9D%A2%E7%BB%8Fc++11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>面经C++11新特性</p>
<span id="more"></span>

<h3 id="请问C-11有哪些新特性？"><a href="#请问C-11有哪些新特性？" class="headerlink" title="请问C++11有哪些新特性？"></a>请问C++11有哪些新特性？</h3><ol>
<li>新增 auto 关键字，可以根据变量的初始值推断变量类型，但是对于函数的参数和数组的类型不能推断</li>
<li>新增 nullptr 关键字，可以代表任意类型的指针。C中的 NULL 为宏定义0，在函数重载的时候可能会有歧义，int  or  指针？</li>
<li>新增 share_ptr, weak_ptr 等智能指针</li>
<li>新增了右值引用 &amp;&amp; ，实现了语义移动和完美转发的功能，大大减少了临时变量的重复构造析构的次数，提高了性能</li>
<li>新增了STL 容器 array  tuple</li>
<li>支持使用初始化列表对类进行初始化 好像只有构造函数支持初始化列表</li>
<li>atomic 原子操作用于多线程资源互斥操作</li>
</ol>
<p>… </p>
<h3 id="详细介绍一下C-11中的可变参数模板"><a href="#详细介绍一下C-11中的可变参数模板" class="headerlink" title="详细介绍一下C++11中的可变参数模板"></a>详细介绍一下C++11中的可变参数模板</h3><p>c++11的可变参数模板对参数进行了高度泛化，可以表示任意数目、任意类型的参数，其语法为在 class 或者 typename 后面带上省略号。省略号作用如下：</p>
<ul>
<li><strong>声明</strong>一个包含0到任意个模板的参数的参数包</li>
<li>在模板定义的右边，可以将参数包<strong>展成一个个独立的参数</strong></li>
</ul>
<p>C++11可以使用递归函数的方式展开参数包，获得可变参数的每个值。<strong>通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数</strong>。例如。参数包Args …在展开的过程中递归调用自己，每调用一次参数包中的参数就会少一个，直到所有参数都展开为止。当没有参数时就会调用非模板函数printf终止递归过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> ...<span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T a, Args ...rest)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>(rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="详细介绍一下C-11右值引用"><a href="#详细介绍一下C-11右值引用" class="headerlink" title="详细介绍一下C++11右值引用"></a>详细介绍一下C++11右值引用</h3><h3 id="详细介绍一下C-11-lambda新特性"><a href="#详细介绍一下C-11-lambda新特性" class="headerlink" title="详细介绍一下C++11 lambda新特性"></a>详细介绍一下C++11 lambda新特性</h3>]]></content>
      <categories>
        <category>C++</category>
        <category>面经C++汇总</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>面经C++容器和算法</title>
    <url>/2021/04/24/C++/%E9%9D%A2%E7%BB%8FC++%E6%B1%87%E6%80%BB/%E9%9D%A2%E7%BB%8Fc++%E5%AE%B9%E5%99%A8%E5%92%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>面经C++容器和算法</p>
<span id="more"></span>

<h2 id="容器和算法"><a href="#容器和算法" class="headerlink" title="容器和算法"></a>容器和算法</h2><h3 id="map和set有什么区别，分别怎么实现"><a href="#map和set有什么区别，分别怎么实现" class="headerlink" title="map和set有什么区别，分别怎么实现"></a>map和set有什么区别，分别怎么实现</h3><p>​        map 和 set 在 c++ 中底层都是红黑树实现。他们的区别在于：</p>
<ol>
<li>map的存储形式是key value的形式，在树中对 key关键字进行排序。而set就是以集合种元素本身作为建立红黑树的关键子，set只存储元素。</li>
<li>对map 迭代时，可以对 value修改，但是不能对key修改，因为红黑树以Key为依据建树，一旦修改红黑树就会自动调整，这时候迭代器的指向顺序就乱了。而同理 set 是直接对 集合中的元素建树，所以set迭代时是不可修改的</li>
<li>map 支持下标操作，可以通过关键字访问对应的元素，但是在使用下标访问时，如果map中存在该键就将值返回，否则以默认值新建该键值关系，因此在只需要判断该键存在与否的时候 使用 find最好。set 不行。</li>
</ol>
<h3 id="STL的allocaotr"><a href="#STL的allocaotr" class="headerlink" title="STL的allocaotr"></a>STL的allocaotr</h3><p>c++的内存管理使用 new/delete 关键字管理。new/delete的具体执行过程：</p>
<ul>
<li>new分为两个阶段 :  1. 调用::operator new内存配置  2. 调用构造函数</li>
<li>delete:分为两个阶段：  1. 调用对象析构函数  2. 调用::operator delete释放内存</li>
</ul>
<p>而 STL 中 为了精密分工，将两个阶段（内存配置和对象构造 / 内存释放和对象析构函数）分开操作</p>
<ol>
<li>alloc::allocate() 内存配置 </li>
<li>alloc::deallocate() 内存释放</li>
</ol>
<p>同时SGI STL采用了两级内存配置，当分配的内存低于128B 时 使用 内存池技术，通过空闲链表链表管理内存，防止内存碎片化，当分配的内存大于128B时，直接使用malloc realloc free等函数分配一整块内存。</p>
<h3 id="STL-迭代删除元素"><a href="#STL-迭代删除元素" class="headerlink" title="STL 迭代删除元素"></a>STL 迭代删除元素</h3><p>主要考虑迭代器失效的问题。</p>
<ul>
<li>对于序列容器中的vector deque ，删除当前元素，后面的元素都会往前移动一个位置，导致后面的迭代器失效（deque的头尾插除外），而 <code>erase</code> 函数会返回下一个迭代器，因此使用返回值即可。</li>
<li>对于 list 是由双向环形链表构成，因此也只是当前的迭代器失效，不影响后面的。它的erase方法也会返回下一个有效的iterator。</li>
<li>对于关联容器，map 和 set 底层都是红黑树，删除当前元素只是当前迭代元素失效，后面的不影响, 备份即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要求删除键值为偶数的键值对</span></span><br><span class="line"> map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//错误实现：</span></span><br><span class="line"> <span class="keyword">while</span> (it != m.<span class="built_in">end</span>())&#123;</span><br><span class="line">   <span class="keyword">if</span>(it-&gt;second % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">     m.<span class="built_in">erase</span>(it);</span><br><span class="line">   &#125;</span><br><span class="line">   it++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//正确实现：</span></span><br><span class="line"> <span class="keyword">while</span> (it != m.<span class="built_in">end</span>())&#123;</span><br><span class="line">   <span class="keyword">if</span>(it-&gt;second % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">     m.<span class="built_in">erase</span>(it++); <span class="comment">//重点！！！  it++的写法才行不能  m.rease(it); it++;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">     it++;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="STL有什么基本组成"><a href="#STL有什么基本组成" class="headerlink" title="STL有什么基本组成"></a>STL有什么基本组成</h3><ol>
<li>容器：STL内部封装好的数据结构，是一种class template，常用的包括vector、list、deque、set、map等</li>
<li>算法：是一种函数模板，常用的有sort、search、copy等，STL中算法与数据相分离（不像面向对象中将算法与数据封装在class中）。</li>
<li>迭代器：类似于泛化的指针，用来访问可迭代序列。</li>
<li>适配器：提供转换操作，有容器适配器、仿函数适配器、迭代器适配器。</li>
<li>分配器：负责空间配置与管理，用以支持容器。是一种class template。</li>
<li>仿函数：行为类似函数，就是使一个类的使用看上去像一个函数。它的具体实现就是通过在类中重载了operator()，使这个类具有了类似函数的行为。</li>
</ol>
<p>关系：分配器用于给容器分配空间，算法通过迭代器访问容器中的数据从而完成一定的功能，配接器用于适配套接仿函数或容器，或者说通过一定的方法进行封装。例如 queue 和  stack 基本模型都是 deque 通过配接器实现而来。仿函数可以协助算法完成各种操作。</p>
<h3 id="STL中map与unordered-map"><a href="#STL中map与unordered-map" class="headerlink" title="STL中map与unordered_map"></a>STL中map与unordered_map</h3><ul>
<li>底层数据结构不一样，map 是使用 红黑数实现，un..使用hash表</li>
<li>因此查询效率等都不一样</li>
<li>map 是有序的  un 是无序的 不能迭代访问</li>
</ul>
<h3 id="vector和list的区别，应用，越详细越好"><a href="#vector和list的区别，应用，越详细越好" class="headerlink" title="vector和list的区别，应用，越详细越好"></a>vector和list的区别，应用，越详细越好</h3><p>1、区别：</p>
<ol>
<li>vector底层实现是数组；list是双向 链表。</li>
<li>vector支持随机访问，list不支持。</li>
<li>vector是顺序内存，list不是。</li>
<li>vector在中间节点进行插入删除会导致内存拷贝，list不会。</li>
<li>vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。</li>
<li>vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。</li>
</ol>
<p>2、应用</p>
<ul>
<li>vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。</li>
<li>list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。</li>
</ul>
<h3 id="STL中迭代器的作用，有指针为何还要迭代器"><a href="#STL中迭代器的作用，有指针为何还要迭代器" class="headerlink" title="STL中迭代器的作用，有指针为何还要迭代器"></a>STL中迭代器的作用，有指针为何还要迭代器</h3><p>迭代器给我们提供了一种 不用知道聚合物具体实现的方式，而可以按序访问聚合物中元素的方式，使得算法和数据结构分离。</p>
<p>他本质是类模板，表现的像指针，重载了 ++ – 和 -&gt;等操作，封装了原生指针，更像智能指针，可以根据不同的数据结构类型来实现不同的++ –等操作。迭代器返回的是对象的引用而不是对象的值。</p>
<h3 id="STL迭代器是怎么删除元素"><a href="#STL迭代器是怎么删除元素" class="headerlink" title="STL迭代器是怎么删除元素"></a>STL迭代器是怎么删除元素</h3><p>考察的是迭代器失效的问题。</p>
<h3 id="找到数组中每个元素后面比他大的第一个数"><a href="#找到数组中每个元素后面比他大的第一个数" class="headerlink" title="找到数组中每个元素后面比他大的第一个数"></a>找到数组中每个元素后面比他大的第一个数</h3><p>单调栈   <a href="https://leetcode-cn.com/problems/next-greater-element-ii/">下一个更大元素 II</a></p>
<h3 id="STL中resize和reserve区别"><a href="#STL中resize和reserve区别" class="headerlink" title="STL中resize和reserve区别"></a>STL中resize和reserve区别</h3><p>resize 和 size 参数相关，reserve函数和 capacity参数相关。</p>
<ul>
<li>size指容器当前拥有的元素个数，它代表的空间是初始化了的 可以直接访问</li>
<li>capacity则指容器在必须分配新存储空间之前可以存储的元素总数，只是空间预分配，未初始化，不可访问</li>
</ul>
<p>调用 resize(n) 函数后，容器的 size = n；  如果 n 不超过最大容量capacity，则不需要重新分配内存，capacity不变；反之则重新分配内存 capacity = size；</p>
<p>调用 reserve(n) 函数后，如果 n  不大于 capacity ，capacity不变，否则重新分配 n 的内存使得capcity等于n，同时将之前 size 的内容拷贝过来。 </p>
<h3 id="C-STL-的内存优化"><a href="#C-STL-的内存优化" class="headerlink" title="C++ STL 的内存优化"></a>C++ STL 的内存优化</h3><h4 id="二级配置器结构"><a href="#二级配置器结构" class="headerlink" title="二级配置器结构"></a>二级配置器结构</h4><p>STL 内存管理使用二级内存配置器</p>
<ol>
<li><p>第一级配置器。当分配的内存数大于128字节时，直接使用 malloc free realloc 等函数执行实际的内存分配，和释放等操作。</p>
</li>
<li><p>第二级配置器，当分配的内存少于128字节时，使用内存池管理。又称之次层配置（sub-allocation）。每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。</p>
<p> a. 通过size找到合适的空闲链表，如果链表不为空，则直接返回第一个node</p>
<p> b. 如果链表为空，则使用 blockAlloc 请求分配 node ，即从图中的 start_free-end_free 中的空闲区域再划分出多个连续的node出来。</p>
<ul>
<li>果有足够一个node 的空间，就尽可能的分配多的node （最多20）个，将一个Node返回，其他的添加到空闲链表中</li>
<li>如果一个多的空闲node都没有，再次向操作系统请求分配内存<ul>
<li>若分配成功 再次使用 b 步骤，分配 block</li>
<li>若分配失败，循环各个自由链表寻找空间，如果寻找到了，再次进行 b 过程，否则抛出异常</li>
</ul>
</li>
</ul>
</li>
<li><p>用户调用deallocate释放内存空间，如果要求释放的内存空间大于128bytes，直接调用free。否则按照其大小找到合适的自由链表，并将其插入</p>
</li>
</ol>
<p>上述步骤有三个关键函数：</p>
<ol>
<li><p>空间配置函数<code>allocate</code>：</p>
<p> 检查申请的空间大小，大于128字节就调用一级空间配置器使用malloc分配，否则就调用二级空间配置器，从空闲链表中拿数据块。如果空闲链表为空，则调用 refill 函数重新填充空闲链表。</p>
</li>
<li><p>重新填充空闲链表 <code>refill </code></p>
<p> 在使用 allocate 配置空闲空间时，如果对应的空闲链表中没有可用的块（Node）。那么就会调用该函数充填空闲链表。新的空间取自内存池。默认取出 20 个数据块，如果内存池的空间不够，能取多少取多少。从内存池中取空闲块给空闲链表是由函数  <code>chunk_alloc</code>完成</p>
</li>
<li><p>从内存池取空闲块<code>chunk_alloc</code></p>
<p> 首先根据<strong>end_free - start_free</strong>来判断内存池中的剩余空间是否足以调出nobjs个大小为size的数据块出去。如果内存连一个数据块的空间都无法供应，需要用 malloc 取堆中申请内存。假如山穷水尽，整个系统的堆空间都不够用了，malloc失败，那么chunk_alloc会从空闲链表中找是否有大的数据块，然后将该数据块的空间分给内存池（这个数据块会从链表中去除）。</p>
</li>
<li><p>空间释放函数 <code>deallocate</code></p>
</li>
<li><p>首先先要检查释放数据块的大小，如果大于128字节就调用第一级配置器，小于128字节则根据数据块的大小来判断回收后的空间会被插入到哪个空闲链表。</p>
</li>
</ol>
<p><img src="https://pic2.zhimg.com/v2-d34206291e7b3af0208c63395757f101_r.jpg" alt="preview"></p>
<img src="https://img-blog.csdn.net/20180128161817846?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjYxMTg3OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" style="zoom: 50%;" />

]]></content>
      <categories>
        <category>C++</category>
        <category>面经C++汇总</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>面经C++类和数据抽象</title>
    <url>/2021/05/11/C++/%E9%9D%A2%E7%BB%8FC++%E6%B1%87%E6%80%BB/%E9%9D%A2%E7%BB%8Fc++%E7%B1%BB%E5%92%8C%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/</url>
    <content><![CDATA[<p> 经C++类和数据抽象</p>
<span id="more"></span>

<h3 id="C-中类成员的访问权限"><a href="#C-中类成员的访问权限" class="headerlink" title="C++中类成员的访问权限"></a>C++中类成员的访问权限</h3><p>C++ 通过  pubilc, protected, private 三个关键字来控制成员的访问权限。</p>
<ul>
<li>在类的内部，可以随意访问三种属性的变量</li>
<li>在派生类中，不可以访问父类 私有的 成员</li>
<li>在类的外部，只能通过对象访问成员，并且只能访问public 属性的成员</li>
</ul>
<h3 id="C-中-struct-和class的区别"><a href="#C-中-struct-和class的区别" class="headerlink" title="C++中 struct 和class的区别"></a>C++中 struct 和class的区别</h3><ul>
<li>c++ 可以用 struct  和 class 定义类，都可以用来继承，但是 struct 默认是公开的属性，而class默认成员是私有的类型。</li>
<li>class 这个关键字还可以使用 模板，模板类   而 struct 不能</li>
</ul>
<h3 id="C-类内可以定义引用数据成员吗"><a href="#C-类内可以定义引用数据成员吗" class="headerlink" title="C++类内可以定义引用数据成员吗"></a>C++类内可以定义引用数据成员吗</h3><p>可以，必须通过成员函数初始化列表初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ref</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数形参为传值，不能保证正确性</span></span><br><span class="line">        <span class="comment">// Ref (int target) :myref(target) &#123;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;Ref constructor&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 函数体对引用赋值，编译错误：引用未初始化</span></span><br><span class="line">        <span class="comment">// Ref (int &amp;target)  &#123;</span></span><br><span class="line">            <span class="comment">// myref = target;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;Ref constructor&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果成员为变量为引用类型，那么构造函数的参数为引用类型  这个好理解 因为你都是引用外界的数据，如果用值传递，进来的只是个临时值，再对临时值做引用，显然有问题。</span></span><br><span class="line">        <span class="comment">// 引用必须在成员初始化列表里面初始化，不能在函数体里面初始化。构造函数的参数列表在构造函数之前执行</span></span><br><span class="line">        <span class="comment">// 在函数体里面修改myref，相当于赋值，显然引用不能赋值</span></span><br><span class="line">        <span class="built_in">Ref</span> (<span class="keyword">int</span> &amp;target) :<span class="built_in">myref</span>(target) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Ref constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;myref is: &quot;</span> &lt;&lt; myref &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Ref</span> () &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> &amp;myref;</span><br><span class="line">        <span class="comment">/* data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="右值引用，跟左值有什么区别"><a href="#右值引用，跟左值有什么区别" class="headerlink" title="右值引用，跟左值有什么区别"></a>右值引用，跟左值有什么区别</h3><p>左值：指可以取地址的，或者有具体名字的变量/对象</p>
<ul>
<li>左值可以被赋值，寻址，可变</li>
</ul>
<p>右值：c98中包含纯右值，即临时值，和将亡值，通过右值引用绑定的右值，一般右值都是临时的，表达式结束右值便不再存在（右值引用可以延续右值的生命周期）</p>
<ul>
<li>右值不可变，不可寻址</li>
</ul>
<p>右值引用是c11的新特性，它主要有两个方面的优势：</p>
<ol>
<li>右值引用可以减少拷贝构造或者赋值构造中 对临时变量的 重复拷贝。</li>
<li>能够更简洁明确的定义泛函数</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
        <category>面经C++汇总</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>面经C++编译和底层</title>
    <url>/2021/05/11/C++/%E9%9D%A2%E7%BB%8FC++%E6%B1%87%E6%80%BB/%E9%9D%A2%E7%BB%8Fc++%E7%BC%96%E8%AF%91%E5%92%8C%E5%BA%95%E5%B1%82/</url>
    <content><![CDATA[<p> 面经 C++ 编译和底层</p>
<span id="more"></span>

<h3 id="C-源文件从文本到可执行文件经历的过程"><a href="#C-源文件从文本到可执行文件经历的过程" class="headerlink" title="C++源文件从文本到可执行文件经历的过程"></a>C++源文件从文本到可执行文件经历的过程</h3><p>四个过程。</p>
<ol>
<li>预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译 .i 文件</li>
<li>编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件</li>
<li>汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件</li>
<li>链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件</li>
</ol>
<h3 id="include尖括号和双引号的区别"><a href="#include尖括号和双引号的区别" class="headerlink" title="#include尖括号和双引号的区别"></a>#include尖括号和双引号的区别</h3><p>编译器预处理阶段查找头文件的路径不一样。</p>
<ul>
<li>尖括号：直接从系统目录里查找 头文件。系统目录主要有：编译时 -I 参数指定的头文件搜索路径，系统变量<code>CPLUS_INCLUDE_PATH</code>/<code>C_INCLUDE_PATH</code>指定的头文件路径 </li>
<li>双引号：先从当前目录搜索头文件，然后从系统目录中搜索</li>
</ul>
<h3 id="include头文件的顺序"><a href="#include头文件的顺序" class="headerlink" title="include头文件的顺序"></a>include头文件的顺序</h3><h3 id="malloc原理，以及系统调用"><a href="#malloc原理，以及系统调用" class="headerlink" title="malloc原理，以及系统调用"></a>malloc原理，以及系统调用</h3><p>Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。</p>
<p>当进行内存分配时，Malloc会通过显式链表，根据待分配内存大小在直接从合适的链表中寻找空闲块；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。</p>
<p>Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。</p>
<h3 id="C-的内存管理"><a href="#C-的内存管理" class="headerlink" title="C++的内存管理"></a>C++的内存管理</h3><p>对于32位CPU可寻址4G线性空间，其中0-3G是用户态空间，3-4G是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中,其逻辑地址其划分如下: (前三个为静态区 后 三个为动态区)</p>
<ul>
<li>代码段：用于存放代码和字符常量</li>
<li>数据段：用于存放已经初始化的全局变量和局部静态变量</li>
<li>bss段：用于存放未初始化的全局变量和局部静态变量，或初始化未0的全局局部静态变量</li>
<li>堆区：用于程序运行过程中，用户自行动态分配的管理的内存区域</li>
<li>栈区：用于函数调用时，存放函数的局部变量，函数返回地址，返回值等，由操作系统分配和管理。在创建进程时会有一个最大栈大小</li>
<li>mmap映射区：用于存储动态库等文件映射，同时malloc也可以通过系统调用申请大内存</li>
</ul>
<h3 id="如何判断内存泄漏"><a href="#如何判断内存泄漏" class="headerlink" title="如何判断内存泄漏"></a>如何判断内存泄漏</h3><p>内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。为了判断内存是否泄露，我们一方面可以使用linux环境下的内存泄漏检查工具Valgrind,另一方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。</p>
<p>内存泄漏的分类：</p>
<ol>
<li>堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.</li>
<li>系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 <strong>Bitmap,handle ,SOCKET</strong>等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</li>
<li>没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</li>
</ol>
<h3 id="什么时候会发生段错误"><a href="#什么时候会发生段错误" class="headerlink" title="什么时候会发生段错误"></a>什么时候会发生段错误</h3><p>段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：</p>
<ul>
<li>使用野指针</li>
<li>试图修改字符串常量的内容</li>
</ul>
<h3 id="说一下共享内存相关api"><a href="#说一下共享内存相关api" class="headerlink" title="说一下共享内存相关api"></a>说一下共享内存相关api</h3><p>Linux允许不同进程访问同一个逻辑内存，提供了一组API，头文件在<code>sys/shm.h</code>中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 新建共享内存: </span></span><br><span class="line"><span class="comment">key：共享内存键值，可以理解为共享内存的唯一性标记。</span></span><br><span class="line"><span class="comment">size：共享内存大小</span></span><br><span class="line"><span class="comment">shmflag：创建进程和其他进程的读写权限标识。</span></span><br><span class="line"><span class="comment">返回值：相应的共享内存标识符，失败返回-1*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key,<span class="keyword">size_t</span> size,<span class="keyword">int</span> shmflg)</span></span>;  <span class="comment">// 新建共享内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 连接共享内存到当前进程的地址空间shmat</span></span><br><span class="line"><span class="comment">shm_id：共享内存标识符</span></span><br><span class="line"><span class="comment">shm_addr：指定共享内存连接到当前进程的地址，通常为0，表示由系统来选择。</span></span><br><span class="line"><span class="comment">shmflg：标志位</span></span><br><span class="line"><span class="comment">返回值：指向共享内存第一个字节的指针，失败返回-1*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id,<span class="keyword">const</span> <span class="keyword">void</span> *shm_addr,<span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当前进程分离共享内存shmdt */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制共享内存shmctl</span></span><br><span class="line"><span class="comment">和信号量的semctl函数类似，控制共享内存</span></span><br><span class="line"><span class="comment">shm_id：共享内存标识符</span></span><br><span class="line"><span class="comment">command: 有三个值   IPC_STAT:获取共享内存的状态，把共享内存的shmid_ds结构复制到buf中。</span></span><br><span class="line"><span class="comment">                   IPC_SET:设置共享内存的状态，把buf复制到共享内存的shmid_ds结构。</span></span><br><span class="line"><span class="comment">                   IPC_RMID:删除共享内存</span></span><br><span class="line"><span class="comment">				  buf：共享内存管理结构体。*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id,<span class="keyword">int</span> command,struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="new-和-malloc-的区别"><a href="#new-和-malloc-的区别" class="headerlink" title="new 和 malloc 的区别"></a>new 和 malloc 的区别</h3><ol>
<li>new 是 c++ 的一个关键字，而 malloc 是函数。</li>
<li>new 会根据对象的大小自动分配相同大小的内存，并且会默认调用类的构造函数，而malloc只能自己使用sizeof设定需要分配大小</li>
<li>new分配的后返回的是指向类的指针，而 malloc返回的是void指针，需要自行进行类型转换</li>
<li>new分配使用delete释放，malloc与之对应的是free</li>
<li>new如果内存申请失败会抛出异常，而malloc则返回空指针</li>
<li>malloc分配的内存不够时，可以调用 relloc 进行扩容，而new没有这个操作</li>
<li>申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。</li>
</ol>
<h3 id="C-如何处理内存泄漏"><a href="#C-如何处理内存泄漏" class="headerlink" title="C++如何处理内存泄漏"></a>C++如何处理内存泄漏</h3><p>使用varglind，mtrace检测</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>面经C++汇总</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>相关的编程题汇总-图</title>
    <url>/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/leecode_%E5%9B%BE/</url>
    <content><![CDATA[<p>汇总了刷题中遇到的 图 相关的题目，例如拓扑排序，最短路径等</p>
<span id="more"></span>

<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="拓扑排序类"><a href="#拓扑排序类" class="headerlink" title="拓扑排序类"></a>拓扑排序类</h3><h4 id="leecode-课程表-II"><a href="#leecode-课程表-II" class="headerlink" title="leecode:课程表  II"></a>leecode:课程表  II</h4><p> 现在你总共有 n 门课 <code>0 ~ n-1</code>。想要学习课程 0，要先完成课程 1，用 <code>[0,1]</code> 表示。给定课程总量以及它们的先决条件，返回学完所有课程的顺序（返回一种即可），如果不可能完成所有课程，返回空数组。</p>
<p>​        这道题是一个典型的拓扑排序的问题，或者说 ：</p>
<ul>
<li>能 拓扑排序 的图，一定是有向无环图</li>
<li>有向无环图，一定能拓扑排序</li>
</ul>
<blockquote>
<p>AOV网（Activity On Vertex Network)：将一个工程分为多个小的活动（Activity)，在有向无环图中，用顶点表示活动，用弧（有向边）表示活动的先后关系，简称为AOV网。</p>
</blockquote>
<p>​    此题可以使用广度优先遍历求解。首先寻找入度为 0 的节点，然后将所有入度为0的节点 加入队列，并且初始计算所有节点的度，每次从队列中取出一个节点访问，将其添加到输出数组。<strong>同时将与之相连的所有节点的入度减一，因为这节点已经访问了</strong>，对于领结节点度为0 的点可以加入待访问结点队列。<br>​    最后 如果输出数组的大小 小于节点数量表明图有环 无拓扑排序。</p>
<p>​    此题还可以使用 深度优先遍历，遍历所有节点，若节点未被访问则从该节点开始深度遍历。并将该节点状态设置为正在遍历中 1；当他的所有邻接子节点遍历完成后，再次回溯到这个节点时，将状态设置为 2 并将该节点入栈。 代表访问完成。而当该节点状态为 正在遍历中 并再次访问到它时 代表有环 直接退出，无拓扑排序。<br>​    最后输出时将 栈 反序输出即可。这么做可以成立的原因是，因为  节点入栈实在回溯的时候完成的  因此对于有出度的节点 它入栈的顺序一定晚于 由该节点输出的子节点，符合拓扑排序的要求。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 存储每个节点的入度</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; indeg;</span><br><span class="line">    <span class="comment">// 存储答案</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        indeg.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="comment">// 将所有入度为 0 的节点放入队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 从队首取出一个节点</span></span><br><span class="line">            <span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 放入答案中</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(u);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v: edges[u]) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="comment">// 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span></span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() != numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="最短路径类"><a href="#最短路径类" class="headerlink" title="最短路径类"></a>最短路径类</h3><p>实例：LeeCode 743题</p>
<h4 id="方法一-深度-广度优先遍历"><a href="#方法一-深度-广度优先遍历" class="headerlink" title="方法一 深度/广度优先遍历"></a>方法一 深度/广度优先遍历</h4><p>​        这种方法耗时较长。初始 到其他节点的延时为无穷大。首先从初始节点出发，开始广度/深度优先遍历。判断是否将新的节点加入队列的方法是 <strong>当前延时小，则将该节点加入访问队列（递归节点）</strong>。这样可以防止有环的情况下 出现死循环。对于广度优先遍历的方法，注意不能用 入度数 是否递减到 0 来判断 是否停止 将其加入遍历，例如 4-&gt;1-&gt;2-&gt;3   4-&gt;2-&gt;3 若第一个路劲 为最短 ，但是 若用入度数递减为0判断是否加入遍历的条件，路径一会先到达3这样导致 2-&gt;3提前失效，就无法找到最短的路径一。</p>
<h4 id="方法二-迪杰斯特拉算法-Dijkstra"><a href="#方法二-迪杰斯特拉算法-Dijkstra" class="headerlink" title="方法二 迪杰斯特拉算法 Dijkstra"></a>方法二 迪杰斯特拉算法 Dijkstra</h4><p>特点： （参考链接: <a href="https://blog.csdn.net/qq_35644234/article/details/60870719%EF%BC%89">https://blog.csdn.net/qq_35644234/article/details/60870719）</a></p>
<ul>
<li>求单源最短路径，即求从一个点出发 到其他所有点的最短距离</li>
<li>只适用于非负权图</li>
<li>时间复杂度优秀</li>
<li>使用了贪心思想</li>
</ul>
<p>步骤：</p>
<ol>
<li>初始化两个集合，一个已确定最短路径的节点为集合P， 未确定最短路的节点为集合Q。保存源节点 K 到每个节点的距离，若源节点和它无直接连接，初始化时距离为无穷大。将源节点K放入 P。</li>
<li>从Q中找一个 到 K 距离最短的节点 u, 因为距离权值都是正，而这个又最短，其他的无论怎么从 K 走到 u 都不如这个 K直接到 u 的近。因此将它放入P，代表已经确定。 （贪心思想）</li>
<li>上一步已经确定一个新的 最短路径的节点，这一步就要 确定 以 u 为出的 边所指向的 节点 v，是否能通过 u 缩短 K到v的距离。这一步叫松弛。此时 v 节点还是在Q中。</li>
<li>循环 2 开始 找新的 最短距离 节点 然后再用新的最短边 来松弛 节点。直到 Q 空。</li>
</ol>
<p><strong>核心思想</strong>：基于贪心的原则。每次取出从起点到某节点最短的距离，然后再以该节点为中心 区松弛更新起点到所有节点的距离。</p>
<h4 id="方法三-Floyd算法"><a href="#方法三-Floyd算法" class="headerlink" title="方法三 Floyd算法"></a>方法三 Floyd算法</h4><h4 id="leecode-K-站中转内最便宜的航班"><a href="#leecode-K-站中转内最便宜的航班" class="headerlink" title="leecode:  K 站中转内最便宜的航班"></a>leecode: <a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/"> K 站中转内最便宜的航班</a></h4><p>​        这个题从无向图的最短路径衍生而来。但是区别是这里有转机次数限制条件。因此如果没有跳转次数限制，存储起点到各节点的数组一维就够了，如果是有跳转次数限制，则最短距离数组为两维，新增的第二维为跳转次数：即从起点到节点 j 且跳转次数为 k 的最短距离。因为：如下情况  从A 出发到 节点 C  的最短路径是A-&gt;B-&gt;C 但是转了一次，如果从C 往后还有节点，但是只设置了一维最短距离数组，那么当取出{ C, 5, 0} 时由于  d[5] = 4 &lt;  0 + 5 = 5（d[5] 被 A-&gt;B-&gt;C这个选项先更新为4了），就不会把  {C, 5, 0} (A-&gt;C) 路径加入优先队列，导致后面可能经过C到达节点N的最短路径且满足转机次数要求的路径  是A-&gt;C-&gt;… 这种情况被忽略。所以这个题加入了  转机次数的限制，最短路径就要为 两维数组，保存在转折次数相同时到达节点N的最短距离。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328202842.png" alt="image-20210104223320648"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迪杰斯特拉算法实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; a, vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n, INT_MAX));  <span class="comment">// 用邻接矩阵存储图</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n)</span></span>;  <span class="comment">// 目标顶点到 其他各点的距离  一维数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flights.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            map[flights[i][<span class="number">0</span>]][flights[i][<span class="number">1</span>]] = flights[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;vector&lt;<span class="keyword">int</span>&gt;, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;, cmp&gt; edges;  </span><br><span class="line">        <span class="comment">// 优先队列： 节点p  起点到节点p的距离  起点到p需要中转的次数，如果只是求最短距离，这项没用</span></span><br><span class="line">        edges.<span class="built_in">push</span>(&#123;src, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">	   <span class="comment">//  起始 起点到起点的距离0  转的次数0  （这里的转的次数和题目里的定义K不完全一样 差1）</span></span><br><span class="line">        <span class="keyword">while</span>(!edges.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; edge = edges.<span class="built_in">top</span>();</span><br><span class="line">            edges.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 取出节点到起点最近的  一个节点</span></span><br><span class="line">            <span class="keyword">int</span> p = edge[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> dis_tmp = edge[<span class="number">1</span>]; </span><br><span class="line">            <span class="keyword">int</span> trans = edge[<span class="number">2</span>];</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 如果正好是目的结点，可以退出得到最近距离</span></span><br><span class="line">            <span class="keyword">if</span>(p == dst)   <span class="keyword">return</span> dis_tmp;</span><br><span class="line">		   <span class="comment">// 以距离起点最近的节点 p  	</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> ed = <span class="number">0</span>; ed &lt; n; ed++)&#123;</span><br><span class="line">                <span class="comment">// 如果 节点 p 和 ed 相邻  并且 结果点p到达节点ed的距离比原本 ed 的距离近  就更新到ed的最短距离 并加入队列以后访问  </span></span><br><span class="line">                <span class="keyword">if</span>(map[p][ed] == INT_MAX || d[ed] &lt;= map[p][ed] + dis_tmp) <span class="keyword">continue</span>;      </span><br><span class="line">                d[ed] = <span class="built_in">min</span>(d[ed], map[p][ed] + dis_tmp);</span><br><span class="line">                edges.<span class="built_in">push</span>(&#123;ed, d[ed], trans+<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>​        主要用途是 （参考链接：<a href="https://blog.csdn.net/liujian20150808/article/details/50848646%EF%BC%89">https://blog.csdn.net/liujian20150808/article/details/50848646）</a></p>
<ul>
<li><p>求联通分量：依次对每个边的两个顶点进行并查集合并，可以使得每个连通分量的root相同，从而得出每个连通分量。</p>
</li>
<li><p>查找环： 合并过程中，如果发现一条边的两个顶点已经合并过，说明这两个顶点之前已经通过其他路径合并，再加上这条边，图中就出现了环。<strong>合并节点 a , b 时  发现它两是一个祖先，是无向图，这样再加上边a-b就构成了环</strong>。(leecode 684 冗余连接)</p>
</li>
<li><p>求最小生成树： 贪心思想，从小到大排序所有边，使用并查集依次合并，并跳过形成环的边，即可得到最小生成树。</p>
<p>  基本用方法 （详情 ）：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="keyword">int</span> set_cnt;  <span class="comment">//  统计联通数 初始所有元素各自为一类，然后依次读入数据 不断合并 合并过程中 该变量递减 </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = i;</span><br><span class="line">        <span class="keyword">while</span>(parent[p] != p)</span><br><span class="line">            p = parent[p];</span><br><span class="line">        parent[i] = p;   <span class="comment">//这里的路劲 压缩写的不全  具体百度  思想就是 ，将所有子节点 都直接连接到根节点下，这样查找祖先时一部到位 速度快</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unio</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = <span class="built_in">find</span>(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = <span class="built_in">find</span>(q);</span><br><span class="line">        <span class="keyword">if</span>(rootP == rootQ)  <span class="comment">// 联通的冗余边  当发现q p 已经连接时 ， 又传进p q代表此时成环了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">        set_cnt--;       <span class="comment">// 联通数减一  这里可以加上启发式合并，每次合并保证将小的祖先族添加到大的祖先族下，免得一个方向的深度太深， 查找的慢 3-&gt;2-&gt;1    4-&gt;5  =》 3-&gt;2-&gt; 1 &lt;-5&lt;-4 优于 3-&gt;2-&gt;1-&gt; 4-&gt;5</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        set_cnt = N;</span><br><span class="line">        parent.<span class="built_in">resize</span>(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>(edges.<span class="built_in">size</span>()+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt; edg : edges)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">unio</span>(edg[<span class="number">0</span>], edg[<span class="number">1</span>]) == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span> edg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>​        是 一副连通加权无向图中一颗权值最小的生成树。</p>
<h4 id="Kruskal-克鲁斯卡算法"><a href="#Kruskal-克鲁斯卡算法" class="headerlink" title="Kruskal 克鲁斯卡算法"></a>Kruskal 克鲁斯卡算法</h4><p>​        Kruskal 算法是一种<strong>贪心算法</strong>，将图中的每个edge按照权重大小进行排序，每次从边集中取出权重最小且两个顶点都不在同一个集合的边加入生成树中！<strong>注意：如果这两个顶点都在同一集合内，说明已经通过其他边相连，因此如果将这个边添加到生成树中，那么就会形成环！</strong>这样反复做，直到所有的节点都连接成功！这里可以用前面的并查集实现，复杂度NlogN</p>
<p><img src="https://picb.zhimg.com/v2-584bc7761471fd9835cde91b303935ac_r.jpg" alt="preview"></p>
<h4 id="leecode-找到最小生成树里的关键边和伪关键边"><a href="#leecode-找到最小生成树里的关键边和伪关键边" class="headerlink" title="leecode: 找到最小生成树里的关键边和伪关键边"></a>leecode: 找到最小生成树里的关键边和伪关键边</h4><p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328202902.png" alt="1599203012347"></p>
<p>​        较简单的暴力思想。首先使用 kruskal算法+并查集的方法 求得最小生成树的 最小权值。然后再遍历判断每个边是否为 关键边。例如对于边 i 。判断它是关键边的方法就是在  使用 kruskal 时 跳过该边。如果最后生成的树的权值比开始计算的大 或者 不连通，说明它是关键边。伪关键边只会出现在 权值相同的多个边中，因此在生成树的时候优先以 待判断的边去选择，再对比最后生成树的权值是否最小。    </p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>基本数据结构</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>相关的编程题汇总-树</title>
    <url>/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/leecode_%E6%A0%91/</url>
    <content><![CDATA[<p>汇总了刷题中遇到的 树 相关的题目，例如二叉树的遍历，公共祖先问题等</p>
<span id="more"></span>

<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="特定深度节点链表"><a href="#特定深度节点链表" class="headerlink" title="特定深度节点链表"></a>特定深度节点链表</h4><p>​        <img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328202809.png" alt="1598931882407"></p>
<p>​        这个题 使用 层序遍历的 即可简单完成。类似于广度优先搜索的策略。只不过这里为了体现层的 特点，不是直接将 节点 传入队列 遍历，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;ListNode*&gt; <span class="title">listOfDepth</span><span class="params">(TreeNode* tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree==<span class="literal">nullptr</span>)<span class="keyword">return</span> vector&lt;ListNode*&gt;();</span><br><span class="line">        vector&lt;ListNode*&gt; v;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(tree);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            ListNode *h = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            ListNode *k=h;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=q.<span class="built_in">size</span>(); i&gt;<span class="number">0</span>; i--)&#123;    <span class="comment">/// 这里 先把size 赋给 i 即便for循环内改变了 队列的大小，最终也只是for遍历了原先的元素 ，所有可以记录 遍历的深度</span></span><br><span class="line">                TreeNode *p = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                k-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(p-&gt;val);</span><br><span class="line">                k = k-&gt;next;</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left)q.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right)q.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            v.<span class="built_in">push_back</span>(h-&gt;next); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="合法二叉搜索树"><a href="#合法二叉搜索树" class="headerlink" title="合法二叉搜索树"></a>合法二叉搜索树</h4><p>​        最简单的思路就是 中序遍历 打印出二叉树所有的值，然后判断是不是递增的就可。必须是中序遍历才能将标准的搜索树递增的顺序打印出来。</p>
<h4 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">NULL</span> || B == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> B == <span class="literal">NULL</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (A-&gt;val != B-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(A-&gt;left, B-&gt;left) &amp;&amp; <span class="built_in">helper</span>(A-&gt;right, B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">NULL</span> || B == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(A, B) || <span class="built_in">isSubStructure</span>(A-&gt;left, B) || <span class="built_in">isSubStructure</span>(A-&gt;right, B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​        这道题的思路是，双递归。首先 isSubStructure 第一个递归用来对A树递归，在A中搜索和B树的根节点 相同的 子节点 即return 中的 helper(A, B)  若该节点不满足则递归A  分别搜索A 的左右子节点是否满足。 而help函数的递归是在 第一个输入子节点A,B val值相同时，才开启递归，A和B分别往左右 递归去判断后面的节点是否相同。也就是此时二者的递归是同步的。注意helper中 若B是NULL 那位对应位置的A可以是任意值，所以直接返回True。 </p>
<h4 id="翻转二叉树以匹配先序遍历"><a href="#翻转二叉树以匹配先序遍历" class="headerlink" title="翻转二叉树以匹配先序遍历"></a><a href="https://leetcode-cn.com/problems/flip-binary-tree-to-match-preorder-traversal/">翻转二叉树以匹配先序遍历</a></h4><p>​        这道题容易理解错。题目的翻转的意思不是交换左右子节点的位置，它的反转是交换先序遍历中 左右子节点的访问顺序，之后能否匹配上给定的行程。因此解题思路是 首先 还是先序遍历，如果当前节点值 和 期待的行程值不一样直接返回false；接着先序遍历会递归访问左子节点 再右子节点。但是，这里在访问左子节点时要先判断下如果左子节点非空 且 值等于期待的行程的值 那么再递归的访问左右子节点，否则看右子节点值与期待的是否一样，<strong>若是，则先递归右子节点再左子节点</strong>，这就是所谓的交换子节点了。</p>
<h4 id="收集树上所有苹果"><a href="#收集树上所有苹果" class="headerlink" title="收集树上所有苹果"></a><a href="https://leetcode-cn.com/problems/minimum-time-to-collect-all-apples-in-a-tree/">收集树上所有苹果</a></h4><p>​    这道题主要思路 是 从苹果往它上方通往根节点0的方向回退，并将总路程+2(该节点到父节点的往返) 这样对于有公共父节点的苹果，只用计算父节点到 根节点0的距离 和 各个苹果到该节点的距离。 首先利用并查集里的方法 构建一个 parent 的一维数组，parent[0] = 0代表起始的根节点，后面paent[1] = 0 表示节点1 的父节点是0，类似的 每个节点与它直系的可以通往 节点 0 的父节点相接。这个parent数组的初始化方法是：在并查集合并节点时，首先判断两个节点p,q的迭代到最后的根节点是不是0，若节点p的根节点不是0，q是，则 parent [p] = q 。初始化完了之后，将有苹果的节点加入队列，挨个访问，除了根节点之外 其余的在总路径上加2 表示往返  若他的父节点 没被访问过，则将它的父节点加入队列。    </p>
<h4 id="输出二叉树"><a href="#输出二叉树" class="headerlink" title="输出二叉树"></a><a href="https://leetcode-cn.com/problems/print-binary-tree/">输出二叉树</a></h4><p>​    这道题的主要思路是  首先深度优先搜索确定 树的最大深度。这样就可以直到 最终输出数组的宽度和长度，然后再用递归写一个深度优先搜索来，来依次填数。而这里的填充方法 用二分法定位每个节点子节点在数组中的位置比较方便。</p>
<h4 id="二叉树减树枝"><a href="#二叉树减树枝" class="headerlink" title="二叉树减树枝"></a><a href="https://leetcode-cn.com/problems/binary-tree-pruning/submissions/">二叉树减树枝</a></h4><p>​        这道题思路很简单。写一个 dfs 后续遍历，如果递归左边和右边输出的树指针为NULL 且 当前节点 值为0 则返回NULL指针，否则直接返回 输入的结点。 </p>
<h4 id="二叉树右视图"><a href="#二叉树右视图" class="headerlink" title="二叉树右视图"></a><a href="https://www.cnblogs.com/liuzhen1995/p/11921771.html">二叉树右视图</a></h4><p>​        使用层次遍历，较简单。每次先把右子节点加入队列，每次输出只输出第一个节点的值。即可</p>
<h4 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">重建二叉树</a></h4><p>​        这类题目有 从前序和中序遍历的结果生成二叉树，或者从前序和后续遍历的结果生成二叉树，中序后序遍历的结果生成二叉树。要根据 不同遍历的 特点来构造递归。</p>
<ul>
<li><p>前序遍历：根节点 + 左子树所有节点 + 右子树所有节点的值</p>
</li>
<li><p>中序遍历：左子树的所有节点 + 根节点 + 右子树所有节点的值</p>
</li>
<li><p>后续遍历：左子树的所有节点 + 右子树所有节点的值 + 根节点 </p>
<p>  有了上述的规律，考虑 已知前序 和 后序遍历时，首先根节点 确定，然后根据前序遍历的 左子树序列的第一个值，即左子树的根节点值，在后续遍历序列中确定 左子树的范围。因为 前序和后续的同一颗子树的根节点 必然一个在最开始 一个在最结尾。这样递归的划分子树，构建即可。为了加快速度，使用<strong>Hash表</strong>构建 值-&gt;位置的索引，快速划分子树。</p>
</li>
</ul>
<h4 id="二叉树最近公共祖先"><a href="#二叉树最近公共祖先" class="headerlink" title="二叉树最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树最近公共祖先</a></h4><p>​        这道题目的思想 在于  在一颗子树下的两个 待寻找的节点，找到最上面那个节点后 直接返回该节点，不用再往下递归搜索啦。因为如果深度往下搜的时候已经找到了 那么另一个要么 在它之下，要么在另一颗子树，这两种情况 最后最近的公共节点都是 这个返回的值。</p>
<h4 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">二叉树中的最大路径和</a></h4><p>思路比较简单，但是是个困难的题目</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="无序数组的topK小元素"><a href="#无序数组的topK小元素" class="headerlink" title="无序数组的topK小元素"></a>无序数组的topK小元素</h4><p>​        可以使用优先队（大根堆），c++ 中的数据结构为<strong>priority_queue</strong>。思路是，首先对数组前K个元素建大根堆，然后依次读取数组后面的元素，若该元素大于 堆顶的元素，则丢弃不管，若小于堆顶元素，则将它入堆，并pop掉原本的根节点的数据。遍历完数组后，最后堆中剩下的就是TopK小的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">vec</span>(k, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> vec; <span class="comment">// 排除 0 的情况</span></span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt;Q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) Q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; (<span class="keyword">int</span>)arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Q.<span class="built_in">top</span>() &gt; arr[i]) &#123;</span><br><span class="line">                Q.<span class="built_in">pop</span>();</span><br><span class="line">                Q.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            vec[i] = Q.<span class="built_in">top</span>();</span><br><span class="line">            Q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/">数据流的中位数</a></h4><p>使用大小堆解决。一个大顶堆一个小顶堆。每次先把数据从小顶堆输入，输出到大顶堆。这样就保证了 小顶堆中的数始终大于等于大顶堆的数。（因为大顶堆的数是从小顶堆过来的，小顶堆弹出的一定是最堆中最小的，而大顶堆堆定数最大 ）最后每次维持小顶堆的数据量大于或等大顶堆中的数据量即可（如果大顶堆数量大于小顶堆数量，就反过来将大顶堆数据弹出一个给小顶堆，这样两堆元素数量就相等了）。这样当数据量为偶数时就是两个堆定元素平均，否则就是小顶堆的堆顶元素。</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>基本数据结构</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>相关的编程题汇总-表</title>
    <url>/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/leecode_%E8%A1%A8/</url>
    <content><![CDATA[<p>汇总了刷题中遇到的 表 相关的题目，例如栈，哈希表，数组字符串相关的题目</p>
<span id="more"></span>

<h2 id="数组-字符串"><a href="#数组-字符串" class="headerlink" title="数组/字符串"></a>数组/字符串</h2><h4 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a><a href="https://leetcode-cn.com/problems/rotate-image/">旋转图像</a></h4><p>要做到不占用额外空间  </p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210426192915.gif" alt="rotate.gif"></p>
<p>方法一：需要用  暂存一个值 然后 循环交换。  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">                matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">                matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">                matrix[j][n - i - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法二：先水平镜像 后竖直镜像</p>
<h4 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a><a href="https://leetcode-cn.com/problems/calculator-lcci/">计算器</a></h4><p>方法一：递归的方法 很好理解。用递归 实际上也是 遍历了一边确定没有乘除之后 再遍历一圈计算加减</p>
<p>定义函数计算 cal(string &amp;s, int l, int r) 字符串s在区间[l,r]的结果</p>
<ol>
<li>由于是递归所以优先级低的+-先判断进入递归</li>
<li>因为同等优先级是从左往右 所以递归是从右往左开始扫</li>
<li>如果没有符号则说明这个区间里是一个数字 使用 stoi 返回数字即可</li>
</ol>
<p>方法二：使用堆栈  只遍历一次。遇到乘除直接计算值，遇到加减，将数字放入堆栈（带符号的放入），最后计算堆栈中所有数字的和</p>
<h4 id="验证IP地址"><a href="#验证IP地址" class="headerlink" title="验证IP地址"></a><a href="https://leetcode-cn.com/problems/validate-ip-address/">验证IP地址</a></h4><p>这个题 很恶性  主要就是各种边界条件的判定。有三种方法：</p>
<ol>
<li>不使用任何库函数 就纯c++手写循环。使用状态机的思路 构建了状态表 逻辑比较清晰 不会乱</li>
<li>使用 <code>stringstream</code> 来分割字符串</li>
<li>使用 正则表达式 这种方法最慢，但是代码最简介。 </li>
</ol>
<h4 id="移除无效的括号"><a href="#移除无效的括号" class="headerlink" title="移除无效的括号"></a><a href="https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/">移除无效的括号</a></h4><h4 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></h4><p>这个题要求实现 log(m+n)的时间复杂度。首先想到的是使用  归并的方式从头到尾寻找中位数。但是这样复杂度是O(m+n)。不符合要求。看到log(m+n)首要想打就是 二分法。问题是这个怎么用二分法呢。</p>
<p>首先找中位数 就是找第k个数，那么我就上下 各找前 (k-1)/2个数，然后比较两个数组这个位置数字大小，因为数组是有序的，一旦比较大小比出结果，就可以排除一大部分数字。再在后面的区间中找.</p>
<h4 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">重复的子字符串</a></h4><p>一开始想到的是 暴力枚举  子字符串的个数，从2，3，4…. 字符串长度如果不能整除可以跳过。然后怎么判断 字符串是否是3个子串重复的呢？例如  a = a1 + a2 + a3 如果要判断a是三个重复的组成就要判断 a1 == a2  a2 == a3 都成立，这样写麻烦，直接把 比较（a2 + a3 + a1 ）== (a1 + a2 + a3) 是否相等即可，代码写着比较简便。</p>
<p>但是更好的方法是 双倍长度法  构建新的双倍长度的字符串 s == a + a 然后 从 s 的第1个元素开始查找 和 a 匹配的位置，如果a 没有重复字符串组成 那么 找到的位置一定是从 a.size() 开始，即只能找到后面那个 a。</p>
<h4 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/">下一个排列</a></h4><p>这个题主要要想清楚下一个大排列的规律。 参考连接：<a href="https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/">https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/</a></p>
<h4 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a><a href="https://leetcode-cn.com/problems/rotate-array/">旋转数组</a></h4><p>这个题很经典。要求不使用 额外的 空间将 数组平移。方法1是使用三次翻折法，比较好想。方法二是循环移位法，原理假如下：</p>
<p>假设现在有 A 、B 、C、 D、 E 五名同学，今天考试完，老师要求换座位，每个同学向后移动3个座位。于是就从 A 同学开始换座位了… A同学 非常自觉，看了看自己座位号（0），根据老师要求，他走到了3 号位置，即 D 同学的位置，同时他把D 同学赶到了角落，自己坐在了 3 号位置，第一个完成任务真爽！D同学 一看，不行啊，我咋能呆在角落，于是D同学也按要求理直气壮来到了1号位置，同样把B同学赶到了角落，猛男落泪…B同学 当然也不干，气汹汹走到了4号位置，”E同学，麻烦起来一下，角落给你收拾好了：)”,于是 E同学来到角落..E同学 一想：不行呀，我这么帅，必须有座位！站起来跑到了2号位置，二话不说，赶走了C….</p>
<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210426110441.png" alt="image-20210426110441307" style="zoom:67%;" />

<p>同样，对于循环移位类的问题，可以这样理解，移动后的位置 i = (k + i) % len；但是移动的时候，可能还没遍历完所有的元素，就回到了起点。也可能从起点0开始，往后寻找，到下一轮回到了1位置，这时候再循环，可以到2位置….最终肯定能够再回到起点位置。也可能是从起点开始，到下一轮刚好又回到起点。</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210426113941.png" alt="image-20210426113941474"></p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h4 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">相交链表</a></h4><p>双指针，走 m + n + c    n + m + c 相遇 </p>
<h4 id="LRU-缓存机制"><a href="#LRU-缓存机制" class="headerlink" title="LRU 缓存机制"></a><a href="https://leetcode-cn.com/problems/lru-cache/">LRU 缓存机制</a></h4><h4 id="LFU-缓存"><a href="#LFU-缓存" class="headerlink" title="LFU 缓存"></a><a href="https://leetcode-cn.com/problems/lfu-cache/">LFU 缓存</a></h4><p>这个题和上面的区别在于，LRU的题意是，删除最久没使用过的元素，所以通过一个链表即可完成。而这个题要求删除使用最少的元素，所以就需要记录每个元素的使用次数。但是这个最小使用次数有一个规律，使用一个 变量 记录最小使用的次数，每次插入元素</p>
<ul>
<li>若该元素A在缓存中存在，且A的使用次数大于最少使用次数，那么该次插入对最小使用次数不影响</li>
<li>若该元素A在缓存中存在，且A不是唯一一个使用次数最少的元素，那么将它的使用次数加1之后，还是不影响系统的最下使用次数</li>
<li>若该元素A在缓存中存在，且正好A就是唯一的一个最少使用次数的元素，那么系统的最少使用次数 + 1  并将改元素移动到  使用频率为 min+1 的缓存池中</li>
<li>若该元素A是个新元素，那么删除缓存中的最少使用频率的元素后，系统使用次数最少频率  就 是  1 </li>
</ul>
<p>综上，在这个操作逻辑下 想要维护系统最小使用次数这个变量，其实逻辑不复杂，不需要排序。因此优化上述的数据结构，可以很容易O(1) 实现所有功能</p>
<p>但是，如果想不到 上述 O(1) 的方法，想到要取出 频率最小的元素，其实就应该 想到  堆 二叉搜索树 等数据结构，但是 用堆，当插入的元素不是堆顶的元素的是偶，从堆中搜索其他元素，O(n) 所以，考虑使用 红黑树，来维护 使用频率的有效性。c++中 set 底层是 红黑树，自定义数据结构后对  &lt;  重载，就可以保证插入到集合中的元素是有序的，每次取出集合起始的元素即可。（但是 要注意，自定义数据结构中，仅仅以 频率作为排序依据实不行的，因为不同元素使用频率可能一样，而集合要求每个元素不同，另外题目也要求 使用频率一样的 删除最近没使用的变量，所以新增一个 time（时间戳） 变量来标记每个元素，当有新的操作增加时，对应被操作的元素time更新时间戳，当使用频率相同时使用time的大小做为排序依据）。这种使用红黑树的方法，每次插入元素复杂度为 O(log N)</p>
<h4 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">回文链表</a></h4><p>基本的方法是 遍历链表 把 每个节点缓存到数组里 然后使用双指针判断是不是 回文链表。空间复杂度O(1) 的方法是 先使用快慢指针找到链表的中点，然后将链表后半部分反转，再和前半部分比较，这样没有缓存任何东西，空间复杂度O(1) 时间复杂度O(N)</p>
<h4 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a><a href="https://leetcode-cn.com/problems/sort-list/">排序链表</a></h4><p>很容易想到归并排序，但是在实现过程中 很容易出现 无线递归的情况。这样考虑  一个节点的时候 中点节点回是哪个，两个节点的时候中点节点会是哪个，基本四个以上的节点就不会出问题了  主要是节点少的时候容易无限递归。</p>
<h2 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h2><h4 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a><a href="https://leetcode-cn.com/problems/first-missing-positive/">缺失的第一个正数</a></h4><p>这个题 有点意思 要时间复杂度 O(N)  常数的空间复杂度。首先一个隐含条件需要看出来，那就是缺失的最小正整数一定是[1, N+1]其中N为数组长度。所以要实现时间复杂度O(N)很容易，直接枚举N个数。用hash表判断每个枚举的数在不在表中即可。</p>
<p>但是要空间复杂度为O(N)  那就不能额外新建hash表了。但是题目给定的数组可以修改啊，于是乎 怎样在修改数组中数的前提下，害不修改数组的值呢？那就是用正负号标记喽。只对原数组中的数做 正负 处理，如果某个元素存在就将该元素对应的下标上的数 用负标记。（由于数组中可能会存在 0或这负数，而这些数肯定不是  要找的最小正整数，所以将他们预先设置为N+1，不影响负号的标记即刻）。最后再遍历，最先出现正数的位置（即每被标记过） 即为 最小的正数。</p>
<p>综上 遍历三次 第一次 将负数和0设置为 N+1，第二次遍历标记出现过的数对应的下标的值标为 负数，第三次遍历找第一次为正数的下标</p>
<h4 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">最长连续序列</a></h4><p>这个题不难实现，但是关键是先能想到的使用暴力的方法 求解的逻辑，然后再使用 Hash 去优化，最后再进行剪枝，最终实现 O(n)。</p>
<h4 id="和为K的子数组"><a href="#和为K的子数组" class="headerlink" title="和为K的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">和为K的子数组</a></h4><p>这个题还可以变化一下  和 大于 K 的最短子数组 就是另一个题目了</p>
<h4 id="连续数组"><a href="#连续数组" class="headerlink" title="连续数组"></a><a href="https://leetcode-cn.com/problems/contiguous-array/">连续数组</a></h4><p>这类 连续数组  和   &gt;&gt;   前缀后  &gt;&gt;   数组中两数差/两数和   &gt;&gt;   Hash </p>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h4 id="下一个更大元素-II"><a href="#下一个更大元素-II" class="headerlink" title="下一个更大元素 II"></a><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">下一个更大元素 II</a></h4><p>这是一个典型的单调栈的题目 。 就是栈中元素,按递增顺序或者递减顺序排列。</p>
<h4 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/">接雨水</a></h4><p>单调递减栈。这个题，关键点 是没想到 怎么计算雨水的容量，一开始想的是 宽度x短边长，但是如果这里面还有其他矮的柱子，还得减去矮柱子的面积，想到了使用栈的方式，但是没想到使用栈的第推计算面积的方式，计算面积可以通过高度差的方式 累计面积。</p>
<h4 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a></h4><h4 id="和至少为-K-的最短子数组"><a href="#和至少为-K-的最短子数组" class="headerlink" title="和至少为 K 的最短子数组"></a><a href="https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/">和至少为 K 的最短子数组</a></h4><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h4 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a><a href="https://leetcode-cn.com/problems/decode-string/">字符串解码</a></h4><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h4 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">滑动窗口最大值</a></h4><p>这个题 和  最大栈/单调栈 类似。只不过那个是用来记录栈数据中的最大值，因此需要一个额外的最大栈。这种题目中 最大值都是和元素的增加顺序有关，因为滑动窗口很像 双端队列的逻辑，所以使用一个双端队列来记录最大值。具体的   窗口前端增加数据时，首先队列前端所有比他小的元素，然后再将改元素从前端入队，同时窗口可能还要收缩一个单位，如果待收缩的元素不是队列尾端的，就不管，若是就从尾端弹出。最后窗口最大的元素就是队列末尾的元素了。o(N)</p>
<p>但是这个题也可以用优先队列做。首先优先队列中存放K个数，顶端的肯定是最大的，但是不一定在窗口中，因此每次去顶端元素时，要先保证它在窗口中（同时记录每个元素的大小 和 其在数组中的索引位置）即索引位置在窗口以外，就弹出，直到顶端元素在窗口中，那么顶端元素就是窗口的最大值。这个方法复杂度 O(log(N))</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>基本数据结构</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-图</title>
    <url>/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/</url>
    <content><![CDATA[<p>数据结构之图，记录了图有关的定义和常规操作</p>
<span id="more"></span>

<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="几个重要的概念"><a href="#几个重要的概念" class="headerlink" title="几个重要的概念"></a>几个重要的概念</h2><ul>
<li>有向图 / 无向图 / 混合图：每个边都是有向边，个边都是无向边，…</li>
<li>度：顶点相邻边的数目，常用 <code>deg(V)</code>, <code>d(v)</code> 表示。有向图中 以该顶点为终点的边的数目 <strong>入度</strong>；   以该顶点为起点的边的数目 <strong>出度</strong> ； 顶点的度 = 入度 + 出度。</li>
<li>连通的 / 连通图 /  连通分量 / 极大连通子图：从顶点 u 有路径到达 v ，则 <code>u,v</code> 是连通的；任意两点连通；H是G的连通子图，且不存在连通图F，使得 <code>H ⊊ F ⊆ G</code>，则H是G的连通分量。<ul>
<li>连通图只有一个连通分量，即图自身</li>
<li>非连通图有多个连通分量。</li>
</ul>
</li>
</ul>
<h2 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h2><p><strong>直接存边</strong>：使用一个数组来存边，数组中的每个元素都包含一条边的起点、终点和边权（带边权的图），或者使用多个数组分别存起点、终点和边权。</p>
<p><img src="https://i.loli.net/2021/03/28/BNKUo93ncTrgdWY.png" alt="1598969422109"></p>
<p><strong>邻接矩阵 Adjacency Matrix</strong>二维数组 <code>adj[][]</code>，<code>adj[u][v]</code> 为 1 表示存在 u 到 v 的边，为 0 表示不存在。如果是带边权的图，可以在 <code>adj[u][v]</code> 中存储 u 到 v 的边的边权。</p>
<p><strong>邻接表 Adjacency Table</strong>：使用一个支持动态增加元素的数据结构构成的数组，例如c++中的 vector<int></p>
<ul>
<li><p>领接表：中 <code>adj[u]</code> 存储的是点 u 所有出边的信息（终点、边权等）</p>
</li>
<li><p>逆邻接表：中 <code>adj[u]</code> 存储的是点 u 所有入边的信息（起点、边权等）</p>
<p>​    </p>
</li>
</ul>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><ul>
<li>深度优先搜索 (Depth-First Search, DFS)</li>
<li>广度优先搜索 (Breadth-First Search, BFS)</li>
</ul>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>基本数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-表</title>
    <url>/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%A1%A8/</url>
    <content><![CDATA[<p>数据结构之表，例如数组，哈希表，链表</p>
<span id="more"></span>

<h1 id="表"><a href="#表" class="headerlink" title="表"></a>表</h1>]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>基本数据结构</category>
      </categories>
      <tags>
        <tag>表</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer</title>
    <url>/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/b.%20%E5%89%91%E6%8C%87Offer/</url>
    <content><![CDATA[<p>记录了剑指offer中的题目，不会写的都在后面加了思路注释，重点复习不会写的就行</p>
<span id="more"></span>

<h2 id="数组与矩阵"><a href="#数组与矩阵" class="headerlink" title="数组与矩阵"></a>数组与矩阵</h2><ul>
<li>[3. 数组中重复的数字](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/3. 数组中重复的数字.html)   </li>
<li>[4. 二维数组中的查找](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/4. 二维数组中的查找.html)</li>
<li>[5. 替换空格](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/5. 替换空格.html)</li>
<li>[29. 顺时针打印矩阵](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/29. 顺时针打印矩阵.html)</li>
<li>[50. 第一个只出现一次的字符位置](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/50. 第一个只出现一次的字符位置.html)</li>
</ul>
<h2 id="栈队列堆"><a href="#栈队列堆" class="headerlink" title="栈队列堆"></a>栈队列堆</h2><ul>
<li>[9. 用两个栈实现队列](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/9. 用两个栈实现队列.html)  </li>
<li>[30. 包含 min 函数的栈](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/30. 包含 min 函数的栈.html)      no    栈的数据进出顺序逻辑的应用 例如 在栈低的较大的数一定后出，那么最大栈的顶端一定得是它</li>
<li>[31. 栈的压入、弹出序列](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/31. 栈的压入、弹出序列.html)   no    模拟栈的push pop流程 重点在如何代码简化这个逻辑</li>
<li>[40. 最小的 K 个数](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/40. 最小的 K 个数.html)   no   堆</li>
<li>[41.1 数据流中的中位数](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/41.1 数据流中的中位数.html)  no    中位数 只关心中间大的那个数，因此只需要中位数左边序列最大的右边序列最小的即可，两个堆</li>
<li>[41.2 字符流中第一个不重复的字符](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/41.2 字符流中第一个不重复的字符.html)    </li>
<li>[59. 滑动窗口的最大值](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/59. 滑动窗口的最大值.html)   no  和min函数栈很类似。同样从数据进出先后顺序的逻辑下手存储数据流中的最大值</li>
</ul>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><ul>
<li>[57.1 和为 S 的两个数字  ](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/57.1 和为 S 的两个数字.html)</li>
<li>[57.2 和为 S 的连续正数序列](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/57.2 和为 S 的连续正数序列.html)    no  先想到暴力枚举，再想双指针优化</li>
<li>[58.1 翻转单词顺序列](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/58.1 翻转单词顺序列.html)     no  面试不能用 split 那么就倒序用双指针确定每个单词的边界</li>
<li>[58.2 左旋转字符串](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/58.2 左旋转字符串.html)</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li><p>[6. 从尾到头打印链表](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/6. 从尾到头打印链表.html)</p>
</li>
<li><p>[18.1 在 O(1) 时间内删除链表节点](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/18.1 在 O(1) 时间内删除链表节点.html)</p>
</li>
<li><p>[18.2 删除链表中重复的结点](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/18.2 删除链表中重复的结点.html)</p>
</li>
<li><p>[22. 链表中倒数第 K 个结点](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/22. 链表中倒数第 K 个结点.html)    快慢指针</p>
</li>
<li><p>[23. 链表中环的入口结点](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/23. 链表中环的入口结点.html)</p>
</li>
<li><p>[24. 反转链表](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/24. 反转链表.html)   用递归做的关键思路是  清楚递归函数的意义。此题递归函数 输入为链表头，输出为反转后的新的链表头。</p>
<p>  1-&gt;2-&gt;3-&gt;4  例如从 2 开始递归 那么  把2递归完毕后  1-&gt;2  null&lt;-3&lt;-4 并且返回的要是节点4；而2-&gt;3依然存在因此在递归完2以后需要把2接上3后面，然后把之前的递归的节点返。</p>
</li>
<li><p>[25. 合并两个排序的链表](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/25. 合并两个排序的链表.html)</p>
</li>
<li><p>[35. 复杂链表的复制](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/35. 复杂链表的复制.html)</p>
</li>
<li><p>[52. 两个链表的第一个公共结点](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/52. 两个链表的第一个公共结点.html)     a-&gt;b  c-&gt;b  b-&gt;d 的距离分别为 a,b,c 则 a+c+b = b+c+a  相遇即为公共节点。</p>
</li>
</ul>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul>
<li>[7. 重建二叉树](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/7. 重建二叉树.html)</li>
<li>[8. 二叉树的下一个结点](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/8. 二叉树的下一个结点.html)   按照中序遍历的规则  分情况讨论</li>
<li>[26. 树的子结构](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/26. 树的子结构.html)   递归</li>
<li>[27. 二叉树的镜像](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/27. 二叉树的镜像.html)</li>
<li>[28. 对称的二叉树](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/28. 对称的二叉树.html)</li>
<li>[32.1 从上往下打印二叉树](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/32.1 从上往下打印二叉树.html)    层序遍历 （BFS）</li>
<li>[32.2 把二叉树打印成多行](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/32.2 把二叉树打印成多行.html)</li>
<li>[32.3 按之字形顺序打印二叉树](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/32.3 按之字形顺序打印二叉树.html)</li>
<li>[33. 二叉搜索树的后序遍历序列](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/33. 二叉搜索树的后序遍历序列.html)    按照比较大小的方法递归 判断左右子树是否合法</li>
<li>[34. 二叉树中和为某一值的路径](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/34. 二叉树中和为某一值的路径.html)</li>
<li>[36. 二叉搜索树与双向链表](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/36. 二叉搜索树与双向链表.html)   官方的方法是 中序遍历一定是按照大小顺序遍历到搜索树的每个节点的 因此设置一个 pre  cur指针来迭代的更改指向即可。还可以分支的思想 递归左子树 和右子树 分别得到左右两个循环链表 再加上中间节点重组成一个新的双向链表 但是这种方法逻辑比较复杂。</li>
<li>[37. 序列化二叉树](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/37. 序列化二叉树.html)   主要是  字符转分割操作  怎么用 stringstream</li>
<li>[54. 二叉查找树的第 K 个结点](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/54. 二叉查找树的第 K 个结点.html)</li>
<li>[55.1 二叉树的深度](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/55.1 二叉树的深度.html)</li>
<li>[55.2 平衡二叉树](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/55.2 平衡二叉树.html)   递归  要注意所有节点的左右子树高度差都得满足</li>
<li>[68. 树中两个节点的最低公共祖先](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/68. 树中两个节点的最低公共祖先.html)  这个题也是递归 但是套用递归的思路很巧妙。 </li>
</ul>
<h2 id="贪心思想"><a href="#贪心思想" class="headerlink" title="贪心思想"></a>贪心思想</h2><ul>
<li>[14. 剪绳子](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/14. 剪绳子.html)   贪心思想。</li>
<li>[63. 股票的最大利润](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/63. 股票的最大利润.html)  记录最低的买入价格，并尝试以当前价减去前面最低的买入价得到利润。遍历求最大利润即可。</li>
</ul>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ul>
<li><p>[11. 旋转数组的最小数字](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/11. 旋转数组的最小数字.html)</p>
</li>
<li><p>[53. 数字在排序数组中出现的次数](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/53. 数字在排序数组中出现的次数.html)</p>
</li>
</ul>
<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><ul>
<li>[16. 数值的整数次方](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/16. 数值的整数次方.html)    递归</li>
</ul>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><ul>
<li>[12. 矩阵中的路径](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/12. 矩阵中的路径.html)   DFS</li>
<li>[13. 机器人的运动范围](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/13. 机器人的运动范围.html)   DFS  BFS都可</li>
<li>[38. 字符串的排列](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/38. 字符串的排列.html)   DFS  将每个字母轮换放在首位 然后递归剩下的字符串   注意相同字母去重</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul>
<li>[21. 调整数组顺序使奇数位于偶数前面](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/21. 调整数组顺序使奇数位于偶数前面.html)  快慢指针 or  首尾对象指针</li>
<li>[45. 把数组排成最小的数](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/45. 把数组排成最小的数.html)   这道题关键是知道  字符串比较的 性质  例如 1991 &gt; 1199 是默认按照从高到底字符顺序比较的。那么在自己自定义  cmp  函数的时候 使用这个性质来快速 比较 两个字符串谁放前面。看谁放前面组合成新的字符串哪个小。或者自己写快排</li>
<li>[51. 数组中的逆序对](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/51. 数组中的逆序对.html)   归并排序  稍加改进即可  因为归并排序递归到最后就是比较两个数的大小，同时又由于  归并的时候左右两边的都是有序的  所以比较次数少。</li>
</ul>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul>
<li><p>[10.1 斐波那契数列](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/10.1 斐波那契数列.html)</p>
</li>
<li><p>[10.2 矩形覆盖](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/10.2 矩形覆盖.html)</p>
</li>
<li><p>[10.3 跳台阶](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/10.3 跳台阶.html)</p>
</li>
<li><p>[10.4 变态跳台阶](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/10.4 变态跳台阶.html)</p>
</li>
<li><p>[42. 连续子数组的最大和](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/42. 连续子数组的最大和.html)</p>
</li>
<li><p>[47. 礼物的最大价值](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/47. 礼物的最大价值.html)</p>
</li>
<li><p>[48. 最长不含重复字符的子字符串](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/48. 最长不含重复字符的子字符串.html)    动态规划 or  双指针   动态规划 ！！！ 注意连续 这就和 子数组最大和设置dp的出发点相同了</p>
</li>
<li><p>[49. 丑数](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/49. 丑数.html)  不能 试图 按着判断某个整数是不是丑数，会超时。因此要从递推的角度思考，第n个丑数  和  第 n-1个丑数的关系。第n个大的丑数一定是由  第n-1个丑数 x 2/3/5得来的 至于是乘的哪个  那肯定是选最小的喽。但是不是 dp[n] x 2/3/5  可能是  dp[i] x 2  dp[j] x3 … 以2/3/5，所以就要设置三个指针分别 记录。有点像  三个迈的步子分别为 1/3/5的三个人从同一个1的起点开始走。走的距离最短的人优先跳步…..</p>
</li>
<li><p>[60. n 个骰子的点数](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/60. n 个骰子的点数.html) 状态转移方程很好想   n个筛子 点数  由  n-1个筛子时的点数 + 1  +2 … + 6 (注意判断边界)</p>
</li>
<li><p>[62. 圆圈中最后剩下的数](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/62. 圆圈中最后剩下的数.html)   思考子问题  不要关注中间 怎么数  只关注 起始 和 结束</p>
</li>
</ul>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><ul>
<li>[39. 数组中出现次数超过一半的数字](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/39. 数组中出现次数超过一半的数字.html)     空间复杂度O(1)  时间复杂度O(N) 的方法  摩尔投票法</li>
<li>[66. 构建乘积数组](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/66. 构建乘积数组.html)  数学问题</li>
<li>[43. 从 1 到 n 整数中 1 出现的次数](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/43. 从 1 到 n 整数中 1 出现的次数.html)  题目别理解错了 是 所以的数字中  所有的1的个数，不是说统计含有1的数字的个数。因此思路就是分别统计个位/十位/…分别为1的个数，最后求和</li>
</ul>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ul>
<li>[15. 二进制中 1 的个数](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/15. 二进制中 1 的个数.html)  </li>
<li>[56. 数组中只出现一次的数字](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/56. 数组中只出现一次的数字.html)   异或的性质</li>
</ul>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul>
<li>[17. 打印从 1 到最大的 n 位数](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/17. 打印从 1 到最大的 n 位数.html)  要考虑 越界 因此本质是全排列问题</li>
<li>[19. 正则表达式匹配](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/19. 正则表达式匹配.html)     太难了  待定</li>
<li>[20. 表示数值的字符串](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/20. 表示数值的字符串.html)  状态机  通过状态表实现  就是情况很多</li>
<li>[44. 数字序列中的某一位数字](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/44. 数字序列中的某一位数字.html) 找规律</li>
<li>[46. 把数字翻译成字符串](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/46. 把数字翻译成字符串.html)  动态规划</li>
<li>[61. 扑克牌顺子](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/61. 扑克牌顺子.html) 找规律</li>
<li>[64. 求 1+2+3+…+n](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/64. 求 1+2+3+…+n.html)  用 &amp;&amp; 代替 条件判断  （(true) &amp;&amp; (a+=b)）这种条件判断里也能使用+=</li>
<li>[65. 不用加减乘除做加法](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/65. 不用加减乘除做加法.html)    二进制加法  不进位和 = 异或  进位 = 与左移  另外要注意c++负数左移低位默认补1 所以要强转为无符号。</li>
<li>[67. 把字符串转换成整数](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/67. 把字符串转换成整数.html)</li>
</ul>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>算法思想汇总</title>
    <url>/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/a.%20%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<p>汇总了编程中常用的编程思想的原理，例如DFS，动态规划，回朔等</p>
<span id="more"></span>

<h1 id="算法思想汇总"><a href="#算法思想汇总" class="headerlink" title="算法思想汇总"></a>算法思想汇总</h1><h2 id="广度-深度优先搜索-BFS-DFS"><a href="#广度-深度优先搜索-BFS-DFS" class="headerlink" title="广度/深度优先搜索 BFS/DFS"></a>广度/深度优先搜索 BFS/DFS</h2><p>​        广度优先搜索 是<a href="http://baike.baidu.com/view/3148644.htm">连通图</a>的一种<a href="http://baike.baidu.com/view/549585.htm">遍历</a>策略。因为它的思想是从一个顶点V0开始，辐射状地优先遍历其周围较广的区域 BFS同样属于盲目搜索。一般用队列数据结构来辅助实现BFS算法。</p>
<ol>
<li>首先将根节点放入队列中。</li>
<li>从队列中取出第一个节点，并检验它是否为目标。如果找到目标，则结束搜寻并回传结果。否则将它所有尚未检验过的直接子节点加入队列中。</li>
<li>若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。</li>
<li>重复步骤2。</li>
</ol>
<p><img src="https://i.loli.net/2021/03/28/mJ4GI6aciKLot9F.png" alt="1598357141189"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 广度优先搜索</span></span><br><span class="line"><span class="comment"> * @param Vs 起点</span></span><br><span class="line"><span class="comment"> * @param Vd 终点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(Node&amp; Vs, Node&amp; Vd)</span></span>&#123;</span><br><span class="line">	queue&lt;Node&gt; Q;</span><br><span class="line">	Node Vn, Vw;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//初始状态将起点放进队列Q</span></span><br><span class="line">	Q.<span class="built_in">push</span>(Vs);</span><br><span class="line">	<span class="built_in">hash</span>(Vw) = <span class="literal">true</span>;<span class="comment">//设置节点已经访问过了！</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())&#123;<span class="comment">//队列不为空，继续搜索！</span></span><br><span class="line">		<span class="comment">//取出队列的头Vn</span></span><br><span class="line">		Vn = Q.<span class="built_in">front</span>();</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//从队列中移除</span></span><br><span class="line">		Q.<span class="built_in">pop</span>();</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">while</span>(Vw = Vn通过某规则能够到达的节点)&#123;</span><br><span class="line">			<span class="keyword">if</span> (Vw == Vd)&#123;<span class="comment">//找到终点了！</span></span><br><span class="line">				<span class="comment">//把路径记录，这里没给出解法</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回</span></span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">isValid</span>(Vw) &amp;&amp; !visit[Vw])&#123;</span><br><span class="line">				<span class="comment">//Vw是一个合法的节点并且为白色节点</span></span><br><span class="line">				Q.<span class="built_in">push</span>(Vw);<span class="comment">//加入队列Q</span></span><br><span class="line">				<span class="built_in">hash</span>(Vw) = <span class="literal">true</span>;<span class="comment">//设置节点颜色</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//无解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>​    </p>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Backtracking（回溯）属于 DFS</p>
<ul>
<li>回溯算法就是按照深度优先的顺序，穷举所有可能性的算法，但是回溯算法比暴力穷举法更高明的地方就是回溯算法可以随时判断当前状态是否符合问题的条件。一旦不符合条件，那么就退回到上一个状态，省去了继续往下探索的时间</li>
<li>优化剪枝策略，就是判断当前的分支树是否符合问题的条件，如果当前分支树不符合条件，那么就不再遍历这个分支里的所有路径。</li>
<li>启发式搜索策略指的是，给回溯法搜索子节点的顺序设定一个优先级，从该子节点往下遍历更有可能找到问题的解。</li>
<li>普通 DFS 主要用在 <strong>可达性问题</strong> ，这种问题只需要执行到特点的位置然后返回即可。</li>
<li>而 Backtracking 主要用于求解 <strong>排列组合</strong> 问题，例如有 { ‘a’,’b’,’c’ } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。</li>
</ul>
<p>​        该页中 平洋大西洋水流问题  中解释中的，将他看作从四周到中间可达问题比较简单，但是自己第一次做的时候其实是用的回溯的思想做的，比较复杂。 因为 Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>​    回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。用回溯算法解决问题的一般步骤：</p>
<ol>
<li><p>在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；</p>
</li>
<li><p>但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。</p>
</li>
</ol>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>​        贪心算法，又名贪婪法，是寻找<strong>最优解问题</strong>的常用方法，这种方法模式一般将求解过程分成<strong>若干个步骤</strong>，但每个步骤都应用贪心原则，选取当前状态下<strong>最好/最优的选择</strong>（局部最有利的选择），并以此希望最后堆叠出的结果也是最好/最优的解。</p>
<ol>
<li>从某个初始解出发；</li>
<li>采用迭代的过程，当可以向目标前进一步时，就根据局部最优策略，得到一部分解，缩小问题规模；</li>
<li>将所有解综合起来。</li>
</ol>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>​        双指针 有 <strong>快慢指针</strong> 和  <strong>左右指针</strong> 。双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。</p>
<p><strong>快慢指针</strong> ： 般都初始化指向链表的头结点 head  ，前进时快指针 fast 在前，慢指针 slow 在后。</p>
<ul>
<li>判定链表中是否含有环。从head出发， 快指针每次移动慢指针两倍的距离，二者相遇则有环，快指针先结束无环。</li>
<li>返回环的长度。相遇后，固定一个指针不懂，移动另一个到再次相遇 记录走过的步长 即为环的长度</li>
<li>返回环的起点。在刚才相遇的B点，将一个指针回归到起点，另一个还是在B点，然后二者以相同的速度移动，二者再次相遇的 点即为换的起点。具体证明可画图 理解。</li>
<li>返回链表的中点。类似上面的思路，让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。</li>
<li>寻找链表的倒数第 k 个元素。让快指针先走 k 步，然后快慢指针开始同速前进。当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点。</li>
</ul>
<p><strong>左右指针</strong>： 左右指针在数组中实际是指两个索引值，一般初始化为 left = 0, right = nums.length - 1。当数组提到有序时就应该想到双指针。</p>
<ul>
<li>二分查找，反转数组，两数之和…</li>
<li>滑动窗口算法 。滑窗的关键在于判断什么时候座指针收缩窗口，何时更新数据，合理的收缩窗口的方法可以大大简化代码。</li>
</ul>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>​        二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法**时间复杂度为 O(logN)**。</p>
<p>​        <strong>m 计算</strong>： m = l + (h - l) / 2<br>​        <strong>未成功查找的返回值</strong>：循环退出时如果仍然没有查找到 key，那么表示查找失败。可以有两种返回值。-1：以一个错误码表示没有查找到 key；l：将 key 插入到 nums 中的正确位置。<br>​        <strong>变种</strong>：二分查找可以有很多变种，实现变种要注意边界值的判断。例如<strong>在一个有重复元素的数组中查找 key 的最左位置</strong>的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] &gt;= key) &#123;</span><br><span class="line">            h = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><p>​        分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p>
<p>​        适用的情况：</p>
<ol>
<li>该问题的规模缩小到一定的程度就可以容易地解决</li>
<li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</li>
<li>利用该问题分解出的子问题的解可以合并为该问题的解；</li>
<li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</li>
</ol>
<p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，<strong>如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法</strong>。第四条特征涉及到分治法的效率，如果各子问题<strong>是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好</strong>。</p>
<p>​    分治法在每一层递归上都有三个步骤：</p>
<ol>
<li>分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</li>
<li>解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</li>
<li>合并：将各个子问题的解合并为原问题的解</li>
</ol>
<p>常见的例如  二分搜索，汉诺塔问题，归并排序，快速排序等都是使用分治的思想。</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>算法思想</tag>
      </tags>
  </entry>
  <entry>
    <title>相关的编程题汇总-分治</title>
    <url>/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/leecode_%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<p>记录了分治算法类的题目，最常见的 快排，归并排序中都使用了分治的思想</p>
<span id="more"></span>

<h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>​        <strong>快速排序</strong>的核心思想是在待排序数组中选取一个 基准数据（原则上要尽量保证 基准数据正好是中位数，这里以常用的第一个元素作为基准数据，基准数据选的不好 算法的复杂度会达到O(n^2)，但是平均复杂度趋近O(N)）。首先以数组第一个元素为基准a，将大于a的元素都放在a的右边，小于的放在左边。再递归的在左右区间使用这种策略直至排序完成。具体的伪代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">randomPartition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">        <span class="built_in">swap</span>(a[i], a[r]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">partition</span>(a, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//双指针 划分 数组</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = a[r], i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt; r; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt;= x) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[++i], a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(a[i + <span class="number">1</span>], a[r]);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="求无序数组的第K大"><a href="#求无序数组的第K大" class="headerlink" title="求无序数组的第K大"></a>求无序数组的第K大</h4><p>​        这个题 可以暴力的将数组先 排序 完后取出。但是不是最好方法，可以使用快速排序 （分治）的方法，取基准数 按照与基准数的大小关系将数组划分左右，后判断 基准数左边有几个大于它的元素，再分别选择对左边 或者右边 数组进行再一次的 快排，直到 正好找到第K个。<br>​        求K大问题除了使用快排之外，还可以使用 堆的 方法。</p>
<h4 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a><a href="https://leetcode-cn.com/problems/sort-colors/">颜色分类</a></h4><p>​        这个题 数组中其实 只有 0，1， 2 三种元素。不能使用额外的空间。最直观的想法是，先使用 基准元素 1 将数组划分为 左边的 0/1 右边的2，再设置基准为0前半部分 将0，1分开。这就是最朴素的 快排的思想。但是，因为只有三种元素，可以考虑 使用三个指针，一个指针移动负责遍历所有元素，一个左指针寻找0的最右边边界，一个右指针寻找2的最左边边界。当前指向的元素等于0就和左指针交换元素，并且滑动一个位置，同理。这就和快排中 将数组中元素根据 与基准数据的大小关系分堆类似。</p>
<h4 id="为运算表达式设计优先级"><a href="#为运算表达式设计优先级" class="headerlink" title="为运算表达式设计优先级"></a><a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/">为运算表达式设计优先级</a></h4><p>​        这个题很典型的分治 算法。将 运算符 看作 分隔点，每次计算运算符左边的 字符串表达的等式的值 和 右边的字符串表达的算式的值，最后 使用该运算符计算二者的 和/差/积 即为最终的一种结果。但是注意 左边字符串算出的 值 可能有多个 使用 vector 保存  右边的也是。所以计算的时候需要两个for循环。</p>
<h4 id="不同的二叉搜索树-II"><a href="#不同的二叉搜索树-II" class="headerlink" title="不同的二叉搜索树 II"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">不同的二叉搜索树 II</a></h4><p>​        首先 这个题  二叉搜索树的特点是 中序遍历输出的为有序 数组。所以 要将1~n的 数组还原为二叉搜索树，就是 选定根节点，然后 按照中序遍历的特点 分别递归的构建左右子树，也是分治的思想。要注意递归的停止边界条件。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h4 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">数组中的逆序对</a></h4><p>根据逆序对的定义，会想到 这个比较过程 可以通过归并排序的过程等效转换，因为归并过程中存在前半部分 和 后半部分比较的过程，且前半部分和后半部分都是有序的，因此速度快。</p>
<h4 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a><a href="https://www.nowcoder.com/practice/edfe05a1d45c4ea89101d936cac32469?tpId=101&tqId=33089&tPage=1&rp=1&ru=/ta/programmer-code-interview-guide&tab=answerKey">小和问题</a></h4><h4 id="计算右侧小于当前元素的个数"><a href="#计算右侧小于当前元素的个数" class="headerlink" title="计算右侧小于当前元素的个数"></a><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">计算右侧小于当前元素的个数</a></h4><p>这个和逆序数问题很像，所以直接用归并排序的思路求解即可。</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>相关的编程题汇总-DFS/BFS</title>
    <url>/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/leecode_DFS_BFS/</url>
    <content><![CDATA[<p>记录了DFS/BFS相关的题目</p>
<span id="more"></span>

<h4 id="被围绕的区域"><a href="#被围绕的区域" class="headerlink" title="被围绕的区域"></a>被围绕的区域</h4><p><img src="https://i.loli.net/2021/03/28/4Fv9EmPOSTH1Bu7.png" alt="1598364256416"></p>
<p>​        这个题直接找被围绕的区域可能会超时，因为如果测试的矩阵很大，那么中间的元素很多。而直接从四周寻找和边界联通的点，那么可以减少计算量。可以使用广度优先搜索方法 从边界开始的 ‘O’开始 寻找与其联通的其他‘O’并将其一并标记为‘A’  </p>
<h4 id="单词接龙"><a href="#单词接龙" class="headerlink" title="单词接龙"></a><a href="https://leetcode-cn.com/problems/word-ladder/">单词接龙</a></h4><p>​        这个题思路不难，很容易想到要用广度优先遍历，寻找起点和终点的最短路径。但是，需要提前建图，再对图用广度优先遍历的方法去寻找起点到终点的最短路径。图以  邻接表的形式保存。但是这种方法有优化的空间。字符串传递 引用的形式传入，否则时间不够</p>
<h4 id="朋友圈"><a href="#朋友圈" class="headerlink" title=" 朋友圈"></a><a href="https://leetcode-cn.com/problems/friend-circles/"> 朋友圈</a></h4><p>​        这个题 和上面不一样，<strong>朋友圈的模型 给定的就是一个图的邻接矩阵</strong>，然后要求这个图中的连通图的个数。这个题一种方法是并查集做 一种是 深度/广度优先遍历，每次遍历与当前节点连接的节点并标记。</p>
<h4 id="太平洋大西洋水流问题"><a href="#太平洋大西洋水流问题" class="headerlink" title="太平洋大西洋水流问题"></a><a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">太平洋大西洋水流问题</a></h4><p>​        这个题 有两个关键点。<strong>一是 想到 从边缘向内部深度优先遍历，标记和边缘相连的点。二是 想到分步完成</strong>，记录两个表，分别表示和左上边缘（太平洋） 和 右下边缘（大西洋）相连的点。最后两个表都标记为1 的位置即为 既可以流向大西洋也可以流向太平洋的位置。<br>​        自己在做的时候 不仅没想到 应该从边缘 向内遍历的 方法，也没想到 先判断大西洋连接再判断太平洋连接的操作。直接把两种状态放在一起遍历，考虑得情况很多，很难理清，因为对于一个点向四个方向  分别由遍历得到的四种结果  连接大西洋/太平洋/都不连接/两个都连接。四种结果综合才能确定 当前点的状态，最后想到一个用两位数表示的方法 二进制 11 01 10 00 四个遍历方向 按位 或 == 11则表示该点同时连接 两个洋。虽然此法行得通，但是 每次遍历的状态 只有 11 的情况可以用来剪枝。这种想法其实 和 回溯比较类似。</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>DFS/BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>相关的编程题汇总-双指针</title>
    <url>/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/leecode_%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>记录了解题中双指针方法典型的题目，例如二分法中的首位指针，图的环判定中的快慢指针，滑窗方法等</p>
<span id="more"></span>

<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h4 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">旋转数组的最小数字</a></h4><p><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">在 D 天内送达包裹的能力</a></p>
<p>这个题有点意思。看题目很难朝二分查找上想。但<strong>凡是能用二分查找的就能用暴力</strong>。所以这个题如果先用暴力想到就可以简单的换成二分法。如果可以想到的是 船的运载量越大，越可能完成运载任务，题目要求可以完成运载任务的最小运载量。如果已经给定一个运载量，那么可以很容易地判断在这个运载量下能否完成运输。贪心地思想，每趟尽可能的多运，如果最后一天还运不玩 那说明这个运载量少了，需要增加运载量。于是暴力搜索运载量的方法就产生了。那么如何转换成二分呢。<strong>起始运载量越大越可能完成这个隐藏条件就是二分查找有序的条件</strong>。最后就是确定二分查找的边界。很明显当运载量为总重时是 右边界，运载量还得大于单个货物的重量。</p>
<p><a href="https://mp.weixin.qq.com/s/o-1VJO2TQZjC5ROmV7CReA">切木头</a></p>
<p>这个题目和上面的题极为类似。</p>
<p><a href="https://leetcode-cn.com/problems/minimum-limit-of-balls-in-a-bag/">袋子里最少数目的球</a></p>
<p>和上面那个题一样的思路。</p>
<h4 id="元素和小于等于阈值的正方形的最大边长"><a href="#元素和小于等于阈值的正方形的最大边长" class="headerlink" title="元素和小于等于阈值的正方形的最大边长"></a><a href="https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/">元素和小于等于阈值的正方形的最大边长</a></h4><p>和上面的思路也是一样 只不过要用到前缀和  加速计算任意矩形面积元素和</p>
<p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a>    </p>
<p>！！！！！！！！！！！！！！！！1</p>
<h4 id="找到字符中所有字母异位词"><a href="#找到字符中所有字母异位词" class="headerlink" title="找到字符中所有字母异位词"></a>找到字符中所有字母异位词</h4><p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328203029.png" alt="1598512368162"></p>
<p>​        这道题典型的使用双指针的方法来实现滑动窗口。初始两个指针都在起点，然后右指针滑动向右，和左指针构成一个滑窗。关键在于左指针的收缩方法。一开始想的是左右指针始终保持一个 宽度为p.length()的</p>
<h4 id="有序数组中的单一元素"><a href="#有序数组中的单一元素" class="headerlink" title="有序数组中的单一元素"></a><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">有序数组中的单一元素</a></h4><pre><code>     这个题要求时间复杂度为 O(logn) 则必须使用二分查找。这个题很有意思，给定数组中按照升序排列，找出单一的元素。这个题使用二分的关键在于 两个相同的元素相邻，根据 二分之后索引的奇数偶数来确定向前还是向后搜索。
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328203040.png" alt="image-20200930204059711"></p>
<h4 id="寻找旋转排序数组中的最小值"><a href="#寻找旋转排序数组中的最小值" class="headerlink" title="寻找旋转排序数组中的最小值"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">寻找旋转排序数组中的最小值</a></h4><p>​        二分法。这个题关键是找对比较对象，否则 特殊情况 不好处理。关键是 计算中值后都与右边的数比较   如果  mid &gt; right  说明需要调整左区间++  如果 mid &lt;  right 说明 mid 在右边，但是此时可能mid就是 最小值，所以 r = c; 而不减一。  </p>
<h4 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></h4><h4 id="寻找峰值"><a href="#寻找峰值" class="headerlink" title="寻找峰值"></a><a href="https://leetcode-cn.com/problems/find-peak-element/">寻找峰值</a></h4><p>第一个难点在于如何将该问题转化为 二分查找的方法去做，另一个难点在 怎么用代码实现二分查找，写的不对的话 边界情况很麻烦，但是框架写对了，就不需要处理边界情况</p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">最长重复子数组</a></p>
<p><img src="https://pic.leetcode-cn.com/9ed48b9b51214a8bafffcad17356d438b4c969b4999623247278d23f1e43977f-%E9%94%99%E5%BC%80%E6%AF%94%E8%BE%83.gif" alt="错开比较.gif"></p>
<h4 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">最小覆盖子串</a></h4><p>这是个 很典型的 用滑动窗口的方法。右指针增加用于 扩大 窗口，当窗口中覆盖了需要的所有字符后，左指针不断收缩窗口。</p>
<h2 id="首尾指针"><a href="#首尾指针" class="headerlink" title="首尾指针"></a>首尾指针</h2><h4 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/">盛最多水的容器</a></h4><p>这是典型的双指针的题目。和二分法类似，但是二分查找有明显的排序条件在其中，总之都是根据一定的条件收缩指针。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="递增的三元子序列"><a href="#递增的三元子序列" class="headerlink" title="递增的三元子序列"></a><a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/">递增的三元子序列</a></h4>]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>双指针</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>相关的编程题汇总-回朔</title>
    <url>/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/leecode_%E5%9B%9E%E6%9C%94/</url>
    <content><![CDATA[<p>记录了回朔类的题目，常见的 八皇后问题，排列组合等</p>
<span id="more"></span>

<h4 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/">复原IP地址</a></h4><h4 id="全排列-II"><a href="#全排列-II" class="headerlink" title="全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/">全排列 II</a></h4><p>​        使用 swap 的方法全排列 去重的关键在于两点 一是和首元素相同的 不再swap  而是swap过的元素不再swap</p>
<h4 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/">组合总和</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; re;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, vector&lt;<span class="keyword">int</span>&gt;&amp; se, <span class="keyword">int</span> tg, <span class="keyword">int</span> sel)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tg == <span class="number">0</span>)&#123;</span><br><span class="line">            re.<span class="built_in">push_back</span>(se);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = sel; i &lt; candidates.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tg &lt; candidates[i])  <span class="keyword">continue</span>;</span><br><span class="line">            se.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, se, tg - candidates[i], i);   <span class="comment">////  i  关键  第一次 取 i 了之后  后面取的第二个 第三个...数 都只能从 第i 以及 i 之后开始取  比如 第一次取得第 2个数  那么第二次 就只能在 第二个 以及 第二个之后的数中取，因为 第二次再取第一个数的话 ，就 和 第一次取的第一个的情况重复</span></span><br><span class="line">            se.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, tmp, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="组合总和-II"><a href="#组合总和-II" class="headerlink" title="组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/">组合总和 II</a></h4><p>​        相对上一个题 去重的关键是 要 先 排序 相同的元素在一起 ，才方便去重。</p>
<h4 id="子集"><a href="#子集" class="headerlink" title="子集"></a><a href="https://leetcode-cn.com/problems/subsets/">子集</a></h4><p>思路：对于每个位置的元素 由选和不选两种情况，选的话，就 push_back到缓存数组中，然后从下一个元素递归。如果不选当前元素，就要pop出来，再对从下一个元素递归。同理下一个元素也有选和不选两种状态。最终结束的标志就是 遍历完整个数组长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; re;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> sel, vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">int</span>&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sel &gt;= nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            re.<span class="built_in">push_back</span>(ans);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">               </span><br><span class="line">        ans.<span class="built_in">push_back</span>(nums[sel]);</span><br><span class="line">        <span class="built_in">dfs</span>(sel+<span class="number">1</span>, nums, ans);</span><br><span class="line">        ans.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(sel+<span class="number">1</span>, nums, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, nums, ans);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/">括号生成</a></h4><p>和上面的题很类似，就没通过回朔的方法，枚举当前位置是 左括号  or   右括号，分别进行递归。但是要满足有效的条件，就额外增加条件约束，即 只有左括号数量大于右括号的数量的时候才能再添加右括号，当左括号数量大于整体数量一半的时候 不能再添加左括号。</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法思想</category>
        <category>算法思想</category>
        <category>�㷨˼��</category>
        <category>�㷨˼��</category>
        <category>�㷨˼��</category>
        <category>�㷨˼��</category>
        <category>�㷨˼��</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>回朔</tag>
      </tags>
  </entry>
  <entry>
    <title>相关的编程题汇总-数学思想</title>
    <url>/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/leecode_%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<p>记录了解题中需要用数学思想的题目，这类题目规律最多样。</p>
<span id="more"></span>

<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h4 id="用-Rand7-实现-Rand10"><a href="#用-Rand7-实现-Rand10" class="headerlink" title="用 Rand7() 实现 Rand10()"></a><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/">用 Rand7() 实现 Rand10()</a></h4><p>这个题有意思。第一次做很容易想到 rand 用两次然后相加得到1-14范围…这种操作就不是均匀分布了，类似扔筛子。这道题的解法是，将 执行两次 rand7 得到x y 坐标。然后映射。类似 如果 x 坐标和 y坐标是均匀分布，那么x,y构成的格点都是均匀分布的，这样就能得到7*7=49个格点，我们只要ran10 因此可以只用前40个 （对10取余即可）如果不是前40个点，则再投一次坐标（<strong>拒绝采样</strong>）。当然可以优化，剩下多的8个点其实可以看做 rand8  然后 和 rand7 再组成一个坐标网格….以此重复，使得丢弃的数少，运行效率就高。</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328203006.png" alt="image-20210315221237407"></p>
<p>[39. 数组中出现次数超过一半的数字](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/39. 数组中出现次数超过一半的数字.html) </p>
<p>[66. 构建乘积数组](<a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87">http://www.cyc2018.xyz/算法/剑指</a> Offer 题解/66. 构建乘积数组.html)</p>
<h4 id="打乱数组"><a href="#打乱数组" class="headerlink" title="打乱数组"></a><a href="https://leetcode-cn.com/problems/shuffle-an-array/">打乱数组</a></h4><p>这个题 主要的思路是 如何用 一定的操作规则 模拟 打乱的情景。数组的排列有n!种 那么如何保证等概率的输出一种排序呢？就相当于把数组所有元素放进盒子里，然后无放回抽取出，按抽出的先后顺序即为….</p>
<h4 id="阶乘后的零"><a href="#阶乘后的零" class="headerlink" title="阶乘后的零"></a><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/">阶乘后的零</a></h4><p>这个题 要找规律。首先 阶乘后的0的个数，阶乘后的0能怎么来呢？ 例如 1x2x3x4x5x6… 这时候组合一下  1x3x4x6x(2x5) 很明显 10=2x5 所以 就是找结成中有多少个 2x5 的组合 即可。而 2 是每两次至少出现一次 5 大一些 显然出现的次数少  所以就是找有多少个5  像 但是  25 可以算 5x5  75=15x5=3x5x5 可以算有两个5  所以简单的 5 等间隔取肯定是不够的 </p>
<p>1 2 3 4 5x1 6 7 8 9 5x2 11 12 13 14 5x3 ….  n     n/5 之后相当于 获得了  (5x1  5x2  5x3…. 5x5 5x6… 5xn/5) / 5  =<br>1 2 3 4 … n/5  所以说 n/5之后 又变成了 求 n/5前面有多少个5的问题了。</p>
<h4 id="字符串相乘"><a href="#字符串相乘" class="headerlink" title="字符串相乘"></a><a href="https://leetcode-cn.com/problems/multiply-strings/">字符串相乘</a></h4><p>使用 字符串 模拟 竖式乘法 呗；类似的还有 字符串加法的题目…. </p>
<h4 id="灯泡开关-https-leetcode-cn-com-problems-bulb-switcher"><a href="#灯泡开关-https-leetcode-cn-com-problems-bulb-switcher" class="headerlink" title="灯泡开关](https://leetcode-cn.com/problems/bulb-switcher/)"></a>灯泡开关](<a href="https://leetcode-cn.com/problems/bulb-switcher/">https://leetcode-cn.com/problems/bulb-switcher/</a>)</h4><p>这个题 以看 测试的 n 10^9 的级别，就肯定是数学找规律的问题。通过归纳总结也能找到规律吧。但是理性分析的话 也是很容易得出结论的。对于第  n  个灯泡的状态，能改变它的只有它的只有 它的 因数轮，例如 36 能被 1 2 3 4 6 | 6 9 12  18 36 注意除了中间的 6 只有一个，其他的都是成对出现了，这就说明 如果 n 恰好能被完全开平方，那么状态切换一定是奇数次，然后第 n 个状态就是亮的，否则如果不能被完全开平方，例如 24 = 1  2  3  8  12  24  因数一定是偶数个，最后第24个状态就是灭的状态，同时24轮及其以后都碰不到它了。所以…. </p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>相关的编程题汇总-贪心算法</title>
    <url>/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/leecode_%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<p>记录了解题中需要用贪心思路的题目。</p>
<span id="more"></span>



<h4 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">根据身高重建队列</a></h4><p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328203047.png" alt="1598428994335"></p>
<p>​        这道题的关键是  先对队列按照高到低的顺序排序，当高度相同时，多的在后面。这样从前往后挨个调整得时候，前面元素得移动只可能是往前诺，不会对后面得产生影响。后面得元素插入前面 也不会对已经插入过的影响，因为后面得身高低。</p>
<h4 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a><a href="https://leetcode-cn.com/problems/gas-station/">加油站</a></h4><p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328203050.png" alt="1598435271191"></p>
<p>​        这道题使用 两个for循环遍历 也不会超时 时间复杂度是 O(N^2)  但是这样并不好。首先选一个 起点0运行  通过累加 油量 和 损耗量，到第 N 站如果 油量  &gt; 损耗 说明无法到达，<strong>将起点修改为第N+1站作为新的开始</strong> 这里不是从0到1挨个 作为起点测试。因为，如果在第N站  油不够了 而前N站都够，那么油量&gt;=消耗量，那么在这之中选择一个起点 油量=消耗=0 必然到第N站还是不够，所以起点直接选 N+1开始新的测试。</p>
<h4 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">无重叠区间</a></h4><p>​        <img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328203056.png" alt="image-20200926211802074"></p>
<p>​        这个题和  <a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">用最少数量的箭引爆气球</a> 题目类似。<br>​        首先 对区间的end位置 升序排列，如图所示，从上往下 依次寻找找没有交集且最邻近的 区间，直至结束。那么总数就是可以剩下的最大区间数。为何 这么做就是对的呢？考虑以下 例如从上往下 扫面的过程中， 第0个只和  第1，2 相交，那么 1，2相互也必定重叠。这三个必删掉 两个，删掉哪两个呢？若保留1或者2，那么不能保证 1或者2下面没有区间和它相交，但是保留1，则可以保证就没有其他的再可能与1相交。所以 应该删掉1，2.这也是一种贪心的思想。从上往下扫描，删掉与其相交的 区间。<br>​        但是按照上面思路去写代码 正确性有保证，但是并没有完全利用到里面的规律 会有冗余的 循环。<br>​        再接着 想，从上往下扫面，如果 遇到一个与其相交的 就跳过（代表删除了）再接着往下扫描直到遇到以一个与当前区间不相交的区间，此时将该区间的尾部坐标更新，再接着往下扫面。每次遇到不相交的区间计数加一 统计 总共不相交的区间数量即可。这样取第0个区间的时候 并没有依次遍历完下面所有与第0个区间相交的区间，但是任然可行。因为如果 x(0)(1) &lt; x(3)(0) 即第0，3区间不相交 而 若 x(0)(1) &gt; x(n)(0)  即 第 0 n区间也相交。那么x(3)(1) &gt; x(3)(0) &gt; x(n)(0) 即第3，n区间也必然相交。这样 即便在第0个区间的时候没扫描并删除第n个区间，但是在 切换到第三个区间并往下扫描的时候 也可以将n 删除。</p>
<h4 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a><a href="https://leetcode-cn.com/problems/partition-labels/">划分字母区间</a></h4><p>​        这个题的 关键就是 寻找 字母结束的最大位置，当 遍历到 第 i 个 字母时  i == end 则可以作为一个分割点</p>
<h4 id="最大交换"><a href="#最大交换" class="headerlink" title="最大交换"></a><a href="https://leetcode-cn.com/problems/maximum-swap/">最大交换</a></h4><p>在做题的时候 要首先理解清楚题目的意思，然后尽可能用简单的模型来描述  完成题目要求，而不是在边界情况都还像清楚的时候，就下手用可能的方法解题。例如本题  已读题目就 感觉应该可以用单调栈写。其实本质就是求  高位  左边最大<strong>且 靠后</strong> 的数交换。用单调栈很难一下想到 且靠后 这种边界情况。</p>
<p>对于查找某个位置 一侧比他大的最大的最远/最近的数，像数字和字符</p>
<h4 id="有效的括号字符串"><a href="#有效的括号字符串" class="headerlink" title="有效的括号字符串"></a><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/">有效的括号字符串</a></h4><p>这个题也可以使用两个栈做。但是贪心的方法更简单。对于不含有 星号 的问题，只需要累计左右括号的相对数量，如果始终是左括号数大于等于右括号数，并且最终左括号数等于右括号数，那么代表有效。如果有星号，当星号作为左括号时，左括号数可以为 x+1, 当它为右括号时，左括号数可以为  x - 1，所以当前位置的左括号数量累计为一个区间  [l_down, l_up] ，每次遇到 星号，l_down–，r_up++，当 l_down == 0 时，代表前面的左括号数最少为0个，此时再遇到星号，星号就不能再作为右括号了，因此 l_down 限制为0；当 左括号的最大上限 &lt; 0 时，代表即便前面所有的星号都用做左括号，也无法保证左括号数大于等于右括号数。</p>
<p>最终如果最少的左括号数大于0，表明星号即便全作为右括号，也不够抵消所有的左括号，返回 false</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>典型算法-KMP算法</title>
    <url>/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>详细记录了 KMP 算法的原理，KPM算法是一种字符串匹配算法，可以在 O(n+m) 的时间复杂度内实现两个字符串的匹配。</p>
<span id="more"></span>

<h1 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h1><p>KMP算法是一种<strong>字符串匹配</strong>算法，可以在 O(n+m) 的时间复杂度内实现两个字符串的匹配。如下图所示，字符串匹配就是从主串中搜索是否存在模式串。字符串匹配是一个非常频繁的任务。例如，今有一份名单，你急切地想知道自己在不在名单上；又如，假设你拿到了一份文献，你希望快速地找到某个关键字（keyword）所在的章节……凡此种种，不胜枚举。</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328211045.png" alt="image-20210328211045841"></p>
<h2 id="暴力-Brute-Force"><a href="#暴力-Brute-Force" class="headerlink" title="暴力 Brute-Force"></a>暴力 Brute-Force</h2><p>首先想到的就是 暴力搜索，从最开始对齐比较 如果不相同，将模式串往后移动一位再去和主串对应位置的子串比较….直到找到。但是显然这样比较的复杂度为O(n*(m-n+1))  n 为主串的长度，m为子串的长度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328212909.png" alt="image-20210328212909725"></p>
<p>暴力的方法很慢，那么有没有优化的方法了。暴力方法中每次 没匹配上 都是往后移动一格，然后接着比较，这样比较的趟数很多，完全没有用到上一次比较失败的教训。<strong>尽可能利用残余的信息，是KMP算法的思想所在</strong>。上面的例子中在匹配 algor 全对上了，但是最后一个a没有匹配上，按照暴力的逻辑 可能就往后滑动一个 再接着配。但是我们可以明显看出  algor 这几个字母如果错位，就不可能再配上，所以完全可以从 i 去比较，可以直接跳过主串中algor这几个字母。再例如下面的例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328213445.png" alt="image-20210328213445574"></p>
<p>还是在 最后一个 d 处对不上，但是已经比较了 abcab 这一段，这一段模式串和主串是对的上的，根据这个已知信息 按照直觉逻辑，这次可以跳到ab试试，因为可以保证 模式串中已经比较过的 ab 和 主串中的部分对的上，而且 比较过的这一段中 存在首ab 和 尾ab相同。一句话总结  <strong>我们在已经比较并确定对齐的模式串的主串abcab后，我们移动的准则是 从abcab中 找到 模式串的首ab 和主串的尾ab对齐的位置，再往后就是主串之前没比过的位置就接着比</strong> 。这是KMP算法的核心了。</p>
<h2 id="KMP原理"><a href="#KMP原理" class="headerlink" title="KMP原理"></a>KMP原理</h2><p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328215038.png" alt="image-20210328215038322"></p>
<p>如上图所示，绿色部分是成功匹配，失配于红色部分。深绿色手绘线条标出了相等的前缀和后缀，<strong>其长度为next[右端]</strong>. 由于手绘线条部分的字符是一样的，所以直接把前面那条移到后面那条的位置。因此说，<strong>next数组为我们如何移动标尺提供了依据</strong>。</p>
<h2 id="PMT表"><a href="#PMT表" class="headerlink" title="PMT表"></a>PMT表</h2><p>上述 ab … ab 这样首位相同的结构，叫做前缀和后缀。（也叫 next 数组 即 PMT表）</p>
<p> 如果字符串A和B，存在A=BS，其中S是任意的非空字符串，那就称B为A的前缀。例如，”Harry”的前缀包括{”H”, ”Ha”, ”Har”, ”Harr”}，我们把所有前缀组成的集合，称为字符串的前缀集合。同样可以定义后缀A=SB， 其中S是任意的非空字符串，那就称B为A的后缀，例如，”Potter”的后缀包括{”otter”, ”tter”, ”ter”, ”er”, ”r”}，然后把所有后缀组成的集合，称为字符串的后缀集合。要注意的是，字符串本身并不是自己的后缀。</p>
<p>如果一个字符串长度为N 那么PMT表的长度就为N 定义为：<strong>PMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度</strong>。例如 对于字符串”ababa”，它的前缀集合为{”a”, ”ab”, ”aba”, ”abab”}，它的后缀集合为{”baba”, ”aba”, ”ba”, ”a”}， 两个集合的交集为{”a”, ”aba”}，其中最长的元素为”aba”，长度为3。</p>
<h2 id="构建next数组"><a href="#构建next数组" class="headerlink" title="构建next数组"></a>构建next数组</h2><p>next数组是 针对模式串的。next数组的定义：</p>
<ul>
<li>定义 “k-前缀” 为一个字符串的前 k 个字符； “k-后缀” 为一个字符串的后 k 个字符。k 必须小于字符串长度。</li>
<li>next[x] 定义为： P[0]~P[x] 这一段字符串，使得<strong>k-前缀恰等于k-后缀</strong>的最大的k.</li>
</ul>
<p>用动态规划的思路思考，如果已知 next[0] next[1]  next[2] … next[x]  要求 next[x+1]呢？首先，已经知道了 next[x-1]（以下记为now）。</p>
<ol>
<li>如果 P[x] 与 P[now] 一样 (图中的是不相等的情况) 最长相等前后缀的长度就可以扩展一位，很明显 next[x] = now + 1。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210328220456.png" alt="image-20210328220458845"></p>
<ol start="2">
<li>P[x] 与 P[now] 不一样 。如上图  不能直接+1，因此，我们应该<strong>缩短这个now</strong>。 但是还是可以知道字串A == 字串B（这是由next[x]确定已知的），后面要新增一个 c 所以这个 c 肯定要用上，那么我们希望从 字串 B 的尾巴（后缀集合）中找一段  假设为 C ， 和字串A 的前缀中找一段 假设为 E 满足   C + ‘c’ == E，把 E 拆开为 E1 + 字符n ，又字串A == 字串B，这不就等于在子串 A 中 找相等的最大前缀C和后缀E （回到了next的定义 即为next[now - 1] ），然后再判断‘c’ 是否等于字符n。综上：<ul>
<li>now = next[ now - 1]</li>
<li>再判断 p[x] == p[now] 是否成立，成立就是 next[now - 1] + 1 否则循环</li>
</ul>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><img src="https://pic1.zhimg.com/v2-010a582b0c92a92044c43a2a2ea88928_r.jpg?source=1940ef5c" alt="preview"></p>
<p><img src="https://pic2.zhimg.com/80/v2-a6bd81af7cf9bbda32b2cfb0e4858276_1440w.jpg?source=1940ef5c" alt="img"></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>经典算法</category>
      </categories>
      <tags>
        <tag>典型算法</tag>
        <tag>KMP算法</tag>
      </tags>
  </entry>
  <entry>
    <title>典型算法-排序算法</title>
    <url>/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>整理、对比了常用的排序算法，插入排序，快速排序….</p>
<span id="more"></span>

<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="各种排序算法概述"><a href="#各种排序算法概述" class="headerlink" title="各种排序算法概述"></a>各种排序算法概述</h2><p><img src="https://i.loli.net/2021/03/28/2TKAQ1MtRfIrZSh.png" alt="image-20201116223456289"></p>
<p><a href="https://www.cnblogs.com/onepixel/articles/7674659.html">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p>
<ul>
<li>插入排序：平均时间复杂度O(n^2)  两层循环，外循环从第二个数开始，起始认为第一个元素是有序的，每个外循环就是将当前指向的元素插入到前面已排好序的序列中。因此还需要一个内循环来完成当前外循环指向的待插入元素与前面已排好序的每个元素逐一比较寻找插入点。每次寻找插入点的过程是这样实现空间O(1)的： 待插入元素和它卡面相邻的比较，比他还大就不用比了，他就在这儿不动，如果比他小，和他交换位置，再接着往前比，直到遇到比它小的元素为止。因此整个插入过程是不断和相邻位置交换的。</li>
<li>选择排序：就是每次循环遍历序列，记录当前序列中最小的元素，将其放到序列首；再从剩余序列中寻找最小的放第二个…. 因此两个循环 。在数组实现中，空间O(n) ，不稳定  例如  5  3  5  2  第一趟选择出最小的2  和 首元素 5 交换，破坏了两个5原本的顺序，所以是不稳定排序。如果用链表就是稳定排序。</li>
<li>冒泡排序：从第一个元开始比较和他右边响铃的元素的大小，前大后小就交换，否则不动，接着第二个和第三个比，交换….直到最后一个。这样第一趟中，一定会把序列中最大的元素交换到最后。第二次冒泡就只用比较到倒数第二个元素就结束。即序列后面是拍好序的。循环执行，直到所有有序。由于每次都是相邻比较交换，所以是稳定排序。两层循环 O(n^2)</li>
<li>希尔排序：第一个时间复杂度突破O(n^2)的算法。思想是，先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序。每趟排序，根据对应的增量ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序（按照增量大小，间隔增量的元素划分为一个组）。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。这么设计算法的原因是，考虑到原始的插入排序中，当最小的元素在最后时，往前插入，要从尾比到头，循环一轮，很浪费时间。这样分组，起始组间间隔较大，可以大步长的将较小的元素调换到靠前的位置。因此 不是相邻交换元素了，是不稳定排序，时间复杂度 O(n^1.3)</li>
<li>堆排序：利用了小顶堆这个数据结构。堆是完全二叉树，因此用数组存储，首先将数组所有元素堆化（构造大顶堆），这样数组第一个元素是序列中最大的。然后将数组首元素和最后一个元素交换（即将最大的元素放到了数组最后面），因为交换了顺序，此时不满足堆的性质了，因此接着将前n-1个元素堆化，再将首元素和倒数第二个交换….循环直到堆里只剩一个元素。时间复杂度O(nlogn)，涉及到首位交换元素，不稳定排序，空间复杂度O(1)</li>
<li>快速排序：快速排序的思想是，每次从序列中选择一个基准数据，然后将比他小的数放他左边，大的放右边。这样再递归的对它左边子序列和右边子序列执行上述过程的快排。分组的过程是这样的，使用双指针，默认每次选取序列第一个元素为基准元素，初始数据遍历指针和数据存储指针都指向基准后的元素，遍历其后每个元素，如果小于基准数据，就和数据存储指针指向的数据交换，在将数据存储指针自增，每时刻，数据滑动指针总在存储指针之后的。由于这个分组过程也不是相邻元素互换了，所以是不稳定排序。空间复杂度是因为递归需要额外数据保留空间 O(nlogn)</li>
<li>归并排序：和快排一样也是用了分治的思想。递归函数作用是将数组指定区间变为有序。因此函数中，先对左半部分递归归并，使得左半部分序列有序，再对右半部分递归，使得右半部分有序，最后归并，将两部分有序的序列合并，使用双指针的方法，合并时需要一个辅助数组，因此空间复杂度O(N)，涉及到二分法所以时间复杂度O(NlogN) 同时 归并递归到最底层就是相邻两个元素的比较，所以是稳定排序。</li>
<li>计数排序：计数排序只能对正整数排序。首先要确定数组中最大最小元素，来确定分配多大的内存。然后遍历一次数组，每个数据放到其对应下标的备用数组中。遍历完后，再遍历备用数组的每个位置，将对应位置的元素一次输出，即可。所有都是O(n+k)</li>
<li>桶排序：首先根据一定的函数映射关系，例如均匀映射，将数组中 的元素分配到N个桶中，再对桶中元素执行插入排序，最后将桶所有元素拼接。这个和计数排序类似，只不过计数排序的分桶映射方式是 数据 和 数组下标直接对应，因此计数排序只能应用于数据分布范围小的整数，而桶排序不限于此。</li>
<li>基数排序：基数排序的思想是，对整数的每个位 逐位排序。先找出最大元素的位数，循环，先根据个位数的值对所有元素排序，拍完之后对于只有一位的元素，就完成排序；接着根据元素十位的值对剩下元素进行计数排序，对于只有两位数的元素也排序完成…..O(N*k) K为位数。每一位的排序是一个计数排序 为 N。</li>
</ul>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>​        <strong>快速排序</strong>的核心思想是在待排序数组中选取一个 基准数据（原则上要尽量保证 基准数据正好是中位数，这里以常用的第一个元素作为基准数据，基准数据选的不好 算法的复杂度会达到O(n^2)，但是平均复杂度趋近O(N)）。首先以数组第一个元素为基准a，将大于a的元素都放在a的右边，小于的放在左边。再递归的在左右区间使用这种策略直至排序完成。具体的伪代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lf, <span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lf &gt;= rt || rt &lt; <span class="number">0</span>)    <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> base = nums[lf];</span><br><span class="line">        <span class="keyword">int</span> pl = lf+<span class="number">1</span>, pr = lf+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pr &lt;= rt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[pr] &lt; base)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[pr], nums[pl++]);</span><br><span class="line">            &#125;</span><br><span class="line">            pr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[lf], nums[pl<span class="number">-1</span>]);  <span class="comment">// 这一步很关键 要将比较的基准数字最后切换到中间，然后再递归它的左边和右边部分</span></span><br><span class="line">        <span class="built_in">partition</span>(nums, lf, pl<span class="number">-2</span>);</span><br><span class="line">        <span class="built_in">partition</span>(nums, pl, rt);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">partition</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序的要点</p>
<ul>
<li>连续数组存储，对于每个节点 i  它的 左 / 右 节点的下标 2 x i + 1 / 2 x i + 2 </li>
<li>建立堆的时候，每次从最底下非叶子节点开始 向上判断 节点是否大于子节点的值，若不是 和较大的节点交换值，然后再递归的调整叶子节点。因此可以看作是两个循环</li>
<li>构建好大堆之后，每次将堆顶的元素和最后一个元素交换，然后将堆顶元素下沉淀，然后将数组长度减一接着交换…    </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/// 从 节点 i 开始调整，调整完毕后 （调整的数组长度为 i） 可以保证 i 节点及其以下的部分是 满足要求的堆</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjMaxHeap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> len, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>((i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span> &lt; len)&#123;</span><br><span class="line">            <span class="keyword">int</span> lf = (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rt = lf + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> max_idx = i;  <span class="comment">// 当前节点，左右子节点，取值较大的点的序号</span></span><br><span class="line">            <span class="keyword">if</span>(lf &lt; len &amp;&amp; nums[lf] &gt; nums[max_idx])  max_idx = lf;</span><br><span class="line">            <span class="keyword">if</span>(rt &lt; len &amp;&amp; nums[rt] &gt; nums[max_idx])  max_idx = rt;</span><br><span class="line">		  </span><br><span class="line">            <span class="built_in">swap</span>(nums[max_idx], nums[i]);</span><br><span class="line">			</span><br><span class="line">            <span class="keyword">if</span>(max_idx == i)  <span class="comment">//如果未在该节点处未发生调整，可以直接推出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span>             <span class="comment">//如果未在该节点处发生调整，还要往下递归的调整</span></span><br><span class="line">                i = max_idx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 构建堆，第一次构建大堆时，要从最底层的节点开始向上 不断调用 adjMaxHeap 调整 </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="built_in">adjMaxHeap</span>(nums, len, i);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; nums[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 对于已经构建好的大堆，每次将堆顶的最大元素 调换到素组后端，然后将堆顶元素重新下沉，因为只修改了堆顶元素，所以直接从堆顶开始不断向下调整即可。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortMaxHeap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="built_in">buildMaxHeap</span>(nums);</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = len<span class="number">-1</span>; l &gt; <span class="number">0</span>; l--)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[l], nums[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">adjMaxHeap</span>(nums, l, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">sortMaxHeap</span>(nums);</span><br><span class="line">       <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序的原理是，设置 m 个桶，桶是有序的，首先将 n 个待排序数分别放到对应的桶里，然后再分别对桶里的元素进行排序。假设桶内的元素使用 快排，复杂度是 O(nlogn)，那么桶排序的复杂度为 O(N + M X (N / M) X log(N/M)) = O(N + Nlog(N / M))，当桶的数量接近于数组的长度时，复杂度接近O(N)，因此对于数据分布均匀的数组，采用桶排序效果较好。桶排序的缺点是空间复杂度高，且实际数据并不是接近均匀的情况，因此效果一般。</p>
<h3 id="典型的例题"><a href="#典型的例题" class="headerlink" title="典型的例题"></a>典型的例题</h3><h4 id="最大间距"><a href="#最大间距" class="headerlink" title="最大间距"></a><a href="https://leetcode-cn.com/problems/maximum-gap/">最大间距</a></h4><p>自己一开始做的时候，想到了用桶排序，但是把题目要求的空间复杂度看成常数的空间复杂度，感觉桶排序不满足。那如果是要求线性空间复杂度为啥不找出最大最小值，然后用Hash标记一下某个元素是否存在，然后枚举呢。当时也是没一下子想到桶排序的抽屉原理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> minVal = *<span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> maxVal = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> d = <span class="built_in">max</span>(<span class="number">1</span>, (maxVal - minVal) / (n - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> bucketSize = (maxVal - minVal) / d + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">bucket</span>(bucketSize, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;);  <span class="comment">// 存储 (桶内最小值，桶内最大值) 对，(-1, -1) 表示该桶是空的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = (nums[i] - minVal) / d;</span><br><span class="line">            <span class="keyword">if</span> (bucket[idx].first == <span class="number">-1</span>) &#123;</span><br><span class="line">                bucket[idx].first = bucket[idx].second = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bucket[idx].first = <span class="built_in">min</span>(bucket[idx].first, nums[i]);</span><br><span class="line">                bucket[idx].second = <span class="built_in">max</span>(bucket[idx].second, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket[i].first == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="number">-1</span>) &#123;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, bucket[i].first - bucket[prev].second);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>经典算法</category>
      </categories>
      <tags>
        <tag>典型算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/05/13/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95_tmp/</url>
    <content><![CDATA[<hr>
<p>title: 典型算法-排序算法<br>categories: </p>
<ul>
<li>算法和数据结构</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>C++_bind_function_package_task</title>
    <url>/2021/04/29/C++/%E5%BA%93%E5%87%BD%E6%95%B0/bind_function/</url>
    <content><![CDATA[<p>该笔记作为理解通用线程池代码的基础。包含了异步编程的方法，函数绑定的方法等…</p>
<span id="more"></span>

<p>参考链接：</p>
<p><a href="http://cpp11.bitfoc.us/#title-6">http://cpp11.bitfoc.us/#title-6</a><br><a href="https://cloud.tencent.com/developer/article/1584075">https://cloud.tencent.com/developer/article/1584075</a><br><a href="https://www.jianshu.com/p/f191e88dcc80">https://www.jianshu.com/p/f191e88dcc80</a></p>
<h2 id="function类"><a href="#function类" class="headerlink" title="function类"></a>function类</h2><p>通过std::function 对 C++中各种可调用实体（普通函数、Lambda表达式、函数指针、以及其它函数对象等）的封装，形成一个新的可调用的std::function对象，只要呗包装的可调用类型的函数符合相应的函数调用签名（即  返回值类型，输入参数列表类型相同的函数）；让我们不再纠结那么多的可调用实体。std::function对象最大的用处就是在<strong>实现函数回调 (延迟调用)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码出自链接：http://www.jellythink.com/archives/771</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::function&lt; <span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; Functional;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestFunc</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> lambda = [](<span class="keyword">int</span> a)-&gt;<span class="keyword">int</span>&#123; <span class="keyword">return</span> a; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数(functor)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Functor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.类成员函数</span></span><br><span class="line"><span class="comment">// 2.类静态函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ClassMember</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">StaticMember</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 普通函数</span></span><br><span class="line">    Functional = TestFunc;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">Functional</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;普通函数：&quot;</span>&lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda表达式</span></span><br><span class="line">    Functional = lambda;</span><br><span class="line">    result = <span class="built_in">Functional</span>(<span class="number">20</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Lambda表达式：&quot;</span>&lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仿函数</span></span><br><span class="line">    Functor testFunctor;</span><br><span class="line">    Functional = testFunctor;</span><br><span class="line">    result = <span class="built_in">Functional</span>(<span class="number">30</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;仿函数：&quot;</span>&lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类成员函数</span></span><br><span class="line">    TestClass testObj;</span><br><span class="line">    Functional = std::<span class="built_in">bind</span>(&amp;TestClass::ClassMember, testObj, std::placeholders::_1);</span><br><span class="line">    result = <span class="built_in">Functional</span>(<span class="number">40</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;类成员函数：&quot;</span>&lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类静态函数</span></span><br><span class="line">    Functional = TestClass::StaticMember;</span><br><span class="line">    result = <span class="built_in">Functional</span>(<span class="number">50</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;类静态函数：&quot;</span>&lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现技巧"><a href="#实现技巧" class="headerlink" title="实现技巧"></a>实现技巧</h3><p>首先  function 的底层实现其实是一个模板类，他使用了函数签名的模板特化形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认的模板没实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">function</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现有返回值类型和 2 个参数类型的偏特化  根据模板特化的原则可以知道，虽然原本的模板只有一个参数T，而这里偏特化却有三个参数，其实不是这样的，这里也还是一个参数。 &lt; Ret(Arg0, Arg1) &gt; 中等价于一个模板参数，是一个整体</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ret, <span class="keyword">typename</span> Arg0, <span class="keyword">typename</span> Arg1&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">function</span>&lt;</span><span class="built_in">Ret</span>(Arg0, Arg1)&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先通过上面的  函数签名，就可以匹配到特定类型的函数调用，例如都是 <code>int(int)</code>返回值类型为 int 输入参数为int，只不过调用形式不同，可能是 函数指针，可能是 函数，lambda函数，拟函数等等。因此 function 类内部要对不同的调用对象做一步统一封装。</p>
<ol>
<li><p>首先封装出来的类需要  可执行，因此需要重载 () 操作符</p>
</li>
<li><p>考虑无论什么调用对象，它都可以归结到一个函数指针，但是不知道函数指针的具体类型，因此 需要增加一个 (void*) p 类型的函数指针，指向输入的可调用对象。</p>
</li>
<li><p>我们希望 把 所有可调用对象都执行 一次 封装，封装成 这种形式：</p>
</li>
<li><p>当function&lt;int(int)&gt;( f ) 执行构造函数时，此时有了 f 具体的可调用对象，那么我们可以将构造函数加上 Functor 的模板，进而编译器可以根据 实例 f  自动推断 Functor 的具体类型。</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>* p = f;                           <span class="comment">//  f 是实际输入的可调用对象  类型是 Functor 的函数指针</span></span><br><span class="line"><span class="function">R <span class="title">invoke_functor</span><span class="params">(<span class="keyword">void</span>*p, <span class="keyword">int</span> args)</span></span>&#123;	   <span class="comment">//  我们希望将 f 统一包装成  统一的  invoke_functor() 函数，第一个参数是可调用对象的函数指针，后面的是函数的输入参数，统一都在  call_able 函数中首先 将可调用对象的类型转换为 它原本的 Functor类型然后调用。</span></span><br><span class="line">	<span class="keyword">return</span>  <span class="keyword">static_cast</span>&lt;Functor&gt;(p)(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>有了上面的 Functor 类型，我们可以将  不同的调用对象都封装成上述的 call_able 的形式来完成调用。多以就有如下更完整的代码</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">function</span>&lt;</span><span class="built_in">R</span>(Args...)&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>* functor_ptr; <span class="comment">// 由于无法确定函数对象的具体类型, 就用 void* 保存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并利用以下模板函数转换类型</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Functor&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Functor&amp; <span class="title">get_functor</span><span class="params">(<span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">static_cast</span>&lt;Functor*&gt;(p);                            <span class="comment">// (c)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个函数指针, 当需要调用函数对象时, 从此函数指针上调用</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">invoke_fn_t</span> = <span class="built_in">R</span>(*)(<span class="keyword">void</span>*, Args&amp;&amp;...);</span><br><span class="line">    <span class="keyword">invoke_fn_t</span> invoke_f;</span><br><span class="line">    <span class="comment">// 它将以下面这个函数的特化作为有效值</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Functor&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> R <span class="title">invoke_functor</span><span class="params">(<span class="keyword">void</span>* p, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get_functor&lt;Functor&gt;(p)(std::forward&lt;Args&gt;(args)...); <span class="comment">// (b)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 对外暴露的函数调用算符重载</span></span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 检查是否为空, 并在为空时抛出异常</span></span><br><span class="line">        <span class="comment">// if (!this-&gt;invoke_f) throw bad_function_call(&quot;function is null&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">invoke_f</span>(<span class="keyword">this</span>-&gt;functor_ptr, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从函数对象构造</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Functor&gt;</span><br><span class="line">    <span class="built_in">function</span>(Functor f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;invoke_f = invoke_functor&lt;Functor&gt;;                    <span class="comment">// (a)</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;functor_ptr = <span class="keyword">new</span> <span class="built_in">Functor</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许隐式从 nullptr 转换构造, 此构造函数没有 explicit</span></span><br><span class="line">    <span class="built_in">function</span>(std::<span class="keyword">nullptr_t</span> = <span class="literal">nullptr</span>)</span><br><span class="line">        : <span class="built_in">invoke_f</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>a. 首先看 构造函数中的 (a) 部分，根据传入构造函数中的 实际调用对象 Functor，来构造一个通用的 函数指针 。单独看 <code>invoke_functor</code> 函数，是个模板函数，将这个模板函数实例化后成为一个实例化后的函数指针，实例化出的函数指针也是前面说的要封装出的通用调用方式，即第一个参数为 可调用对象的指针，后面是输入参数，在函数中完成函数调用。所以 <code>invoke_f </code> 定义的也是一个<code>R(*)(void*, Args&amp;&amp;...);</code>类型的通用函数指针。然后 再 new  一个指向可调用对象的函数指针，并把它存为  void* 类型，做为后面调<code>invoke_functor</code>的第一个参数。</p>
<p>b. (b) 部分就是 通用函数中需要干的事儿了，首先将 指向可调用对象的 void* 类型的指针 转化为 其原本的 Functor 类型，这一步是通过<code>get_functor </code> 函数 (c) 部分中使用 static_cast 完成的类型转换。</p>
<p>c. (c) 部分即为 一个强制类型转换</p>
<p>最终在 重载的 () 函数中，完成函数调用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结一下实现的流程：</p>
<ol>
<li>当我们只是声明一个 <code>Function&lt;int(int)&gt;</code> 类型时，还不知道具体的需要管理的 可调用对象的类型，因此内部只能先new一个 void* 指针用来指向将来需要指向的可调用对象。</li>
<li>当我们将 一个可调用对象赋值给 <code>Func  </code>传入拷贝或者赋值构造函数时，通过该函数的模板实参推导可以得到 该实例的类型为 Functor</li>
<li>在拷贝构造/赋值构造函数中，使用<code>Functor </code>实例化一个 通用函数指针，即前面说的  第一个参数为 void 函数指针，后面为输入参数…Functor 目的是作为 通用函数中 <code>static_cast </code>转换的依据</li>
<li>将一个void指针指向 可调用对象</li>
<li>当要运行的时候，首先将 void* 指针传入通用函数，在函数中，根据<code>Functor</code>类型完成 <code>void*</code>指针到 Functor类型的类型转换，然后执行 该函数并返回计算结果。 </li>
</ol>
<h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><p>首先，std::bind 是标准库中新增的一个<strong>函数</strong>，std::function是一个类 ，package_task 也是一个类。可将std::bind函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。std::bind将可调用对象与其参数一起进行绑定，绑定后的结果可以使用std::function保存。std::bind主要有以下两个作用：</p>
<ul>
<li>将可调用对象和其参数绑定成一个防函数；</li>
<li>只绑定部分参数，减少可调用对象传入的参数。</li>
</ul>
<h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">my_divide</span> <span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;<span class="keyword">return</span> x/y;&#125;  </span><br><span class="line"><span class="keyword">auto</span> fn_half = std::<span class="built_in">bind</span> (my_divide,_1,<span class="number">2</span>);   <span class="comment">//bind的第一个参数是函数名，普通函数做实参时，会隐式转换成函数指针。因此std::bind (my_divide,_1,2)等价于std::bind (&amp;my_divide,_1,2)；_1表示占位符，位于&lt;functional&gt;中，std::placeholders::_1；</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">fn_half</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;                        <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h3 id="普通成员函数的绑定"><a href="#普通成员函数的绑定" class="headerlink" title="普通成员函数的绑定"></a>普通成员函数的绑定</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_sum</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span></span>&#123;       </span><br><span class="line">        std::cout &lt;&lt; n1+n2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="keyword">auto</span> f = std::<span class="built_in">bind</span>(&amp;Foo::print_sum, &amp;foo, <span class="number">95</span>, std::placeholders::_1);  <span class="comment">//因为普通的成员函数 有 this指针，必须传入一个对象才行。如果是静态成员函数，不需要这样。</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">5</span>); <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这是因为 类的成员函数指针的调用方法为 ： </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;f(&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;value &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;g(&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;value &lt;&lt; <span class="string">&quot;)\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Foo* foo1, Foo* foo2, <span class="keyword">void</span> (Foo::*fun)())</span> </span>&#123;</span><br><span class="line">    (foo1-&gt;*fun)();  <span class="comment">// call fun on the object foo1</span></span><br><span class="line">    (foo2-&gt;*fun)();  <span class="comment">// call fun on the object foo2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo foo1&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    Foo foo2&#123;<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">apply</span>(&amp;foo1, &amp;foo2, &amp;Foo::f);   <span class="comment">// 使用类的成员函数，传入两个不同的实例对象，该函数指针可以访问对象1中的数据和2的数据</span></span><br><span class="line">    <span class="built_in">apply</span>(&amp;foo1, &amp;foo2, &amp;Foo::g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>bind绑定类成员函数时，第一个参数表示对象的成员函数的指针，第二个参数表示对象的地址。</li>
<li>必须显示的指定&amp;Foo::print_sum，因为编译器不会将对象的成员函数隐式转换成函数指针，<strong>所以必须在Foo::print_sum前添加&amp;；</strong></li>
<li>使用对象成员函数的指针时，必须要知道该指针属于哪个对象，因此第二个参数为对象的地址 &amp;foo；</li>
</ul>
<h3 id="被绑定的参数为引用参数"><a href="#被绑定的参数为引用参数" class="headerlink" title="被绑定的参数为引用参数"></a>被绑定的参数为引用参数</h3><p>默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。但是，与lambda类似，有时对有些绑定的参数希望以引用的方式传递，或是要绑定参数的类型无法拷贝。<strong>使用 标准库 ref 函数转化为 引用</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream &amp; <span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> string&amp; s, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;string&gt; words&#123;<span class="string">&quot;helo&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;this&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;C++11&quot;</span>&#125;;</span><br><span class="line">    ostringstream os;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), </span><br><span class="line">                   [&amp;os, c](<span class="keyword">const</span> string &amp; s)&#123;os &lt;&lt; s &lt;&lt; c;&#125; );</span><br><span class="line">    cout &lt;&lt; os.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ostringstream os1;</span><br><span class="line">    <span class="comment">// ostream不能拷贝，若希望传递给bind一个对象，</span></span><br><span class="line">    <span class="comment">// 而不拷贝它，就必须使用标准库提供的 ref 函数</span></span><br><span class="line">    for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">                   <span class="built_in">bind</span>(print, <span class="built_in">ref</span>(os1), _1, c));</span><br><span class="line">    cout &lt;&lt; os1.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="package-task"><a href="#package-task" class="headerlink" title="package_task"></a>package_task</h2><p>std::packaged_task 包装一个可调用的对象，并且允许异步获取该可调用对象产生的结果，从包装可调用对象意义上来讲，std::packaged_task 与 std::function 类似，只不过 std::packaged_task 将其包装的可调用对象的执行结果传递给一个 std::future 对象（该对象通常在另外一个线程中获取 std::packaged_task 任务的执行结果）。</p>
<p>因此，和 function的区别</p>
<ul>
<li>功能上都可以包装可调用对象，实现都是一个类</li>
<li>但是pack_task 可以实现异步获取对象返回结果的功能，就是在一个线程中执行可调用对象，在另一个线程中 获取该对象的执行结果，达到异步访问的目的。而 function 不行</li>
</ul>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span>       <span class="comment">// std::packaged_task, std::future</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span>       <span class="comment">// std::chrono::seconds</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span>       <span class="comment">// std::thread, std::this_thread::sleep_for</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// count down taking a second for each value:</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countdown</span> <span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=from; i!=to; --i) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Finished!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> from - to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span>&gt; <span class="title">task</span><span class="params">(countdown)</span></span>; <span class="comment">// 设置 packaged_task</span></span><br><span class="line">    std::future&lt;<span class="keyword">int</span>&gt; ret = task.<span class="built_in">get_future</span>(); <span class="comment">// 获得与 packaged_task 共享状态相关联的 future 对象.</span></span><br><span class="line">    <span class="function">std::thread <span class="title">th</span><span class="params">(std::move(task), <span class="number">10</span>, <span class="number">0</span>)</span></span>;   <span class="comment">//创建一个新线程完成计数任务.  10  0  为函数的输入参数</span></span><br><span class="line">    <span class="keyword">int</span> value = ret.<span class="built_in">get</span>();                    <span class="comment">// 等待任务完成并获取结果.    </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The countdown lasted for &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; seconds.\n&quot;</span>;</span><br><span class="line">    th.<span class="built_in">join</span>();                                <span class="comment">// 要么 join 要么 detach 子线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="std-packaged-task-构造函数"><a href="#std-packaged-task-构造函数" class="headerlink" title="std::packaged_task 构造函数"></a>std::packaged_task 构造函数</h3><p>std::packaged_task 构造函数共有 5 中形式，不过拷贝构造已经被禁用了。下面简单地介绍一下上述几种构造函数的语义：</p>
<ol>
<li>默认构造函数，初始化一个空的共享状态，并且该 packaged_task 对象无包装任务。</li>
<li>初始化一个共享状态，并且被包装任务由参数 fn 指定。</li>
<li>带自定义内存分配器的构造函数，与默认构造函数类似，但是使用自定义分配器来分配共享状态。</li>
<li><strong>拷贝构造函数，被禁用</strong>。</li>
<li>移动构造函数。 move 调用的</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span>      <span class="comment">// std::move</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span>       <span class="comment">// std::packaged_task, std::future</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span>       <span class="comment">// std::thread</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::packaged_task&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; foo; <span class="comment">// 默认构造函数.</span></span><br><span class="line">    <span class="comment">// 使用 lambda 表达式初始化一个 packaged_task 对象.</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">bar</span><span class="params">([](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> x*<span class="number">2</span>;&#125;)</span></span>;</span><br><span class="line">    foo = std::<span class="built_in">move</span>(bar); <span class="comment">// move-赋值操作，也是 C++11 中的新特性.</span></span><br><span class="line">    <span class="comment">// 获取与 packaged_task 共享状态相关联的 future 对象.</span></span><br><span class="line">    std::future&lt;<span class="keyword">int</span>&gt; ret = foo.<span class="built_in">get_future</span>();</span><br><span class="line">    std::<span class="built_in">thread</span>(std::<span class="built_in">move</span>(foo), <span class="number">10</span>).<span class="built_in">detach</span>(); <span class="comment">// 产生线程，调用被包装的任务.</span></span><br><span class="line">    <span class="keyword">int</span> value = ret.<span class="built_in">get</span>(); <span class="comment">// 等待任务完成并获取结果.</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The double of 10 is &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="std-future"><a href="#std-future" class="headerlink" title="std::future"></a>std::future</h2><p>​    std::future 可以用来获取异步任务的结果，因此可以把它当成一种<strong>简单的线程间同步的手段</strong>。std::future 通常由某个 Provider 创建，你可以把 Provider 想象成一个异步任务的提供者，Provider 在某个线程中设置共享状态的值，与该共享状态相关联的 std::future 对象调用 get（通常在另外一个线程中） 获取该值，如果共享状态的标志不为 ready，则调用 std::future::get 会阻塞当前的调用者，直到 Provider 设置了共享状态的值（此时共享状态的标志变为 ready），std::future::get 返回异步任务的值或异常（如果发生了异常）。</p>
<p>一个有效(valid)的 std::future 对象通常由以下三种 Provider 创建，并和某个共享状态相关联，Provider 可以是函数或者类，他们分别是：</p>
<ul>
<li>std::async 函数</li>
<li>std::packaged_task::get_future，此时 get_future为 packaged_task 的成员函数，返回即为 std::future 类</li>
<li>std::promise::get_future，get_future 为 promise 类的成员函数</li>
</ul>
<ul>
<li><input disabled="" type="checkbox"> Future更详细的用法…</li>
</ul>
<h2 id="C-11异步编程"><a href="#C-11异步编程" class="headerlink" title="C++11异步编程"></a>C++11异步编程</h2><p>主要有三个， <strong>std::async</strong>， <strong>std::packaged_task</strong>， <strong>std::promise</strong></p>
<p>C++11中提供的异步任务高级抽象，包含在 &lt; future&gt;头文件中，它能让我们方便的实现异步地执行一个耗时任务，并在需要的时候获取其结果。例如：</p>
<ol>
<li>批量拷贝/下载文件；</li>
<li>进行一个复杂的计算；</li>
<li>执行多个嵌套的SQL查询语句；</li>
</ol>
<h3 id="std-promise"><a href="#std-promise" class="headerlink" title="std::promise"></a>std::promise</h3><p> std::promise是一个<strong>类模板</strong>，它的作用是在不同的线程中实现数据的同步，与future结合使用，也间接实现了<code>future</code>在不同线程间的同步。下面的例子可以看出， <code>promise + future</code> 等同于  <code>package_task</code>，无需用户自己设置future值。相当于后者对前者进行了封装。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x, std::promise&lt;<span class="keyword">int</span>&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">	x++;</span><br><span class="line">	x *= <span class="number">10</span>;</span><br><span class="line">	p.<span class="built_in">set_value</span>(x);</span><br><span class="line">	std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::promise&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">	std::future&lt;<span class="keyword">int</span>&gt; fu = p.<span class="built_in">get_future</span>();        <span class="comment">// 并将结果返回给future</span></span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(fun, <span class="number">1</span>, std::ref(p))</span></span>;</span><br><span class="line">	std::cout &lt;&lt; fu.<span class="built_in">get</span>() &lt;&lt; std::endl;          <span class="comment">// 当promise还没有值的时候在此等待</span></span><br><span class="line">	std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="std-package-task"><a href="#std-package-task" class="headerlink" title="std::package_task"></a>std::package_task</h3><p>前面已经介绍，是个<strong>类模板</strong>，用来打包可调用对象的。相对 promise 有着更高级的封装吧</p>
<h3 id="std-async"><a href="#std-async" class="headerlink" title="std::async"></a>std::async</h3><p><strong>这个函数是对上面的对象的一个整合</strong>，<code>async</code>先将可调用对象封装起来，然后将其运行结果返回到<code>promise</code>中，这个过程就是一个面向future的一个过程，最终通过<code>future.get()</code>来得到结果。它的实现方法有两种，一种是<code>std::launch::async</code>，这个是直接创建线程，另一种是std::launch::deferred，这个是延迟创建线程(当遇到<code>future.get</code>或者<code>future.wait</code>的时候才会创建线程)，这两个参数是<code>std::async</code>的第一个参数，如果没有使用这个两个参数，也就是第一个参数为空的话，那么第一个参数默认为<code>std::launch::async | std::launch::deferred</code>，这个就不可控了，由操作系统根据当时的运行环境来确定是当前创建线程还是延迟创建线程。那么<code>std::async</code>的第二个参数就是可调用对象的名称，第三个参数就是可调用对象的参数。</p>
<p>这个函数  直接封装 了 中间对象打包过程和线程创建过程，因此封装度更高，操作的灵活性更低。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	x++;</span><br><span class="line">	x *= <span class="number">10</span>;</span><br><span class="line">	std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// std::launch::deferred 当执行到fu.get才开始创建线程</span></span><br><span class="line">	std::future&lt;<span class="keyword">int</span>&gt; fu = std::<span class="built_in">async</span>(std::launch::deferred, fun, <span class="number">1</span>);</span><br><span class="line">	std::cout &lt;&lt; fu.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>C++</category>
        <category>库函数</category>
      </categories>
      <tags>
        <tag>STL库</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title>面经C++基础知识1</title>
    <url>/2021/05/11/C++/%E9%9D%A2%E7%BB%8FC++%E6%B1%87%E6%80%BB/%E9%9D%A2%E7%BB%8F-c++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861/</url>
    <content><![CDATA[<p> 面经 C++ 基础知识</p>
<span id="more"></span>

<h2 id="C-基础知识"><a href="#C-基础知识" class="headerlink" title="C++基础知识"></a>C++基础知识</h2><h3 id="static-关键字的作用"><a href="#static-关键字的作用" class="headerlink" title="static 关键字的作用"></a>static 关键字的作用</h3><ol>
<li><p>修饰变量</p>
<ul>
<li>局部静态变量：存放在静态存储区，不随函数的退出而销毁，默认初始化为 0</li>
<li>全局静态变量：作用域是 定义该变量位置开始到文件结尾，而常规的全局变量其他cpp文件可以通过 extern引用</li>
</ul>
</li>
<li><p>修饰函数</p>
<p> ​    加上static 修饰函数之后，该函数只能被当前文件调用，不会被外部同名函数影响。</p>
</li>
<li><p>类中使用</p>
<ul>
<li>类中的静态变量：该类实例化的所有对象的静态变量 公用一个存储区，即公用一个变量，使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。</li>
<li>类中的静态函数：同样也是所有对象公用的函数，成员调用函数不需要 加上对象引用，直接调用。静态函数中可以直接调用类中申明的静态函数，但是想要调用 类中非静态函数，需要 以 <em>&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;)</em>  的格式。</li>
</ul>
</li>
</ol>
<h3 id="C-C-区别"><a href="#C-C-区别" class="headerlink" title="C/C++区别"></a>C/C++区别</h3><ul>
<li><p>设计思想上 C 是面向过程的结构化变成语言，而C++是面向对象的语言，因此C++具有 额外的 封装，继承，多态三大特征</p>
</li>
<li><p>C++ 增加类型安全的操作，例如 强制类型转换</p>
</li>
<li><p>C++支持范式编程，例如 模板类 和 函数模板</p>
</li>
</ul>
<h3 id="C-四种cast转换的区别"><a href="#C-四种cast转换的区别" class="headerlink" title="C++四种cast转换的区别"></a>C++四种cast转换的区别</h3><p><code>const_cast&lt;T&gt;(expression);</code></p>
<ul>
<li>reinterpret_cast 重解释转换 : 和 c 语言的强制转换中的部分功能—数据的二进制形式重新解释，但是不改变其值 。 如指针转int这种，灵活度高。</li>
<li>const_cast : 用于去掉/增加<strong>指针/引用</strong>的 const 属性</li>
<li>static_cast :  <ol>
<li>和 c 语言中的强制类型转换 的功能一样  如 float -&gt; int 但是这种会对数据做二进制的修改（丢失小数点的精度），这点 和 重解释转换不一样。</li>
<li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换，可以上行转换，下行转换由于没有动态类型检查，运行会异常。</li>
<li>不能去掉 变量const, volite关键字</li>
</ol>
</li>
<li>dynamic_cast : 类层次间类指针或引用的转换，运行时会检查转换的可行性，这点与static 不同的是，下行转换 会返回 null 因此更安全。</li>
</ul>
<h3 id="C-指针和引用的区别"><a href="#C-指针和引用的区别" class="headerlink" title="C++指针和引用的区别"></a>C++指针和引用的区别</h3><ol>
<li><p>指针是一个变量，占内存，而引用是一个变量的别称，不占内存。</p>
<ul>
<li>sizeof(指针)  和 sizeof(引用)  不同</li>
<li>指针有const 而 引用没有</li>
</ul>
</li>
<li><p>指针可以更改指向的对象，而引用一旦确定，就和所引用的对象绑定了，不能更改</p>
</li>
<li><p>指针需要 被解引用 才能对对象操作，而引用直接就是对对象的操作</p>
</li>
<li><p>指针可以多级 引用只能一级。</p>
</li>
<li><p>如果返回动态分配的内存 只能用指针。</p>
</li>
</ol>
<h3 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++智能指针"></a>C++智能指针</h3><p>​        auto_ptr&lt; &gt; ,  unique_ptr&lt; &gt;  ,  share_ptr&lt; &gt;,  weak_ptr&lt; &gt; 。当 new 了 一个指针后，必须手动delet，否则会内存泄漏，为了解决这个缺点，c++中增加了 智能指针，智能指针实际上是一个类，对new出来的指针用 类 进行了一层封装，超出类的作用域的时候会自动调用析构函数释放指针指向的内存，并在类中 对 ()  -&gt; 等操作符进行了重载。<strong>智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏</strong></p>
<ol>
<li>auto_ptr : 是 c++98里的东西，在 c++11已经被弃用，但是后面三个的基本用法还是类似的。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt; string&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;I reigned lonely as a cloud.”));</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">auto_ptr&lt;string&gt; p2;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">p2 = p1; //auto_ptr不会报错.  这时 p2 剥夺了 p1 的所有权，但是调用 p1 的时候还是会内存崩溃，因为此时p1指向的其实是空地址</span></span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>unique_ptr : 独占的意思，就是某个指针，只能被一个智能指针独占，当试图使用赋值运算符去复制指针时，编译器会报错，解决了auto_ptr中潜在的问题。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span> <span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;auto&quot;</span>))</span></span>;   <span class="comment">//#4</span></span><br><span class="line">unique_ptr&lt;string&gt; p4；                       <span class="comment">//#5</span></span><br><span class="line">p4 = p3;   <span class="comment">//此时编译会报错！！</span></span><br><span class="line"><span class="comment">//但是 如果是临时右值  可以赋值，因为 临时右值执行完之后就被析构了  不存在风险</span></span><br><span class="line">unique_ptr&lt;string&gt; pu3;</span><br><span class="line">pu3 = unique_ptr&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;You&quot;</span>));   <span class="comment">// #2 允许</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是想要重用这个指针  可以使用 便准库中带的  move</span></span><br><span class="line"><span class="function">unique_ptr&lt;Test&gt; <span class="title">ptest</span><span class="params">(<span class="keyword">new</span> Test(<span class="string">&quot;123&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;Test&gt; <span class="title">ptest2</span><span class="params">(<span class="keyword">new</span> Test(<span class="string">&quot;456&quot;</span>))</span></span>;</span><br><span class="line">ptest-&gt;<span class="built_in">print</span>();</span><br><span class="line">ptest2 = std::<span class="built_in">move</span>(ptest);<span class="comment">//不能直接ptest2 = ptest</span></span><br><span class="line"><span class="keyword">if</span>(ptest == <span class="literal">NULL</span>)  cout&lt;&lt;<span class="string">&quot;ptest = NULL\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>share_ptr  :  上面的 unique_ptr虽然很安全，但是不方便，不能赋值要求太死了。share_ptr  使用计数机制来表明资源被几个指针共享。当计数值为0 就释放资源。调用 reset 放弃内部对象，会使引用对象计数值减一。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;Test&gt; <span class="title">ptest</span><span class="params">(<span class="keyword">new</span> Test(<span class="string">&quot;123&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;Test&gt; <span class="title">ptest2</span><span class="params">(<span class="keyword">new</span> Test(<span class="string">&quot;456&quot;</span>))</span></span>;</span><br><span class="line">cout&lt;&lt;ptest2-&gt;<span class="built_in">getStr</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;ptest2.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">ptest = ptest2;<span class="comment">//&quot;456&quot;引用次数加1，“123”销毁</span></span><br><span class="line">ptest-&gt;<span class="built_in">print</span>();</span><br><span class="line">cout&lt;&lt;ptest2.<span class="built_in">use_count</span>()&lt;&lt;endl;<span class="comment">//2</span></span><br><span class="line">cout&lt;&lt;ptest.<span class="built_in">use_count</span>()&lt;&lt;endl;<span class="comment">//2</span></span><br><span class="line">ptest.<span class="built_in">reset</span>();</span><br><span class="line">ptest2.<span class="built_in">reset</span>();<span class="comment">//此时“456”销毁</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;done !\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>weak_ptr : 上述的 <strong>共享指针在相互引用时 会出现 锁死的情况，导致内存泄漏</strong>，就是 计数值永远减不到0的情况。而weak_ptr 指针就可以弥补这个缺点。weak_ptr  指向一个 shared_ptr 管理的对象，它不控制对象的生命周期，进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造，它的构造和析构不会引起引用记数的增加或减少。</li>
</ol>
<h3 id="给定三角形三顶点-判断点是否在三角形里"><a href="#给定三角形三顶点-判断点是否在三角形里" class="headerlink" title="给定三角形三顶点 判断点是否在三角形里"></a>给定三角形三顶点 判断点是否在三角形里</h3><p>​        ABC  即判断 面积 OAB + OAC + OBC = ABC 是否成立即可。计算面积使用海伦公式 S = ( x1 y1  1  x2 y2 1 x3 y3 1 ) 构成的3x3行列式的值的一般即为 面积。</p>
<h3 id="C-多态"><a href="#C-多态" class="headerlink" title="C++多态"></a>C++多态</h3><p>​        多态性可以简单地概括为“一个接口，多种方法”，它是面向对象编程领域的核心概念。</p>
<p>​        多态的目的：封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了“接口重用”。也即，不论传递过来的究竟是类的哪个对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。</p>
<p>​        c++多态的两种形式：</p>
<ol>
<li><p>编译时多态：通过函数重载实现</p>
</li>
<li><p>运行时多态性（动态多态）：通过虚函数实现，重写  （一般函数子类和基类函数同名时对基类函数屏蔽的作用不叫 多态）</p>
</li>
</ol>
<p>​        虚函数是实现多态的机制。其核心理念就是通过基类访问派生类定义的函数。多态性使得程序调用的函数是在运行时动态确定的，而不是在编译时静态确定的。</p>
<p>​        虚函数实现的过程是：<strong>通过对象内存中的虚函数指针vptr找到虚函数表vtbl，再通过vtbl中的函数指针找到对应虚函数的实现区域并进行调用</strong></p>
<ul>
<li>虚函数：    在类成员方法的声明（不是定义）语句前加“virtual”, 如 virtual void func()。子类可以不重写虚函数。子类如果不提供虚函数的实现，将会自动调用基类的缺省虚函数实现，作为备选方案；</li>
<li>纯虚函数，在虚函数后加“=0”，如 virtual void func()=0。子类必须对纯虚函数实现，否则编译报错。（纯虚函数在基类中的实现跟多态性无关，它只是提供了一种语法上的便利，在变化多端的应用场景中留有后路）</li>
</ul>
<h3 id="为什么C-默认的析构函数是不是虚函数，为什么析构函数最好是虚函数"><a href="#为什么C-默认的析构函数是不是虚函数，为什么析构函数最好是虚函数" class="headerlink" title="为什么C++默认的析构函数是不是虚函数，为什么析构函数最好是虚函数"></a>为什么C++默认的析构函数是不是虚函数，为什么析构函数最好是虚函数</h3><p>​        为什么要是 虚函数：因为当使用基类指针指向 new 出来的子类对象时，如果子类中分配了新的内存，此时如果析构函数不是虚函数，会调用基类的析构函数 无法释放子类新定义的变量造成内存泄漏。<br>​        为什么c++默认不是虚函数：当不使用基类指针指向子类对象时，就不会出现上述内存泄漏的情况，而定义虚函数  会多分配一个虚函数指针，占内存。</p>
<h3 id="简述函数指针"><a href="#简述函数指针" class="headerlink" title="简述函数指针"></a>简述函数指针</h3><p>​        函数指针就是一个指针变量，只不过它指向的是函数的入口地址，可以使用定义的函数指针去调用它指向的函数。概念上和指向变量的指针相似。<br>​        作用：可以用函数指针做回调函数 或者 函数的入口参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fun</span><span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;  &#125;</span><br><span class="line"><span class="keyword">char</span> * (*pfun)(<span class="keyword">char</span> *);  <span class="comment">//函数指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* (*pfun_ty)(<span class="keyword">char</span>*);</span><br><span class="line"></span><br><span class="line">pfun_ty pfun2 = fun;</span><br><span class="line">pfun = fun;</span><br></pre></td></tr></table></figure>



<h3 id="c-中析构函数的作用"><a href="#c-中析构函数的作用" class="headerlink" title="c++中析构函数的作用"></a>c++中析构函数的作用</h3><p>​        析构函数与构造函数对应，当其生命周期结束的时候，系统会自动调用析构函数，用户在类中使用了动态内存分配，就需要在析构函数中释放内存。如果用户没有显示的写析构函数，系统编译会自动生成一个析构函数。<br>​        顺序：<strong>子类本身的析构函数，子类对象成员的析构函数，基类的析构函数。</strong></p>
<h3 id="重载和覆盖的区别"><a href="#重载和覆盖的区别" class="headerlink" title="重载和覆盖的区别"></a>重载和覆盖的区别</h3><p>​        重载：是相同的函数名，不同的参数列表（返回值没要求），程序编译时会根据调用的参数的类型选择对应的函数。编译时多态<br>​        重写： 子类继承父类，子类对父类的虚函数重写，在运行过程中确定是调用子类还是父类的函数。</p>
<h3 id="请你说一说strcpy和strlen"><a href="#请你说一说strcpy和strlen" class="headerlink" title="请你说一说strcpy和strlen"></a>请你说一说strcpy和strlen</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;  <span class="comment">//strcpy是字符串拷贝函数</span></span><br><span class="line"><span class="comment">//从src逐字节拷贝到dest，直到遇到&#x27;\0&#x27;结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。</span></span><br><span class="line"><span class="comment">//strlen函数是计算字符串长度的函数，返回从开始到&#x27;\0&#x27;之间的字符个数。</span></span><br></pre></td></tr></table></figure>

<h3 id="请你说一说你理解的虚函数和多态"><a href="#请你说一说你理解的虚函数和多态" class="headerlink" title="请你说一说你理解的虚函数和多态"></a>请你说一说你理解的虚函数和多态</h3><p>​        多态：多态分为静态多态和动态多态，前者是重载实现，在编译的时候就确定了，而后者主要通过虚函数实现，是程序运行过程中动态确定要执行那个函数。例如  父类中含有一个虚函数，子类中重写了虚函数，当new一个子类对象并使用基类指针指向它时，此时指针调用虚函数调用的其实是子类中重写的函数，这就实现了一个接口复用的功能。<br>​        虚函数的实现：虚函数通过虚函数指针和虚函数表实现。当类种某个函数申明为虚函数的时候，这个类会多一个看不见的 虚函数指针，这个指针指向虚函数表，表中放了虚函数的地址（实际虚函数在代码段）。<strong>当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</strong></p>
<h3 id="i-和-i-的-区别，-以及他们的实现"><a href="#i-和-i-的-区别，-以及他们的实现" class="headerlink" title="++i  和 i++ 的 区别， 以及他们的实现"></a>++i  和 i++ 的 区别， 以及他们的实现</h3><p>记住 i++ 重载要使用 int 占位；而 ++i 不用；再根据作用 i++ 是先返回再自增，就是需要备份再自增，然后返回备份的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">int</span>::operate++(<span class="keyword">int</span>)&#123;   <span class="comment">// i++  先返回 再自增  使用一个int占位 和 i++ 区分</span></span><br><span class="line">	<span class="keyword">int</span> tmp = (*<span class="keyword">this</span>);</span><br><span class="line">    (*<span class="keyword">this</span>)++;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">int</span>::operate++()&#123;  <span class="comment">// ++i  先自增 再返回</span></span><br><span class="line">    (*<span class="keyword">this</span>)++;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="请你来写个函数在main函数执行前先运行"><a href="#请你来写个函数在main函数执行前先运行" class="headerlink" title="请你来写个函数在main函数执行前先运行"></a>请你来写个函数在main函数执行前先运行</h3><p>在main函数之前运行的 有以下几个思路：</p>
<ol>
<li>全局变量在 main 开始之前就初始化了 ，因此可以定义一个全局 的 类 在 这个类的构造函数  和析构函数即为 main 之前之后调用的</li>
<li> attribute 关键字 </li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__attribute((constructor)) <span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; start &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="智能指针shared-ptr的实现"><a href="#智能指针shared-ptr的实现" class="headerlink" title="智能指针shared_ptr的实现"></a>智能指针shared_ptr的实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  关键点 ：</span></span><br><span class="line"><span class="comment">//  1. tmplate &lt;typename T&gt;  模板</span></span><br><span class="line"><span class="comment">//  2. 需要管理的指针变量设置为 T* ptr, 计数值也设置为 int * 指针，在构造函数时给 计数变量分配 内存并初始化为1</span></span><br><span class="line"><span class="comment">//  3. 除了构造函数中重新分配内存外，重载的 = 运算符  和  拷贝构造函数 都是公用计数变量 和 公用 管理的区域</span></span><br><span class="line"><span class="comment">//  4. 在拷贝构造函数中，需要先释放等号左值管理的内存区，再将其指针（计数指针和管理的指针）指向等号右边智能指针管理的地方</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPointer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">SmartPointer</span>(T* p=<span class="number">0</span>): _ptr(p), _reference_count(<span class="keyword">new</span> <span class="keyword">size_t</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p)</span><br><span class="line">			*_reference_count = <span class="number">1</span>; </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			*_reference_count = <span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">SmartPointer</span>(<span class="keyword">const</span> SmartPointer&amp; src) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;src) &#123;</span><br><span class="line">			_ptr = src._ptr;</span><br><span class="line">			_reference_count = src._reference_count;</span><br><span class="line">			(*_reference_count)++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载赋值操作符</span></span><br><span class="line">	SmartPointer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPointer&amp; src) &#123;</span><br><span class="line">		<span class="keyword">if</span>(_ptr==src._ptr) &#123;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">releaseCount</span>();</span><br><span class="line">		_ptr = src._ptr;</span><br><span class="line">		_reference_count = src._reference_count;</span><br><span class="line">		(*_reference_count)++;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重载操作符</span></span><br><span class="line">	T&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">		<span class="keyword">if</span>(ptr) &#123;</span><br><span class="line">			<span class="keyword">return</span> *_ptr;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//throw exception</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载操作符</span></span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">		<span class="keyword">if</span>(ptr) &#123;</span><br><span class="line">			<span class="keyword">return</span> _ptr;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//throw exception</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">SmartPointer</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (--(*_reference_count) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">            <span class="keyword">delete</span> _reference_count;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T *_ptr;</span><br><span class="line">        <span class="keyword">size_t</span> *_reference_count;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">releaseCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(_ptr) &#123;</span><br><span class="line">			(*_reference_count)--;</span><br><span class="line">    			<span class="keyword">if</span>((*_reference_count)==<span class="number">0</span>) &#123;</span><br><span class="line">    				<span class="keyword">delete</span> _ptr;</span><br><span class="line">    				<span class="keyword">delete</span> _reference_count;</span><br><span class="line">    			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">SmartPointer&lt;<span class="keyword">char</span>&gt; <span class="title">cp1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">char</span>(<span class="string">&#x27;a&#x27;</span>))</span></span>;</span><br><span class="line">    <span class="function">SmartPointer&lt;<span class="keyword">char</span>&gt; <span class="title">cp2</span><span class="params">(cp1)</span></span>;</span><br><span class="line">    SmartPointer&lt;<span class="keyword">char</span>&gt; cp3;</span><br><span class="line">    cp3 = cp2;</span><br><span class="line">    cp3 = cp1;</span><br><span class="line">    cp3 = cp3;</span><br><span class="line">    <span class="function">SmartPointer&lt;<span class="keyword">char</span>&gt; <span class="title">cp4</span><span class="params">(<span class="keyword">new</span> <span class="keyword">char</span>(<span class="string">&#x27;b&#x27;</span>))</span></span>;</span><br><span class="line">    cp3 = cp4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组和字符串区别"><a href="#数组和字符串区别" class="headerlink" title="数组和字符串区别"></a>数组和字符串区别</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * arr = <span class="string">&quot;123&quot;</span>; <span class="comment">// 存放在栈区域，不能修改值</span></span><br><span class="line"><span class="keyword">char</span> * brr = <span class="string">&quot;123&quot;</span>;       <span class="comment">//和上面那个一样 也是存放在常量存储区  因为字符串默认就存储在常量存储区 不可修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> crr[] = <span class="string">&quot;123&quot;</span>; <span class="comment">//数组 应该存在 栈区域 但是加了 const 编译器会将他优化，存到常量区 不可修改</span></span><br><span class="line"><span class="keyword">char</span> drr[] = <span class="string">&quot;123&quot;</span>;	      <span class="comment">// 存放在栈区域</span></span><br></pre></td></tr></table></figure>

<h3 id="C-里是怎么定义常量的？常量存放在内存的哪个位置？"><a href="#C-里是怎么定义常量的？常量存放在内存的哪个位置？" class="headerlink" title="C++里是怎么定义常量的？常量存放在内存的哪个位置？"></a>C++里是怎么定义常量的？常量存放在内存的哪个位置？</h3><p>​    局部常量 存储在栈区，全局常量 存在全局存储区，字面值常量如字符串 存在常量区</p>
<h3 id="const-修饰成员函数的目的"><a href="#const-修饰成员函数的目的" class="headerlink" title="const 修饰成员函数的目的"></a>const 修饰成员函数的目的</h3><p>​        const 修饰的成员函数表明函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这<strong>样无论const对象还是普通对象都可以调用该函数</strong>。</p>
<h3 id="c-隐式类型转换"><a href="#c-隐式类型转换" class="headerlink" title="c++隐式类型转换"></a>c++隐式类型转换</h3><ul>
<li>对于内置类型，低精度的变量给高精度变量赋值会发生隐式类型转换</li>
<li>对于只含一个参数的构造函数的对象来说，函数调用可以直接传入该类型的参数，编译器会使用该参数调<strong>用构造函数生成临时对象</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BOOK</span>  //定义了一个书类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        string _bookISBN ;  <span class="comment">//书的ISBN号</span></span><br><span class="line">        <span class="keyword">float</span> _price ;    <span class="comment">//书的价格</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//定义了一个成员函数，这个函数即是那个“期待一个实参为类类型的函数”</span></span><br><span class="line">        <span class="comment">//这个函数用于比较两本书的ISBN号是否相同</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isSameISBN</span><span class="params">(<span class="keyword">const</span> BOOK &amp; other )</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> other._bookISBN==_bookISBN;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//类的构造函数，即那个“能够用一个参数进行调用的构造函数”（虽然它有两个形参，但其中一个有默认实参，只用一个参数也能进行调用）</span></span><br><span class="line">        <span class="built_in">BOOK</span>(string ISBN,<span class="keyword">float</span> price=<span class="number">0.0f</span>):_bookISBN(ISBN),_price(price)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BOOK <span class="title">A</span><span class="params">(<span class="string">&quot;A-A-A&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">BOOK <span class="title">B</span><span class="params">(<span class="string">&quot;B-B-B&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;A.<span class="built_in">isSameISBN</span>(B)&lt;&lt;endl;   <span class="comment">//正经地进行比较，无需发生转换</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;A.<span class="built_in">isSameISBN</span>(<span class="built_in">string</span>(<span class="string">&quot;A-A-A&quot;</span>))&lt;&lt;endl; <span class="comment">//此处即发生一个隐式转换：string类型--&gt;BOOK类型，借助BOOK的构造函数进行转换，以满足isSameISBN函数的参数期待。</span></span><br><span class="line">    cout&lt;&lt;A.<span class="built_in">isSameISBN</span>(<span class="built_in">BOOK</span>(<span class="string">&quot;A-A-A&quot;</span>))&lt;&lt;endl;    <span class="comment">//显式创建临时对象，也即是编译器干的事情。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-函数栈空间的最大值"><a href="#C-函数栈空间的最大值" class="headerlink" title="C++函数栈空间的最大值"></a>C++函数栈空间的最大值</h3><p>​    1M 可调整</p>
<h3 id="extern“C”"><a href="#extern“C”" class="headerlink" title="extern“C”"></a>extern“C”</h3><p>​    C++ 调用 C 函数 需要 extern c  因为c语言没有函数重载</p>
<h3 id="new-delete与malloc-free的区别是什么"><a href="#new-delete与malloc-free的区别是什么" class="headerlink" title="new/delete与malloc/free的区别是什么"></a>new/delete与malloc/free的区别是什么</h3><p>​        前者 c++ 的 关键字  后者 c 的内存分配的库函数，后者使用必须指明申请内存空间的大小。对于类类型的对象，后者不会调用构造函数和析构函数。</p>
<h3 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h3><h3 id="c语言怎么进行函数调用的"><a href="#c语言怎么进行函数调用的" class="headerlink" title="c语言怎么进行函数调用的"></a>c语言怎么进行函数调用的</h3><p>会分配函数栈，在栈内进行函数执行，先将返回地址地址压栈，再把当前函数的esp指针压栈</p>
<h3 id="C语言参数压栈顺序"><a href="#C语言参数压栈顺序" class="headerlink" title="C语言参数压栈顺序"></a>C语言参数压栈顺序</h3><p>从右往左</p>
<h3 id="c-如何处理返回值"><a href="#c-如何处理返回值" class="headerlink" title="c++如何处理返回值"></a>c++如何处理返回值</h3><p>创建临时变量，将临时变量的引用作为函数参数输入函数</p>
<h3 id="c-拷贝构造函数能否值传递"><a href="#c-拷贝构造函数能否值传递" class="headerlink" title="c++拷贝构造函数能否值传递"></a>c++拷贝构造函数能否值传递</h3><p>不能，会无限循环</p>
<h3 id="fork-函数"><a href="#fork-函数" class="headerlink" title="fork 函数"></a>fork 函数</h3><p>​        pid_t fork(void);  成功调用 fork函数后，fork会创建出一个新进程，他几乎和调用fork的进程一模一样，不同的是，父进程中，fork返回的是 子进程的pid , 子进程中fork返回的是 0 ；可以根据这两个来区分是子进程还是父进程 这样来并行的执行两个任务。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>面经C++汇总</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-树</title>
    <url>/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/</url>
    <content><![CDATA[<p>数据结构之树，例如二叉树，平衡二叉树，堆，等</p>
<span id="more"></span>

<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的类别"><a href="#树的类别" class="headerlink" title="树的类别"></a>树的类别</h2><p><img src="https://pic3.zhimg.com/v2-e7a99fda571a4294e9b2196d58f8e65c_r.jpg?source=1940ef5c" alt="preview"></p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>​        给定一棵树 判断是否为平衡二叉树，即任意节点的左右子树的高度差不超过1，即为平衡二叉树。</p>
<p>​        这道题的关键是，任意子节点的左右子树高度差不超过1。如果只是判断根节点的左右子树的高度，那么写一个前序遍历的递归即可，如下代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">height</span>(root-&gt;left), <span class="built_in">height</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入根节点，通过前序遍历的方式往下遍历，遍历计算左节点高度-&gt;回退父节点-&gt;遍历计算右子节点高度-&gt;二者高度取最大+1。但是这么一次遍历 最终计算的只是 根节点的左右子节点的高度。因此还需一个递归，来遍历判断所有节点是否为平衡节点。加入以下递归调用的方式。先判断当前节点的左右子树的高度差是否满足 再判断左右子树的子树高度差是否满足…..</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(<span class="built_in">height</span>(root-&gt;left) - <span class="built_in">height</span>(root-&gt;right)) &lt;= <span class="number">1</span> &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>​        （采用二分法思维把数据按规则组装成一个树形结构的数据）</p>
<p>​        是一种特殊的二叉树  （参考：<a href="https://blog.csdn.net/John_xyz/article/details/79622219%EF%BC%89%EF%BC%8C%E5%AE%83%E6%94%B9%E5%96%84%E4%BA%86%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E6%9F%A5%E6%89%BE%E7%9A%84%E6%95%88%E7%8E%87%E3%80%82%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E6%9C%89%E4%BB%A5%E4%B8%8B%E6%80%A7%E8%B4%A8%E3%80%82%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9B%B8%E6%AF%94%E4%BA%8E%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BC%98%E5%8A%BF%E5%9C%A8%E4%BA%8E%E6%9F%A5%E6%89%BE%E3%80%81%E6%8F%92%E5%85%A5%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%BE%83%E4%BD%8E,%E5%9D%87%E4%B8%BAO">https://blog.csdn.net/John_xyz/article/details/79622219），它改善了二叉树节点查找的效率。二叉查找树有以下性质。二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低,均为O</a>(log n)。对于任意一个节点 n：</p>
<ul>
<li>其左子树（left subtree）下的每个后代节点（descendant node）的值都小于节点 n 的值；</li>
<li>其右子树（right subtree）下的每个后代节点的值都大于节点 n 的值；</li>
<li>没有键值相等的节点</li>
</ul>
<h3 id="二叉搜索树有关操作"><a href="#二叉搜索树有关操作" class="headerlink" title="二叉搜索树有关操作"></a>二叉搜索树有关操作</h3><p>​    <strong>插入</strong>：若b是空树，则将s所指结点作为根节点插入，否则；若s.val等于b的根节点的数据域之值，则返回，否则；若s.val小于b的根节点的数据域之值，则把s所指节点插入到左子树中；否则把s所指节点插入到右子树中<strong>新插入节点总是叶子节点</strong></p>
<p>​    <strong>删除</strong>：分三种情况，如下图，1. 如果待删除的节点是叶子节点，那么可以立即被删除；2. 如果有一个子节点，要将下一个子节点上移到当前节点，即替换之；3.如果有两个子节点，则将其右子树的最小数据代替此节点的数据，并将其右子树的最小数据删除。</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406095944.png" alt="1599307406058"></p>
<p>查找：最佳情况Olog(n)Olog(n), 最坏情况O(n)O(n)<br>插入：最佳情况Olog(n)Olog(n), 最坏情况O(n)O(n)<br>删除：最佳情况Olog(n)Olog(n), 最坏情况O(n)</p>
<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p>​        平衡二叉排序树，首先是二叉搜索树，其次是平衡树。因此有二者的共同特点。所有子树都是平衡二叉树，且左右子树的高度差不值不超过1。<a href="https://www.cnblogs.com/lanhaicode/p/11321243.html">https://www.cnblogs.com/lanhaicode/p/11321243.html</a></p>
<h3 id="平衡因子"><a href="#平衡因子" class="headerlink" title="平衡因子"></a>平衡因子</h3><p>​        某结点的左子树与右子树的高度或深度 差即为该结点的平衡因子（BF,Balance Factor），平衡二叉树（AVL树）上所有结点的平衡因子只可能是 -1，0 或 1。AVL树的数据结构中 存放的是 节点的高度 height。</p>
<h3 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h3><p>​        和二叉搜索树类似</p>
<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><p>​        二叉搜索树每次插入节点都插在树的叶节点。在插入后，树可能失衡。处理流程为：<br>​        按照搜索树的方式插入新节点 -&gt;  搜索最低失衡点 -&gt; 判断失衡点的类型  -&gt; 调整二叉树平衡</p>
<p><em>失衡的类型</em> ： <strong>RR  LL RL  LR</strong> </p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406095948.png" alt="image-20201102213545758"></p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406095950.png" alt="image-20201102213920250"></p>
<p>​        LL 和 RR 型相对简单。只需要旋转一次即可。</p>
<p><img src="https://img2018.cnblogs.com/blog/1590962/201908/1590962-20190812202510882-2058601498.gif" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406095954.png" alt="image-20201102214304915"></p>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>​        比插入还复杂，但是本质还是那四种旋转方式。只不过删除可能会多两种 RE LE 类不平衡的情况。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>​    红黑树是特殊的二叉查找树，首先它满足二叉查找树的所有要求，其次为了缓解二叉查找树不平衡的坏情况带来 数据查找效率降低的问题，引入了红黑树的一些独有的限制。具体的有如下特性：</p>
<ol>
<li>每个节点要么是红色要么是黑色（用一个数据表示）</li>
<li>根节点是黑色</li>
<li>每个叶子节点都是黑色，并且为空节点。（这里的叶节点是黑色的意思是 常规的叶子节点下面都有两个空的null，算作黑色节点，对于只有一个孩子的节点，他的另一边也是一个null空的黑色节点）</li>
<li>红色节点后必须是两个黑色子节点。即红色节点不能连续。（黑色节点可以）</li>
<li>从根节点到最后的null(黑色)的叶子节点，每条路径上的黑色节点数应该一样。</li>
</ol>
<p>在上述4，5的约束下，红黑树的 最长路径（红黑相间路径 2N）不会超过 最短路径（全是黑色节点的路径N）的两倍</p>
<h3 id="插入节点-1"><a href="#插入节点-1" class="headerlink" title="插入节点"></a>插入节点</h3><h3 id="删除节点-1"><a href="#删除节点-1" class="headerlink" title="删除节点"></a>删除节点</h3><p>参考 ：<a href="https://zhuanlan.zhihu.com/p/22800206?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1266313842667769856&amp;utm_campaign=shareopn">https://zhuanlan.zhihu.com/p/22800206?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1266313842667769856&amp;utm_campaign=shareopn</a></p>
<p>​        首先，红黑树删除节点和普通二叉搜索树一样，首先找到待删除的节点X，如果 X 有两个子节点，那么在他的右子树或左子树寻找替代节点S，然后将替代节点S的值和待删除节X点的值交换（颜色不变）问题就转变为删除节点S （且此时的S节点最多只有一个孩子，因为由二叉搜索树的性质，替代节点一定是右子树的最小值）。因此最终问题都归结为删除 至多有一个孩子节点的节点。 下面详细分析：</p>
<ol>
<li>如果删除的是红色叶子节点，直接删除即可，删除一个红色叶节点不违反任何特性。</li>
<li>如果删除的是黑色叶子节点，明显删除了之后经过该叶子节点的路径上黑色节点数量少一 需要处理。</li>
<li>如果删除的节点有一个叶子节点，两个一黑一红，可以直接转换成 1 解决。</li>
<li>如果删除的节点和其叶子节点都是黑色，将叶子节点和待删除节点值替换，那么问题转换为 （删除一个黑色叶子节点的情况 2）</li>
</ol>
<p>综上，所有情况都转换为 情况1，2两种，而情况1很容易，下面讨论问题2的解决方法 （删除一个黑色叶子节点）</p>
<p>​    这是，待删除的叶子节点是黑色，那么他一定有兄第节点 （如果 S 没有兄弟节点，到兄弟 null 的路径上黑色节点数比到 S 的null叶节点上的黑色节点树少1 。不满足红黑树性质5的约束）下面就是对它的兄弟节点的颜色讨论：</p>
<ol>
<li><p>待删除的节点是一个左叶子节点  即图中的 80 为待删除节点</p>
<ol>
<li><p>兄弟节点是黑色，此时兄弟节点可能会有1/2/0个红色节节点 （此时兄弟的子节点不可能是黑色，需满足红黑树约束）</p>
<p> a.  兄弟有一个红色右节点</p>
<p> b. 兄弟有一个红色左节点  简单旋转兄弟节点和兄弟节点的子节点位置即转为 情况 a</p>
<p> c. 兄弟有两个红色节点</p>
<p> d. 兄弟没有子节点</p>
</li>
<li><p>兄弟节点是红色，此时兄弟一定会有两个黑色子节点，如果是一个也不满足条件5约束 </p>
</li>
</ol>
</li>
<li><p>待删除的节点是一个黑色右叶子节点 即中的 110</p>
<p> … 同上分类</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406100001.png" alt="image-20201104210955575"></p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406100003.png" alt="image-20201104212934752"></p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210406100006.png"></p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><p>​        二叉树虽然搜索效率也很高，但是二叉树应用的是场景是对存储在内存的数据查找，对于存储在硬盘的数据，数据量大，且硬盘读写速度慢，而将整个硬盘存储区的内容一次读入内存也装不下，因此需要用B树/B+树，主要用于数据库的查找索引等。因为B树每个节点可以存储多个子节点（键值），所以B树需要对硬盘的读写次数较低（尽管比较次数较二叉树多）。B树的阶数一般为磁盘每页的容量大小 （从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读）</p>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ol>
<li><p>排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；</p>
</li>
<li><p>子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉；</p>
</li>
<li><p>关键字数：非根节点的关键字数量大于等于 ceil(M/2)-1 个 （向上取整） 且小于等于M-1个；</p>
</li>
<li><p>所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</p>
<p> <img src="https://pic2.zhimg.com/v2-2c2264cc1c6c603dfeca4f84a2575901_r.jpg" alt="preview"></p>
<p> 如图中，每个内部节点如果有 n 各关键字，那么他们就有n+1个间隔，子树的所有键值一定在对应的间隔大小范围内。</p>
</li>
</ol>
<h3 id="插入节点-2"><a href="#插入节点-2" class="headerlink" title="插入节点"></a>插入节点</h3><p>​        插入的规则就是，先往下搜索到最底层，插入，如果当前位置的关键字数量超过了它允许的最大数量，就取中间那个键为新的根，左右分裂为两个新的子树，再将新的根归并入他原本的父节点中，此时父节点也超了，同理再分裂向上增加节点，若直到根节点还是超，那么此时树的高度就增加了1。</p>
<p><img src="https://pic1.zhimg.com/v2-3057eaab2b1764dd51c2a8658791cc98_r.jpg" alt="preview"></p>
<h3 id="删除节点-2"><a href="#删除节点-2" class="headerlink" title="删除节点"></a>删除节点</h3><ol>
<li>如果删除的是叶子节点，且删除后数量依然满足要求，就直接删</li>
<li>如果删除的不是叶子节点，且删了之后数量不够<ul>
<li>如果它的左边 或者 右边 兄弟节点树比最低标准多，那么就根兄弟节点接节点。具体的，如果是跟右边的兄弟节点借，先把右边兄弟节点最左边的键移动的父节点，再把父节点中对应的节点移动到该子节点。</li>
<li>如果它的左右兄弟节点都不够借，就和左/右兄弟节点合并。具体的 将该节点和上连的父节点比他大的键以及右边兄弟节点一起 合并为一个子节点。（和左边兄弟节点合并也类似）然后此时父节点由于给出一个关键子，可能数量少于要求了，就对父节点做同样的调整。至到满足要求的节点 或者 根节点（此时树高度就减一了）</li>
</ul>
</li>
<li>如果删除的不是叶子节点，类似二叉查找树里的操作，寻找右边子树最小的叶子节点或左边子树的最大叶子节点与他替换，就转化为删除叶子节点的问题。</li>
</ol>
<p><img src="https://i.loli.net/2021/03/28/kBc3dPOD1ZV4RwY.png" alt="image-20201111220009652"></p>
<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><p>​        同样B+树也是通常用于数据库和操作系统的文件系统中。B+树的特点是能够保持数据稳定有序， 其插入与修改拥有较稳定的对数时间复杂度。</p>
<h3 id="与B树的区别"><a href="#与B树的区别" class="headerlink" title="与B树的区别"></a>与B树的区别</h3><ul>
<li><p>有 n 棵子树的节点中含有n个关键字(即每个关键字对应一棵子树)；B树中有最多n个分支子树，则有n-1个关键字。</p>
</li>
<li><p>所有叶子节点中包含了全部关键字的信息， 及指向含这些关键字记录的指针，且叶子节点本身依关键字的大小自小而大顺序链接；B+树中节点保存的是 索引值和对应的value。</p>
</li>
<li><p>所有的非终端节点可以看成是索引部分，节点中仅含有其子树（根节点）中的最大（或最小)关键字  B树的子节点是介于父节点对应关键字的区间之中</p>
</li>
<li><p>除根节点外，其他所有节点中所含关键字的个数必须 &gt;= ceil (m/2 )  B树是至少 ceil (m/2 )-1个关键字 ，ceil (m/2 )个子节点；</p>
<p>  <img src="https://ivanzz1001.github.io/records/assets/img/data_structure/ds_bplus_tree1.jpg" alt="img"></p>
</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</li>
<li>B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</li>
<li>B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</li>
<li>B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li>
</ol>
<p>​       <strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快。</p>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>​        堆(heap)又被为优先队列(priority queue)。队列中允许的操作是先进先出（FIFO），在队尾插入元素，在队头取出元素 而堆也是一样，在堆底插入元素，在堆顶取出元素，但是堆中元素的排列不是按照到来的先后顺序，<strong>而是按照一定的优先顺序排列的。这个优先顺序可以是元素的大小或者其他规则</strong>。Linux中的任务调度器就是堆实现的。<br>​        堆的一个经典的实现是完全二叉树(complete binary tree)。这样实现的堆成为二叉堆(binary heap)。<br>​        完全二叉树是增加了限定条件的二叉树。假设一个二叉树的深度为n。为了满足完全二叉树的要求，该二叉树的前n-1层必须填满，第n层也必须按照从左到右的顺序被填满，比如下图:            </p>
<p><img src="https://i.loli.net/2021/03/28/9w6YBOVIz18edCD.png" alt="img"></p>
<p>堆常用的用途：</p>
<ul>
<li>构建优先队列</li>
<li>支持堆排序</li>
<li>快速找出一个集合中的最小值（或者最大值）</li>
</ul>
<h3 id="堆属性"><a href="#堆属性" class="headerlink" title="堆属性"></a>堆属性</h3><p>​        在<strong>最大堆</strong>中，父节点的值比每一个子节点的值都要大。在<strong>最小堆</strong>中，父节点的值比每一个子节点的值都要小。这就是所谓的“堆属性”，并且这个属性对堆中的每一个节点都成立。 由此 最大堆的堆顶 是最大的，而最下的是某个叶节点，至于那个并不一定；最小堆 堆顶是最小的元素。</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>​        用数组来实现树相关的数据结构。它在时间和空间上都是很高效的。这点远优于二叉树，这 也是完全二叉树的特点。对于某个节点 i,其父节点和左右子节点 在数组中的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parent(i) &#x3D; floor((i - 1)&#x2F;2)</span><br><span class="line">left(i)   &#x3D; 2i + 1</span><br><span class="line">right(i)  &#x3D; 2i + 2</span><br></pre></td></tr></table></figure>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>​        插入就是先放在数组最后末尾，然后向前索引它的父节点，如果不满足堆的定义，就和父节点交换。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>​        通常是 pop 堆顶的元素。删除它，就将数组最后一个叶子节点拿过去 替换原本的节点，然后将它下沉 堆化。</p>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>​        哈夫曼（Huffman）编码算法是基于二叉树构建编码压缩结构的，它是数据压缩中经典的一种算法。算法<strong>根据文本字符出现的频率，重新对字符进行编码。因为为了缩短编码的长度，我们自然希望频率越高的词，编码越短，这样最终才能最大化压缩存储文本数据的空间</strong>。例如常规的 每个字符都是占一个/多个相同的数量的字节树，要存储 n 个字符就需要 kn 个字节的空间，这是等长编码。但是哈夫曼树是一种不等长编码，根据序列中不同字符出现频率不同，分别重新进行不等长编码，出现次数多的字符希望它单个字符占用的空间少，出现次数少的可以多一点。只不过哈夫曼树实现不等长编码使用的是 二叉树完成的。<br>​        另一个，不等长编码虽然是无损压缩节省存储空间，但是得保证  不出现歧义性，例如 00  0 分别表示两个字符ab，那么单看00可以有多种解释方法，而哈夫曼编码是一种<strong>前缀编码</strong>，不存在歧义。<br>​        前缀编码： 任意一个字符的编码都不是另一个字符的编码的前缀。</p>
<p><a href="https://www.cnblogs.com/penghuwan/p/8308324.html">https://www.cnblogs.com/penghuwan/p/8308324.html</a></p>
<h3 id="构建哈夫曼树"><a href="#构建哈夫曼树" class="headerlink" title="构建哈夫曼树"></a>构建哈夫曼树</h3><ul>
<li>将字符序列中，不同字符出现的频率按照 低到高排序，每个字符是一个节点。构建一个小顶堆（优先队列），保证每次取出的树的根节点的频率都是队列里最少的。</li>
<li>从优先队列中取出两个 节点（出现频率最少的两个），将他们合并构成一个二叉树，新的根节点的频率为 两个 节点的和，再将这个新的根节点入队</li>
<li>再从队列中取出两个节点（可能是之前已经合并过的树的根节点），再左右合并成一个新的树，将新的根节点入队</li>
<li>循环上述步骤直到只剩一棵树，完成哈夫曼树的构建。（此时所有字符都是树的叶子）</li>
<li>根据哈夫曼树对字符编码。叶节点中存储的字符 重新编码为 ，从根节点到叶节点的边构成的编码如下图</li>
</ul>
<p><img src="https://i.loli.net/2021/03/28/a5zYbvtFNHldpAs.png" alt="image-20201109222200118"></p>
<h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isEnd; <span class="comment">//该结点是否是一个串的结束</span></span><br><span class="line">    TrieNode* next[<span class="number">26</span>]; <span class="comment">//字母映射表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210419110553.png" alt="image-20210419110553476" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210419110622.png" alt="image-20210419110622319" style="zoom:67%;" />
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>基本数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>面经-数据结构相关</title>
    <url>/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E7%BB%8F-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>整理了面试中常问的数据结构相关的知识点</p>
<span id="more"></span>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="红黑树和AVL树的定义，特点，以及二者区别"><a href="#红黑树和AVL树的定义，特点，以及二者区别" class="headerlink" title="红黑树和AVL树的定义，特点，以及二者区别"></a>红黑树和AVL树的定义，特点，以及二者区别</h3><p>​        AVL树是平衡二叉搜索树，每个节点的左右子树的高度差不超过1，左右子树的高度做差称为平衡因子，平衡因子的取值只可能是 0 +-1 绝对值超过1的就不是平衡二叉树。<br>​        红黑树是以 一个数据位标记节点红黑颜色的树，也是二叉搜索树，每次插入和删除节点都要满足一定的着色规则，从而约束红黑树使得根节点到叶子节点的最长路径不超过最短路径的2倍。（每个节点非红即黑，根节点是黑色，每个叶节点是黑色，如果一个节点是红色，其子节点必须是黑，每条路径上黑色节点数目一致）</p>
<p>​        <strong>区别</strong>：红黑树是弱平衡二叉树，AVL 树由于平衡条件过于严格，导致每次插入或删除节点都容易使得平衡打破，需要频繁的旋转调整树，导致效率下降。所以在需要频繁插入或删除的应用场景，红黑树速度更快。<strong>红黑树插入节点最多旋转两次，删除节点最多旋转三次。</strong></p>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>​        哈夫曼编码是哈夫曼树的一种应用，用于数据的无损压缩。根据序列中字符出现频率，使用0/1来对字符重新编码。是一种不等长前缀编码，出现频率高的字符使用较多位空间编码。具体：</p>
<ol>
<li>哈夫曼树是一种自底向上构建表示的最优前缀二叉树T</li>
<li>算法以|C|个叶节点（每个叶节点表示一个字符）开始，经过C-1次合并运算产生最终要求的树。</li>
<li>构建步骤  … </li>
</ol>
<h3 id="map底层为什么用红黑树实现"><a href="#map底层为什么用红黑树实现" class="headerlink" title="map底层为什么用红黑树实现"></a>map底层为什么用红黑树实现</h3><p> 介绍AVL树定义特点,  介绍红黑树 定义特点</p>
<p>​        <strong>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。所以红黑树在查找</strong>，<strong>插入删除的性能都是O(logn)，且性能稳定</strong>，所以STL里面很多结构包括map底层实现都是使用的红黑树。</p>
<h3 id="介绍一下B-树"><a href="#介绍一下B-树" class="headerlink" title="介绍一下B+树"></a>介绍一下B+树</h3><p>​        B+树是一种多路搜索树，主要为磁盘或其他直接存储设备而设计的一种平衡查找树，因为磁盘相对内存而言读写速度慢，使用B+树相对二叉搜索树  每次 减少磁盘读写次数。B+树每个节点可有多个孩子，每个节点中的键值有序排列。所有值都存在叶节点中。相对B树有以下特点：</p>
<ul>
<li>内部节点不存数据，只存键值</li>
<li>叶子节点存放数据，且和相邻叶子节点构成有序链表</li>
<li>每个节点的最大子树个数M 则键值M  而 B树M M-1</li>
<li>….</li>
</ul>
<h3 id="说一说map和unordered-map的底层实现"><a href="#说一说map和unordered-map的底层实现" class="headerlink" title="说一说map和unordered_map的底层实现"></a>说一说map和unordered_map的底层实现</h3><p>​        map 的底层是基于红黑树实现的 因此map内部元素是有序的，且查找速度log(N)  而unordered_map是无序的底层基于 哈希实现，查找更快 接近常数级别，极端情况会O(N)</p>
<h3 id="map和unordered-map优点和缺点"><a href="#map和unordered-map优点和缺点" class="headerlink" title="map和unordered_map优点和缺点"></a>map和unordered_map优点和缺点</h3><p>对于map，其底层是基于红黑树实现的，优点如下：</p>
<ol>
<li>有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作</li>
<li>map的查找、删除、增加等一系列操作时间复杂度稳定，都为logn</li>
</ol>
<p>unordered_map</p>
<ol>
<li>内部基于哈希表，以（key,value）对的形式存储，因此空间占用率高</li>
<li>无序</li>
<li>Unordered_map的查找、删除、添加的时间复杂度不稳定，平均为O(c)，取决于哈希函数。极端情况下可能为O(n)</li>
</ol>
<h3 id="回答一下epoll怎么实现的"><a href="#回答一下epoll怎么实现的" class="headerlink" title="回答一下epoll怎么实现的"></a>回答一下epoll怎么实现的</h3><p><strong>epoll应用场景</strong>： 对于高连接的应用场景。例如 有上百万个用户通过TCP连接至服务器，但是每一时刻只有几十个或几百个TCP活跃（接受TCP包 ，需要内核完成读写文件操作）。那么epoll就是为了在此种场景下高效处理数据连接。在linux内核2.4以前，使用select 或者 poll事件驱动的方式实现。</p>
<p><strong>select</strong>: select的工作流程：创建socket－&gt;绑定端口bind－&gt;监听listen－&gt;accept-&gt;write/read。当有客户端连接到来时,select会把该连接的文件描述符放到 fd_set（文件描述符(fd)的集合  相当于数组）,然后select会循环遍历它所监测的 fd_set 内的所有文件描述符，如果没有一个资源可用(即没有一个文件描述符可以进行read/write可以操作)，则select让该进程阻塞的等待，一直等到有资源可用为止。而fd_set是一个类似于数组的数据结构，由于它每次都要遍历整个数组，所以它的效率会随着文件描述符的数量增多而明显的变慢，除此之外在每次遍历这些描述符之前，系统还需要把这些描述符集合从内核copy到用户空间，然后再copy回去，如果此时没有一个描述符有事件发生（例如：read和write）这些copy操作和便利操作都是无用功，可见slect随着连接数量的增多，效率大大降低。可见如果在高并发的场景下select并不适用，况且select默认的最大描述符为1024。</p>
<p><strong>epoll</strong>: Linux epoll机制是通过红黑树和双向链表实现的。 首先通过epoll_create()系统调用在内核中创建一个eventpoll类型的句柄，其中包括红黑树根节点和双向链表头节点。然后通过epoll_ctl()系统调用，向epoll对象的红黑树结构中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。最后通过epoll_wait()系统调用判断双向链表是否为空，如果为空则阻塞。当文件描述符状态改变，fd上的回调函数被调用，该函数将fd加入到双向链表中，此时epoll_wait函数被唤醒，返回就绪好的事件。</p>
<p><strong>总结</strong>： epoll 的机制感觉就是  充分利用了回调函数。使用一个红黑树 存储当前的所有感兴趣事件 （百万级别 很多休眠），而使用一个双向链表来存储 活跃连接。TCP开始活跃时 系统 在中断中调用事先注册的回调函数向 链表中添加 活跃事件。用户只用通过 epoll_wait() 去链表访问活跃事件的数据和id即可。  </p>
<h3 id="请你说一说Top-K-问题"><a href="#请你说一说Top-K-问题" class="headerlink" title="请你说一说Top(K)问题"></a>请你说一说Top(K)问题</h3><ul>
<li>直接排序法：直接调用一般的排序算法，对所有元素进行排序，然后去topK，这种方法效率低，对内存需求大，因为进行了很多无意义的排序。</li>
<li>基于快速排序的变形：根据快排的思想，每次从待排列的数据中随机选取一个作为 参考数据，将比他大的放在它的右边，小的放左边，分组完成后，如果基准元素右侧的个数n=K，完毕；如果n&gt;K，则重新对左边数据进行一次相同的分组操作；如果基准元素右侧的元素个数n&lt; K，则重新对左边数据进行一次相同的分组操作，此时K=K-n；</li>
<li>基于堆排序的思路：首先构建一个含有 K 个元素的小顶堆，每次读入数据和堆顶数据比较，如果小于它直接pass，否则删除堆顶元素并将其入堆。遍历完成后，堆中数据即为TopK</li>
<li>分治法：</li>
<li>Hash 法：对于含有大量重复元素的数据，可以先通过hash法把重复的数去掉。这样可以减小很多的不必要计算</li>
</ul>
<h3 id="请你说一说C-两种map"><a href="#请你说一说C-两种map" class="headerlink" title="请你说一说C++两种map"></a>请你说一说C++两种map</h3><p>unordered_map  (Hash) 和  map (红黑树)</p>
<h3 id="请你说一说红黑树的性质还有左右旋转"><a href="#请你说一说红黑树的性质还有左右旋转" class="headerlink" title="请你说一说红黑树的性质还有左右旋转"></a>请你说一说红黑树的性质还有左右旋转</h3><p><a href="https://blog.csdn.net/weixin_43939593/article/details/104420724?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159021709219725211930470%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=159021709219725211930470&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v1~rank_blog_v1-1-104420724.pc_v1_rank_blog_v1&amp;utm_term=%E7%BA%A2%E9%BB%91%E6%A0%91">https://blog.csdn.net/weixin_43939593/article/details/104420724?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159021709219725211930470%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=159021709219725211930470&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v1~rank_blog_v1-1-104420724.pc_v1_rank_blog_v1&amp;utm_term=%E7%BA%A2%E9%BB%91%E6%A0%91</a></p>
<h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><h3 id="说一说你理解的stack-overflow"><a href="#说一说你理解的stack-overflow" class="headerlink" title="说一说你理解的stack overflow"></a>说一说你理解的stack overflow</h3><p>​        栈溢出概念：栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变。</p>
<p>​        栈溢出得原因：</p>
<ul>
<li>局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。局部变量是存储在栈中的，因此这个很好理解。解决这类问题的办法有两个，一是增大栈空间,二是改用动态分配，使用堆（heap）而不是栈（stack）。</li>
<li>递归调用的层数太多。递归函数在运行的时候会执行压栈操作。当压栈次数太多时，也会导致堆栈溢出。</li>
<li>数组指针越界</li>
</ul>
<h3 id="栈和堆的区别，以及为什么栈要快"><a href="#栈和堆的区别，以及为什么栈要快" class="headerlink" title="栈和堆的区别，以及为什么栈要快"></a>栈和堆的区别，以及为什么栈要快</h3><p>区别：</p>
<ol>
<li>地址生长方向，栈是由高地址向低地址，堆反之</li>
<li>分配方式：栈是系统自动分配内存，有硬件实现，存放局部变量参数等。而堆是人为实现的一种结构，需要手动申请和释放内存。</li>
<li>栈由于其先进后出的特性，不会产生内存碎片</li>
<li>栈高效</li>
</ol>
<p><strong>栈高效的原因</strong>：栈是操作系统提供的数据结构，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行；而堆是由C/C++函数库提供的，机制复杂，需要一些列分配内存、合并内存和释放内存的算法，因此效率较低。</p>
<h3 id="手写代码，两个栈实现一个队列"><a href="#手写代码，两个栈实现一个队列" class="headerlink" title="手写代码，两个栈实现一个队列"></a>手写代码，两个栈实现一个队列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.<span class="built_in">push</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.<span class="built_in">size</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = stack2.<span class="built_in">top</span>();</span><br><span class="line">        stack2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(stack1.<span class="built_in">size</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = stack1.<span class="built_in">top</span>();</span><br><span class="line">        stack1.<span class="built_in">pop</span>();</span><br><span class="line">        stack2.<span class="built_in">push</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<h3 id="小根堆特点"><a href="#小根堆特点" class="headerlink" title="小根堆特点"></a>小根堆特点</h3><ol>
<li>堆是一个完全二叉树，除最后一层外，其他的都得是满的</li>
<li>小顶堆，父节点总是小于他的左右子节点的值，因此堆顶的元素最小。大顶堆相反。</li>
</ol>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h3><p>数组的特点：数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。数组的插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。但数组的随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。并且数组不利于扩展，数组定义的空间不够时要重新定义数组。</p>
<p>链表的特点：链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。比如：上一个元素有个指针指到下一个元素，以此类推，直到最后一个元素。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表数据结构了。不指定大小，扩展方便。链表大小不用定义，数据随意增删。</p>
<p>数组的优缺点：</p>
<ol>
<li>随机访问性强</li>
<li>查找速度快</li>
<li>插入和删除效率低</li>
<li>数组大小固定，不能动态拓展   可能浪费内存</li>
<li>内存空间要求高，必须有足够的连续内存空间。</li>
</ol>
<p>链表的优缺点：</p>
<ol>
<li> 插入删除速度快</li>
<li>内存利用率高，不会浪费内存</li>
<li>大小没有固定，拓展很灵活。</li>
<li>不能随机查找，必须从第一个开始遍历，查找效率低</li>
</ol>
<h3 id="判断有无重复数"><a href="#判断有无重复数" class="headerlink" title="判断有无重复数"></a>判断有无重复数</h3><p>​        一个长度为N的整形数组，数组中每个元素的取值范围是[0,n-1],判断该数组否有重复的数，请说一下你的思路并手写代码</p>
<p>思路： 把每个数放到自己对应序号的位置上，如果其他位置上有和自己对应序号相同的数，那么即为有重复的数值。时间复杂度为O(N),同时为了节省空间复杂度，可以在原数组上进行操作，空间复杂度为O(1)</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="手写快排的代码"><a href="#手写快排的代码" class="headerlink" title="手写快排的代码"></a>手写快排的代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="海量数据如何去取最大的k个"><a href="#海量数据如何去取最大的k个" class="headerlink" title="海量数据如何去取最大的k个"></a>海量数据如何去取最大的k个</h3><ul>
<li>基础的对所有元素进行排序，效率不高，因为只用求K大 并不需要对所有元素排序</li>
<li>快排的变形，选取基准数，左右分区，如果右边比基准数大的个数不等于K，根据与K的大小关系选择是对基准数左半部分or右半部分数递归求K-N or K 大。</li>
<li>最小堆法。首先建立一个含有K个元素的最小堆，每次取序列中的元素与堆顶元素比，如果比堆顶元素大，将堆顶元素弹出，改元素入堆，如果小，就说明他肯定不是K大中的一个，跳过。依次遍历到结束，最后堆中的元素就是topK</li>
<li>分治法：将所有元素分为N 分，如果每份的元素数量可以放入内存，就分别对每份找出前K大，否则继续分治处理。最后每份挑出了K个，一共有N*K个元素，可以使用快排的变形找出前K个。</li>
<li>Hash法：对于含有大量重复元素，使用Hash去重，如果剩下元素可以读入内存了，就直接排序，否则可以使用分支法读入内存在处理或者堆法。</li>
</ul>
<h3 id="快排的时间复杂度最差是多少？什么时候时间最差"><a href="#快排的时间复杂度最差是多少？什么时候时间最差" class="headerlink" title="快排的时间复杂度最差是多少？什么时候时间最差"></a>快排的时间复杂度最差是多少？什么时候时间最差</h3><p>元素倒序，O(n^2)</p>
<h3 id="什么是稳定性排序"><a href="#什么是稳定性排序" class="headerlink" title="什么是稳定性排序"></a>什么是稳定性排序</h3><p>对于相等的元素，排序前后相对顺序不变</p>
<h3 id="快排算法最差情况推导公式"><a href="#快排算法最差情况推导公式" class="headerlink" title="快排算法最差情况推导公式"></a>快排算法最差情况推导公式</h3><p>一般的快排中的基准元素选取的为 最左边或者最右边的元素。<br>当选取最左边元素作为基准，而序列原本又是正序的时候，每次左右分拨都要挨个交换位置，就和冒泡排序类似；所以O(n^2)<br>反之当选取最右边基准…倒序…..；<br>当元素都相同时</p>
<p>所以可以随机选择基准元素，降低出现最坏情况的概率    </p>
<h3 id="稳定排序哪几种"><a href="#稳定排序哪几种" class="headerlink" title="稳定排序哪几种"></a>稳定排序哪几种</h3><p>插入法，冒泡排序，归并排序，计数排序，基数排序，桶排序</p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="hash表的实现，包括STL中的哈希桶长度常数"><a href="#hash表的实现，包括STL中的哈希桶长度常数" class="headerlink" title="hash表的实现，包括STL中的哈希桶长度常数"></a>hash表的实现，包括STL中的哈希桶长度常数</h3><p>主要包含两部分，一是Hash函数构造由key的值使用Hash函数处理的得到地址。另一个是处理Hash冲突</p>
<p>前者构造Hash的方法主要有  直接地址法，平方取中法，除留余数法<br>后者的方法有：开放地址法，链地址法，再Hash法，建立公共溢出区等方法</p>
<p>使用链地址法不一定必须满足 桶的个数为质数….？</p>
<h3 id="解决hash冲突的方法"><a href="#解决hash冲突的方法" class="headerlink" title="解决hash冲突的方法"></a>解决hash冲突的方法</h3><p>​        当不同经过hash产生相同的地址时，即差生hash冲突。此时解决的方法有如下：</p>
<ul>
<li>开放地址：所谓开放地址，就是当hash过后 地址重复了之后，按照一定的规律从当前地址往其他地方搜索表中的空内存区 （Hi = H(key + di)）。根据寻址扩展的规律分为如下。产生新地址的方法能覆盖所有表区，免得内存浪费。再读取时，如果在Hash的地址找不到对应的元素，那么就按照指定的寻址方式往其他内存寻找元素对比key，找到表尾也没找到说明不存在。<ol>
<li>线性探查：di = c x i  就是地址线性往后递增 （注意对表长取余了 所以会循环 可以覆盖所有区域）</li>
<li>二次探查： di = + - i^2  就是平方规律分别向前和向后探测</li>
<li>伪随机探测：di 是一组伪随机数</li>
</ol>
</li>
<li>链地址：向指定地址插入Hash值时，如果该地址已有元素，桶内使用链表存储新增的数据。那么在读取的时候也是遍历链表找到对应的key的内容。</li>
<li>公共溢出区：建立一个公共溢出区域，把hash冲突的元素都放在该溢出区里。查找时，如果发现hash表中对应桶里存在其他元素，还需要在公共溢出区里再次进行查找。</li>
<li>再hash：再散列法其实很简单，就是再使用哈希函数去散列一个输入的时候，输出是同一个位置就再次散列，直至不发生冲突位置。每次冲突都要重新计算散列，计算时间增加。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210413153208.png" alt="image-20201117201021698"></p>
<h3 id="哈希表的桶个数为什么是质数"><a href="#哈希表的桶个数为什么是质数" class="headerlink" title="哈希表的桶个数为什么是质数"></a>哈希表的桶个数为什么是质数</h3><p>​        哈希表的桶个数使用质数，可以最大程度减少冲突概率，使哈希后的数据分布的更加均匀。如果使用合数，可能会造成很多数据分布会集中在某些点上，从而影响哈希表效率。<br>​        例如常用的Hash函数是标准的求模函数，质数的因数只有1和它本身，合数不止。例如 6 和 7  ，当Hash数是2/3的时候，6%2 = 6%3=0  也就是经过取模Hash后  Key=2/3在同一个地址了。</p>
<h3 id="hash表如何rehash-怎么处理其中保存的资源"><a href="#hash表如何rehash-怎么处理其中保存的资源" class="headerlink" title="hash表如何rehash  怎么处理其中保存的资源"></a>hash表如何rehash  怎么处理其中保存的资源</h3><p>Hash表中有个负载因子，代表 存储数据长度 / 表的长度。负载因子越大，查找复杂度就越大。每次往表中装载数据要保证负载因子 &lt; 1否则就需要rehash，保证可以装载成功。rehash过程类似数组扩容，开辟一个新的原桶数组的两倍大的空间，并把原本的桶的数组中的元素全部重新Hash到新的Hash桶数组中。</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="手写代码：最长公共连续子序列"><a href="#手写代码：最长公共连续子序列" class="headerlink" title="手写代码：最长公共连续子序列"></a>手写代码：最长公共连续子序列</h3><h3 id="手写代码：求一个字符串最长回文子串"><a href="#手写代码：求一个字符串最长回文子串" class="headerlink" title="手写代码：求一个字符串最长回文子串"></a>手写代码：求一个字符串最长回文子串</h3><h3 id="手写代码：查找最长回文子串"><a href="#手写代码：查找最长回文子串" class="headerlink" title="手写代码：查找最长回文子串"></a>手写代码：查找最长回文子串</h3><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="手写代码，如何合并两个有序链表"><a href="#手写代码，如何合并两个有序链表" class="headerlink" title="手写代码，如何合并两个有序链表"></a>手写代码，如何合并两个有序链表</h3><h3 id="手写代码：反转链表"><a href="#手写代码：反转链表" class="headerlink" title="手写代码：反转链表"></a>手写代码：反转链表</h3><h3 id="手写代码：判断链表是否为回文"><a href="#手写代码：判断链表是否为回文" class="headerlink" title="手写代码：判断链表是否为回文"></a>手写代码：判断链表是否为回文</h3><h3 id="什么是单向链表"><a href="#什么是单向链表" class="headerlink" title="什么是单向链表"></a>什么是单向链表</h3><h3 id="判断两个单向链表是否相交"><a href="#判断两个单向链表是否相交" class="headerlink" title="判断两个单向链表是否相交"></a>判断两个单向链表是否相交</h3><h2 id="高级算法"><a href="#高级算法" class="headerlink" title="高级算法"></a>高级算法</h2><h3 id="加密方法有那些"><a href="#加密方法有那些" class="headerlink" title="加密方法有那些"></a>加密方法有那些</h3><h3 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h3><h3 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h3>]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>基本数据结构</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>算法和数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的面试题</title>
    <url>/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/c.%20%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>记录了CS-NOTE中整理的高频面试题，把不会写的单独记录下来了</p>
<span id="more"></span>

<h4 id="数组中的重复数字"><a href="#数组中的重复数字" class="headerlink" title="数组中的重复数字"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/submissions/">数组中的重复数字</a></h4><ul>
<li>这道题可以用判断环的方法找 环的起点 </li>
<li>通过swap的方式 swap(nums[i], nums[nums[i]]) 将数组还原为 num[i] = i  若遇到 num[i] == nums[nums[i]] 则为重复的数字。</li>
</ul>
<h4 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">二维数组中的查找</a></h4><p>​        类似双指针的 使用方式之一，不过不是 二分查找，而是 设置行列指针，选取矩阵右上角为起点，这样行指针往左移，列指针往下移，数据分别边小，变大。<strong>核心思想就是两个指针都是单方向移动，且指向的数据变化趋势是相反变化的，这样依次判断 和target的大小关系只能 有一个放行的指针移动。</strong></p>
<h4 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">替换空格</a></h4><p>​        主要在于 如果只能在原字符上操作，首先遍历判断空格数量，将源字符串扩容 + i x 2；接着从字符串末尾两个指针，依次从后向前填充。例如 原本 “ss ss” -&gt;“ss ss  ”</p>
<h4 id="二叉树的下一个结点-https-cyc2018-github-io-CS-Notes-notes-8-二叉树的下一个结点"><a href="#二叉树的下一个结点-https-cyc2018-github-io-CS-Notes-notes-8-二叉树的下一个结点" class="headerlink" title="[二叉树的下一个结点](https://cyc2018.github.io/CS-Notes/#/notes/8. 二叉树的下一个结点)"></a>[二叉树的下一个结点](<a href="https://cyc2018.github.io/CS-Notes/#/notes/8">https://cyc2018.github.io/CS-Notes/#/notes/8</a>. 二叉树的下一个结点)</h4><p>​    1. 该节点没有有子节点。当它有右子节点时，中序遍历接在它后面输出的节点应给是 它子树的最左边的叶子节点</p>
<pre><code>         2. 该节点没有子节点。这时就要回溯了，一直找到它父节点，知道它是父节点的左子树为止。 具体要参照中序遍历的输出规律。好理解
</code></pre>
<h4 id="矩形填充"><a href="#矩形填充" class="headerlink" title="矩形填充"></a><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">矩形填充</a></h4><p><img src="https://i.loli.net/2021/03/28/aMROkmxHqfGSeX9.png" alt="image-20200912171353588"></p>
<p>f(n) = f(n-1) +  f(n-2) 斐波拉西</p>
<p><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">青蛙跳台阶</a></p>
<p>​        这个和上一道一样，状态方程在于  看青蛙 最后一步是跳一步 还是 最后一次一下子跳两步，就转换为 斐波拉西数列。最后(a + b)%c = (a%c + b%c)%c。</p>
<p><a href="https://cyc2018.github.io/CS-Notes/#/notes/12.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84">矩阵中的最小路径</a>    </p>
<p>​        考点是 回溯算法，使用深度优先遍历实现回溯。回溯 和 单纯的优先遍历的区别 在于 回溯在每次试探性的前进之后有条件 判断 剪纸。如果沿着某一方向下去 不满足条件 马上返回 ，并且需要还原 之前的状态</p>
<p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">机器人的运动范围</a></p>
<p>​        这题就套用DFS BFS模板即可</p>
<h4 id="减绳子"><a href="#减绳子" class="headerlink" title="减绳子"></a><a href="./leecode%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">减绳子</a></h4><h4 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/c-cheng-fa-kuai-su-mi-by-yizhe-shi/">数值的整数次方</a></h4><p>​        这个题考察的是 快速 幂乘法，a^N  = axaxa…xa 这样直接一个个乘肯定是很慢的，会超时。将N 转换为 二进制表示。如N = 9，则a^9 = a^(1001) = a^(1x8+0x4+0x2+1x1)^ = a^1^  x a^0x2^ x a^0x4^ x a^1x8^ ; 循环 计算  a = a*a；即 计算了 a^0^  a^2^   a^4^… 对于N的二进制 为1的位置 就乘进结果，为0 的就乘1。    </p>
<h4 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/shi-pin-tu-jie-dong-tai-gui-hua-zheng-ze-biao-da-s/">正则表达式匹配</a></h4><p>​        动态规划。f[i] [j] 表示字符串 s (目标字符串) 的 前 i  个 字符 和 p (正则字符串) 的前 j 个字符 匹配的状态。那么对于<br>f[i] [j]  当 p[j]  不是 “*” 时就很简单 只用看  i-1 j-1 的状态 和 s[i]  与 s[j] 是否匹配（相等或者为‘.’）即可。复杂的是 当 p[j] 为※号时的情况。如果 ※号的用法可以分为两类： 1. 他前面一个字符出现0次，就是消掉他，那么  f[i] [j]  的状态由 f[i] [j-2]决定。 2. ✳将他前面的字符重复1-n次的情况。此时 若 s[i] 和 p[j-1] 匹配,例如都等于a，那么就由  f[i-1] [j] 状态决定，此时相当于 s[i-1] 后面再加一个 a 此时 ✳再复制一次即可 所以状态取决于 f[i-1] [j] </p>
<p><img src="https://i.loli.net/2021/03/28/VFQRBkwazWuAI7s.png" alt="image-20200914202819724"></p>
<h4 id="删除链表倒数第K个节点"><a href="#删除链表倒数第K个节点" class="headerlink" title="删除链表倒数第K个节点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/submissions/">删除链表倒数第K个节点</a></h4><p>​        核心的 使用快慢指针 先将快指针 从头往后移动K个，再二者一起 往后移动 ，知道快指针为NULL 责慢指针停下的地方就是 了。为了排除 边界情况 可以在链表头加一个 哑铃节点，然后 每次让慢指针停在 待删除节点的前一个节点。这样就不用备份慢指针的父节点啦。</p>
<h4 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/fan-zhuan-lian-biao-yi-dong-de-shuang-zhi-zhen-jia/">链表反转</a></h4><ol>
<li>双指针，两个相邻的指针，每次反转一个。一个初始化为NULL 另一个为头指针 </li>
<li>递归 / 栈 </li>
</ol>
<h4 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></h4><p>​        递归！！！！</p>
<h4 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">顺时针打印矩阵</a></h4><p>​        使用的深度优先遍历 + 减枝  速度较慢。反正都是暴力</p>
<h4 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/submissions/">包含min函数的栈</a></h4><p>​        要求O(1)的时间复杂度取出 栈中的最小值（不是每次都删除最小值），使用一个辅助的栈来将最小的保存在栈顶。当push进一个数时，如果 比当前栈顶最小的 小 那么就进入这个辅助栈…..   <strong>单调栈</strong>  </p>
<h4 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">栈的压入、弹出序列</a></h4><p>​        用一个栈 模拟 出栈操作，如果最后栈空，则OK。首先读取push数组中的一个数，并加入堆栈，如果它和pop数组中的数相同，则马上将其出栈，并将 push 数组指针滑动。</p>
<h4 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">二叉搜索树的后序遍历序列</a></h4><pre><code>    1. 递归  分治法。抓住 后续遍历 和  搜索树的特点

         2. 单调栈 
</code></pre>
<h4 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">二叉树中和为某一值的路径</a></h4><p>​    前序遍历 先判断是不是 和满足要求 且到达叶子节点 是   这里 的技巧 可以在 遍历完左右子节点后 再将当前节点的值出栈。这样不用来回拷贝vector 省时间</p>
<h4 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">复杂链表的复制</a></h4><p>​        Hash表 保存 每个节点 和 新new的节点的对应   遍历两编链表 第一遍 new 拷贝所有节点 并 map 第二次遍历 链接节点</p>
<h4 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">二叉搜索树与双向链表</a></h4><p>​        首先 二叉搜索树 -&gt; 有序双向链表。就能想到中序遍历。暴力的方法是，首先中序遍历将所有节点存下来，然后链接。也可以在中序遍历的时候进行 指针的转换，这样只用遍历一次，而这样的难点就是如何 在中序遍历中转换指针的指向。<br>​        申请两个 节点指针，pre  和 cur  pre指向上一次遍历指向的节点，cur为当前遍历指向的节点。初始 pre 初始为 dummy指针。在中序遍历的位置完成 pre 和 cur 左右节点的指向，同时更新 pre 的指向：（可以看出 在中序遍历回到节点时，此时已经完成 左子节点的遍历，因此左指针可以修改。此时也确实只修改了左指针） 最后  使用dummy指针找到节点头。最后的cur指针指向的是最后一个访问的节点，即节点的尾。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">       <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">cur = root;         <span class="comment">// 变更开始时更新 cur</span></span><br><span class="line">pre -&gt; right = cur; <span class="comment">// 变更左右指针的指向， 符合双向链表的指针指向， 即当节点有一个指针指向前一个节点， 前一个节点也有一个指针指向当前节点</span></span><br><span class="line">cur -&gt; left = pre;</span><br><span class="line">pre = root;         <span class="comment">// 变结束后更新 pre ， 以便下一次使用</span></span><br><span class="line"><span class="built_in">dfs</span>(root-&gt;right);</span><br></pre></td></tr></table></figure>

<h4 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">数组中出现次数超过一半的数字</a></h4><p>​        使用Hash法 空间复杂度O(N)  时间复杂度 O(N)    由于 题目说某个数字的个数出现次数大于一半，那么可以使用 一个计数变量，当遇到相同的数字+1  否则-1 当减为负，这个数字就是当前遍历的中最多的。而遍历完，这个指向数字一定是 最多的。</p>
<h4 id="最小的k个数-https-leetcode-cn-com-problems-zui-xiao-de-kge-shu-lcof"><a href="#最小的k个数-https-leetcode-cn-com-problems-zui-xiao-de-kge-shu-lcof" class="headerlink" title="最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)"></a>最小的k个数](<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/</a>)</h4><p>​        这道题的考点是 快排中分治的思想 或者  优先队列（二叉堆）。二叉堆的基本性质是 堆顶 元素 top 总是最大/最小的。因此构建一个含有K个元素的 优先队列，依次读取剩下的元素，若比堆顶小，则弹出堆顶元素并 将新元素入堆….<br>​        类似解决 topK 的题都是这两种思路 最好。快排的思想是 当前选取一个基准数，然后比他大的和小的 各放一边…..</p>
<h4 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">数据流中的中位数</a></h4><pre><code>    1. 第一中方法是 每次插入 都保持 数组有序，使用二分法插入元素。取中位数的时候 就直接取中间即可。查找O(logn) + insert(O(n)) =插入新数据一共 O(n)。

         2. **使用优先队列的方式**。构建一个大顶堆和一个小顶堆。大顶堆保存中位数左边较小的 数据，小顶堆保存中位数右边较大的数据。每次插入新数据，先将其加入大顶堆，再将大顶堆的最大数据弹出 加入小顶堆；然后判断一下两个堆的大小，保证大顶堆的数据量&gt;小顶堆的。求中值的时候，奇数个数据就是 大顶堆数据 最大的那个 4，3  偶数二者平均。 加入新数据 时间复杂度 O(logn)  
</code></pre>
<p><img src="https://i.loli.net/2021/03/28/HNhUWojJM6A1tsx.png" alt="image-20200917215844317"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; lo;                              <span class="comment">// 大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; hi;   <span class="comment">// 小顶堆</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Adds a number into the data structure.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lo.<span class="built_in">push</span>(num);                                    <span class="comment">// 加到大顶堆</span></span><br><span class="line"></span><br><span class="line">        hi.<span class="built_in">push</span>(lo.<span class="built_in">top</span>());                               <span class="comment">// 平衡</span></span><br><span class="line">        lo.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lo.<span class="built_in">size</span>() &lt; hi.<span class="built_in">size</span>()) &#123;                     <span class="comment">// 维护两个堆元素个数</span></span><br><span class="line">            lo.<span class="built_in">push</span>(hi.<span class="built_in">top</span>());</span><br><span class="line">            hi.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the median of current data stream</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lo.<span class="built_in">size</span>() &gt; hi.<span class="built_in">size</span>() ? (<span class="keyword">double</span>) lo.<span class="built_in">top</span>() : (lo.<span class="built_in">top</span>() + hi.<span class="built_in">top</span>()) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="数字-1-的个数"><a href="#数字-1-的个数" class="headerlink" title="数字 1 的个数"></a><a href="https://leetcode-cn.com/problems/number-of-digit-one/">数字 1 的个数</a></h4><p>​        这是个找规律的题目</p>
<h4 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">把数组排成最小的数</a></h4><p>​        排序 对于 相同长度的字符串，直接 从高位到低位，小的字符排在前面。对于不同长度的字符串a, b   比较 a+b b+a 大小即可。就是正反组合 产生的新的字符的相互比较。</p>
<h4 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">把数字翻译成字符串</a></h4><p>​        动态规划</p>
<h4 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">礼物的最大价值</a></h4><p>​        动态规划  二维dp  每个位置的最大礼物价值只由它的 左边 和 上边 格子的最大数 的较大者决定。</p>
<h4 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a><a href="https://leetcode-cn.com/problems/chou-shu-lcof/">丑数</a></h4><p>​        首先，判断一个数n是不是丑数，就看 n能否被 分解为多个 2 or 3 or 5 相乘的形式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(n!=<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>) n/=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">5</span>==<span class="number">0</span>)	n/=<span class="number">5</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">0</span>) n/=<span class="number">3</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        但是要输出 第n个丑数，暴力遍历从1开始的所有整数 计算 是否为丑数 然后累加到n停止，虽然可以使用备忘录的方法 加速计算，即如果  k/2 为丑数 那么 k 也为丑数，但是依然会超时。<br><img src="https://i.loli.net/2021/03/28/X2iSloYLq1yJWe4.png" alt="image-20200922213736488">        </p>
<h4 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">数组中的逆序对</a></h4><p>​        使用 归并排序的 方法。 分治的思想。在 归并排序中，每次 将数组划分为左右 两半 部分 分别 sort 然后再 merge 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> lf, <span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lf &gt;= rt)     <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (lf + rt) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, tmp, lf, mid);   <span class="comment">//递归的调用归并排序  排序后  左半部分 和 右半部分都是有序的</span></span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, tmp, mid+<span class="number">1</span>, rt);</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = lf, j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= rt)&#123;   <span class="comment">// 双指针将两个有序的 左右半部分合并为一个有序的数组，此时需要一个缓存数组 tmp</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= nums[j])&#123;</span><br><span class="line">                tmp[pos++] = nums[i++];   </span><br><span class="line">            &#125;<span class="keyword">else</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                cnt+=mid-i+<span class="number">1</span>;            <span class="comment">//  相对归并排序增加的一个计数变量  </span></span><br><span class="line">                tmp[pos++] = nums[j++];  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">            tmp[pos++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=rt)&#123;</span><br><span class="line">            tmp[pos++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = lf; i &lt;= rt; i++)&#123;  <span class="comment">// 将tmp的内容再存储到num中</span></span><br><span class="line">            nums[i] = tmp[i-lf];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, tmp, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">两个链表的第一个公共节点</a></h4><p>​        这个题 暴力的是查询的算法，但是时间空间复杂度较低，最好的是双指针算法。两个指针分别从A,B开始遍历，到达终点后就换个起点接着遍历。最终二者相遇的地方便是交点.</p>
<h4 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">数组中数字出现的次数</a></h4><p>​        这个题用 异或 做  异或的性质</p>
<p><img src="https://i.loli.net/2021/03/28/mQfvBUKTstk4xGa.png" alt="image-20200923110415455"></p>
<p>​        如果对于一个数组 只有一个数字出现了 一次,其他数字都出现了两次，找出这个单独的数字。根据异或的性质，全员异或 最终的结果便是这个单独的数字。而此题是有两个不同的单独的数字，要找出这两个。最直观的想法是，将这两个不同的数字分别放在两组，然后每组中除了 这个单独的数字就是其他成对的数字，这就退化成了 第一个问题。即要求分组的数字 有以下性质：</p>
<ol>
<li>两个不同的数字分别被分到不同的组</li>
<li>每组中 除了一个不同的数字 其他的都是成对的 这样组内 全员异才能满足 最终的结果是不同的那个。</li>
</ol>
<p>​        如何分组？首先全员异或，结果肯定是 两个不同的数字异或的 结果。而这两个数字异或结果为1 的位  代表这两个数字 该位 不同，一个为1 另一个必定为0。例如 011 111 异或， 100 则第三位肯定不同。这样根据该位的值来分组 可以很好的分开这两个数字到不同组，对于其他数，相同的 该位 也一定相同，也一定在一个组。由此两个条件都满足。所以这样分组，再组内异或 分别就找出了两个不同的单数字。</p>
<p>​        <strong>而解决此类 除了 除了某个元素出现一次 其余均出现 m 次的问题</strong> 都可以统计 二进制各个位元素为1的个数，如果个数 % m 有余数，那么表明该位 是不同的那个数字为 1 的位置。 </p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><a href=".%5Cleecode%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">平衡二叉树</a></h4><h4 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">滑动窗口的最大值</a></h4><p>​        这道题考察<strong>有序队列</strong>。实现有序队列  要结合 c++ 标准库中的 deque 双端队列，即可以从前 也可以从后插入删除数据。对于队列，如果后进去的数据 比我队列尾端的数据小，就直接放在它后面，如果比他大，就将原本尾部的数据弹出，直到遇到比他大的数据，再将其放进去。这样 队列头部一定是当前队列的最大数据。删除的时候，只用判断当前要出对队的元素是不是和 头部的相同，相同就弹出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span> <span class="comment">//单调队列（从大到小）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; que; <span class="comment">// 使用deque来实现单调队列</span></span><br><span class="line">    <span class="comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span></span><br><span class="line">    <span class="comment">// 同时pop之前判断队列当前是否为空。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span> <span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。 </span></span><br><span class="line">    <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span> <span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value &gt; que.<span class="built_in">back</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">push_back</span>(value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="comment">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span></span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="n个骰子的点数"><a href="#n个骰子的点数" class="headerlink" title="n个骰子的点数"></a><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">n个骰子的点数</a></h4><p>​        直接动态规划  或者  递归+dp备忘录减枝 (因为直接递归有大量的重复计算)</p>
<p><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/"> 圆圈中最后剩下的数字</a></p>
<p>​        首先， 考虑一种规律。对于一个圈 不管起点是从哪个点开始，假设是 2，最终最后一个留下的是第3个，那么 如果此时开始的位置 为3，那么最后剩下的位置就是 4 （此时不考虑成环返回的问题），因为其实所有数字围成一个圆圈，处处堆成，起始位置和最终位置肯定是保持一个相对的位置关系。</p>
<p>​        如果 假设 f(n-1, m) = x  代表第n-1个数，从0开始，m个删除一次，最终剩下的数的位置 是 x；考虑 f(n, m) 的关系。n个数，在第一次删除，即去掉 第 m -1 个数后(起点是从0开始)，就剩下 n-1 个数了，此时就退化为 f(n-1, m) 了只不过，这里n-1的起点是 m%n （删除了第 m%n-1个数，就从第m%n个数开始）。根据上面的规律，f(n, m) = (x + m%n) % n。起点相对 f(n-1) 的 0  变为 m  终点也应该相对 x 向后 + m，由于是环，所以 % n </p>
<h4 id="求1-2-…-n"><a href="#求1-2-…-n" class="headerlink" title="求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">求1+2+…+n</a></h4><p>​        判断，循环语句等不能用。使用递归求和  但是需要有判断 递归停止的条件，<strong>可以使用 &amp;&amp; 逻辑运算符</strong> 替代 判断。当递归的返回值 n 为 0 就开始 return </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        n &amp;&amp; (n += <span class="built_in">sumNums</span>(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">不用加减乘除做加法</a></h4><p>​        使用位运算 比较简单</p>
<ul>
<li><p>计算机中 申请一个 int 型的 变量，它在内存中直接存的 补码。因此此题只用将两个数 按照加法的逻辑计算即可，不需要再转补码了。  </p>
<p>  位运算  两个数相加  可以分为两部分 ： 无进位和 + 进位  满足以下规律：</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/03/28/yPMmYSpuXVrzJ6x.png" alt="image-20200924203153740"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;   <span class="comment">//当进位 为  0 时 就停止递归 计算结束</span></span><br><span class="line">        <span class="keyword">return</span> b ? <span class="built_in">add</span>(a^b, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a&amp;b)&lt;&lt;<span class="number">1</span>) : a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>相关的编程题汇总-动态规划</title>
    <url>/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/leecode_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>记录了动态规划类的题目</p>
<span id="more"></span>

<h1 id="动态规划类题目"><a href="#动态规划类题目" class="headerlink" title="动态规划类题目"></a>动态规划类题目</h1><h2 id="数组类"><a href="#数组类" class="headerlink" title="数组类"></a>数组类</h2><h4 id="等差数列划分"><a href="#等差数列划分" class="headerlink" title="等差数列划分"></a><a href="https://leetcode-cn.com/problems/arithmetic-slices/">等差数列划分</a></h4><p>​        关键是  对于一个等差数列  例如 -1, 0, 1, 2, 3 这个数列  第2个开始  等差子数列个数 为 1  依次为  2+1=3   3+2+1=6  可以理解为  当只有三个元素时 子序列就只有 他本身1个，当有四个元素时，子序列总个数分为以下两部分（含有三个元素的子序列个数   +  含有四个元素子序列的个数） 前者就为 上一次的个数 + 1  后者就为上上次的个数。以此类推 如若 有 五个元素的等差数列 那么子序列的个数 就为  3 + 2 + 1 （三个元素的，四个元素的，五个元素的子序列）所以 dp[i] = dp[i-1] +1 ; all_cnt = dp 求和 （非等差序列的位置的dp = 0）</p>
<h4 id="连续子数组和"><a href="#连续子数组和" class="headerlink" title="连续子数组和"></a>连续子数组和</h4><p><img src="https://i.loli.net/2021/03/28/UaJ4dIolSTCO7bh.png" alt="1597909311300"></p>
<p>​        基本方法是积分法，记录每个位置的前面所有元素和。基于此将子区间的所有元素求和转化为求差，两元素的差等整除K 就相当于两元素对k的余数相同。判断相同 这里用了哈希表的方法。</p>
<h4 id="点数删除与获得"><a href="#点数删除与获得" class="headerlink" title="点数删除与获得"></a>点数删除与获得</h4><p><img src="https://i.loli.net/2021/03/28/d53VscIon614MfU.png" alt="1598010356430"></p>
<p>​        主要思想是 构建上面 那个 all数组，就将状态转移函数简化了很多。all数组的含义是 对数组中的每个整数元素 的 计数，数组的下标代表 元素i 。例如 all[1] 代表 数组中元素1 的个数。如果没有则为0。 这样 dp 的每个状态的切换只在相邻的两个下标发生，dp[i]  与 dp[i-2]没有关系。这样简化了状态转换的情况。</p>
<h4 id="使序列递增的最小交换次数"><a href="#使序列递增的最小交换次数" class="headerlink" title="使序列递增的最小交换次数"></a>使序列递增的最小交换次数</h4><p><img src="https://i.loli.net/2021/03/28/ofr7S8eCcEBs3GR.png" alt="1598665416838"></p>
<p>​        这个题的关键在于 每次只能交换相同位置的两个元素。当交换求前n个元素最小交换次数的时候，只需考虑前面两个元素时候交换，并且对应的交换次数。这么一来就会有四种情况，两两取最小。1. 上一次没交换，这一次也不交换，总交换次数不变 2. 上一次交换了，这一次不交换；3. 上一次不交换，这一次交换； 4. 上一次交换，这一次不交换。1,2  3,4分别取较小值，并保存 用以下一次迭代。</p>
<h4 id="减绳子"><a href="#减绳子" class="headerlink" title="减绳子"></a>减绳子</h4><p><img src="https://i.loli.net/2021/03/28/cStoirT5M7sbq9X.png" alt="1598782259320"></p>
<p>​        这道题的关键在于 n 太大的时候 会溢出。所以用 dp 递归去计算则不太合适。如果n &lt;= 58。可以用 递归加dp记忆和剪支的方法。但是 这个题 用数学方法比较好回避。根据数学推导，分割的最大值情况为 等分，并且都为3时最好；分三种情况 3,3,3,..3全是3；3,3,3,..2,2  3,3,3…3,2。三种情况。同时 求余越界可以转换为循环求余。 </p>
<h2 id="玩游戏类题目"><a href="#玩游戏类题目" class="headerlink" title="玩游戏类题目"></a>玩游戏类题目</h2><h4 id="石子游戏"><a href="#石子游戏" class="headerlink" title="石子游戏"></a><a href="https://leetcode-cn.com/problems/stone-game/">石子游戏</a></h4><p>数学法：根据题目描述 偶数堆石子，石子总数是奇数个，必定有胜负方。所以可以知道序号奇数堆的总和一定和偶数堆总和不相等。而先手可以保证每次都取奇数堆的石子或者偶数堆，所以先手一定获胜。直接return true</p>
<p>动态规划法：设置dp[i] [j]  数组，表示只剩 i 到 j 堆石子时，先手先取可以获得的最大石子数量  对角线的元素可以直接填充。然后由对角线向矩阵一个角扩散求解。</p>
<h4 id="石子游戏II"><a href="#石子游戏II" class="headerlink" title="石子游戏II"></a>石子游戏II</h4><p><img src="https://i.loli.net/2021/03/28/nlGHCz8ZE39XjAK.png" alt="1598277131828"></p>
<p>​        <strong>关键思想 在于这个是反向推的，</strong>假设剩余的 n 堆石子时，先手 开始 取，能取得的最大的石子数，但是还要考虑 此时 M 的值。想想 如果此时从头往后递推的话，那么M 的取值与前面的取法息息相关，很难讨论全面。而从后往前推，就算是 M 最大 为石子堆数的总数，就便利把所有的 M取值情况都算一下好了。注意：虽然 M 的取值都算了，但是并不是所有都有效的，这个由石子的总堆数决定的，例如表格给 i = 1 时，此时为剩余堆数为5 即 第一堆开始，而第一堆第一M = 1为设定值，此时的 算的M = 2,3,4..在 石子只有五堆的情况下是无效的。<br>​        那么 从最后n堆开始，先手能取的最多石子数 dp[ i ] [m]    1&lt;=m &lt;= L(总堆数)  这是前两个for循环需要遍历的。对于特定的 i M   如果  i &lt;= 2*M 表明先手可以一次拿完剩下的所有的 即为最大 = sum[i : end]  i &gt; 2xM 则 先手可以 取 1&lt;=x &lt;=Mx2 ，有这几种取法。遍历所有x的取法，取最大为 dp[i] [m]。对于特定 1&lt;=x &lt;=Mx2  剩余 i - x 堆时 先手取得的最大的数量 那么 i 堆时的先手取得的总数为 sum_n - dp[i] [i - x]。遍历x 求最大的。</p>
<h4 id="新21点"><a href="#新21点" class="headerlink" title="新21点"></a><a href="https://leetcode-cn.com/problems/new-21-game/">新21点</a></h4><p>这个题目和上面类似也是反向递推。设置 最终问题是 最终得分不超过K 即为获胜的概率。假设 当前起始总分数为 i ，那么求 dp[i] 总分已经有 i 分后 获胜的概率。很显然这次总分数为 由于一次抽取的数字只能是 [1, W]  由于是等概率抽取，那么 dp[i] = 1/W x  (dp[i+1] + dp[i+2] + … + dp[i+W]) 。即递推公式，两次抽取获胜概率的关系。从规则可知，最终抽取总分数 只能是 1 ~ （K-1+W）当得分大于等于K时不能抽了。而整个得分区间又可以分为两段。一段得分区间是 （1<del>K-1），这段区间内的得分之后至少还能再抽一次，于是可以用到上述地推公式。另一段  K</del>K-1+W 此时已不能再抽，小于等于N的获胜概率为1  否则为0 是固定值。</p>
<p>综上可以从后往前推出  dp[0] 的概率定义并不关心你中间过程是怎么抽的分，只知道当前持有分数再抽下去最终会获胜的概率。而这个起始概率是从末尾已知，往前递推的。</p>
<h2 id="斐波那希数列类"><a href="#斐波那希数列类" class="headerlink" title="斐波那希数列类"></a>斐波那希数列类</h2><h4 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title=" 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/"> 爬楼梯</a></h4><h4 id="打家劫舍-II"><a href="#打家劫舍-II" class="headerlink" title="打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/">打家劫舍 II</a></h4><p>​        这道题相对于打家劫舍1 的区别是，这里是环形的房子，有个首尾能否挨着的问题。首先对于 一般的  不是环形的房子。状态转移方程，max(dp[i-2] + num[i],  dp[i-1])   意思是，求 第 i 个及其之前的 最大金额，就两种，一是 他 前一个 dp[i-1]  此时 第i 个不能取，要么就是 dp[i-2]  + num[i]  这是因为 i-2 肯定和 i 不关联，但是如果 dp[i-1] 也和 i 不关联 即没取第i -1个呢，如果dp[i-1] 中没包含 第 i-1 那么可以说明  dp[i-1] 一定 小于等于 dp[i -2] 的 所以上面那个 状态方程成立。但是这个问题是  环形数组，首尾也不能同时取。那问题简单 分情况讨论呗  在数组个数小于等于3个时  一定是取最大的那个，在大于3 个的时，就分两种情况 分别算一次 dp 即 取第一个 不取最后一个  和 不去第一个可以取最后一个这两种情况。返回较大的那个，即遍历两次 dp.</p>
<h4 id="母牛生产-https-cyc2018-github-io-CS-Notes-notes-Leetcode-题解-动态规划-id-5-母牛生产"><a href="#母牛生产-https-cyc2018-github-io-CS-Notes-notes-Leetcode-题解-动态规划-id-5-母牛生产" class="headerlink" title="[母牛生产](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode 题解 - 动态规划?id=_5-母牛生产)"></a>[母牛生产](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Leetcode">https://cyc2018.github.io/CS-Notes/#/notes/Leetcode</a> 题解 - 动态规划?id=_5-母牛生产)</h4><p>​        一只小牛在三年成熟之后可以每年开始产一头小牛。那么  第 dp[i-1] 表示第 i-1年的小牛数量 首先它可以顺延至 i 年 因为不会死。其次 这其中还有一批 牛已经是成熟的母牛 可以每头再产一头小牛，那么 i - 1中有多少头成熟的小牛呢，因为小牛变成成熟母牛需要三年，那么 第 i  年往前推3年的 dp[i-3] 第 i-3 年的牛到 第 i 年 隔了三年，也即是 dp[i-1] 年的牛 每头可在 i 年产一头小牛 即 第 i 年牛的数量是  dp[i] = dp[i-1] + dp[i-3]</p>
<h2 id="矩阵路径"><a href="#矩阵路径" class="headerlink" title="矩阵路径"></a>矩阵路径</h2><h4 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和</a></h4><p>​        这个题的关键是  从左上角到右下角 每次只能向下或者向右移动一步  那么  对于从起点到 格子上的任意位置  (i, j)  只能是从他的正上方 下来 或者 正左边向右移动一个 选较小的 即  min(dp[i-1] [ j ] ,  dp[i] [j - 1]) </p>
<h4 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/">不同路径</a></h4><p>​        思路同上</p>
<h4 id="最大正方形"><a href="#最大正方形" class="headerlink" title="最大正方形"></a><a href="https://leetcode-cn.com/problems/maximal-square/">最大正方形</a></h4><h2 id="分割整数"><a href="#分割整数" class="headerlink" title="分割整数"></a>分割整数</h2><h4 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a><a href="https://leetcode-cn.com/problems/integer-break/">整数拆分</a></h4><p>​        思路是 对于 拆分整数 n  可以 分解为  拆分  i x  (n-i) 两个数相乘  或者  i x dp[n-i] 拆分成两个以上的数相乘  dp[n-i] 表示 将整数n-i拆分的乘积最大值。因此需要两个循环。</p>
<h4 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">完全平方数</a></h4><p>​        这个题和上面那个题有一点类似。思想是一样的，但是细节有不同。在 求 dp[n] 时 若可以直接开平方 就为 1 不能直接拆就 拆分为 1x1 和 dp[n - 1x1], 2x2 和 dp[2x2]…中较小的。不拆分的情况的dp要提前遍历将不能拆分的情况的dp设置成无穷大，可以直接开平方的设置为1。</p>
<h4 id="解码方法"><a href="#解码方法" class="headerlink" title="解码方法"></a><a href="https://leetcode-cn.com/problems/decode-ways/">解码方法</a></h4><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><h4 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">最长上升子序列</a></h4><p>​        基本的方法是  动态规划法  高级的是 二分法+动态规划。动态规划 的状态数组为  第 i  个元素结束的  最大上升子序列个数。那么 以第 i + 1 个元素结束的最大上升子序列 可能是从前 i  个结尾的任意一个接过来的 因此要取最大  同时 从第 j 个接至第 i  个元素 如 num[ j]  &lt; num[ i ]  那么 dp[ i ]  + 1  否则  1  因此O(n^2)</p>
<h4 id="最长数对链"><a href="#最长数对链" class="headerlink" title="最长数对链"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/">最长数对链</a></h4><p>​        这个题 同 最大重叠子区间 扎气球类 的题目   参考  ： <a href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/solution/chuan-shang-yi-fu-wo-jiu-bu-ren-shi-ni-liao-lai--2/">https://leetcode-cn.com/problems/maximum-length-of-pair-chain/solution/chuan-shang-yi-fu-wo-jiu-bu-ren-shi-ni-liao-lai--2/</a></p>
<h4 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">摆动序列</a></h4><p>​        这个题 可以按照 题目最长上升子序列的思路  dp设置为 dp[n] [2]  0 表示i位置结尾 上升子序列的个数  1 表示下降的个数  使用相同的n^2的时间复杂度循环即可。但是这个摆动序列相对那个题目可以优化，因为是摆动序列  其实 状态转换 就只和  当前元素与它前一个元素的大小关系有关 再与之前的无关  所以可以做线性优化  o(n)  只循环一次  若当前元素大于上一元素 当前元素的上升个数 等于前一元素的下降个数 + 1 另一个不变…..</p>
<h4 id="最长湍流子数组"><a href="#最长湍流子数组" class="headerlink" title="最长湍流子数组"></a><a href="https://leetcode-cn.com/problems/longest-turbulent-subarray/">最长湍流子数组</a></h4><p>这个题目和上面那个 摆动序列很相似。将湍流数组的定义抽象化 即为 求最长的 连续的  摆动子序列长度。和上面那个题的区别在于：</p>
<ul>
<li>摆动序列可以不连续 但是这个最长湍流 必须连续</li>
</ul>
<p>所以状态方程略有差别。但大体思路都是  根据上一次是上升还是下降摆动 来推导这一次的状态。</p>
<h2 id="最长子序列"><a href="#最长子序列" class="headerlink" title="最长子序列"></a>最长子序列</h2><h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">最长公共子序列</a></h4><h4 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a></h4><p>这个题 要注意 二维 dp 遍历的方法，外层循环可以设置为 起点到重点的长度 0<del>n-1  内层循环为起点 0</del>  dp数组的含义还是 起点 到终点确定的二维数组</p>
<h4 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">最长重复子数组</a></h4><p>动态规划反而复杂度更高 </p>
<h2 id="背包问题类"><a href="#背包问题类" class="headerlink" title="背包问题类"></a>背包问题类</h2><p><a href="https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/">背包类问题总结</a></p>
<h4 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集</a></h4><p>​        记录两个思路 一个是自己想到的 按照 回朔 + 记忆 的方法   一个是 看解答的标准的动态规划的思想。<br>​        首先 无论怎么做 要判断能不能分割为两个和相等的子集就是 先求和  然后除2  即为在数组中找和为 target的组合。</p>
<p>​        思路1，对于数组，每个元素有取 和 不取  两种状态。因此  回溯就是  从前往后 对于 第 第 i  个元素  return dfs(i， target-num[i]) |  dfs(i, target)  前者是 第 i 个元素取得情况下  能够满足，后者是 第 i 个元素不取的情况下能否 后面能否  满足和为 target。但是直接这样写会超时，因为会有大量重复的情况。为此加入备忘录  设置 dp[i] [target]   记录子问题的结果 防止重复。这种由于递归的 子问题就是  dfs( i, target)  所以在加入记忆优化 也必然是使用 dp 数组存储对应组合的状态，防止后面重复。</p>
<p>​        思路2， 动态规划  dp 数组的含义  dp[i] [j]  表示 在数组的前 0~i (包括i) 中，能否找到取和为  j  的情况。最终就是要求                   dp[n-1] [ target] 的状态 。<br>​        考虑一下 要求 对于前  i - 1 个 增加了 第 i 个元素  可以分为 取了第 i 个 和 没 取 第 i 个 元素。dp[ i - 1 ] [ j - num[i]]  || dp[i - 1] [j]  两种取 或 不取。 意思是 如果第 i 个取了 和 为 j  成立  那么 反过来 抛去 第 i 个元素，前 i -1 个元素任取应该能找到 和 为  j-num[i] 的情况，再取一次 num[i] 就可以满足 j ；那么如果这次  i  没取  但是 和 为 j 的情况 很好理解 没取相当与不存在，考虑  i - 1 的情况即可。但是还得考虑 j - num[i]  &lt; 0的情况 ，此时 num[i] 肯定不能取，因为已经大于 j 目标值了，所以此时 == dp[i-1] [j]。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210401152541.png" alt="image-20201014225610678"></p>
<h4 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/">目标和</a></h4><p>​        这个题 技巧和上面一样。自己做的时候先想到的不是动态规划  是 递归+剪枝  也不会超时。单纯的暴力递归 复杂的 指数级，会超时。</p>
<p>​        递归的思路。首先每次    选择 target - num[sel]  或者 target - num[sel] 递归。判断到最后一个元素且target==0的时候 计数。剪枝的方法是，增加一个当前剩余元素的最大和limit  起始 limit = sum(nums) ,  递归时  limit - nums[sel] 。 通过判断 当前 target  是否在 区间 [-limit，limit] 之间，不在就返回 不递归。 </p>
<p>​        动态规划的方法。首先状态数组 含义和上面题 一样 只不过这里记录的是个数。dp[i] [j]  的含义就是 前 i 个元素的和 为 j  的个数。最终就是求 dp[n] [S]<br>那么 第一个元素就已知了 dp[0] [ num[0] ] += 1, dp[0] [-nums[0]] += 1; 那么怎么挨着求到最后呢。首先  j 的 范围 肯定在 正负 sum( nums )之间，因此就建立一个这么宽的状态表 （这样 j 的 值是稀疏的，不会取到这里面的所有值）但是这么建立表格 方便循环。没用到的 计数值为 0 即可。虽然看起来增加了很多无用的 j 的计算过程 但是相对递归的指数级 时间复杂度 还是好很多。状态转移就是   dp[i] [j]  =  dp[i-1] [j - nums[i]]  + dp[i -1] [j + nums[i]]  注意数组索引正负的问题和 后面溢出判断的问题。</p>
<h4 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">一和零</a></h4><p>​        这个题 也可以看成背包问题。将 每个字符串价值看成1，每个字符串占用的体积即为 0/1 数量。背包的容量为最多容纳的0/1的个数。状态 dp[i] [mc] [nc]  的含义是  只有前 i 个 字符串时，背包容量 (总的0/1个数) 是 mc nc 时最多可选的字符串的个数。<br>​        dp[i] [mc] [nc]  = max( dp[i-1] [mc - mi] [nc - ni]  + 1,  dp[i-1] [mc] [nc])  含义是 这次选 则第 i  个字符串，则可以取得最大数量，就是上一次最大容量为 mc-mi  nc-ni 时可以取的最大个数 + 1，另一种情况是 这次不取 第 i 个元素，二者取大的。</p>
<h4 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a></h4><p>​        这道题和  面试题一类中的 矩形面积填充 和青蛙跳台子 的 类型相似。这个题要求到兑换金额为 amount 需要的 最少零钱的组合，那么组合的到最后 amount 只和  dp[amount - coins[i]] 有关，其中取最小即可。</p>
<h4 id="零钱兑换-II"><a href="#零钱兑换-II" class="headerlink" title="零钱兑换 II"></a><a href="https://leetcode-cn.com/problems/coin-change-2/">零钱兑换 II</a></h4><p>​        这个题 和 青蛙跳台阶 很像 （dp[m] = dp[m-1] + dp[m-2] 值看最后一步 是跨了几层阶梯），但是又有本质的区别，青蛙跳台阶有先后顺序，总的次数实际是个排列问题，但是这个凑钱的问题是一个组合问题，1，2  和 2，1凑3是一种情况。所有状态方程不一样。</p>
<p>​        首先，是组合问题，假设硬币集合 [1, 2, 5]  那么就按照一个硬币 一个硬币增加的逻辑 来思考。就是所有取硬币的方式 只和硬币种类有关，只有1 硬币  只有1，2硬币 含有1，2，5硬币这种。然后总的数量 是 需要凑的钱数 amount。也可以从 背包问题 推广到这个题，钱数是背包的容量，取得物品是 硬币，只不过要刚好 把背包装满。因此按照背包问题的通常方法  状态 + 选择，即选择每次选不选当前的硬币，状态是凑成当前金额数 的硬币取法组合。</p>
<p>​        dp[k] [j]  表示 含有前k个硬币集合，取够金额 j 存在的组合组合数。那么对于 只含 前k-1个硬币组合的情况，组成 金额 j 中的硬币 含有几个 硬币 k , 含有0个硬币k  就是  dp[k-1] [j - coins[k]] 个取法，含有两个 硬币 k  就有 dp[k-1] [j - 2*coins[k]] … 以此类推求和。但是这个状态方程起始还可以简化。具体推导 <a href="https://leetcode-cn.com/problems/coin-change-2/solution/dong-tai-gui-hua-wan-quan-bei-bao-wen-ti-by-liweiw/">https://leetcode-cn.com/problems/coin-change-2/solution/dong-tai-gui-hua-wan-quan-bei-bao-wen-ti-by-liweiw/</a><br>结论 ：  dp[k] [j]  = dp[k-1] [j]  + dp[k] [j - coins[k]] ; 可以这么理解 就是 要凑成 金额 j 可以分为 不使用 第 k 个硬币 dp[k-1] [j]  和 使用第 k 个硬币 dp[k] [j-coins[k]]  这一项其实是保证了 肯定取一个 硬币 k,至于取了 &gt;= 1的几个 k硬币，其实都包含在了 dp[k] [j - coins[k]] 中了。因为 dp[k] [] 这一行 凑齐前面的金额其实都是使用了 &gt;=0 个 第k个硬币的。</p>
<h4 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a><a href="https://leetcode-cn.com/problems/word-break/">单词拆分</a></h4><p>​        dp[i]  表示 s 中 前 i 个字符能否被字典中的单词拆分。判断字符串是不是在字典中 可以使用Hash来加快判断。有多个单词，其中在 I位置 有一个是 true dp[i] 就等于true。</p>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210401152523.png" alt="image-20201018115551358"></p>
<h4 id="组合总和-Ⅳ"><a href="#组合总和-Ⅳ" class="headerlink" title="组合总和 Ⅳ"></a><a href="https://leetcode-cn.com/problems/combination-sum-iv/">组合总和 Ⅳ</a></h4><p>​        和 零钱兑换问题2 对立 这个是排列 问题。</p>
<h2 id="股票交易类"><a href="#股票交易类" class="headerlink" title="股票交易类"></a>股票交易类</h2><h4 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">最佳买卖股票时机含冷冻期</a></h4><p><img src="https://pic.leetcode-cn.com/7ae8b65cf80c5e9980ea33973abb6678f10098646aeac699cac12817b7e250ce-309%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F%E5%9B%BE%E8%A7%A3%E5%9B%BE.png" alt="309最佳买卖股票时机含冷冻期图解图.png"></p>
<p>​        dp[i] [0]   dp[i] [1]   dp[i] [2]   分别代表 当天 持有股票时的累计财产，当太难不持有 且不可买入时的 累计财产，当天不持有但是可买入时的 财产。理清从前一天到今天的状态准换关系即可。 买入/卖出 是动作，而 持有不持有才是状态，由不同的动作，导致每天不同的状态，因此要以 状态设置数组。</p>
<h4 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费</a></h4><p>​        类似上。</p>
<h4 id="买卖股票的最佳时机-III"><a href="#买卖股票的最佳时机-III" class="headerlink" title="买卖股票的最佳时机 III"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">买卖股票的最佳时机 III</a></h4><h4 id="买卖股票的最佳时机-IV"><a href="#买卖股票的最佳时机-IV" class="headerlink" title="买卖股票的最佳时机 IV"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">买卖股票的最佳时机 IV</a></h4><h2 id="字符串编辑"><a href="#字符串编辑" class="headerlink" title="字符串编辑"></a>字符串编辑</h2><h4 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">两个字符串的删除操作</a></h4><p>​        这题就是最长上升子序列的问题</p>
<h4 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/">编辑距离</a></h4><h4 id="只有两个键的键盘"><a href="#只有两个键的键盘" class="headerlink" title="只有两个键的键盘"></a><a href="https://leetcode-cn.com/problems/2-keys-keyboard/">只有两个键的键盘</a></h4><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a><a href="https://leetcode-cn.com/problems/burst-balloons/">戳气球</a></h4><p>正确的建模很关键。一开始做的时候，想到 假设 k 位置为第一个戳破的气球最终的收益，然后遍历每个位置，取最大。第K个位置被戳破，那么 剩下的就是不连续的数组，即 dp[ i ] [ k ] [ j ] + n[k] x n[k-1] n[k+1] 但是这时候就需要带断点的数组，中间维度K为断点。这样建模很不好写。</p>
<p>答案是 设置 i j 的开区间中最大的收益，并且 最后一个戳破的 为 k  位置的 气球，由于是开区间，而 k 是最后一个戳破的，所以 k 左边的部分 和 右边的 部分是完全独立的两部分，建模方法就简单很多。</p>
<p>很好的解析：<a href="https://leetcode-cn.com/problems/burst-balloons/solution/zhe-ge-cai-pu-zi-ji-zai-jia-ye-neng-zuo-guan-jian-/">https://leetcode-cn.com/problems/burst-balloons/solution/zhe-ge-cai-pu-zi-ji-zai-jia-ye-neng-zuo-guan-jian-/</a></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
        <category>算法思想</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>研究生期间个人项目总结</title>
    <url>/2021/05/11/%E5%85%B6%E4%BB%96%E7%AC%94%E8%AE%B0/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="1c47ba17c4ca3aea98af448e0844c6bb1f92e6c7f5db175f752ba03a949691dc">995e50c340763ee1a325e8c3b289bb94042f5aabaa770bc0112db74bfe3b3d8bcf0171a02d8c4b6eedae4b4b26a86161f4236067e2227367b0a2f121de36f6055ebf218f838d3623efdd5730d46b18a0b67a38bac991aeda3d805b201c7ecb210e95fd0afc416e7b0bfbbe2ae0545a914984aae6b6b04540a8a6e4dbe887b43bf1a808ab68b3d19e2785b18b4c8af14bb0d9d1739c9c585f231bacd8cec5eb52b24d41fe195a68348b99314a6c453e3a2e1c823e4eb771c724da9b0b1f28a23b19c85e390f5494e26ac85082bbdaeae0ceedeb4707af979858ce5288bb5e2583cc629a5fd3a895cbdd0f587f933276f01af7959d1436ac042d46b64755b30532dfe316358e1b0131bd041bf4bc87c5e968f1800356f1280bf6c5c69f6f165d5e1015a1f70cf61995e21657195c913d27628babeaa0b50b380a3eb6c0128db14a769c83c8520dfd60c70ebfb5fa17ce82a89c2b9cfc8954a2c45166653c6961eb896a5994fe89dcb153d3bffa2b254db4b63d8a15326287b63beb73844c3be4060db4fabaebe4096e1ef0863f18df644aaa5413cbe0152b0ab629cb9e7ff265ea8a6822709edaae84a9f8700b3a1954e21df43fb58092da1e0ca1dd5792dac3d7fed06d1c9fc4b101951e6c78961175d46e588bf38cc94f7c8669d602a8809ae5d82687a1b794ccc0659f18dc0823a89247a1a744a84a0e406748d30389113f824b4c22f575d4fcb7b83bdca2879ce25533cdf3d7b6af531b79119ad8d70e969da61df943867083156e49b27402082b22b6d52522da0ef45c9ca013974e58d666622214f94765770096c3fd8ec52aafd6a693637574b2fc0aa6626bedf3be48171eccea510e5486b21ed02e1bd56cf2e843d064db4b42610946a334aa53b5c8a55ae3b35cd7625b9040994f323603f8ab23e4b13681b87d4578506fcd226c3bd98e3da6d52d4470f01cc250f2dcf1fe26c6a7b09fe5f1baeb9dfb1e36372cad5ca64101fed7639ac56300d6f7399ab3889e5f79de22a9b8fd0a5b712edca5d91de079689a5f449568d2aa3ff21a34af429bbf65d11ef5d2190b4d4a62113711738745376660e6c9a834b37557d38b6a0938c039f1f59e059b329ef734ff873a3cbbd47a9e6df7bf5f9b8016069f3f19071549e7bd2cc87fcd1879a11fb57e57811ce4044a2a35bef92b388882fd4addadf316d9eb761737a598633057105d07c4f86754a9963b804ce80ae97572e58bdcff2dec82b06a3c15acf2ab9e9e3fd63b9c2a44d9c0d2af663dcecefadc06527dd2f379b726546f4a60b86a66262ed7768e35fb024ed3a7a2b9e37578193fead69c676cfcaca2080456da64c3fcaccfe42e444eed6ac70a52a47880186a3b0d0edb64ccc291233430505f00905556505b83cf3890e770bfd21d6451821f379faa5f06d6f1bd78554bd7a8479007c53aec527fcb56132fef1467ca2612c55205ca2f6bce0261fb36bf08436d46a30553038e46a888feeff223440d3b0a9663d6d0c53bb113918052961b731157bc963d8f3c6cfa16a668b605846bf3fd5c244106e8240c0385aa73607cd621777e714cf50aa8aa48e92b1538b266567e6f3c785232776a75ef15867586deaa69a0f5a0284eb51395efc112a420058527d39d0921297e65c9f7f3998b33fa4d8c9a197c294392feee0c490a9e7a13d5c3ae846ccf899b04f7907d47e2e8ebce5a9fe98a753b98af0b4288c33a6c9e7d911ab331b1e3e14623a8006b32a5d8c4fcac7f5833cf844ec835117213ab89ad160b98783b1282ac9c1b8d0baac86de06715ad5284987a8960e9bfb3d7f2d15760054f3f12918cf02ed7d2475fab7f7aa48dbe2f61f3682617f9d08f8bd9230fc3c1d9ab6bbcaafe1fe2e861bfe7eafbe87be70876208dbd4370c8ea13139ea74c9a72b819a562bee8bab9a456d152dba1ccb8423382bececc32bf73a9c98b7528351897f52080d2d05b84a62213d8ba3ee8d9acd0c2c700d7f5f91cdcf89500d571b88ff3c3e65b93175d2f71e53c6cf7bb156c39a374438ef6202b85d05dc4c6f204a67b03c42b11e312230df80b74d10ef6e7c8a726764cc7c4858cd870f653597de585a8ec8afd03d729ec9f9e22ef40cef07887d4247136cbc3748ca0118fd8ed44267dd4d1ddf37a4ee5d87ca27af95a17631397a2d4ec6f0a1a6e7a8a5201c37a0dd214860dcbe5f9fc07f752ca9dd834631e1cde46a1ed6abe8f52382a4265e5295c24a49516a9a83d8d6303d7ce6f80309da8a530ea8faa6cee038af5d37fcd0be104500b0c0d390a300bd46579720c4f546ad47b0a049d4b59aa24a9df118469105e9c5ae6aa1ae448884d78e1e2ce930ae37fd94af5f3e7eeffb598ca5deac5b1de6e33ed975593042f3abc3c49980730146ad74a138ab471c28014b2088d2ce0aaf9c1a69fb98ec8177f320c88edd1bb02136605d309ee3809606d0fc67ddc4d86d423050e7616e07e45c3a185da54b8020cd07ca268499a3ab2149ea7450dd767c54807a9b887f632703402c0231f39135c013f9f0f375fb8cae22ad929446d76ee6b75dac6f2fa69ebcae7cb51bd6e45dba0f4b118d7be9d0a8059086ac7d2e430379b92699894b303a14cab6747df001905c5a7b561f13ff217a64a3450dc21938e68c2d1150558b2c26d5bf2bf3bbb5170604a8279f87469ee83a39a30717ecfff439d6acc7477e271b73d3b6102c0a0c7c9b97257662152536615d98d3d1e3e14207a3c1ca4abdc71c10d63c17c101c4831e32255e76947b6122b874eb686ed47ea7eb7be0835b220975cf2a71468dfa9a3622dfde613a155844b4be1e7829321896c3d23ae401badbb0cae0871d7f1623b64fcb1ee60f8820ae7d2c8f013d4efc172d699b7c3142b5899beecda3c40a13a836e1fbbc7e0a2c1719f5b66c4c7890ae35db321dc0c8255a1f75da211c0710aa75ca62cb45d78dbc4dd23836d6065f8564b89bd5a73ff7e0a84d91d4cbb37e6485a883f1d04a4c9c0da9dd42407e10324e7d17b89df8a50f68f68b036db6cf4e86c11423dc18c3aa8bb9b4e0d5b72fec597dfda27c919e3468bda8f72ebc97057148862dec3c653dfdf07ca86419f3ff234a1f841e2b6e0c21c05042c2fe81058aa388acd50ae580c6427e0dcf0c4eb3c1795a5f6fdac9842f7a7c6620ad64f0e0bfaacbc2ba0180dae9bb0774c21dd73017a5ee6bb2f53f88bd32b959d6bea7483cfca76b802a5c6b4bf71b00aefb9597565a912c310ba537ec5648d5550cc711f56dcc567f75c26a74a19d532d9d670e0175b004b70f2c7481bcdf3d6b679895bd5799e8b17bffbf2f151a1eb61da126abb1ba59ac7a97801fd53513af26c2e2f6e898662cdb25dcd7cd8b91f33ac0b75d74d8d6b72844b9544ac8e8f0fd491781eb66f5b05b975e981cd4ac62f5e732cd924a22e8f7ddcd0fb5248ce314a8f54aee0271daee4d8789b99b103452e3f9bbca7cb20ab2c60d2b417839e8ab8b285b2189401a559feac0d32a0a59d597decbe395e2c04bc6d557ec5e9a778ed8ffb0c3fc5e1b221fe11c5bd61479d95b3ac72d9c554b1d72d55d981135cded0d64e3bcd2c917b44e1a7c3c5c1d98e73f2ecbb35f6bb4325ed5ef89bb0b46e703d458371199a711cddcfce52bf410c422b05feaaab0495058cb55875c5cd2d6526b7ffafba9825f4c55906a9850c7600f05a57a581d0238bdfd0e3e4be063741c3520f804166b6b4e44b9c9646ffb40d2faf33f4dbf8f941ee86650e935b939d15f1560e40680bd4ca5c2fa4ab8bd8658e0040fd54aecd48944a8f1861ef3b60838ce61bf0d17a4bc53b271b6f997e359f09dd75683f8dfe0513e9b13f650e765928ff6c8a334dc921cc789940e812c4faf8463b70f9bb6a8e62ca37352c38a52c6918148e617b65bf80483c6a1906b2f905f3a9adf5b4bf1811e1f92d4917f8fdbb8daa2f7fff5fd94545a9aa786e14c430ff8f03929b894c387e8b3cd3b3cc3a2065ab4662c96d647075d7406929be642e9e391cb45fa817a999d934c5bef094204dc97c9fe5fcabc7151efe1bc29d893b2e55c4113544f9432cfd41404bccd72c5b2a690a2f99dc66d9af63b50c327f374dfeada54ed8c4c373b2c20f6e7f36a29c5d801f0d96ffd28682a3006db8ee72095dc0c3c7bc4bb308635dfbfac85238d77fd0f60d703c05c9991193373c8b7f1f24a911c89125d68fd4e7228eb4f8fbae24dc45f8329ab7abc994c5ecd097860989713032367e044652d5efdadc36f140294a077dba0abb3c8c9ab52bb7589c28e635aee12d685fed87bfd20fdb27cf2a1a41b99a14e1bef1b0bf48694a3f0c1df757d73a0ebf0cf46a3bfcd32c758ae1de4710ea30725ca368e31ce839406b9ad0c1cc6980b96c07df9db3c2a44ea0937f5223b12858943e3471afdaaee308379916a250b273f6b932eb845f590250d7383873a60c597497497cb5c66c8dd108d86d2ebd599258deceb776d6f19f21026a5af292aa937c5d88ad36bff015737893eae1e116326504e12b3237ed45e978bd1e08723b849ce4129e25e309eb9b5951d295fad4223ce6487a21fb327462246ce69967f9572067c141928e5d3edbe1bce074fb54e58c211a13d7dc7373226edc825b14cf8425d970dfebc0ea09c708806db12b73856028f5d65cedb79a13cb0241e98390c64a79ae1470a700b3463c90cde5ed676438e9f3deff42018e0409e8dfa213f3073ce99c6e9906045c5a89f81d64296c0e54e50c347f281b0a60c4c22196afd9052d028a309f2f48b3aaf99469f81a620120ceae29541746e9c1a7b3219b2eeebf328146a3da22c9efd7ac62ae80a69e639c3aad56e945cdeac496671486298bdd5af93ffd77a89f61b98f2df2efc9875489dbfe62caa4cc603b3b10d37f250effa749a14fb44fbae479372ba51f91e76626a25cf8ad1d2d8b99325b9f98ee28368b619394bb6843e3ce57b35e9a5217171fb13452171ae0848cfe9ec0f4dc05b283f2cd4a28db79d764ed5959c1e35761c39e1b79929e396aec02aafebd19ccde40b55436faa3cd190ec43f1f5c8eacdcb88959b6171a63efeed92dc27db95e4d990245bada4f353e0f5232d6b700ed3fc823ab309517ed48a8cdebfa424f8a4d281b298e06129360b1ec82bc1191d022e2f05b9599b0e1e884aca0dd4f6d27579aee748549a411f3ab03a27a1e7796ed7b89d4d2293991b95c8ad36e35a8fe6d5731e8c0b88fb71c442cf7a02264b0d060c56d0caad9c949e2127c080cbdbb6d8db6ff55b44daaa636a622d0bce03a9b6ed1679d471e772fd9b1809b990718c0e4512683293fc82bd483d20ce784046a20cdf20048e816b0fa995c054b9ce2c45bc8d674f6bda20cce3cf3d02ca3d1c5d391a7f4fcc999872b39956bb300d72fdf7faf0276be3f345ebac46562a2ccce30a9f9741d0fdefd98d29bf09f833b67d2ec7e6f017a06a9a3fc335b89a7b92134559b944c8162ab49339f3142b8731f78c6507c4f064629d7428ee990bfac7a926d20d54edd2f5cb8d4bdbd8d7fd02324dbfe5d7d8ef1bf34673da985d7f552731ad6db059d5414365d4974bc021fce69e9c33641979e30c5e5c7f1cb8d83d3a3238ef1e1a1a575d35e66fede194588afd3ae9336e51448fb9b7610320ac47fd31000e6e63f3d176dddf6585e16c36ab3ec0d8654cef57dff9a49cdbb4fe349303f521e3dfc591ce68b6117dce3181e59b057f993704e02c211625c685b066da95fa675b349d7353c14e3beca28751ec208d03d1d7f2a2887037a92e17670dce823560c706c92571da94c20b2a9f14cc835bb9c8c7dd14f46e49e84c5d2fcca8a94e5f17547b9a017799f0d4bce261436a3a528263d8029e134d9e99e827b4d2f632993e3121bfecb250dd78c76ec52818281165f65e4b87c1c2d3fc4158363dec6dddcaa746a064141b8c1962280002f619d5eeb1caaa51cfca39b6aec0b3c7ce55836f16b1006f38a628d97fe89616c0c6a65990e55ea899f93eb30364784970c803f4f46109fc4539619cd3dd7722292700be9962a800227c15ce064969756cfd8fef720cb1ccb7fa6df5d2afde6fbebb5eb3c8ec89d1ad2ef64c428055b97cffca512567826d15adfcdc63299be0a22601a6f7933ff6ce33d756fdf974f94a408e1dbf64f5e0092c2ee31847e399cb371490467e146e065085b93888fc9c7640eac9c4574726b7b2aa181a6a52081224164a1ea96cf5d578bd8af31b7fa6b3b93e442d05f7f84539b4c2f134e1feb1120f81066c641a2c1958586243e2d9eacad9bffdec6cdb9515f6f554f71ec965eb4fc7f9715c7331aab6ece8dd4af1e1220eedf27918fc7bc1522e71c19502ae5a51ed5239fa0ecb0f6af561d17d7ba037393b33d7e9e9d1c7957847fbeb59c70684e1c7dd72ec414526c9db6c1d5249d4b83f55857cf8e19e119bf8b69fea95478eb8bec91e35f92c4a5c061415bcafda0a66d054bc164bbf341e9d4adfd700a335a2446d71da6c917b735a80cf8e0c4168ac7d70bfeebcc4b9d38bb8b027d1c3943426c9e26be81bdb598baf1b73c30e868d4b82145fa27a314d8ea1e77fb73984aa85e7f841bca3a5e668437f9d6bdd423779fb656013404a07bb80dcf3d5191dcf20afc5bae1b03745824ff9d1373622908a9429b56d7b73ffb7275e71269e815e634296feaa4148d4ef4f28ba0a88e00a28fb8e843c4e7f68a69781e144267d35dc4b22b62308fdb17f54ac6be895d987d499494e20efe1ea7fe52c34132bee4e675a6696c519558bd327dfd973f6ae349847d820156c5c34817657de881acac6dbafa96de445dd6162ab0007c8381059bf79bbcaf670e6bea54ae220132925e8d8da724807757b5e1d2dcd73a13eb53eda066b3fc836f46056ca02ad8d2a40a5cae1fa9700d5b330324939b07cded9eb4668558fac5bed7ed322ff8cc9a8a133f2833d81993fa292dedf03363ca75c519b0d80e5c97f00da813ee262e69969d1603b0bd496daad9c1170e3accbbcba27f47ceb5bfca9f13f75b7c9bfcd282ddf4116dd59fc1c26a6372a2110409f909fc579b659cb70b23078f84e5995fcc2dd89a4f070110b213224d7fffdc33b0c3b970320a75527f1bd35c8278882472f3cb880d68232706975dc602f118dc5bd9a15d4518bdc13d99b6e192e09e4f30db56081b7d85051b2987cb3fa019c860bb7a70f16f0f9a7f4aa083b3f58b2af01ced8413ce1c637809fb0af8e09e6cafca2ea18b5107a7ea3b428cdee9e8302e8891e57cebfa6d8d7768a882ceb02397cddd43561db8157efee111b171c55eae78a3c69fa2d4c78a11aa4ce10f1e94d4a3203c571cbb7f7c530de25a423754fdeebccb17c9fab0cea5507d2f18cd950e7af5cb3c2c876f680871e1086f91533cd51a81359d0230f80bd1979b2a94671b719c50b339aedd5cfb260e91b77f7a9c2d5b916567216c6c1f9764d86a5985a3db4b62ce09a80935b6ed3d90b950e3212741be95918d5e7940c50e1e36de9ed9ed561cf8fffd2f70f10a184ac5ef1557e286393739ff7ee925083dc99a757d5a1cef970c1c433b6397b215ee50e35b2be51aaa6c3f2faf8a5a174e89b199a71dcf1a15e1edd7c98670bb42b9fb91314ca0d1fcebdaf72740eeca4a02643a73ce36adbc31021b37ce29ca8db53b72b8c81cdaa253df86924cd36e893e48f62e13b2f7f04630d252b64a2f71daf9e5c8d29228e22745fefda3cd4af2697f1e4b82dadccf132154d1849412277f09a2a443c3bf423a0628ec4c8b468008f7a135c2101482482781d713a3b673ab826e7efb369809d666d733832a0b9925bac5c5ced477f91b48a90ce3d706d8c7a924f9499c7bbfe283a94a3aa639656bb93e4aabd5cd9f7e693a4d34a857dac1656b68c1e98420c271de6de6f191412a1038455e6faa5991f705344c6f32572d82f30c35a95cd1951058164b888b6ab9b127f8e816ac3820a838883e75af916013d636e2e5460a54a26c2000d2bf01729042083c367b5ff3781b91924c20effbcf6ceae46c6307a2a6b1a2ebb3a26ac3d219874c98349939589572bcd8c64f70afc7e3df04392a3fbaa7dc978016648b20fa639635f53ca33304110c53ea2008a44b8fd34451e3f23d8da52a9d42517c8a5c087efbb81767a52232d0fb00f7849d7d8de367db947597af2d5065d63b7eec3b0ecab9445f23c07e9df85b62b3fe019a56d5e2b240648f3b783a3615786d9f9f6c0e7a6cb9fbdac729120a6047a86772bac93bcbbeba7220aaf064884d6dab21f4c9001206ac312e639787065edcd14a13d9e26d30c3f5723cd178f08b6e1080cda89b04682645f52878c4abd237285d3d42ea23197dcfb22f882783bd98f90db2db3c4813d20e92d9cd33e1b752c3a7ca0051635109f3b67c07e5cd8485f295f60c449d83f4ee0265d77204da85bae68c597d317d397d804d7e922c964bded168dde54fb13337f2ab200fb3805786ab454757fe49f59bc89d7aa469174ae4b1bba1410d7b92766effe8dbe07c9a9ad70c391135fe3b78968d482d78b3935da6c13a92ba3e71b764c639f59de9ca1231b42782dd421e8c7865b522c8c30413d18a91e42e0a0082d21445144d500a8748b151db660c95e0b7590182a04453564c81afd1a0eccbd2cec151c5908e064e7333ef17f64e6e8ce69c2c4a64eea43e1c7a74f305e845a07fc5ebe20549ec73dc063167ab9f0e6e7661c7d19e47dc6370ba3f21858e3d695ede9c369ed77f59578698ce430165d6fe2ac6dc8fc69c14a64657d43fbcb9fd6cc74a13735940846e9f9034629f707c91a979c711e751082f14d1904f98f4e7a5fc604127871eb5d1929ae415fe6859728a6647b370be111ecaac2fd73036e92278a67c8a0769ffefc53470708df8a6c71d6472226018ccd5979099977aef261e43affe0baef2f063329b43cae02c8ab0b184b135c89fdd226b62f04b62db054203954f068ade4b3aa7287b0185dee34986bffa890b035f5196d0049484ad12cf7f0a575153368e140fa969ce636c623d2c8b62eb0e506dd0584172cc09d2ac782bcc5604b45ed9df166125fee909fc4182d1bc402a567bbb4a1c5c9a03497ca55ed3bec6a2bff8b9800326a92569197ef30e8d49d3d75244e177f02d7b045e286e5ca9e898ed66543c521a1061b8e1f3b5a143c3779a0b2ae84d22efd03ec15dc5454fc8e94f48ae7edfa9ac4d2e8ccd9d9b72832db2107d1429e4212f6947f017fb070b68642f4d9fa045312524c7cef868d2491a2532aeba111d3f4eca85c7593026400344f31cdf44b3f2460d80c276707ccf84ebceb423a8840b8ce3b11a73583e42d643755918401c5b339f5382f9f28693eed575db5bb972d484df7a962a631c37f9141dabd0aa6646b4fc12dd5776f6625155fff8306afea923d980d1ebef4420c7dbf9318ba40c90fd2fce50b498d24025c008562f507c85563fb8a007deddf355ec9269a614df9b5f88a4cbc027cf198f5aa33857509230e51faceb978a6dc244e5e0067f3c879e1eceeab729776c63ca0e1a57338ee9d8e40336c41777577ce1ebef3ab39f4f4b53fe0fde95e8405db8f3a726b1f3400de92e577d7c4f86a49930637a8ec82177dffb1300ab863932552f9bdec9c071e310149dc59e4ca93f056f5470eaa55f3e7d605b4c96dc8761ca849c92d1bb0143791cc7c8c87b8cb98523c70efc94f7914e06a4412cc6042ac43411be4cd35b38a39e550fded1d58cd48422429e35de0291128e40b6ea0f20edeee50d34da440de6231c55ef6b047eb1caf7e212848f09e1207ab4672c0710b21a90fd9d828ac651084c5ffc719724a2abb1f831bf0852dbf08a0dacd2a70b46bdfd8ee0ba5d9f0c39ddbe97b5650cc6830e843bbe732808518486d790e10ecb3c81d5ddf0411e80f1ba3b547bc6fd020bb0b97ae6d581b1979b77aaf80915717b855429e3adf830e81d5cda8c9744443de0603395fad700534c206ce5a06b0fc71b3a09e26eda6f1c759a62fa0b2ac19de996557308dd66090881cffdfe8e193b39ad6f6d5d4ad48e9804b1a9763dbdcc0ecbf278f7a61a2fb49d71ba9a864e380c912ed801b93aaf18b9d7e34743ea58e294f75f26294d79b876870f8425eabf2a301b43e065e12966e31f3e61bb78fc5f209f7f6177b64c2a3febb40c5aaf851162d32599ffa3f14deb813f3688d3652161c507261ef8260a01aafa638d5e71888268e0b6e64f8f64b8e7a76174cd834884a3fc65a59eca2057792ec955f3d79f3357ceaa28981bcd3a3781b6efdd0e25dfadb70e60480e614ecf180cfd3a1238403a519a026b4a3eaecda46ddca9cfb6bbe8ce60bdc28ce3eb320364ff5490abf1dd13b7aa93290e5087fbf48e3a67e8050784dd400cc1acf77774f818bf0fe6c147144b1603b27996238993e2b3196ab9c223d8e9667bb3ba646fcc5248d8dd7ff427e37bea5c08dd25a7f2f544b420a6030bbeb028e250498c5546493300b5f5c569b76dd6550b14338846c12c361a40ef77786c5d8cb33cc2471d6ad7fe40d1a9a9b68f75ec5db50ed4a2a9d6a77ebe7ed85580b153aa1de28aac4dd498aa372069dba89786d612f27a1a851d5900197c86918d4de45c441f3da7d2619478c021b2edfc77e8a16dcf3f83323a336aeca355b81e466bc1e57307dc6bd1242c413a13ff54fe2cb07a0244c9b9fdef5e05fdceedc6fb97159c02fe06435553bc6650bfa02eb7faad67b46c282b598b40f7041f2d5a90c426efb13ec9732be7ec995fbef102f97a0ab8b73a6d72338ecab878bda5afad22ce71cf99c188a9c43df3cb091e1c69c2f4236bff8a06361ea179e39ce14b79b3a0e40c47413ced2e2ae9bb2348e38f0ad78a34dd67641fc2ce243b0062bd4ee80bde488ca69a450af57160985419a6567d011e3e45ef69c17b8452f2edd43c14e7ebb23b29bfa4ce2b85eb9d459cabe6ce6ce6107d44f1c41ea5a0ee28b2b86974ef6be665916de0bf8eff4ea6cfae23823118a232d579494db0b86c2cd34eb11048129827919b1caf32d402eb67c392a766b076c037042524cb939d9cf97d752c937f7e7a601239530ea2fe7970ed87636eff0b8a4f8f21152ae78aecd571e26febcd39d37d82b02f823f6ba0a6dba12c3c3c634db25daee0feb9077bb3377225e61d73ae8ee59372a2905c8e16ef3133febf47f8049774cf50e7db3aa2aa1c5d1ca254c119961e41ca0f677353649fec710d2e85e649755af966142967b890828803d5afc039b217c47d2245de4baf5636ef97489d36507537e08fbeceab431d549a0e68307e832ff9d95a3b1c002112fd9518c5e500488391b2afdb4178967d57f256e907d302cd9cf05d40f69bb0fa19d830594e1709177494db72815e546aa5e469e96f4b6b88267eb4a3568f58c5ec0f30cc407ca5f518c594124a7e8f5835867f05313e81ac886928ed5b81215ee97fec1f341c5fd81e337940b82ad2f02d4d1a496dd026f34c036ea4da1c1c31aae209aec10a6d8973eed008284df6ad05907905abb2cee7eb5c498509a3b6f3882c11816ba23b31fa76a3c89016c0aca3dcfbe9dad0c19d81be130227664e44e2a9ecaf686b2235fb960091b1f9ce7652a781342833b71cdec7be832b85ea1053c7b22f95980fc5f28de4c91d13b72efeebbf46d80305798873fa9d70ca25b7e63126021cefc0049d0063c72a0894298c4cf94da6498144e1cd79ebce41e1f1624b311369ba81cd5ea50b5b4a306a85a4ed66b529ef6ed8272d0542cf17e65f27e8fe98a9b88bc45dabde1f442f848dceab8aadd90cef8f372853a9abc7b01113e33793ed14156936097d0a130179f14376244bb91ba2e13168e2c8de2ff669b1d30e6cd3739494ef18fffe9bec606602bc95417d642ca36872665c586aa9e0cd4a3d730be4f64f3b81f70a037e7d594cd611db43cc0c395a4cb1e14fd114d026b342cb07916e31465f712ca64dfedcf4881c4d9391661ff7e4bf374b61beef1d27697e785f59866aac489bc707d5292042eebf926a43b1d516872871ad10b1aa9982981caf3bb6e2a48c1f248ff30c081204da44658dcd1a8ab6e4f12b73e6a9ec6ad92adf32959a88480e831cfb9423d00033c2f0d793130cc25f744c6385fff92a3efed06190793446387b42b42b9e7ee9fc0d35f917d74b54117f76f2776731618409321f03cb05a7e4d60e33e7697e880c43bb087e217ae636e21a8b84bed56d4e1d81fa5930acdbc6869fa51c8259bfdc2cc386880d0d3a1240149a024877f9f7f9cbccf8fa16a151cfdb0b788fe636dfeeef4b71fb1399d8ef9f6a4b0381dde145eff4f60e4d996e5b4e89092b76055c55a649412f08c9ff4b2d9f57a6d8250a3f3277448eb17bde56a0b6655440d7b07ff88157fd395e25d4278f26ee8023c78399a9c8134fa3dd560af64800b6faa85b337f555be04a28629234b49f7b979cfaed3ac565a43d19fa25ffe55c1d530f279e5489936ad84cc6ef4051187e59b7c3e38c9880ec1f137acebf810a966391c99cd8d712825ce4eac02079571715886493cbf1f18f39401f9acd80ea13671b0868ab57dd4f230ce45cf79ee7354c1cacf31a52e791be3decbcc6a2129c71bc0a50d75990f0fb30459fc4eb7ba100530df202e55e307e282b02ad00a378c179a65c2babb5e0233c10440e4d455901c57b29be95bff10521082de50f900ad122a81bb0abe1390b803136730525c94f14a8963e3b4966348ed637117a451534522ad698f5c998cdc23d594fff4a1f6ff83158842d5102bb25a4d06a4206171f0439f93f14959ca64639d6d56c0528d9403f7abb29c31d3ec7fbabae224cc7267cdda765cba1873f9b0d2a292edc3f83b42117d7363247d309ff8f2288f5473c58ccaa106b18c40b973bfee0230a8368555aa09a47f909701682dfb3c18f01d533e3c669237b3fa7ef4ff3e6ecac86c7726659873931c268b00de276aecdfe218bf25daba05b2dd6a962f7c9178bca0c9b943d8a8b9ccffb38edfe81037ea5f8bbbca026f6c080ae6e89efca1f78b5139dccd57d28a1aca16f0725bd4ae8f9a107b92bb72eeb80dbf0dffff359c389705b046694d635e173d0a0b3adfb2a7171038071fd2381d8c30ec7ff8177bbb20eb5a011f299c6e1b2562ac2cf04015b0910ebeb6a926d5dff8f23e079a6812df48ef8ae03247bd6f0fabbb28201b962c67f035038b30be41e1a54e62d53f03fba43a1b73b36d4c74316220009b6f3364cd0c383793404088829187ddc3d473ca9d3f4827b26a6745915b8649284c0b1e560b1ba50826a75d767ce8694f55797bd3a0489cd8f236173fe2795ff200b73e2833cd968197781db49218ac514b1f55732198cabaa017274dbfe2e5131a3ae78d0b92f99553b6bc8b60d5e398a6bed2ec53ca1bfb71fb8bb83f4906f7d8f8c3ffd8ef9e180933ae7a27041505113531509824e3608f11c960f5b85fde386fcc3ef37d70837af357fa9e1aea5f7f3fd91a84878725db144251e12ff26fb9a5d8904a002f3b11c9b8ae281b942ab8f13dbcfdea1029b4e8b1c0bec9e8e78a0e99d29146f6facef3e7592831871e80d27ec3528974289be05cecb0d8165eccfbd28ac7b69c201851ef47117323b8e2c2aa8177cbbba6681726cbf9f41ce3dcabb233639cb449f7b5b882288ceff088c3b024d685c28dc331687470bc9045ecbea54592a799915fb072192c454a01ee8dab86ffd69d5d378f4e33f69a848f340f2bdc1f159a886abce5d59de85a972d4914f0fe8e40cf4e4e696959f707349a2155fb7c1bb0824bd2a29d3983b48818fb236160405b4fb83470fe350d21c9132408808fd42927d6e86b56c7d78d08edfb9d675aee6156f850bd15c3591dc317de8320ab53a8a74787e48574a2de07d4890ed1ff3504bea1b3a4daa08e45cfa9b7788db723b7c6c26d137bef2eeced5f83733d90648465cf617bd5dc5584162767940835154f907fc82b97688a1435b29ef3b13c4959717c8d7723f92c2118f4f278bf49b6b30b730eccf267ceb689c6a39a76fbb66dc0bdaaa34a2b45b039c5f22ef9db6f335e467a853bbed13052f7e0cc9fdfd625774ff23e744ec7adbef20ffd4bc59af36a10f983858ab941dd7df55969cc821f552cbdf5c434fa7d8b6da4d353ac857e638beec6fd1149ebf2b092fb2bb86ae06852a9fbcdf5b3be118f963ab361bfdfe6ff68e91ccb8c42ee256dd9d33e2b011e708033d4a46a77d4000c29a6aecb24e80aa5498ea494466c66b26048a29cbdc71f8b78ad1b532e1ac0eec4300b668d9261a27052934c24c17facc2c96678ee0e73d2aae2664d1add3d4cc48bd0bc18dab021f9a6bad805b6eab602768864681238d36fdc6b18639376d156892768921ef59c09d631f70cf0da07cd9b0fca5bfbf70068f2275f00ceaf9dda564f03915f86469a97b3dde4b7eb6d36928af5bf1c3d0475db29d1c1cd388cf0b4804756a856737d7a6c7e1b86f35caaa2794f5fea968e51190a08fdf01c10beb8df2c7080bfdba51b355fea66a0cd18a65fea4730b516cb9a891e44749d438ef1336694c45be65801768aa6a7229f50c04490cb46b46410e7a48b4f375d2b34a728a4235bbbb10fe067cc9db6c6b76bf8ee44c2e02ac9a8f9c046803b808d3afe89ebaef78904eb57566c59a1482696f8a3f13b281611ffc2b80ff739d6366d9aecc31e4092d064c59c71cc07be7480f2b1b3093720317593b84efefd24a25130566e1110d1f360b03977b26355b702379c78b74aff32e5961837dad3f10a0cdef3885e75088b48bf4c582e31807e8f2aaca3307595c8eb8ac812d84485350b047b3632c1748ccf802a4647c99df69a0b527ef2daa9a7ea0ad868ad502c9e6083af9a6a8be54714cfa3ef34e71ba624e4e1c0e3180c246c1671a7171119a932b389619e67901cda53b0b0a507d808a0ad4c43172f3530bccc1567b94f8e0b55e5df8d09d1741d8e15562d170e4d82d7d58adfb6e1c3fbceb613ad0bcfeb3f7168bbef39bbe8cdf6a746e7811a6a76af70706d77ecb8837a00b8faff98d617fa828e9d59adba238562569cdb8409d6770b80a198b10696a0c7ad59c0022c8971cc2d96812816ea8c67b831c76c7c8fae1117752dea9d30d57b512b750b183c97d18ae6142e087a0744ddff8ce202878611132ee4818e506ebc1892ea58c5eb9908a3adb72e4a5e4832514cbf9a784eae81646e020db99cf7c75bb089e7a74ad5f3d0409da4d68ba44e21cff0877f95949fd0f55eea6c2d6794b956ba64a5e04569d9693b0cd2b32e219f7271547fd66ac38aa74a39eb08a4b375ac791d26c4a68a659d9994c223b6ce850b6e1579ff577eaae6105829f392ed3e1945248b6ba7008e021ce707a69a68aaa6f1b1d27d1a8d7534b17722d81f1cf1da689c365ad249e75131c9f58ce40da7c7a7037aeb2b9a3fc1c18dc7a8459a8111bf1f3dc264c49586a1e0f98bc44282a7a0e73162134c6736fb0087ad9b09f511c7194fa2ddbb68a55885484c71c0000f5807bc5334539ca4e5f6ecd7a0d2214d6569a5bd6330fe8b61faab37109a820ac9c67fbcc8c93f682c16e80d8275bb914bf2803faa669ebd61dbfbce2b2a279e8278d1465aaeb4d9094af1ebf9dfd3b97ca662e2e32892179b75c21ac66b97d7159f8f4522a1a206183d2beba49bd99a6c8ebd6ccdf4e9833704475a2dea1fb2934d9ae65d40eade1f90cc36432c7a169652fb8ef6af764730ac9f34a632a394e23977cd35347695e636e4b6753fd291a2a30c5460d55eef6438ef8ba310876413b9cbd3472fd0470e0064db327a3392e0989b489e114628763a7fe5451e76895b3d9c691a14035a67799d7cb9045c3c89bab89295c4d303988a4303b38c2de6750b0a69fee028e5a12890863c1b049f69e0f4e72e002fe8122a96823cc0e9ad08863361ca1bc1da8629f2fe84e070321fa7fe1d6c262edfb17c5dff53ea426105479689080ac11eeefbcf348bfc4f4e7924922cc10cdd3829865f968185daf82b02ef7d3bb3869cfcaab3e065980bb538c3d5ac715caa1f576eb8d8e11a85c6970fc1079741a285a8251d19069bac9aa254608056a1a7bf32bff2818022b08c85340e9c98fe18f091b61df4db3251f4e35a6d5b19e8b8f052fd269fd91041d633fb9bc83085594ab7ad0cc54279e0738d0a7aad91f6d45d17645fd387c98905b1431f7482ca25cc1bd92802a58a4ab028c79062ca6a693142aa3900846fbb5772f7d6a5429f3f04b0064588b676f93dc6679867408238e1bcf7c21ae7a203498ec6f1dbc7d3c12d5a847b118cd2f45503763c87b5cd444a88213521e78f8ace1d113a3fd2ca3921361dd4e9cd4e8fcb11d63130d37f50766128725702bdf655157c34054d984e0e85035e5b403eaed3bb4ee8b9f7ed98762471c3de0871e4f4526722e9179988eb40149d181ce19a739d3046150741b0d4c0a77a9861475ad15c3da91bbb5f0995c354b6392d62956a472ff8cf46d906e1b83bc12146f41837c38af0f90d5b04ceab4b06ce313b019c0bd3bf130942c7c63fc84d052b0c55966613ba8cac9071ed5bc17a2eac6039556395f23c2273eb6e344b48ace35bcbf2cdcbc09186e8d19f1dcdd5342c8d196008796f8a0ee42e05e2297992acd21c55c924f2d3a4a4d405f58d006ba9f5cd95a2e7669abf0cf44ded82a38ad0833965b6e3b3625a0c3b62aadb4d57ee56ca1c1e68e4ebd05e6675ad8b1cc7a232fe5f5c63b36ae8431e888195a50cb3551324d3d803778d5607c409569d1af5d8d6a6111b1240c2558833efd7da5b3be17c4d3b4aa5958178fa2e183df198b98de960bfe063f00dcc78e87a3cecd36498b28a264d8a0c9239ebb173d87e48db4daa46af72e10c33d50799a87c28e2ff4975dd1f7ed8296322626136094eae1cd7e55093914fdeb897e0f3db26503e642b21e49e3e6f009a7744fd1e0d863e403bb74d58418cd600a636126e39ef59d6f2cc1d61a3c36af6187bdf09db87e32124e2f91ac76908daad55b57f1bc599caa8ac07235ad807954f18b41aa1241bc089ba7b9b7a0081dfeb9677daf137060c7a9eb691042a0512515f151429d5cfcaf3d79b942a8bf82da11595b6d6f719ad6ef606ebb1a016804723bc634559592e38deb62b2e8a9756ff245696f47d948774a6c6b5fecf8d791581e8bdd79c3bdf7f416a15f34bd58ebca97de13b4b3b7a4ee85017acf3b8eb3d41711a23f6e332b8954e5592e44ae439b5e031b0c0e8492f643d66dc829834f1d2270c31d62e79cadd6c0b1ce03d1f584ac9cfac718da0af187cb980f1375fdd424ffdb51f8fe6dc08af0ca47119d4327d6b115f4a409c60ebfa1bffdc015d187903c97fe0165e4169e76c82a7ee42884a39c5df0cfe928a9e41fec1fec19cb7549baae6c820f62c8be07dc78eb3954dab2bd6fc88fe4d3a32f97c0f568f70ee9fb7a30548e9ed29be477a8c9115c63140e41488c9e388f77727189557142147bf2b50e29c9c493b91792e0a1b30e7fcb0e7e5187cd99e0e0a6685780d0b05ce275fa89b0d5dabc0334e996f7032740df1fb45141965cef9072054ff1d09c9b73edd06dbc4389505e7cd04075f4059b39e00fc8ac226d9447c9517f1c218f2092e7bebe784bc33a33d6f7ea8fa788563cb5b80147f08462a473d6978530818aae69357913cb4bedee2e7a59dd1ff00238e0c976bf6f0aeb4099be08801f5c519f53c1bd55cd102dc5afa764b21629ee50026ea6aaa449d33956ecda36a05b54d19b964f98670e685a03657e06bd769c47021d8ca034ea6581ee046eb4a94be467ce7d35e0d95743b8d94f0d850154345492e5904371ea999ce4bfc9df0a2ea51a6a7f6f0eb428d49861089123e4248ebf5f5b7b843bbe70d6a78b33824ad33e2389a3b72303c948f074215ef0939429d0331d86f259be1a0327d5d85cd0a77eafb1f7370b257462a7cf2e29f21a1df0b20560d88bc0e9f46a7fa8c6da12b297482a37da396aad9adf66e6988f4e93f27100c5fb00f60b670108bb0926abbf7ae89f642c22b14cb4003b79487677e392235e18b2b9cb61282b80877fcd44cf545f230fefa349632a9a6dbf5243dd479324655b9e743fdeda2cc81ad2e17f0cf49e558c86216ae35aaad43a081fe598139778e92fa945d4a7e32c9adf98e389127c995c9fbd202166fdea0931f57959f8ef0b2b64f30fb9bac66f123d02558b54d46757bc1b53bd415742bec2836a1a85702a0a678c910b870fde75d036a2fce407efe3899d772613a5f4d0d609b9541dd5ec51c2bfdacc917b4a5e3035e15dadfea1b545031d21b25247adc95b9c26dc16b8156d1161894b6945e982f4cf38522a5503503e9d3c25514a691b6ff1c4098613f3d8639806d82aa323a7bb636f82ae791e61894357bde42d2959a477d30dfd5110e995db54be46dfa53f191f18c7a1a943d5e7c7cd0f607a5154b270d44761d395c8c3438709089f2b054cba6e0fc70defd0b2f59da0023da5f4b1d696bb0694ba41ee243fdaaaa5e279801e3c1c28e85b2b669c9473576f857fcbabf89703dc210311cb3da80b0ae39f14a6fb8ee3a95689b62c89df11fb9372070a8ca0cde0604673d5ead7bddfd2daa4137e89629aabe2499a4a88eeaaad16db2404570f9027c2c22d47d6ad0ab6ea1ab9acce05178271c9fec6a4a810986d5d0d03ee38b6603f15f8630108dbbd50217590e18ce1fd9022e88bd91174701327770e16262aed054a9fda3ab84943a2af6210e4951ccc92e63cac5637edc941e7c6d31c467f03f58ff98ef8a30d85f147f05bc07a5fdd9ec5b0219cbbe9665b696a2bc222f75a3cde8d6a7cd82898de52aedf1e594b1c490043bd8e132af1d515b19a4aaeed7b5321fd7390681fb6ab88af21acc5ef3dbe779221d7bcdde475e32ebf14a22f539b23cec3db3abf6be152bcb5205267d6ec96a8ba99ed6cbe61609f49178cd38b0c3a27f4c6d4f6db4d154f20056687d97f8d9c57a0cb5c4103f073c7f17004f69a939a93c1eae6ab304fc6c2363087069d9ba98da352db5cb1d3e82e1c228ece210c280d093849dd22fab35da270853c11bcd9c81d69a95e4b75c5f4b3d8481bc583635a48340284ee09a95a51de13af2bcecedc8056084ea0f811f055f8c7f9ebe231b4f47c68c9e6749dcce6a35a23d1ca6879b737bb31a2c3f82e04fa3b4e6ebc74b97d955fae453b1d5a2a2541d115d9a1e31ee5eac851d59609a53a2e84f0cea732be9a4341874bf576bdb7fae48bfb12f767ab3244addcd1c217eed15f0946bfde0dcd771f981ca549f73efc2c7a9ab766f230fbfb1f38690f4b858e3ebb07fad43a63961131e8f2f289c7c4aa2416187b1dfec60542409381b0eaf2a15b195c69c0f7824a43e9bc715d52649834042d2028a0e9389ca9e2b858a57b549f3a67d8b39e99e79951d59915ab58225c8c678837373b63bacc0cc97b23039b981975559a67475aea1d35b305a701a31ea17aefbc3cbf0738980a2d7ab03594efbaf61130b3ece7383d0c4c5173d92292b116bb7a6810478f97408041989c55f58da46d4090e714daa4591710fa2479c1e2f9dba6e64602149c05e4da4397758a9ac80dfff723548920452555e40faae2985e4cbda15976fdacc66a03060c5227e9d5a7800ae16ec6d5b637a92a90180bda480fe6c742486cfd0ac83d55cf68a8ba2676a2d6522910b72b137f5a838a0d43b42e35a7ad44e81d153369d5e6229211b9164e55eb928c1d6058258f182da3162ca29aa682dafd617ed9ba8badf2c69a8a1352ce3b152446aac7fe5279cba49794db48ef15d1fe4d9eefe9a4ba2288307da62d423206795deefc3b717ada3b4c43571a8bd1b8d1ae4319dba9c55fe7855b3133f8d37a2b2755381b18f747f0f85b6142193765c49f8393777465f94a9d8a19abbfe4eb8ff1a3089d4e0e4386c7db98070a3a48d487406e34592f9a241b1bb01f780e41394fbf2ee6d585e567fd6ed39604269fd40b6d7528d96f381d954b980634fcd7a600cb33c16932f8819472f061d962ea650397b6e356c582a2e941f2aa5613ab9084a3d6bdaa6d6017b52aa0b13be197cfbff067a09f589b190458539e8dec04e151e0b1af970664acfa6e6565bb64b658a4a6ecbe585a88212113a40b6034d0c3485ad3cea1eba1e04ef679b5213800407a8ae248e2d0f0ac540bd93a7233d9f226aea4ddd559ef6275722637e7a5ab88f39e5df157e8a69da3e5fc02823be7ff078a0cbf6e1474482a432ea870cea60ebdbbebc7ddf9033df5eba1954eb7cce81d18cf2058e37b69bfd23072ecfc5b710d5d1365fd41c3f0fdd6456706529b388c84f7273956246a368790ba21954e0af8b5b5a3db6905611d3ad80d2c87dfe0def11d1a5dd6c9aff5cc671944a2f5b40a19882db030dfaf880176c89a1078a5d305815a7a305841fb7a8440644975a687fa5dc8a0513b9e9cc2a09cff6cb576c5a9b211b6805d3840e55238b1d21adef98b2d822a444aa38f93f85344f20be78fcf6afa921efd0c9ae59bacbdf5608ce31fbe4d5e3b58157505c4ea1198584c547f8e9e028aba45959dc218d92cbcdf26c7e9255146b71cf4f8edeb04f25d3c18308c7e3e06b641f5f75757ea16c555996e3f226977f7cc1435c783d41f414ec8657d27a94069c11c6b502950c29e0e357fe6f99526f5e566a8c30ba8cf2197284d2ee074c6a95c0920524109d01a53f65cb75a4afe96e7014394e890ae50666dfe7b76e7e9cd5541eb06392db84fb0569f8ad41843c81ff3d470b9509d7cbb937ee3226a82c6169249f5fe2e86b1302033bd00ba982189db0a8dfee67955d72a36d313a243f0362406c8163a92fb75d05bf5188584f612ec7d8e434d6b4254e27cd42d063ef1463fbc405b7da1a6a0950465b3342aecea965800235a1af850127c99eb92dc541fa7ea68d1227f61103bce622e5c5ca43883bd232fc44dfa815a56df642cbdd5758cd5782763bab65546e16f7d80f5c6ed13f1bd494387ce94baa1eeedbf15c07dc9bc174bb61e5d2fcb17f27004d0cb6d575edaa1b3f061c93ca815ba27dbd5cec3c03224f6ac364e0ed679cc86801f1ab562d0b754a3933737177d55d1d1df29f9fd60cc5c1473b600fcfd944b0ebcdb3bd50046daa323d844c5cae9e87a1c631326d1d5ad8d7834f4cb0917cc0755eb4f4cd3e95858e8641b362ed5bbc1618c845cdbec72a08aa300c0dd4aa7456f9c40b1860738c87e88ad88b4ac1894dea7a063070b63efd5acd4e17c6b56f6e4bdcc5b3d1a0f8b98205520ce4130f32d690027dabc04e54aa27e4d7c66986d45e9b526ad68bf0ff99d47831bf116fdf1471ad6c19a6a92952fdbbe209487b8f2ceaa75ba2d92614332cb6711cedd7712e42e053104b97999d3aeb25221d0ce3ceab74d42161c3295c304bbf7f00e82978cf668248ad33650efd6a3dd569825938362915976c65a786498bd1a9e253353e9b3297a49c5aa926ec17f9c5c0608656de3a53a6b6734ea2c0457cc4d3d8cf18529810b73ff4eba1ab1c91b9d202d9f0ebeeb04e73167916c52d0cddca9cbb2ae4c6b8f63254649d55496b3f6d87aae8dda4d15c26c5c38f175fa30112de940ee2619a2a385152a6eb89a398f438d774d4f3d5efdb6dd8ade74e60dc6223632219b8cc25991c078e23a3f53b1695648f0480e99d091aaffd7c09d41c510691080266344eef3abe68edb699aa87925f9a1627bef14ebceb2dc60293baae04bee099271b43b4fb991591c320189a5959a34847ec27099b74b3a0578096072d6560768f2aa252e978bfb7d61d9599c76270bb7fb713f19cf1f823eac9ab2743d54f62064c4f73722f5ade0dec73c22f86a1ec8c5db2440f0ec40e9c82f50756fa1e826dd90a149950357bc834fc07d36c1b275b0055a4d791e5d8b9cf05452cf18fc46993a04953f9f886bf83f3a250c7ac153e7c8fb81c7d348524e9259ccec502177b30fe73bf13171dddd06c41fc83e2aec427ab658f894a4e0536efa7cbb99be06266ab3a78b6a4813d289ab7f2b43cc86d307f65cb5eb7703c98f05abc98c120211119212ddd9f669b554b03fe1dc7443fa0c75f7a2787c1711e5beb4e11767034663fb89249330e96a5345d180bf3a5d638ac4f3c1b2b5e88ec4106f3e52f50113b0b6aa0d8314b4f1b72adc114173786dec8b525defa0f2b3d04cd704a2a7eec29b3fb6dda2e7dd551f1fe99278dd0d769a194d5b53c8cca58ed2130c5330c5f2edf0b8feaf21b9272458212c7a8dabd1327759e968063aad66880337bfe76c722b070ac5a78e358470e68d1e7d13180f581052a46cc1a89e6e3c3d40064d5ec76d8a265230ab19189f38afef15ba2f2013123b2f744ff4ebf0532e7ade4202ad5f5cca57589078df2c7e9775c78c554ac5a015f9df5170ff2d6683f8f266edadcad769375dd0f6d9af30a726698aea12051016b6c9077ed25413b6ad1d27b75aeec79d68b325bd232474ee3152b19c64443426711953f00b0330d53053a78a5a5c15ab52f87b1e554c6a6698002caccc8522b5283107606f03b51310fdb9f0c39a0fbb86fd430be8e6276a363fca66bc2af0ec9ce60792062095acf085a8c2bb9b55c0fad610b5a05bcd3142b77769c6d76d0c163521f5d728957470cda10a5180c18316a5b874af0643bd69497edd358a8fad336a53bc19ab17cf9d123ab2558ba61e2fe32d8b26d7ba28ae43b192aa6a4df7f964f6c36ffefba8640caa36a275b9a57c1a815f6450eb679c161a19a190d44ffe5f94c8b29825a1c0e3e5290d493305817ac6a504ba45c1905b1917262fe43720eb935621b48a0aed93258ab47ce06fef5eb3312fb7b661c99a414b5521ee5a249e4f49cfbf030c40c96687067af009b61e5738494a0835fe27f9b35382edcd754c69c4d002a295cfb8ea07301ea039c30a69868d4fce1b0268975c0086e5dedbe8c9ff159e20b9616636e8e5a5529a08ed672d00fc4ccd21dabf85a560bb69bb871d8894d9a0f52f15fe64798874a40b4e5018d04c50d5f4ebf937c6e5f1206120a06cf2f7bcb7ff47f88dfda46ef1564d64e4e556f3f07653dba9c673279ee8c4e4b3ba4f3f5f16252f105bd49b85bce873f38bb9901e4dfb9e8037d7cb16bcae5a53c0127e6c36abbf90447a0f7b54676f046801f662e0e111d99fe5d0bd2643c37eab93910ac8becbbc4cfa2f0cd6b0ad23b9e8845eac29c0ccc2cc20a86dc79f5cad310c7af287159db73ea734413e2d7e8e0aa48cbdb9c8bd49f808079b69af00db8c6676ef2b2d1a69519b21a40eb46a764a59c8adc9613d81634224d7bca6231f03d702237ce9bfee4e596fddda5da87cb8c418e8b359d154747d583993502ad77fe0409232e29360cc74061c6b63f8a21b7abed8954066ac6b5b5e12c1379a42db612b49c2058efdcb9dda3b5237a9c854a7bde21b44cfb74abdc9528a0177d127e513c77c10e1c81bee9ecba7d706184bbd543f555725443e0772770475c6fafa0e1d29058b90a0b5c07a7d60b4c47c582afe2fffff7a10229753ab4a7b1c70390171c26330ee6bbab963115f1227e11cba2a17b8fe7a0a8ae49d132413744be003322c89852e862a485d8e5baadb6570d9bbe74de3286bd09856d9b48b17d175ccc12cec14622c1404f5dd6a169f4e93ad3803d854c9a6effda07ebb94b596d5ddcacffeb93c5f5c8e154ebd96d0a8c58a22ec0d0f4817ff335a17588e4784a42d6997cec7f90b1f4631f60eb628b545db6a4d6a06a9b54b5af136a612fe228bd8891077b1ed4ff34f22026bbbd03bd57432e42b27c555d9f6299ed31481a37896dcb871326e2a4e7c477f6453018f94beb1c12929c05e701eb2e0e602d37484d078e33da7816bd5636a8411e8d662247eaabaef9a24fdb4e9f5cfc49b53d41047754916f088e5194166e92b922684315c519f53fb0bb9575c6fb12e808a47fc57bc029d6d202149fcf64e29c95180dd8747dc85f2a6ac03ad4b4805d1749548728bfb4a7a1a92c90a69d9332deeec2a2b26407c1ca38e45935fc3cc9d7f3daef5978e37325517f508d30c80d023601588c633dacd3b826d919710c6483d582cf38674aa22439387e204afbd139d7b967b6ea3b92cca8db180c1a89e4339a26102882be4f5c92f9e576bcb01f7687d2cd67143e40555ae8913628860c5ebde40912fc376afa0d88f5efb3b216036be92532e61fa52adaf0fdd03f5e97bda59178d0e138bb79378fdfa8f23c5b43b9a83f7071c52f187756496bc02b57261ddde6f62966c902272425e546562dde27a8cdce62be9e2b20eb5728f94d38a6bbb4f5d33caba0bbb42ed783e152d88577a4133a4fec34d4cb37161e7930304dc3286df77f5d5ed9f6222f557545364886d2a2d465d2e88685da2091abdc655db919d96f126f470c4d4834ef001acba95a5d9d1ecfc8f036465ef1aaff265d4e4efb841953c5bcf9fca1cd9b7483f05c67d299e84876bab9cda597f4a12ab11224cdba17a1077c82e29cacdf6afab600d13a8aa1bd35c6c5f37dbbc8d7b251ac15601f35a75bb0e67de009330155905c717cc0ec0eb301ab3fbcacd67c37bbd56049e71cd7a60616463b65bea0395d34e3c0ba8ad8278d60e0830e67eccbbfc3f949a0af51d33d6c49840dbb201bc051259439b7c3da28037b851a01793d257466a03b5cfbf29852a4b66ba75c008bf9ca467503152a24659957e2c8ccd8479704f62c764d0cab8b2aca2ceaf8e819e37bb2edde787a8b12138f3fa679a7fdc5a6d86b31b8ce11ea0687a06579307567d3443ec88db886909cd173a8b58976b3cb2be148f29ea5b8b8477fff421cc3f5045f10cc39f6447975fd21e8c4a19dcf07c82b3effa481b4ee9cda2d08ab82cdda5529a001f688ab669bd6849e2a95188889482d19cdd8da1f10cb60248568397b2ff4cd019843a03dfd7967deb545c23761c6bee47eef23f02431777af3530a4780cb317532504ae1a44d4d686e405bf40ade2cc323d5f03138d31a6e1171150ece858bfb74eb3e78a2ee8f5fddd5ef1277dfbf8f597fb146d12abc4497860cbea7b848f2fa7d190ae5b13d6a54f42e25acd46d866cac25c060b778856ea13e4530fecff4c3a312d67a74763ced5e3307dabe0d242cd1172c467453d296403337e30462c540ebb2cf2a459ad3183828c6285c1f2bdbf17b4f973ec0da66012c0751266b5a0bd333c227fa6ba7976f36f88180ce7808e9cccc635dbb9979cd6c86d721f5f02b6b3258e6cf3561150efdfd30efad7cf421db5e46c3c63b57a3a4f7072d422bd7f5bac95b9ca2ff57904a5d491bbc6b58ae09bef84c12e0f8980e3c1ebda5f5d4f65c87d0d3beb43858df4ad548d5bc4a339180202690bc79cdc818d4b817cd05bab90a34a1a1290acef6a64018283d46c0044cd74f8338df126d1642dc1b4ef69ae76d51454bd613253061701f9de21e808bba609fbbbcf30325791d4123ed2964e8358e30bd4ce97e9fe1a8fd0528b678df991572646a70c401107a2add2f5385c04c7de84ffa4c8bd6d4e52d337f99932a7f9c6f1126356c98d1ebd4136367d564fcaac2a353e1fc301b11178fb5f32a523289d3a2c6dd7b95902ed23f254c0400e494b125c8d4f97c10c1bf8ba2b339710dc4ded582577545bc1b318417c3b8e2875f253990306a3a0f1d563544430589ec5a459935458a4c38ad0e024a2c0dec18375f698e2e633cf475cc8a3d47e4f1afee027e5c94ee9045d4f9084dbe92d4ba765faaa1952a93427c58ec222f674b2edc1838efd768ae68d36594ae7423467de0ef61381d53509b75113e30bd6742bc08763f65b140743ce5b5f0de12e4971722c87dd62285b890bccdbe7e67c9bd6c8d3095140c512936b9a57d55f6d743261d80bfa6ff8a2a38db2ec6cde40129b4e11f7f96a366f51f9eff4d780ba7861fd8b0983f8967f73e4dde6d8dfd0c919675ebf1f1f81bf0be64eaa7b9b97e517a2568d1622c996c6d75e92a5b2795519c8291499a0ea725d7364ebf4556c32c71971d00bd6ae38f21fac5cbe29cd555439bf14086aaf1d0f35a8b6fadb217ea81170151409818f163c5070b58910286c514ed6bba3762923cd580272e875a063d8dc34514093e5c6bfeb8725d3d461796281bb1060a52245931893ddaccdfa04def5ce13afb3df1d4c954817d516de154ffccfd8d405bca0aebad9ab121758e32ffebf4d9a413086fe60e49dad66fbe02d5efc85fb46eceba8f2fc51ff1214f251767bd170d2af562d29ee112103948e5ddba3397155ff411d501dd86cdbf086522f657e5bd05bbe078476b820456f23f9db0d7affadd49f3685cd3ac2fc225ae71af419de281e4d3e5f30cc4991de9bedab84190bf62608287317e71ae6aa299a98e2c80d6dc004bbaf5754bc962cac5a5283176100c10a0c69a31e3f9d9abfce89ddf14e93f18621b449bcc57c71f464aed5eb9d0d98b77caccfa9e7172e5882ad80afeb4238f345cb550f63d10762bd1bed6c1f8c799b1aa35a6e27e4b61f1dbfb7c90e5c1438eb0f5b656769f9019785a2467b25bbc8e82b646c0ac839b0ae1447521bd5f0650962a678f592ad4ca58f41fe970fb20b148a6c6743af71567b9f5a3c0973afc7cf88eb37cc9c436c41cece0a6002cef939dcffdd7cb77c458498da666e4457065daa66a6cc7db0eb7a6a531a2851fea8c289cb8d122ed1f321bd0262eb65cf57c68bb0c22bd8faa2a3aacfc155736eb3c44b5d5678d47fcedf6552663ab9da1538b881cd4e504026903e5c2a5e978db7a24116d89beeecdfb528bf65db1b4caf3a404dcc5cfca622e6f0b6ca7d556521fde5da87b2c1208d4afe5b0781237e981e0e836d14f8ba1531703ef5877edccecbef6aef39177030c7f77cf5ee75e5e27651bb702c35aa73312024449801eafbc561bb624a51696a470d88523ad37570dbd52b7e98413c4959e819306a855c3ff01e2d642a2796acf32a29fd014933a28055695d30c3ac7aefc10491f2b8a71b2bac0b8b6fdedd3aab8b1678363c2f8663cfce5d446f076eab37b48924d72bcc393a1f46174f8007cc12fc811ca4b0e78f11530b7fc16eac1bde0a5336626da1a4b7949f706e985ed37c9e33d177436b01697cd6ba9bb5b1bd68e32e47c37434aa7724ac00cd3a629428cbda5825fab59edf96b7e7f1e4c10e3fc6b4045ecc3a8acdf6c13c627c70513a4edb158da8998a5563e73795ba19c3473737a18a6af7b759788ec94f5874c988ad86ae89f3e8bf6c443e429c520d4769a9349c13044a12406d5f2c6f772e6a1363b54f22505a987c0f50fec98e1f5f5dcb3a33da6d0995db385569669da708a81e30b122b0d9619ccf293055d2048d3723227683010815c60f7fe0ec8c916646e876e1dab45cda0ec3651c2cfc7adb8ce5e5c0c8626fc603a63690c34309770291827d90969be3f9ead80ac7f780981d0c0a45dff33017251681c01be905a595e6117923b66381eb91cf5c82589eedf4faef6cc1a2fc1cb3308370be146003087e4385758ea8c781ce3fc729ce8d1326ebe769a9da5493fa4d35192ec7556ca8d22f3efa594aff33d8bac718ec283c1153c3827bc62d14cf5cd02b2c15da53f5527f93e218203a268606fc5a6daf726f2867b878992c92221154dabda415647a3a2d2127ac8ea2bcde63fab18598fdfc14f6f377234bd14f6a9cee58a5658daa9340807ad8026d33a1ea9b0691f0e02a39944f085e529b30e68079b9062fb276fdc58c00ab427226b596974499155b3f19b1484ab54b289053cd11413dc9ffb325125b397f0354f8773108623d39bbf626038bdab583e35bb274b693caf027c5ccb855c9a62013e216c9bb9ac96b7aa59c444d0f9f2e0b14087d9ac2e152423d91cec9fbbbb401f43d0c1ce2760c7d911707a1647e9a85a1d429649547d7bc7b72bb3e90fa91f484e8f4f58462c4f38b4077391c88a84591e0d71d95ed5c9d4402b4a3851d30904d37b82a3d9a5a61dd1f8bdfe5d7d936af493ac3406f20457119f9046f23e22eb60fad737c814f74443e68ff73faa5d6241b7a6a3901ba78118cb17a0770f54e5eb4195de14e675ffd07a7245bc542a362a65953883b1cd274bd95f67d0e90a4a85c801e11b1a87af7c3797c04302d5e90f1651f7d1e67fc1d1300be91d88fce41a09434629122eb0c8e0f8b22ebda478b4d219613ba79061c61f170e12210a1cc5a751bae1dbcecc1b6e2c5d0cfe1a1a8323a083e8d564b00a871f0967e9ce931bb2e56e544f469ab3a2276bda19665c6aef3a598eab43256867c8b37778f7fade7269e70a8420e19b67f1eb8bca5c4eae408ac3ff4ecda5335387a290f85f306c857d689e0536be13e52d7b58bbf22c884030462b8634241727bcbae28eb3bb6d16befe13c841c34c6abb660c25d26ae63674fda16b06c5c044e0f2aaff0bff227270fe746ab7d6597f8701239065bb796c7d53c7c0b48e7a20bf054f1980a9b52d1f61e00b11054753891f49f22c3edfd094a39e22b21263505bf277ccf98dcc526c8d646774038d4c37bc1c1d2b0be13f09181f167345ee84e45dc97a4e760ee5a8001016a99bfb599cab2ab5387efcc191d912a27f04687a264a072fbea54abba381ae9242e2a4ff1531f9dbcc517bad49c6cbb9da960f6f5e13960fef9b9e682caeb0313c833d8751747e4caf9224e02ef245151045db9e1558173b26f38f81f344e05b32c488b34313878aa7112eb89ecd4d12b94123d4b2a2b5e84906a34005d7eb38b183ee3384e0c7dea21f1751c300f3f5237e9ceccd1527a49a3611e4f9b36026197599fa21136b21bde2e5c73fad3bd780b300b896a71161ae737437f6100478b194e8f16e2ef0f6785b0cddf6ee669016f0ee776dfe4720b4e6cca408e3f67cab7e7c7853d520c18a8f4863737db7577e235cba3fbe38468c5e55ba17cf5925ab105ebc8e9aeecb3ae56242d85a3de91cd9063e9a0779ce683f71592f37cef5b1fa8373b4913c5f8cdd58de17f19285ca71c33ee3fbffac370d7d0a8d7d74d2afa6b8b8015bf10914ca0576cf8416989a3ecf2a00f05dd678b44b6e4964698f0dc2275fdc6d89e01e0d96d6fae93d512d8434f18090052b52fc8dc162a071cd2b8b0783e651dbc365f0e3fd67b2b4ce61df6725afedb158c8e7a7a91115c1c9c494b8c4c4a9ec208c96226c971c217d39d740d4bdb56af99a5c0ea052c88c4f0e54428745c15844edb4d1587e3f01887e310bf90df910a1d354c7d82a78c995852ecdf4d544fe65300260ef4899af43178f81c3d6a9309e153b7703697a708811e8ad59bccfbd9f9f8aa238bc6e9f3f8cf91675e462e03c1b0b4df3a4004ad2040d28f4528cb55815ba845f83cceef755f6f6d8f624fb0eca489132b6d54fa987a97678a65fc6aca2d8591248b68f8689ff609ba18540d2d6d9e9fdadcf0f24d428ece2891c7b6d30ad8c61d0ed9307fe4da1acafd5ab7ff1ee10e1748054f4ed8532c20d545a6af6a95cfb2c2a99b3fc23d46dfbe0fd2d608e747140485f2a3ac7839649841c0382a07f932044add6a0f4753e5123fe3696dfbab295d27afd85bb4ba6b3c6ffbf0f84b43644e766a9fc601402a627112ba2d3b3f638dbca3407d9cbe7796121a56f10780c0138acf2b43e0801ef60410fcf4cada17ddcc577a8a11239d29235f70e13c03c2b155f527c009b2db890e65bb9a1f4811288d19ca70458a00aa27b7bc4d14708b4ecbe048f6c0c7c3ba69d57a6b3faf8f9421b0dd1aec11587c57fb9c5603f9cee32faf5f348815df2bea58786cb4e19720fcaaf3998f6c84bab2ce1d0b78dba1d735dc5e1fea357edc2c7a8074e3026e183c25e5fe8af3d580c85ecb45673da6a69cd8f294abfc6a14ed0620875acad084e8ddfa1a35c4328e93a0dd69a4026bfb5dadf63e3eccb0a1f1b00fcafe93008f50aac731ead4a620e005861dd464176b5d570e2c4c90ad318b2f7b5233d87632343961931eb575dcd630bc709dd28f7d1e7a32a7c07a8caae9cf630806643fb0888170404e4629c41e4653a040bc0536abaa2740be9aa2171e37f3fb8390f1f155ac78d6ae8c02f4274a873383cfbcc59e522feb7d14513d03eb5bf553cee340e445a08e31097948d9f2b7eb26b97022e17d4258176bd43a17685f8a2707e583fa17893cb268c4a1f18ed5c9ca5201a40eec0a9d34ea36caf0e206b9a3ebfce98761982ead0cc3135b77e0dd371b40772292f4febeea16e4e8a69484df2e5430a6116fe07ca73fd7b4497289b8c5386450fdcd78c1375b8abc1d758919a3edc4f698b280fe02de340190aa600d5b8175a4e494820e6b7c68363af7985d9e9459f6c14b08212daf12b7e05affd9477faa6e9296cacee60baf11e5dfed98375106697b67fcbc38581fb647fb4ee518d7086ae38d99b8d6123ddf3e0dfa8e99d52396d5f031b21ea447e1bc0f44c3db72158ab9be7f553e84b943af500240e26d4c595f69864514faae0496c8166424186e48c79ed576f5246d2fafde3b9398e017f2a9605d0b6c21fa01958bbee2bfea3815ea3ca04a8c147b3d14ce4cd0062fc1eac7670f37440fa7320d06f88e3710d0deaa9ac5da90a7ce51306a02d1211beb5e43c781c762114d44c244e1bf7749aebccba038a921ad6577b05a8bb38d0ded770f55f44119e813d58b848303c574395c514d988bd7e3491bbc18ab57b8c250301886e085c4d3d49bad971d20e34fec2cb5301fe954a6ae8fd25146e5d4070b20bf59dd9e6827fe568235d39ed4590b45e09339b68359cd904d8d06d879a104a56220f098810e25b71c8015429625dd15965a132dd4ddb44ca97c146db95dce583fe07bc203dc0deabb651549d7a21faa786e5a52c8bc4da613a5a51cc0611ca61e9861ee4f4b80c27bf1c372e86fd038faee39a9079a3032fbee5349e90f810602c600dee9c6e9762e3e5bba1e6a353994657d01d7a0384541961c116c289c219cd21e9349b740b342c7db730cb6b976677ac48f3a7ffe80e2fd2e2747d0f5d1489fbe90ddb564e96d4c080485f7c8d57adb9109699518a92b2ea54145c660dfe29bea95a6ac97bda6b499e7598b096f803f9a1072a729222b1e611e85152b5b16f30767bf22dcd54ab545c0ba73ba693143ce15cd630039d993915fdd6837e6855ddb992b98ab2e38116832c0b7cf856c8f9a3065ebf45ce2315b5f5ba9ebed9fa13c7a420498620f7bdc11696dd8bfb21675496b7d95a35271bc38ac7deb575f7d00d2ef5b81ae20ce8bf475ba3f2f5719ef5304b055cf69ec1b326fd8b0309ee355f5e16043e8d3567dca11d0fcc1eb22b758ea215608856a023eccc70cbae14c2eb71e9967f001ca8ba72527db081feabd6357e9bf0e1a2f81e33493e4116dfaa86deb06dbec14a4b0ef47976a095744683c2aa182f282e150f5b35c1ae371adda43e12f7b70324d7d5e482a0796e0b26b90b9b3bee3447603902ae3a7971e0295abdeaa7d3457c02096ae2bd22fbabce72c9730879c2dbbc729914fc680d51436ab17fd13427c6ed57bc931e01b1880de838d80db7e5275151915958316dfb2a64716b5785f3afcdee99f529505d2eb91b97c1c31c1496bc43c4b2ebb21b2d0be8731ec0f46e0c491dfa155065403f48097d57fce83d3b4c61cec4fafa1d1598bc92150f1e71209449786a4c5f0a1fe7beae6935f9b3a7632121f272b95f3ed0e8b064750d01b6d85556b8371ed1c373902e167c1a3ed9b5a0dd46ec43fc878eddd07d8173f00e1b63644fc5de98c980d30a3a9f3b3457a9dd251f5230e85d9d0a1ea85c516d1b10323a4845957a7e92e03b53a37aa589b7eaf4fbfa59b5d8576afe3712c4bab26f9f80803bdbea6bb5a482f84d50f39500dde0d4ef892adec0d28fafa076a83baa2cad15b4b8103e060c875f6f062b5edb15d8a244ad177a3d24626f45ffd95c78dbc74959b1e7ee211f29588c2e0cbd0dce524b62399487d0f6cf818e6e7784df947ae45e0c5b433805b79faab79f818c7d7b837bbe375161fda1ba75cfc5f9b34e220bdce967806e11034307938e0829c771a294aae5c3b5ccb5b530ce44d6505228e88c4c48fe57fc59b655c9b9c87c291ade29c8dddaf74dc0d6eda8b116e941294982a8941c9a50d0bbc6b8733bce73d4c28574c270ec723024967c0da56762334fe62f2d3d0675351e4908f8fd3a844c89786d82f424479b627515f3aa61e53397c8fdcef5e00e0aeba3e071b2cb4450b17cbe9a1d5d4470b98aa0e0ac9d267d069703a9d98959097e48f9c016de789ee0f47912e948040b7384803b99771b6ae2d1957b956a1257e70545eba00343c4a7f0625961db79cd3e2bd5e4e83cf551536fe9ab984e0bd3db06ddf3da894b72d865c4405bd0ef356200e20d7d3e2f38f6e0c2207d61e44157baf8215f32f285c85af4d7f930f0905bc4af76f18e3d51c5ecfe7e527921275eeefec7f1fc16a0a92c3d97ad8c3d197570cc82599024be1ec778f6a607517d75cc587293074d499fa533759a41683feed8b1c0249ddf948e4bfc225d0a2759a07d14ddda390fed959191b8bcd4e54f4773a5296b5989df4b560d8aa439f9c193051ab217d85f44008ff3c2f440acbd6e39808495fe62cd52bbd130a49dec17c6f811949a7b399be59574965f8abfc6c17f3c7254f52fdc7e307a54198e4ff65feb5aaa0f187615219a9021271bfc05814a7d6151f84a4751d95790cdffff0b284909a7dc8443d8f4f4d6f1587ec65e8a50bc43fc0fca1aab8c333808669fe92f93f69b2efcdfeed23b6f721de4c3215b2d0361532518b97106bbe4a033c4c30ee46ae9aea5443bf499d9a26de85fb1dc51b2bffa27bd922237f1943db8d3b5a827950b26e63f02a2ea3e520d7690f5c1d47c718c1b14b4c7a244195ebdcff5cc22f23db3d2aeacfa3fdab1b55deb3c113fc489415421861e37550075865db4f999caaea0c838c21b1c94c5d2c2db43631285ffd0455589d04fc12ac6c814cb4614e1d89633793eebf679dfd220edd328f2c7b186ecb8760fac4e17ee2536c82467eb505d1806c01006ad35383fe5b54979a293fec15493cb5f43375066fc7b3f98a2eb5c418766c2f2cbec0e288763d099d5feb3cfede49a58f3ad1bc4744f135f8d68390b3782dc51c3847399972c2fd3524b191609797e66508b03a440588bc26eb7ea7e3ab31a29421bcafbfb343d60e90bf0c216379752e8e38ef13f8b654c741d5eb9a4eab96fad6f5c5aaa6b75b255a7c47b8ad1e7fe0e304a1b3547114523c105b116ee378dc9bab596939dbd3cb294ea137160c29905bc5b4f0dd0b7dbf9d5d2e74f03dd15342e231bbe70168f8291692547626437b5e3733f537f9693ee06c433e37bf4e455b3239c6353bcae86effdf578e7a61982f7220b0d1709ec0f2089b60543aa59a142b369638577dbccf51d61d8e8ecceea3a180e0d3140138fca0b94bae16301195ddf4334d1bbe500babd8f1a66bce4a3b7c71888e1f508c038a13ab7ba2a9b78c03dc529ff04cdc32de7da667c6b691f886280eb5d5cf6c1da9f6c1491e7329156bd215fc50df4776fbe0806240237e200022086ee8e44b8e7b00ddcac3505f7621deecfb3d473afcb6dda577f71a7bb1357ebbe8545859caab56dd72bf2ae8c78b0405b987e39b20b25b8db763fd0d8a2c57432da07c05e912bc6340fb288849a982d2a092d90b9402afa6fd0c0d39edbaf3f41533e2276c6e7d760b205868ae6039a5012aa248439b74e642471f4eebc83fc0efcd353c2cc161fdbc8d6173809ef319ae6ba38bc52356c610c74a3d5f35aaf98b1b4a6e366a43165edb78af201da690c3439a51beab12e4fcf9f47e183efe714d77a0a6659ef7b1a3fdb358ee2aeeb8a708350494508692d7393be75a9ac8fddede8bc17c872242567236c6b90c70c4b6e588257b95d7fafeaf4c9cb27b36efa5fa1ffc1897e387fb2460759ee4a893b1a07858546f19b51cfa5c6f75c633a59d8199b803bb65c48309e6bea4cf85223061430655507d4a100a20bcdb41c0b10c8741b2c6b6720063a17a62371825e19068454bc307bff55d8edeebf7e2b31da34af66f76ff932bc29e3f958b99e9320a75b3c13a0a1d345de6268d2411d256e87a138da704f5f7e4075bfe27d3e0c389fcd6f89b8fe47a8cc0834b7d3327673aaea0953a862786722402fdd7617fbadc844454979a234967d60aadd0bb08aaa49e88aac5729f1e7257f42032e0bbd6e9aa706b8a889a1b216dd534733ccdbd2a5aa1d9f2c254d480e001258be4cc4505a28e18c1ca0eda4243fa401a1d4c62e4d93f5a383751421c1cd8a8e03fb1b876a684d36fc8347076b1f2171dce31655c70c6e499a93ba3d684adab7257ccc4b48c59aab4c78196da2499f539d64eb4e62ad922773bbfe8732352f30907050dc955e2b7d8dce7342891cbd458e5695d2026b9878ce8c968ce493ea549e78319b95caf2a23c9aaaabcb9ac3716914b34a8d6dcf6dca5dca8a64746cb94a05f3bc1ca0403545eeafe929831014611ec51b54e13c136975a90283536fd4148ff72108ccc58448fbba4b278f861e1cd7f5e7a5847bb3c331ae3c94ac1b9ebaf00f5e994e26f6e92614f9c70eff37195b4694122b666bcf57cb9f36ba185a8634852f04c1673ef324a323ae63a6f7d93b301125ec6e476f667e3c5068173634e26b6d2c03187c463b487e9fce28450cfaf496a39c4f1bddc29037a389c560da01353585ae95df9d64698f37ac364aab83c89bd8fee6937eb2d40eaded8fda77a7f12f7e92f139f2b02e9b929b0a32a033c448ef0844a7a0bcdf196f685425ed464bc6c1c3a36528478d4bde60f8c8579feb11e0bfe14b2716e6351d690f8d49e874e20f24f23f84a21d30fe9afd5e2cdf0fb958ffa4af4942cb799016d0369999b651c16d9c84885e20453c3a1647adf24de7dca7553f274b25f3cd90f9b3bbf90efceaaac7685a70e5ec89f8e409474505e608f93274c8602dbc4de7a69d3704c3efb46f059616ac6437d3d0b7d5c2d69666fb77bcedf8cae2d9d424c51ac562969f62130353f094855b5b8ff010e14354e59bb0f165192bcde38f898381b17694a6c760ea5d80ca1b870b23f68f305ec83e2e717fda99191da118f81782f2d3e1c74b1144992119f90b38d7f27387516c415f5817164126e9c0c872db2369e5ad894dfe2b3cac42a78a62fb658900dcd7254f3f568c69d4925601ed401835069d098c259f2a7fcef6f0bcfc1c52130adc84b83ea8c1f67bde5949afa14f06bc90962aca107345d15b02e0dfe9b4e1c46176adb4eb841597967eeca09b11968e71ec1febae2e23d6ec5515268999af141c3f8535e3e3ec2fdd749a7b7b29d74cd43d43db42beab0f56b9aa5323ce3fa8b798d0d89d13e052727b437d82ad08ef30b78003796b1ed2ed292b4c431a8e1f267725ebe67717cef9a4903b8887305ab2919e0c50b368a765a02d74307e6c53c74be32dd9183eba251253505944346f69f577135a769c499001303806693d9f1d1ccd275a4a512536d03b5a120f975a14b65e2fd5d70a35d2be16a747dc963c0c856d056c47a4ce1231970f02113240e88e389d5a1f17f93125cea1b816e88b7a75d3269ff7942370c1cf9709f34664f4f6d3a00642438d7372171fcf65b962c8e4c618ef8e05a372716ae5f6a09bc3b58d2c15c7ab6fd7528d7837da6fa59cf319b6061b433cf8aae866c8e8b4ee3b6b30fedeb50505cedb261c3e927153d4e2a122aee2bbf2d47b1fcd1e17695cd833e0211185df61bafed2e16758971e0f0c8a47d06f8e2847b7c67ca0e7d350810ca497f06b06e81fd821472e7d733dbea6903326665d9a322e99fa19b30a906ae25af9727a14f49dc0e0a59312a46974414f5098915a412395890f5ef7f21ff339f064876f3c342cd217dcbc79682e7bbc9d68a6f3a4194007d8eeef4348e2715ce69a22247781a6cadf0c98bab9860af170c05b1fca8c7256758723a5e76e78eabc21819d77381f9c7d232ace1f376e96b003f7f46215c2ba388c4124c4cb23ae42be8abac9c41b08ef6db841fde2590fc8ab1c9195ba27054d7aa5ebb848c7144717c85d41f410474555f7840c72cf3a3dfcd760df520badb25deda83a73a2130d15f3835281e6ffa16371dd82a18e4f85e2eb621e9c66844f95106fad02c910161932fb7dee3444dfaf07ca55b35f8838823bc8cfbfe7f8511778b487ca6ee2e24c80371d273da2ff924ed2525484a99fbc734b24ba9ed3f63048663027bb5d3cd8426a9b79562538b080300d78d661ad17659d955236d5486a27b9e1ee737ed33abc8ce556a1c873d3049b9a2a0726f92e39b64011704b644ce8adbe1c9ef2056d05ab5e4afc1e928981816807803f82088103aed7c8554170922cbbc54ef92e27ca3354817cbd977d6df412debc70373f43090c79f1c9e7a218693b9f88422260e05cc1d75b7910502dbb13de033a64d3ce1a0f67c04f24738e1a8e6e7394af96de4579ec986bd9ec6b0e6b97d838d837b954051876df8b261bedb579c21898a1c76f9ece80b88775e70f9525a876a9eb828ca831caa2488c92484e003f1d308a83c68ad1dfe60e209f88a13e6bd3470ee6615ff62d26f66e2cc730229fe8b30801924e0aacb3999ed1ea1caa4765a7047f9ef850e74a3e72e88e8d539797c5e110643785f7c6b245e391c8e9c6e566241e112afd4a12c5f8bd1dadac4df09f11be22e02497d080598f08a9e2d8ea1b699f39c44d0cfa2f8b3e28c10eb968a1c4d25f7ae838308ad252baf39fc3829280721bc6260ffd19fbe65d1d266747d76ab4354b35189d5af3a5a0d7b755b0d1c42da2247b9f896719c181d07b66b35562abb8718278b0aaa4a76b5386cf462f154c3e859a4f4928ad3621a1b51ba6144d8b828ed2255409bd867233336a13ef7ba73e4d0426e47652ec08998f2f3f3610bbdbaf386363dc7b308688dbac203381c3f4e288f00b1f9836f537281848b35b09bd0cb7372af99369c89d1af834dcaa997a8a729e2e71664b7b1fa210144c240aaaef9464eb106119054ea59516c1cdb4ea56e665c621c2942b0f9cc6aa9b6d44558f9ac73e68b8eab87e28b2136add10865bf5fe661e054432cda4e36c53c3c034b48d00f5330340ffe148686ed5b16b3fcd05a86a189d903d0fb1664d3de49bff3653bb86bc47a2a15991b822f7d2b0d7e477c1be67dbfce477901af3d531c3194d9398c1558ec32c1c12fdd2e5aa65891eba805bcca75c22acb0c6bbbb8480ccb10eecd69d05cc74f6e88d42236f8bcdfc653b045701217a2e33c7cfb8a629b6b7344b86bdd083eddc7f9227f74bcc446bc43b9018be6411b4a4e63ea12aa4d53c52f0c9ae5b51e0d8821dc5b9f1558e70a2d44691320e02c329f0df32c24d78a89b0a7374b35a17aee4b27b56e4f391e327712cb8805483c99bd8e9965874cd1155dfa592b9e9bf9114db55748a85f564437d102336ee52f85ad39fec337c9866055f60278ba5fb44b7e1be3197767933ec67123116bff72d589be866cdab1f9714afede629891fd0e1cdbba22268c1612f4eb821624abc7dcae796aa66cac691efb751cee0d3ce922a02777f6b213e67e024e2abb9f09ba4892544e64565468afa58f23a57b746cef8d5a145267d0a396f77919466e383defe5c85cdf2efa05492e5b4b4c14b9c55637c4cc10422efcffa8a97e509374076acc9c48499e2f3ea88914e9d26626e386d297b98888cbeae20ab0fc5421b179b76d6e04e119c4441c6e4ea3152f0037596ca8ff0f5221433c566a8ce2e365718a9f3edf450cd38fff635410186edece04998c982e51dd38a834097fae2415e1af78f11314c522c0264b0eb7f5900188348e055cff1c05c0bd6659fc5443fc2be64f16c74ba2c66831c30e83519dfe1adcbcecae63de86f5932198cc7a3fd409e9d5820751a779155fc4ce2732eb3be8019c4de8f6543f6164556015f9e80e322c8b82b4f232ec51a05b3115db593678265c257dc361c3e7c48b36efdbb69c6437ca8a6749e2e626e79bfbf9ea6d4166144e88e171617513b43c3e1ccfbd811a0dd948489ff33d08ff09262ea7db6468af4e96a4749e72432464c65c00023634dddeb704cdb043e1d4091e7ae37d3b54f055e24664408a2e7a66a10db745a84dc5f55f8fc68f4252b256cab574a974f6eeeb7b4218e48d14da70e8cd11c0ea8c8b4d52078cef125f16da04572ca2944598c4d5f72d628a436c62da5789da48ebd148934ba9d2d20dcc0a7a8658c932990d891d7ea84ded3be560f96762d72b8c7a7e6c42feef47a11684a1d4b377948d10e17f630eb758e3efb3258290a8fcbcb5596cffd0d3d8c415fcc676a73a2e0769f9487343bf10a85170b848adeaeede8b2ae7b360d0a66bb170198a9b63d969f00c8b8f855e239b2d384242eecdab47fb0f7cfe47f8e9d4808b4e5e54af3eb645b81d11e0d5061b83e49a87cbb61285c895321735e368122a60455f3cbbcffe1060b96d7c9763c48dc4d247eb6c4d7e0bd76eb7a264dc435b1e70f33c9656f684a25547316f934c410006a2164eff52ee50f38b75162987acf512e5c64a22650f911cbe3feda37d84e39f6188f777516ce67a6292abcca2293730479c35af5feedc26a935df41b34df7950d93f3a281866af62c95538b15194571b2803d39eb352ae50efd040c5f3e3c9e3095843c491f01ae2ac2003c8a5b1d45177cea1c5be5be8f788d46cab3b7992c379d6238d8ec6e6cc4c08167722b641b4b74e29646b0a9ff1da3b42f60b43f5b808205e37d9269c59c3406a8099b74cbcf3fef01eed5b90e10a3ab13438b768a34ccfdfa7613f82fba233951455072e0e73abfbb70822d7975d6950ff1a0511633fe4586a1b3a4934ed8d9e15dae1afba2aaf6eea80f191a2c949f4a7341b67c46ccae8f82a8b8fc18f5f9504c8e221af7146d21b934898e449c8a7925dfad362f9a5dd1872846329ea092975412010df8329fad317e56ef3f9233a2393814da43f66f3c8b8a9c52e1a0111a6e802578174e4a367ef6c748aae086bbefd0e69b0be6e5032d2e68a98abed050cd840b3f9f7f2eff2ff9e718208c266df379de5125e7ddd7b5b20b9b1c5f4192e65349cf3964ccc4d2736fd2f31e74c96624c739d14f7f0d518054fa4193e075f51744c3a13d53f0ac0cfff33c3fba92d2d387aa79ee50e938f201e53be98a601467219ee9dfca9b91f14a76aaafe4caf99c0b08eea6a779c2d915bba260c8bf970d1623292859ef1976547ba54b99e166a5dfa0230db82a0e9663b5f00f1d52e94931b407128bc7133bd7d8eb1403189b325491989e87141f03a0982f146c72d4b5d9082d4a11fdd832c066f7713bb7123956262a488db469740b2faed71a35ec931e0e5fcca4b6da3ded0ff4e552d02d4ad3a69df9616de2d1481aa50a406e7002787243c7560f0a1c6967cf7a5043a5edd41071f47b91f01eee552c3125751705f058a4998f83bfde230979c2fcdadde193aeb88dc755e918c565a524433c8b59dd9721648939d553f6e68e256b178b7d31ea67d132c2dab36418fbadff8cccf3969448adf25ef9ad43d145404de92dc11c4b25e27688341939d7198c1a981715807cee6be06d126bb2e2c1a0934cfdf126d2056c6427d370f1e3d0fb0965e573dc3faa4db19a71972656802727264332f9a8171a7df91ad09bebaff676e4693f723d2de9592eade908d0c5a5727060ed6cef243b103a56c156d1596b356a22d8d0a721bfe2ca6d2b6ca6365facc3510e896b1f5c18d83da6b3544cb6c676b86a05ba96f6b9e8c3e4846f2724b1593a28e09c3dbc24f1532ee659659d19665ad7b2d77a980f24857375e9fb371e56c4d2f7ac5b193bcacebdef6a892ceac6c84d668e943a25dffa93444e0aed16d50a1e6b3cecad2adaf18e8b8bb8a3b03a62df5173a4b308f468ccc665aa7558a2148941584855629506bba0ddb93c502b556ec4293cacbcabac46b70a18f4dc3a09dc5075be74f54066b8b4fd51f51878328c65a63b0d1548a4aa7aa17abf661869635673e17da0d01c2a1d4e44fe12349f9bbb42511f0979228e4e529268c98edc7029abb2310827c31d28333ad9a5f26629c5e22c051746bb87ab83ac59b298b27055473760558f69baa015fcf3a580163058de4560ebff50c415a62312901664d58be5e44fa66b19b5f2eec2d7b802e1faab49f1e074f22856f3776ea9c2ecc9f611f12f258f2d569e55f20bdcb6a4fe3c50a953b5a695c037f93ba5d5f94c88fcf2ada4208b9026a7e517215008eeb9c9e11537c041c745ea007026e0a1c746e22db0651d0552f03976f769c3ccd3c783c877ff6810662079efa4c508b4e6a1afc0c3b926b213e22e68c8a582d179ac76e8bbd46fd307000e74be1be384279682a21919ad4be61f08fd5ee66a4f2d3afc96e87bdd23eb28e7e96ff71474ba7b591347432a73400a66bc7638f036590261945521a98fa4f4ab9a6735d87cee3eafd1bd53d33095de2793917a64054dab8fa1649566ded711204a015dd8193b3844841ae7af52f1c48726a419a0d165b901acae0200225ec9d519ef4d01f5ca51090ba7867e0aed04eebc1b775940dbfc4a49b06c0620d6c41a0acdd35c1e0b23c54459f10fb88fc52346ebccd8179b2d7cce3831d7ae33b5a23acffaf4ff60e3b95b85e9223680f9061145189d522bb1f0144632fabd24b84907ae39d406ecf11820ef587293716955bd3fbf3e70f955cc101ff645297e3e6c1ce55869b69de209e92f870325bb5af22e36f1bd12d9fa3ee7db5ced35ad8f0a76f9d62e421b83ab8ed28f6d9a2cc4452427d9b86114b3a689098b6dfdc06334fa9950a0c2250d49eeee83e32a78d27ef236d42883f3b87b9481d71134fdf9b4d0c402969ab19265a6e1a93d7e5dfb509f68976d11776b7b5f0596ed0ab6e70ee937d05c01e65209d71d7aa604476679c063258097ba2143bbb528aa1bcc833316c06fbccea82a894eb14e94819c79c0a1d974c6967bce3e1b3bed062aa3ce6df6e3dad19851d1e3004ebbd5b06b9639a6733971ef4acaa7453f9c3a879867a78dd0935529b0a67f4fdabc1d08cfa3757765e3fd375eebc576dd20bc895604ab5eebba627c30ece6eb7bc455a0497e9dced830ace737d9b437e750a23b518978cf8aaff04018b026c84dda9233c2f5f2784f76767703ae31f15f36e7164f1b8cdec9a66ff17b9104b268d47c048939142616732cd366500247646510dda23aad9b0cc081ad89272d1adce8372b75f8979ab8dcef4d42a96cdafa297c0b75327cac735d034f5ac70bad8be855b0bf92fad7bdcdf02d3b9075bfb875380f4cf614e40badd17a0051925de905f88b57e39eadb649131060292fb56338721e521f1db22166beb2bcf1e840e051ac912c942d6d919aced9948852e74e940ba0a3b6f3ac50a3732200a5dc6f5b5a273c7ac2b32fd34527b2d4524bd2fd1c966e4e33bd92c3c491578a06967a58e6db750b1cb9aef68aa4133ad6b833f08c72a0aa035330b8edaa5a55ca06a731c4d54ffd5a59f24c97092362553f62fa5ee43d9154a119cd0d3134c5ace658f203c297f86d2d478892e0962634acc26aa0e2502a8af3f0d944c6abb6ba147b33ec35df40efe35b0cfb446e8eceab090c19a7deb30094cd08ccb325b24fb1e039c1f16dea117faf575b0671e01a20bb245ffdd78322f4658b42d2a6daf5dedf72555ef57f14e6b22fd1633bdf6d7374141542e4546e93020b06fc739d1ac6706ed819e2b37b93c3162ee41e4300dd3dd18d2639828f9dd9244a0f3d029fb2c302e614e27d342687bdc55e252dfe0bf61e105adcdef778e8727f2f91a0513f5fd8864738986fafa1693fe17a90db84d2b1dd531d4a44f8962743a6220bf855287b628974cf1d095014fd4fb3ede7b58aaf3978ae8b851abbdc32176ff6ca9ac8f66f2568cf65bb290a23b11fc42111d2754613ddb217081b5bae635d7ed633f6fac921476803379d660f411f5bf28b8cf77c496778b078ef2c71a217ed8908b4422372f40b7255a025cac47a1dcc189dad1e72f02206be0b2e9ab0861c010391588493f740a78b38d1985c1dcaa1343f7aa1658f9c11ffb33b90f96ed0e3c027383c5f6213cf3a80881f66bf7dab14b86733a81b47f33646419e02c8738dbf5e4d439e77aa845c6b62ff7106fbfe0d899eaffe6cd791898b6d708d1a4264228e84ed3143ed3852afc7bea6ab163b2da33efcf90bfffc3e1ff1ce5749b687f80b5e28d16b74fffa38e41555be9b3416e99e815c9ef38f6c4f4c5827917662a43e90003904721dee4ec2ec12e8a901d73bd9b756939edde6b839a38c347accc6b9a18aa55aa17a275750a44bca96e174af953cec10c0db7f516c0b78f89dc0b6c007a0133263cea05a247cbbadec07b2f74b05946773e066cd08a84c1a344c61c45466f1a6fb216136370fd6925fca0d95a4e680e267505d12d2704c1c0ba52c289b8932e8feed619c75be41c93421f0d3b407003d657742fe65ee952f59890de00f94790cc43724c89a3581e691bee33ff2050e544f28e77e19531a3b9026aaadccd7ac06d2f34b311593d353324baf29136b77df705efc7f0719fc7fc8a84ea5601daee50eaecdf01af29822ee67ef8f5fb31f7cc0f105c752b7ef0704033cfc230807d31037c85d678d8602ef09e0a5ebfb9df408eccd55d3504dfbc30539592df36d8e949cd34ad31f58beb573497743cb7996ef56c0cfa7755bc274d6524236a41487395064902f8db33051684372d8c3a95637603f6d74082679e617ee975f9af78680ed9f8a7b5b57a40b34bb3e672908347729f79ae198fdf5050c4b59fb66044647ed520511423e8619bc33c16bbd06b45e01c45c654461d3af85e7a222be0afa23e100ce8fcb679412e099b558e96e3dcd729b6d6f6cccfdb0ae3b7c90b8dfbd8392f6eb13c60ff79aa8018a7bf779826f1cdb1f571a6c307393769e2c5dd45a6c197502d9ea7e6bbf65f99a7359c5fee649180d4c98bcca97beb8e91c4297c06a34b1204a1a5554184b8774fce3f29850278440d14bb77476a23ba89e20c96d7503a454bf1235afaa9d829d88f9361fc8213edececf08d04d200d9ee413adef002cd812f83689c834eb97d2478f0303c31629d9d6aaffd14f649d86b0cc7a71f15e5e1832c3bcb9dd4f2e552151ebb9e4252a95dab55398cf2f6996835eb4418cafb198e1007f27f042c7362c2fc658c581400b0de7f1c2f952222bd5b733f5804de98168ab7a0391fa87b3fe857ce83f92ade85077807aa39c5d0d88a0627492ec289301a2fa81a85e59d886051d96d31248ef8828a4d89278a245a502d5e950dd1041cbe2c8e139c77c33f08e496fd8017f502b533f208dad96fe269a4d03217fda0fea3ee6c70fea62d24199696d7e0328ce19b2655b78d871d8a812ed42139d319d3b586f03fe0ef00e1f6674250db6077b22acdc65c30b1ffa4be5c794642b1ab6c10ac7e6d83a65e96cbeea5ccda4b6a15c5bee3f9bea9d09456d670cb428ad99ec92267f84d3e820b45e38fc60d8545ce2c9b0120c19b8477328b7f455065418dd1f831b7f47983db9e833dd0e0c34ead6857df5b365c28db5a3c186e24b5bd1855dd64a5f237959079d69f9453d9446be22ab59e89c62bff3da8a046dac7a009fcb2aac748b6581c600d41f0fde84ffb705965cc52dbdd469e4c490a609b8e17997c703f601c22eae73236b1a5f7ecde4196eeae40f95642c56952c4dff3661aa695be3e07ec2a9bc03b97ac06e99f1fc69fc48409615dea4c4260e4dc67f428437e9def3135303da357fd31f158d4294d3ae524ec8effe062d5cb1b5f5d97748fec20ccede3451e9cf4e85eaeca472cbeab4d98f78d8c824d7fe2627ff7bda4555de2c650fe71cf7497fc4b2d87d99db99d0e9963860d1ebcd640881dc54ce73b9a4c5ea080bf60c9693554e6a24dc2644bc5abb136ac8e2becc69eaa7b90c0726f91fd8b037c215b96dd91ecf676ad8990324d79184c4ed3f6fe80ea8b2e9d4e046122ba0f46aa9926326389eeeff81475c9238b731f7597a1519ef2be7ff407c374efeebedca2b214e42b424ed726fc76b992941eeb9c0445f586ca58056c6deb177cbfda691c8ceb16f5ba43841bfc12597791096d96ac4550c74c8500393ed51fc72e37fccfa838b9f1757dffe71d5c8cfb040add1a5bc96311e9158f574c3b234ce49fa921bb9e9262f04242a6d32113381e6f071c715e717e09323bf72f2826bc8a87642cd814c3c096bb605fe4df7c912d832b297ba86c9c82eb0b34cce03967319a2893f62154253a52a54877371a4b588a8982021180dc684f10f3c34a6453c96fea2f969df1b711fce9daed640ddcde4e1e924a779dc39f2247a1016ca6c2220df34e557892c0f64bb5b79570fb0eaa3a3f5b92ec467fc7f9bb5ca31d67d747412d239b074156e72c2904f4f5f10eb10516363bbae17e2825282c9db50b8d1593d022082be9124563c04727d22e4c4642ec54175eed67b26cd4c610cee04317bd2b35caa1ed35290e6bc29f9ef591f6c2cf0e9aa16e0e05ae4eb508b87702cf8698d47fa1844d04e40f3907420f71e50857600e90501c740adde29eec10b63a5b879f6f32a2529f579b65e8333f0f77cdc435fb5ab23a5188e40a95f3aa23a8db4d49bf1eff1f8f79dbc92d50c054e024881993613c916b0ca0188c1b8a4aa90dde3b0730d829b83ac90e69e99f97dba3fb1881c7e1dba962eb89d427dd6c31e4124a1ad43f53a6c1c7f8643f68de5def85f739480cd67eab4f260812a7c6c33480fb54d6f7a3d36a739391986b2e403c476e4aef7d2e53131d42ed3f2059c474c7c6e3dfdd30258656a805823e12d2d91c612262b45ab4887eec38d32c19226d29550baf59b81c913cccfe06301274eaf27d6e4e6bb91c9b7c59fba53679b2eaf6a2c36a7279cdfaf461e2ad719d04b34014a75511e837c2ac39b3fd27612c8c023ee1f1c8c2c4130812801eceae350330e6a4995a6b4d6e99385705fde627b217dae8cca711ffdf5862b8d9856feca230f2fb8791cf8548c03d213b308bc6988777ba08b670eb9c10741619da233a5cd1fca58ba49b8444ec87cffdf2938f3a9eaac55596744b115ec737660b458b0147be5aa44afa35ce3f890c5a9d866ddec8ff4e2be609cbeb483e5585b1014c9d8e4b6c763ac6fffc81b8d6a645d6e2d8aa7c1a6fbcc8196645ea718a4ae191a1c56ddab9f43178adb6774e2dd8029b49a3d5578430478fb30473591e5102d1a3c1095b0a18272b623a3e0ea6a99fd0f64fdf96350cb80f43fc44e380b1acc8abf2922469152c35c2fc83a1ebc490e030ce9cfb609084ea8a5ab83674a97a77a315236a7b8316a39c23d3dfeb37dd2b4bd484b99833bbf71769274886c81c9b040d57442ce96bdeb1f38a24ddd3752111eabbf95d2ed2f7dd37993041b975512fb3aa46b5e24dda2624ab58ecebd635259a2f66b16c5408f1a43a2005c54826bd9d2e01ef87d124154bf2f082199d57a7287cd295694112fd4f6ef28e3f5b5c9039c485fc7c2d2fe4d32f9fb49184403ada605143472bbfb8e2fe31167ab7fb5abfb9cd7d5693800313acd2f8c8e7631d7ced20857eaf1fb2545aaf93e52993964fe8afdf3ff9cd558243b08c719f60ac368f545e4a1cf3b7b9e2a906dd32be4a0adbe2e3c5082a3444df695a5509fb666b3ff79661bab9d05874f147d92ee778ab0d91ee2f08b20c8b0f25e1ce56686bfb09af9835744b61ccb4170b8d1d244a8978033903310c6674225bfe047f90733b8666129ffba56fb58c02bcb7f1aab032c91e71a933e3530fcadbf39501eb630e3ec89491845794e4f06cfa15bb39d74e025bf7c11859ad4cffa0e977a0bd8058b6f12f7c46ad9f6db99568638c93a34d44de83399101069abc5816b2e56b07e5ec3874eac1e254414ed16802533b22aaec97681b47891172faf8a808cfcd350c931fd32756b14424ca82e72830bd59d32f6cd2d9e82dbe4036fa5c5df65c7d687436cdcb8403fd3927e7aa35094504d02271d32c2d462afed08e4650d264dad6a7a6d0b5eb3e6714d8115c9e384a63c77f90a06940c08eca6ace23e311016d56df73b9f17fead49a25a60346612dca08c93821f8e62fc2b8309933b9bff8deb423dfb4c188d7182eff85eda58d9def3b2d61b36e1f0472b2c5cbae3a7c5598e57c6208d94e7e595551b3f54cc8c903c27b1eff159bd0604c4b671e04a348b8d0d304d8b6911057092b5a7245ba05d26091fc2178ce35e21f46644a5278a9e469cc222a812c638e2c4a900baad7673375dec2184a8ba12c979f52622c8c767fbe356680841d284612ecdd008f3a5600c8c750078247797d1bcd6730d947f0f5affcfbdfb9f11bae5aa4674611e731f4a7c398da9a7c7f88ef889bc279f17d019ff43ee0abab74fe54a643c15fb33870e7fd4a18081c0d1f817a14241a6848176f818af123d3998818c09e50e5741f7d86e6e81b1128f8a9edbe79e17ce3d6f281a4cbb7cca4b9b9ed4f918094d125dee7a9131a9a0b0eefd36cdbebd2bedd1a7ee2f88e53a2b41af32efdd715e3945477b26f7135d6408a7daddd3cec0bf1f658aaf2325ef442323c2408a0b15b2431bc8c16d3abaaf59405509ffad58c36e1d317faee12728b4ee4fb2c48edf24911c370dbf168c4ce78f8e754ca40d7aa529c1c0a21801d22d1ae1e90d0da14ee85f0bf70f650ff99136a1b4876502f7cedf03c846b88743ab5b9fc23267ca6f67abc27b17d19e8110684dbef4a36c6564ec2077cff557b889dced99a066bcf5bce98b61aba08332f8f69e7c6e6645b8a9538a38cf5e2c5488e6fae833356f4c48b40f871d173e5ff1df940edba122feab4a4379db5e1231b6ccc1eb728d20a9ebc894e0c7f993ac5fb8a0e6ea41487eb571ba1b290232421d49f566d68a9cc673dc7e0d098af96fedea52797ed63592f1c0b6183c132d920324787ac946604011a37712344e2892b83bbfc67b9ff2e70fb29040fe4e401920674875a7b5df86a4174f970298a4105770cc5de6513e9c51c648ed5c5ce47384d224f77e74a3990bfb9c64d393e9875b3f692667e59d1fca27018c2c69b8af8ebf6f5306a14d4cb6cb1055840cd65874768ed234bc3cb04226ec5f460fd02a02de58527b573a5fd0d0b369b6665c296cb11c5db017a70bc143ac045d5906e8e63bdcb8e091eec3eeee71f5ee306ca031eb579aa0033aa57ff2020b6da8c91dee6923455dfbbd6675061fd34f4828eee0dfe876a9c62087ce08d8b19e1441faa4545747a426632254e6aa1ecbb17f84c42d3f801c00307dcedd53f2d6dabc2b3dacdca8f0df09c391eb551f589c91e891c3f622d039a382e23e4d76c2d57c8b87c4c41b927284f924885832813df7b35b8d75c3168c22aa103153f08c989434ddf03a344a250bd7e184d8724ece12603da37c9bbb084ede727af3054373fdbe8b35b109499eefd486ec2e0c6bb8a70daf2c19d21ca3dd2a0c38fe62a8c433b478adb3d9e77c640554bee6daac5d01785b4f65d2fdc3d8cddf3af63d006bc52546c5e1170985f306dec215e6369a6fbaeaaeb49488198c45f9d460f5eb90e48ab4b82bd379f5a403284f426fb815c9d09e7c6005a960e01b60818607f18971c8d5710b9bbf3ab92df8c9777abd9ff3f23b1e9c70f78328fa7e63a0972e311831850139007a801dedf2a4cb59ffb21bccfe5d13e290cc877cbab2d6b71b0487553dbe34836c52a13b0cdcd8cff7240178744485bec91dcb675e594d10b8f546e84526b671ed60f62c59844a656957d223281ab5ac3aad0a5c6a6510eaba9ac61485592cb6fada026b28e4922ab962ec77c2b162189b47f81d1961d5823d8db4a1db1db25805685be6293ef77da66f1b12dcbdf351c165fce3967a9d528693f73ab5e3bfde1c5a5054c8daa338a6b913f2e046dc9851c952ef9e2085963b58961da87c2e73e02bba87bff252b56e414565b6f7e45a5e797de838c5aa643170ef826959cc675315d1b72fe9bd83a1d0eeb9f368ddceda7714e8715f4885ec701d98a644d4637ebbb6684ec1ca302e9405a35182d40f4165139c3712fd5c05a43c56bb4d302191dde3cb4d7975f2592600e6dd0ed6690dbd20a374bf945914b2b0aea819b196d0238976c2cc1372f5019a7817a877afe1803ea5f2552527c8e6943b41ded9dfed7efce05cf42863e4f80070e5614754b3db84718a1ee2f08f67c5ce1b8c34845f45921dacb3e287c4a0020eea5453c1b272a0b729a3025fc2f91717ef084d3a26bba5509daf3156825adc120692f3ee74ffd7d018d393861ba9c6e203e61394425ee24b96353bb945c68fc9c988c939e1b911c768c777d55e5ee409e19f9cfcad826f0e3dbe3fa67dd552497e1195a0a136bddb3a0111e04a4d4be4dd6365b220be8a0f70f7d0900401107339a240fbed46e49585cd410a4e2cd00c05e50435358e83ea9bb4a14a8d3a324adf7c49391cbd46b60ab41fcf0e66257b14fd00f4214f99444ee618c2aa6552ae5948a13deb97e5999e2146af45943e405aea7fa4a8696d6e9749e38c3aa66d3c23997ca4d58b97e208f403e932603b257d5ff39a448515922067c048579d711165e1398b76a172371c1ae82743c91af66e3d48ced92a056510a05112e8bf69cf183f69802d4994fef45e238e1c4eeffa4beaeffd2474c462110b6006d4259b67ee0d354259c6189509e91ef970743447e2f7f75e4aff6edba2e473a13bd5eac976500d4bc209cc4fb1e4cb76f0f802ce0544ccace3e9e4562266a757eaef50091e1dea326a56e31774dc3f87f9877dc2939c943ad37179886a317e2f3803a4c13ea174c4eee66027c555f5696eefcb0705dfb0db555443499fd7dede01bff830d0cb57968ff8ab040448426516d97bb37bd985005e45facc21b20d7e1e19e905d9f72e8f3c036f84d5468ae85711d7183174e0d85fcd8aa8d921afcf968be99caefabf78d5ebb0cab8ef26ac5c9d6ee8bd00277358c9a475e6cc110738dedad49080660f27d5609233ecb178937de0f79e7a8d3152e2d4b3204251e2fdf711dfe70f76012192680b8d7bb83cc761d554fe4ca0b75fd0db15c8bfb6be3ed2fd7d2c7a7ab1bbf1c70cfee1312f35918356237e7bc2303f0ddd4b756ae7e6076e75933b115921c5818c336188921e963963050ddefec6cc21b45e7548a3a729bf40c2d3636fb199f7d602201fdf73af6fdb433c5a231a4354cdcb40f25e49926e910411c394c9d536189f7422e72c391ebf83abf4be645e5568f546d2c4dce51dd248738dc3d8e70a0bb05fe23a649965c135e93c7ab50ba6750aa524101182f24acb8c669dbbd2bb59a0187778346e8e3400df6b10c59c2dc17431bcd096c840a62a830dff042d9629e6d39e5e8da2b782208dec61c30c6cc1c95591ce871097f3e5c92ef300233510a838643f87ceda159f02bd4241b1423221fd7739c37510733cb5e261c799e6f776edd81259bae7cd3b09d78ab7102cb3f2a2b30feb0d89ab0681f06d82991d0667242ecb67af878452bc1b1d3a29988ecb45c80ea48fd8b9ce88a4a92beba08f85aae69d74b89bc4009089c89bb4959ef7fc5507b1ba1a3282978af08e590e40c20316f23979ce0af73702d8110c52ab86b0433c67d9b133448c6e4d3ca377cca1e0852e68b0825968cca6f4ce950068fc5945bd7f645d71901eafc3c334fa2d6de3d6227fff4faee92786a53957a408be8621c8e7733b807f9d1687eb6c59f788b30ed762edba760b876e6a81fc86b1c4ffb832be48543d4e32c24f5d78224bc61d9b31798deb4876b2a4b1f8c0269136abfd2e1a2ba514960697b3e1a92e754770772eaf07c1fd91833ae975a59995d17b321c1e854addb5ec5de501247e613f8263a0917aeb70a6716eb1795c4972cf7af6e52946e0b11c297b6757e43dd5295f2fb2e0d4a69eb8f0d66c8873f6c5c41d62e0358b1e24bf02ab258cf59280c68c7b3bd2d7750b2cc1c3f15e70cc362ffa77608345f5cf9c21fc95db7c147038de2bcc359a80569cf2f5db1851c06fd12e4f6214d59aff6c53167e09a27b56ca76019759e9b00247473ded4eb83e931e0aab971a512b93ee4eb415e8b53d38f6db647f1807952785339b95aa59c1f899963dd21b9773e23a191df6466feb1e089e6695b5d40c5a1c92794fd44aa059df3671d047098733781dce9dc7ffde682f2b2d8cf281b25ef6c2c47efadd60c421edc7615835fa8c3e7f26f49f0be243397622ab069e8fdda7bdc4d540f58e3636fbff56a597ae8255d4008d3cecf313dbaf353095423095249342c481caffa522a5c3c9d100582bb8778c188a450cd6950c1208d190481a7c6355cfd89f62295fd0bfe384485de086dc62d281a4d434a9f37beba35dcb1c7e94dfd6f1bd2deea85188c81f327c7e21c4f48de91a8fa36d8a7317358ccf0b8a4e016876c56888cb0538f5f455eeadf42f880a0d860c2fcb932844984438724fcb4249c8f093410f2d07581ffa77f098ee0b8be96790db5335f4ef3fb391d173b463ad1ea729cda5b7214074848cf2bb423c09b94b7fa6ea6ea545a24cb75d9141202c789bed33dc6030ad5e314122940b54f961a769c0fb338df8ea29556ec258039576c2cebb5befd2f7e890f417619d73333a49c614922178c8a666574fe072b31eb194389040a9534092ce13f4f0f905aef55d3c72614ff49c914feb88903cc754bf79e30642320fe1e840baed3281483b4c05b6b8e54326b6fe3887627c5a964a74817b23ddb3826be09446e5e218bcdd10c07268d49eddbc1ea03fcb30d355a4ec5ea7af7f35711cb3cf2e412761ca4406ef7535ff4532c4ff3b428e11e0760590d38df3ca6814e8abbfebc74a76b3ce43c1ad36a8fc0a21f750847e94b099c7002d937034145226a6b24dccaa08368e73e92bfe34b1fd69b6ea7143fe5aa9918a8452b12911fa14b2d2187b7c17cad0351fd61278fd4a3a81e1aa8d9b05fb550b241420d25416e4992f9f2b659786a4f1dde949bde055652f7e4f8da7ef3b973478b9e4ade6cf80185a4faee59d9b938c5a45eb99a2ef733a1d4611e3ece93a5365993dc40508bbbd3a93c6b2ba5692f865d07004ea1b79e6fefd4e004ce872814a8c8cdbd647ad96efad95c34150bb7f0ca69b22ecd11e27d248ca2459595bab078b4ea9520f77377903980def2051e3df98a9e5000cb8729adb42ad9c3904c0e5d155711162dc52c8a347bbb69e5f780caa307ae59a11b76f82b9a040c1a5bdd34eb4c9f72a98bbaf8fdc3f76f69f54b0ec58b2b58b5f2e604659993468d08248606ed9d3aabd9b3e6de7a2837a2ed0057fc139f854e34ba8b5c709fef8fc88a15a33aae6d700a9796ebf130fdccfc0a6a4fe619ad2dfea8733a40d638e72212c4e70f874858bbc671017c93ac2041441308160f70e5d8ba63346718e07b39c04455ad51231c9f1444f0448b318cb3153625d0e1333fda8ab4f1b813caa52b69bcd465ab21cfb34652bb9fd604dd221ebc2b855f5a039fc0148f1fa9498b2dcd3d698e315df9941e2ad1b7d698c32be61d1cf09a3ce8194e69414f073b843504bde832d454643eb2a01db93b04f6f8cdc65f692867be6e93457b30351dd731c86f7a34de35f469d32288a33839e2080ed93787de0d16bb427f04785875104d4825b852cfd7389c1498d4cdac036ac499b143958a1d8de3986bb5193622826a99cafbcb5d5bc123edd82921f59fc59dbe962f388d0d2a2d08bb726393a7e02863ff5d1ea5d090a818e235b6a7a82e7275e164f83a6c5ef85a71758a98b5c0347d4924d33663282b524eddbda89b65d1c14408ae42ad4cc893e61b2583c85f21d8ff090d16816a79fc715f3d662cd92d883f44ee3eab7415cabfa512480e7bad8f9d8b273eb3b1bf513dee4793115f00868210d2578b7420c09a6511d8a54dfe3b54ba0c3cefc469a385b151cd2888e81093e7b4c91adcc673a9c2efab7f42270e5daa98cdf61114026cd30035fe45288076f863527432a87c6bec4c5289c0b91d83c593e6d68efc229985cd760962c74029ac5a0f61fcffa5637e676d4df24beac9ebe740453bbe74f9447782558f25eb3589bfa75a4ab730dcf505bb54b14eaa10752ffd4f71fda64a1dd53e704b0e4f4542cdcee707dd75df87c356d828a642fa8db3c20268ec1c88565041534dbbb427e2dc1e02cd320932654ab733ec164db64446afb7fc91d793f0bbf93d73fe4e40bede3d4300b1850b2b9f92e9311c68fac99eea72c58e4f940044cf6cf459693bed0ede8a9b44c92f9ebbfcf4d0d7d6930fa79ba5f3d2cab52d8047a9bbc7c69b2de8f03035bf18364743cc0d6dd7a362da5fd01ccfc8d78bf2ddc474af1bae94b6be775cf390675ae66e0a21d5633324d50ce413e3a5180b623a3d4ce12e1aff5335efcbcf528d130b2024bd1aa31ce0ce25575867662e041d056be297fecc25e88835d29e2a2ed427e5286eef42790946e65b4e35c99031a69954626f09ed5ae8dce13c42f0ff7f5883d879eb7fdb12351af5c818275034fa7af8c478999eb3640e8d9924619b812c806bb6c313058289596a5949fe643a9bf6e5d451204b095fde339a9b8be7120990a573f0d5e44a2bc61aadb18ab0e9ed0232138f9d45887523d81122b9d9795b49ff0af0feaa421003a56848c7d11853b6fb2cd329c6a4cdf6dc681b7d1b382959582e6d4ae0f6ecef91bd445c062e7910607005b27e53d12628c1e7d4d465305d239b8298ffebf02110c93f9d345be907bdc4d1e10531a36bad3923a01f13bc76d43c395d991bb8b8d41b21774b55170a4fe7993447a19bb0b4e0beddb6b588952e9a01843e73f3c5b9aec15d627c8aa7eaa767983509d66b755fb9125e6c6abf6b16a0830917cb1f2c162d0d6408050aafbb0900d45e0c8875fc668987dfad9239e9ebdedf11d2866659715cbc4cf3d5dbbbaf93f6fdce6f27c9efca1a9673aaf4f15909eefdc4a014931efd12e42a8442f386622a08f871d867a54a0196e3efbf4400256aaf49ea90d5adecedeff9dc838c44a6a9b3f6106ded0c198f9d2115754bb33ccd211dc3344be71d3ea53017facbeba6f46950da1d498fbd8d28ea99f4115d13cc706155a7b376242656273f0dd602ff7b8b9cfaa9ea6fed2ff17076272f61d281ba40aea09a483e703030bc42c9151757d013e538ee41eb329b779b2aedc8d4955a8a2ab9e2de749882ccfbf8b2ebdbb45cdbc05a449ac704ed535346eb23c8f0f603840f97651aaa0c416849acf62a5f2174746cdbed25fadf731f560f94b6deeac960e2a3518d44e2584ca4eccd370b30823afeb080a7713b68527a9566146c7d8e15f4565037eef49535d787038d0dd280ca9890aa1ac52e0e55287892445f257597b5a9aff409b5cb240d4845ca3249e032e870f727b357143ac06f02ff92c05fa59754d6f2bbaab1d053b91fd027f2c3644654693027a7e6d8cb73d052fdcce95de90299edf0285ffae9de485ce4110d7de4d8d96a2843f852b7831cfb2c3ec47550af64e338594d4d38867a05b240ca92f481c91febbf854988840647646810589213b642dd2966bf72ea4b043498a8911f6150127a347b11a24b587e7d1a335cc2770909a44472967700b598dc06fc5a7f61209e5d5d7be20fcc107013aabb8c48125543be95e4a0449c2889a6d20f9aa87a28492cebe612aa8a25139099e19d00c030b17a3e4ba57fcba6a85a9a70bacda971ebb1c0198808e3345dbdf1f6b994956167c9b240c72b0997cf7d08385a5805eea7ae1d6a237004a513c53ef881d5308f7d081e8ecc8da27c9fd6210e3a585244f6b20186feed3f630e019017a5a77611a8c46764e2829a4d62ac54593960bd3266e20650f6877ee476d14c5c70ded27fd509509ab82442f5bcdc794b36077bb89d58dca0bd811032aecbafcf7676c6ec9e98f247405052db85e3cee4e984602ccb332b47b6628d52c74fe026fc5b303a00ed516ad95610aa3f3fc3898df77bb7d8ff5f091f6ed90c525ce3cdb06c08c8ae480db75a227f9c1cf6facc83547df6548dbd708881ec6ff234a1d267b200d71d1a7e2f0a8ad47741c16b713705602023f0b6b843ada95a38bc88b7b985c70acea7170e3940de1c21028960c51fb1aaa803bdf18d35bcbac4c7bc79b1df36e8b95bb8cac09d171a0cfcf1c6da3b035fee14f7eb2d2c1e31a2153484593a584885fc17f34219a35556ce456bb9251830cd962a7696219bc27b26868b702495d9fba0ebf2fd2e22f35584a63452f5ef237453c8271c3c1b5ef29acf6a7bba2daf9abe6e39ddc0f08e5995d391c6b6f2bdb8c8154630ca3ebd4e420ddadeb63342d8252dc1468aeb2d6bab813d74ed03e73596bf2d9bbe663f9b78d9ed18f57c2d74882c48cfa9fce621c2be430f51b50c862dfa366838b142b7a737bce11e0f428914979638c1b8d480d545d6afdc20cc0bb45e967e035c4648bc4cec27bbcaec3e5a7521551c4c011ad37177312c799ff35f5dee4acbb2bd8523e5a002774742b43068ee8d08c7daff5f84270085fcef22ccda0424f993f589aa38f81739b541b4ed62d64d5f3a31b0916f028e18d7de32cc07b47c1e403a8c4e2bc09adbb96803de2d55b388374b753eb44437a0f39b5d18f751dd89c159481bf409c9ca8108486690ed981c809d7597c797096c4e570eb2adaabfb08bfd15c4b79817f6ae944b56abf3e1a779df53b2e9485d0ef11507a3a0547289044bdd7f69d2c1a01de16f9455a4b30a960faa93933378b7c2d15015572efb2cd21e0b3020ee3592b864586ae8d58f7383d80b6df858d0e6680e09e162e78e8d9f0fa4c8605aac15a3c8922cb1c40a0062ffa983a7b972f9be63ce3bd75734ffe0547e84545582b56e032001665eb0dce67fb6c74bb9eda00807dddcd583353c632f041c8779ef0c1659656accc69b0c2a3e64faaebee8eb5b78bf924d4e94b6c8ed9d7dc731eecef297a6348709caea3115da3d873bff9da453320c7778374e3dabf5e4ac57ae1b2e52cacbbf1473dfcaca47bdfd197745188651edab46db8b1bff487d269b3191f5274fc09432bb9ddf214f1c5740d2e679cdf79db17265d86631d2f341443e2a9324a93c3f67415fa51cbe4b366d03eb9bad7e76bddd67e6f85d5fd5d4768c038a5666383ee69155572bfdd15ffb1e1efa03628a840e0bbdc4046e1b585935b1506dd8fe171a14b0aa277fc00b0356a22e71ef7181d4f145bb7f72d6480bf466daffd2d19326abd339bcd706bd94b7efc8f4b0d0a35e76d387bbff13dde811794bbbb44690db1fda83d288bbd33128200f0fe1f9fc33f69f846ed9f2b6a53558a2a206e56f7f3a12b792a81b63ac31aa725d78ac997e53c00057132688688429ba6eed82201f15274e61708cfe2bda116e425ae85c21584ea92435b5b25d4a625482ceff5526c71b3979b89b6b6b1d6d68c107226dbf567026848a7b410e8eb1963ee6e5f24eac673f5e31a23db81e50560942487f4e627a30c2a786840933128102469802a2d55b0fc32385195d63fd1ffb5b4451c4c72c898987c94c045507ab04c678cc5326e148778c66d5936c29145b0f4737b647b7a61fde2fd6cbde88258b6f86465fbbf6de08670760c3b7a20cee204a1ef0202378eb38878a9cd8c5910d92ec1c0db87d8936fa29c8ed819210b92b4608b18331e98dbd1701b1cd27805d2287fafad464b5586a59bcf2aa968a7c728c0bb0416e3ae45eb677dbe6c881871f648e0f07106d1cb7589f951770b55d1576434d6a98ef05b619bcb3f09e6626e5a6811d2974fef3ebd2aec1d8855fe766d1bd050768c03a0166f16ba8b265abec070e190adf2333bd2e778846dafd3a14458e1782dcc20ede2fee09778d40f61e6691681c4d86241c0b6c3b5bd7c64d304e3126199713919bef22a9f0c3beaf1985f0789d77d114a264f0134ea626a99deb5344c9d22c09141f9428d3fdd449681e461ce570969d4ca18aca088fd47d9658f968de2cb565cb0ae6923149670a9b924c3264dde71fa66f9ac512c610c6c32ffa206aa4ce7e764865104f024749b34422d0cdc75967fb716</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>其他笔记</category>
      </categories>
      <tags>
        <tag>加密内容</tag>
        <tag>项目总结</tag>
      </tags>
  </entry>
</search>
