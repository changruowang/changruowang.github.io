<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="记录了CS-NOTE中整理的高频面试题，把不会写的单独记录下来了">
<meta property="og:type" content="article">
<meta property="og:title" content="常见的面试题">
<meta property="og:url" content="http://example.com/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/c.%20%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="Ruowang&#39;s blogs">
<meta property="og:description" content="记录了CS-NOTE中整理的高频面试题，把不会写的单独记录下来了">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/03/28/aMROkmxHqfGSeX9.png">
<meta property="og:image" content="https://i.loli.net/2021/03/28/VFQRBkwazWuAI7s.png">
<meta property="og:image" content="https://i.loli.net/2021/03/28/HNhUWojJM6A1tsx.png">
<meta property="og:image" content="https://i.loli.net/2021/03/28/X2iSloYLq1yJWe4.png">
<meta property="og:image" content="https://i.loli.net/2021/03/28/mQfvBUKTstk4xGa.png">
<meta property="og:image" content="https://i.loli.net/2021/03/28/yPMmYSpuXVrzJ6x.png">
<meta property="article:published_time" content="2021-05-11T02:11:04.000Z">
<meta property="article:modified_time" content="2021-05-13T09:01:36.036Z">
<meta property="article:author" content="常若望">
<meta property="article:tag" content="刷题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/03/28/aMROkmxHqfGSeX9.png">

<link rel="canonical" href="http://example.com/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/c.%20%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>常见的面试题 | Ruowang's blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ruowang's blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">去更远的地方，见更亮的光</p>
      <a>
        <img class="custom-logo-image" src="/images/icon.png" alt="Ruowang's blogs">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/c.%20%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="常若望">
      <meta itemprop="description" content="可乐">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ruowang's blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          常见的面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-11 10:11:04" itemprop="dateCreated datePublished" datetime="2021-05-11T10:11:04+08:00">2021-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-13 17:01:36" itemprop="dateModified" datetime="2021-05-13T17:01:36+08:00">2021-05-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">算法和数据结构</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/" itemprop="url" rel="index"><span itemprop="name">算法思想</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>记录了CS-NOTE中整理的高频面试题，把不会写的单独记录下来了</p>
<span id="more"></span>

<h4 id="数组中的重复数字"><a href="#数组中的重复数字" class="headerlink" title="数组中的重复数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number/submissions/">数组中的重复数字</a></h4><ul>
<li>这道题可以用判断环的方法找 环的起点 </li>
<li>通过swap的方式 swap(nums[i], nums[nums[i]]) 将数组还原为 num[i] = i  若遇到 num[i] == nums[nums[i]] 则为重复的数字。</li>
</ul>
<h4 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">二维数组中的查找</a></h4><p>​        类似双指针的 使用方式之一，不过不是 二分查找，而是 设置行列指针，选取矩阵右上角为起点，这样行指针往左移，列指针往下移，数据分别边小，变大。<strong>核心思想就是两个指针都是单方向移动，且指向的数据变化趋势是相反变化的，这样依次判断 和target的大小关系只能 有一个放行的指针移动。</strong></p>
<h4 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">替换空格</a></h4><p>​        主要在于 如果只能在原字符上操作，首先遍历判断空格数量，将源字符串扩容 + i x 2；接着从字符串末尾两个指针，依次从后向前填充。例如 原本 “ss ss” -&gt;“ss ss  ”</p>
<h4 id="二叉树的下一个结点-https-cyc2018-github-io-CS-Notes-notes-8-二叉树的下一个结点"><a href="#二叉树的下一个结点-https-cyc2018-github-io-CS-Notes-notes-8-二叉树的下一个结点" class="headerlink" title="[二叉树的下一个结点](https://cyc2018.github.io/CS-Notes/#/notes/8. 二叉树的下一个结点)"></a>[二叉树的下一个结点](<a target="_blank" rel="noopener" href="https://cyc2018.github.io/CS-Notes/#/notes/8">https://cyc2018.github.io/CS-Notes/#/notes/8</a>. 二叉树的下一个结点)</h4><p>​    1. 该节点没有有子节点。当它有右子节点时，中序遍历接在它后面输出的节点应给是 它子树的最左边的叶子节点</p>
<pre><code>         2. 该节点没有子节点。这时就要回溯了，一直找到它父节点，知道它是父节点的左子树为止。 具体要参照中序遍历的输出规律。好理解
</code></pre>
<h4 id="矩形填充"><a href="#矩形填充" class="headerlink" title="矩形填充"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github">矩形填充</a></h4><p><img src="https://i.loli.net/2021/03/28/aMROkmxHqfGSeX9.png" alt="image-20200912171353588"></p>
<p>f(n) = f(n-1) +  f(n-2) 斐波拉西</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">青蛙跳台阶</a></p>
<p>​        这个和上一道一样，状态方程在于  看青蛙 最后一步是跳一步 还是 最后一次一下子跳两步，就转换为 斐波拉西数列。最后(a + b)%c = (a%c + b%c)%c。</p>
<p><a target="_blank" rel="noopener" href="https://cyc2018.github.io/CS-Notes/#/notes/12.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84">矩阵中的最小路径</a>    </p>
<p>​        考点是 回溯算法，使用深度优先遍历实现回溯。回溯 和 单纯的优先遍历的区别 在于 回溯在每次试探性的前进之后有条件 判断 剪纸。如果沿着某一方向下去 不满足条件 马上返回 ，并且需要还原 之前的状态</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">机器人的运动范围</a></p>
<p>​        这题就套用DFS BFS模板即可</p>
<h4 id="减绳子"><a href="#减绳子" class="headerlink" title="减绳子"></a><a href="./leecode%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">减绳子</a></h4><h4 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/c-cheng-fa-kuai-su-mi-by-yizhe-shi/">数值的整数次方</a></h4><p>​        这个题考察的是 快速 幂乘法，a^N  = axaxa…xa 这样直接一个个乘肯定是很慢的，会超时。将N 转换为 二进制表示。如N = 9，则a^9 = a^(1001) = a^(1x8+0x4+0x2+1x1)^ = a^1^  x a^0x2^ x a^0x4^ x a^1x8^ ; 循环 计算  a = a*a；即 计算了 a^0^  a^2^   a^4^… 对于N的二进制 为1的位置 就乘进结果，为0 的就乘1。    </p>
<h4 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regular-expression-matching/solution/shi-pin-tu-jie-dong-tai-gui-hua-zheng-ze-biao-da-s/">正则表达式匹配</a></h4><p>​        动态规划。f[i] [j] 表示字符串 s (目标字符串) 的 前 i  个 字符 和 p (正则字符串) 的前 j 个字符 匹配的状态。那么对于<br>f[i] [j]  当 p[j]  不是 “*” 时就很简单 只用看  i-1 j-1 的状态 和 s[i]  与 s[j] 是否匹配（相等或者为‘.’）即可。复杂的是 当 p[j] 为※号时的情况。如果 ※号的用法可以分为两类： 1. 他前面一个字符出现0次，就是消掉他，那么  f[i] [j]  的状态由 f[i] [j-2]决定。 2. ✳将他前面的字符重复1-n次的情况。此时 若 s[i] 和 p[j-1] 匹配,例如都等于a，那么就由  f[i-1] [j] 状态决定，此时相当于 s[i-1] 后面再加一个 a 此时 ✳再复制一次即可 所以状态取决于 f[i-1] [j] </p>
<p><img src="https://i.loli.net/2021/03/28/VFQRBkwazWuAI7s.png" alt="image-20200914202819724"></p>
<h4 id="删除链表倒数第K个节点"><a href="#删除链表倒数第K个节点" class="headerlink" title="删除链表倒数第K个节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/submissions/">删除链表倒数第K个节点</a></h4><p>​        核心的 使用快慢指针 先将快指针 从头往后移动K个，再二者一起 往后移动 ，知道快指针为NULL 责慢指针停下的地方就是 了。为了排除 边界情况 可以在链表头加一个 哑铃节点，然后 每次让慢指针停在 待删除节点的前一个节点。这样就不用备份慢指针的父节点啦。</p>
<h4 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/fan-zhuan-lian-biao-yi-dong-de-shuang-zhi-zhen-jia/">链表反转</a></h4><ol>
<li>双指针，两个相邻的指针，每次反转一个。一个初始化为NULL 另一个为头指针 </li>
<li>递归 / 栈 </li>
</ol>
<h4 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></h4><p>​        递归！！！！</p>
<h4 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">顺时针打印矩阵</a></h4><p>​        使用的深度优先遍历 + 减枝  速度较慢。反正都是暴力</p>
<h4 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/submissions/">包含min函数的栈</a></h4><p>​        要求O(1)的时间复杂度取出 栈中的最小值（不是每次都删除最小值），使用一个辅助的栈来将最小的保存在栈顶。当push进一个数时，如果 比当前栈顶最小的 小 那么就进入这个辅助栈…..   <strong>单调栈</strong>  </p>
<h4 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">栈的压入、弹出序列</a></h4><p>​        用一个栈 模拟 出栈操作，如果最后栈空，则OK。首先读取push数组中的一个数，并加入堆栈，如果它和pop数组中的数相同，则马上将其出栈，并将 push 数组指针滑动。</p>
<h4 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">二叉搜索树的后序遍历序列</a></h4><pre><code>    1. 递归  分治法。抓住 后续遍历 和  搜索树的特点

         2. 单调栈 
</code></pre>
<h4 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">二叉树中和为某一值的路径</a></h4><p>​    前序遍历 先判断是不是 和满足要求 且到达叶子节点 是   这里 的技巧 可以在 遍历完左右子节点后 再将当前节点的值出栈。这样不用来回拷贝vector 省时间</p>
<h4 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">复杂链表的复制</a></h4><p>​        Hash表 保存 每个节点 和 新new的节点的对应   遍历两编链表 第一遍 new 拷贝所有节点 并 map 第二次遍历 链接节点</p>
<h4 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">二叉搜索树与双向链表</a></h4><p>​        首先 二叉搜索树 -&gt; 有序双向链表。就能想到中序遍历。暴力的方法是，首先中序遍历将所有节点存下来，然后链接。也可以在中序遍历的时候进行 指针的转换，这样只用遍历一次，而这样的难点就是如何 在中序遍历中转换指针的指向。<br>​        申请两个 节点指针，pre  和 cur  pre指向上一次遍历指向的节点，cur为当前遍历指向的节点。初始 pre 初始为 dummy指针。在中序遍历的位置完成 pre 和 cur 左右节点的指向，同时更新 pre 的指向：（可以看出 在中序遍历回到节点时，此时已经完成 左子节点的遍历，因此左指针可以修改。此时也确实只修改了左指针） 最后  使用dummy指针找到节点头。最后的cur指针指向的是最后一个访问的节点，即节点的尾。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">       <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">cur = root;         <span class="comment">// 变更开始时更新 cur</span></span><br><span class="line">pre -&gt; right = cur; <span class="comment">// 变更左右指针的指向， 符合双向链表的指针指向， 即当节点有一个指针指向前一个节点， 前一个节点也有一个指针指向当前节点</span></span><br><span class="line">cur -&gt; left = pre;</span><br><span class="line">pre = root;         <span class="comment">// 变结束后更新 pre ， 以便下一次使用</span></span><br><span class="line"><span class="built_in">dfs</span>(root-&gt;right);</span><br></pre></td></tr></table></figure>

<h4 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">数组中出现次数超过一半的数字</a></h4><p>​        使用Hash法 空间复杂度O(N)  时间复杂度 O(N)    由于 题目说某个数字的个数出现次数大于一半，那么可以使用 一个计数变量，当遇到相同的数字+1  否则-1 当减为负，这个数字就是当前遍历的中最多的。而遍历完，这个指向数字一定是 最多的。</p>
<h4 id="最小的k个数-https-leetcode-cn-com-problems-zui-xiao-de-kge-shu-lcof"><a href="#最小的k个数-https-leetcode-cn-com-problems-zui-xiao-de-kge-shu-lcof" class="headerlink" title="最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)"></a>最小的k个数](<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/</a>)</h4><p>​        这道题的考点是 快排中分治的思想 或者  优先队列（二叉堆）。二叉堆的基本性质是 堆顶 元素 top 总是最大/最小的。因此构建一个含有K个元素的 优先队列，依次读取剩下的元素，若比堆顶小，则弹出堆顶元素并 将新元素入堆….<br>​        类似解决 topK 的题都是这两种思路 最好。快排的思想是 当前选取一个基准数，然后比他大的和小的 各放一边…..</p>
<h4 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">数据流中的中位数</a></h4><pre><code>    1. 第一中方法是 每次插入 都保持 数组有序，使用二分法插入元素。取中位数的时候 就直接取中间即可。查找O(logn) + insert(O(n)) =插入新数据一共 O(n)。

         2. **使用优先队列的方式**。构建一个大顶堆和一个小顶堆。大顶堆保存中位数左边较小的 数据，小顶堆保存中位数右边较大的数据。每次插入新数据，先将其加入大顶堆，再将大顶堆的最大数据弹出 加入小顶堆；然后判断一下两个堆的大小，保证大顶堆的数据量&gt;小顶堆的。求中值的时候，奇数个数据就是 大顶堆数据 最大的那个 4，3  偶数二者平均。 加入新数据 时间复杂度 O(logn)  
</code></pre>
<p><img src="https://i.loli.net/2021/03/28/HNhUWojJM6A1tsx.png" alt="image-20200917215844317"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; lo;                              <span class="comment">// 大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; hi;   <span class="comment">// 小顶堆</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Adds a number into the data structure.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lo.<span class="built_in">push</span>(num);                                    <span class="comment">// 加到大顶堆</span></span><br><span class="line"></span><br><span class="line">        hi.<span class="built_in">push</span>(lo.<span class="built_in">top</span>());                               <span class="comment">// 平衡</span></span><br><span class="line">        lo.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lo.<span class="built_in">size</span>() &lt; hi.<span class="built_in">size</span>()) &#123;                     <span class="comment">// 维护两个堆元素个数</span></span><br><span class="line">            lo.<span class="built_in">push</span>(hi.<span class="built_in">top</span>());</span><br><span class="line">            hi.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the median of current data stream</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lo.<span class="built_in">size</span>() &gt; hi.<span class="built_in">size</span>() ? (<span class="keyword">double</span>) lo.<span class="built_in">top</span>() : (lo.<span class="built_in">top</span>() + hi.<span class="built_in">top</span>()) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="数字-1-的个数"><a href="#数字-1-的个数" class="headerlink" title="数字 1 的个数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-digit-one/">数字 1 的个数</a></h4><p>​        这是个找规律的题目</p>
<h4 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">把数组排成最小的数</a></h4><p>​        排序 对于 相同长度的字符串，直接 从高位到低位，小的字符排在前面。对于不同长度的字符串a, b   比较 a+b b+a 大小即可。就是正反组合 产生的新的字符的相互比较。</p>
<h4 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">把数字翻译成字符串</a></h4><p>​        动态规划</p>
<h4 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">礼物的最大价值</a></h4><p>​        动态规划  二维dp  每个位置的最大礼物价值只由它的 左边 和 上边 格子的最大数 的较大者决定。</p>
<h4 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/chou-shu-lcof/">丑数</a></h4><p>​        首先，判断一个数n是不是丑数，就看 n能否被 分解为多个 2 or 3 or 5 相乘的形式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(n!=<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>) n/=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">5</span>==<span class="number">0</span>)	n/=<span class="number">5</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">0</span>) n/=<span class="number">3</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        但是要输出 第n个丑数，暴力遍历从1开始的所有整数 计算 是否为丑数 然后累加到n停止，虽然可以使用备忘录的方法 加速计算，即如果  k/2 为丑数 那么 k 也为丑数，但是依然会超时。<br><img src="https://i.loli.net/2021/03/28/X2iSloYLq1yJWe4.png" alt="image-20200922213736488">        </p>
<h4 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">数组中的逆序对</a></h4><p>​        使用 归并排序的 方法。 分治的思想。在 归并排序中，每次 将数组划分为左右 两半 部分 分别 sort 然后再 merge 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> lf, <span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lf &gt;= rt)     <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (lf + rt) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, tmp, lf, mid);   <span class="comment">//递归的调用归并排序  排序后  左半部分 和 右半部分都是有序的</span></span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, tmp, mid+<span class="number">1</span>, rt);</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = lf, j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= rt)&#123;   <span class="comment">// 双指针将两个有序的 左右半部分合并为一个有序的数组，此时需要一个缓存数组 tmp</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= nums[j])&#123;</span><br><span class="line">                tmp[pos++] = nums[i++];   </span><br><span class="line">            &#125;<span class="keyword">else</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                cnt+=mid-i+<span class="number">1</span>;            <span class="comment">//  相对归并排序增加的一个计数变量  </span></span><br><span class="line">                tmp[pos++] = nums[j++];  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">            tmp[pos++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=rt)&#123;</span><br><span class="line">            tmp[pos++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = lf; i &lt;= rt; i++)&#123;  <span class="comment">// 将tmp的内容再存储到num中</span></span><br><span class="line">            nums[i] = tmp[i-lf];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, tmp, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">两个链表的第一个公共节点</a></h4><p>​        这个题 暴力的是查询的算法，但是时间空间复杂度较低，最好的是双指针算法。两个指针分别从A,B开始遍历，到达终点后就换个起点接着遍历。最终二者相遇的地方便是交点.</p>
<h4 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">数组中数字出现的次数</a></h4><p>​        这个题用 异或 做  异或的性质</p>
<p><img src="https://i.loli.net/2021/03/28/mQfvBUKTstk4xGa.png" alt="image-20200923110415455"></p>
<p>​        如果对于一个数组 只有一个数字出现了 一次,其他数字都出现了两次，找出这个单独的数字。根据异或的性质，全员异或 最终的结果便是这个单独的数字。而此题是有两个不同的单独的数字，要找出这两个。最直观的想法是，将这两个不同的数字分别放在两组，然后每组中除了 这个单独的数字就是其他成对的数字，这就退化成了 第一个问题。即要求分组的数字 有以下性质：</p>
<ol>
<li>两个不同的数字分别被分到不同的组</li>
<li>每组中 除了一个不同的数字 其他的都是成对的 这样组内 全员异才能满足 最终的结果是不同的那个。</li>
</ol>
<p>​        如何分组？首先全员异或，结果肯定是 两个不同的数字异或的 结果。而这两个数字异或结果为1 的位  代表这两个数字 该位 不同，一个为1 另一个必定为0。例如 011 111 异或， 100 则第三位肯定不同。这样根据该位的值来分组 可以很好的分开这两个数字到不同组，对于其他数，相同的 该位 也一定相同，也一定在一个组。由此两个条件都满足。所以这样分组，再组内异或 分别就找出了两个不同的单数字。</p>
<p>​        <strong>而解决此类 除了 除了某个元素出现一次 其余均出现 m 次的问题</strong> 都可以统计 二进制各个位元素为1的个数，如果个数 % m 有余数，那么表明该位 是不同的那个数字为 1 的位置。 </p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><a href=".%5Cleecode%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">平衡二叉树</a></h4><h4 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">滑动窗口的最大值</a></h4><p>​        这道题考察<strong>有序队列</strong>。实现有序队列  要结合 c++ 标准库中的 deque 双端队列，即可以从前 也可以从后插入删除数据。对于队列，如果后进去的数据 比我队列尾端的数据小，就直接放在它后面，如果比他大，就将原本尾部的数据弹出，直到遇到比他大的数据，再将其放进去。这样 队列头部一定是当前队列的最大数据。删除的时候，只用判断当前要出对队的元素是不是和 头部的相同，相同就弹出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span> <span class="comment">//单调队列（从大到小）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; que; <span class="comment">// 使用deque来实现单调队列</span></span><br><span class="line">    <span class="comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span></span><br><span class="line">    <span class="comment">// 同时pop之前判断队列当前是否为空。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span> <span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。 </span></span><br><span class="line">    <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span> <span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value &gt; que.<span class="built_in">back</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">push_back</span>(value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="comment">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span></span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="n个骰子的点数"><a href="#n个骰子的点数" class="headerlink" title="n个骰子的点数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">n个骰子的点数</a></h4><p>​        直接动态规划  或者  递归+dp备忘录减枝 (因为直接递归有大量的重复计算)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/"> 圆圈中最后剩下的数字</a></p>
<p>​        首先， 考虑一种规律。对于一个圈 不管起点是从哪个点开始，假设是 2，最终最后一个留下的是第3个，那么 如果此时开始的位置 为3，那么最后剩下的位置就是 4 （此时不考虑成环返回的问题），因为其实所有数字围成一个圆圈，处处堆成，起始位置和最终位置肯定是保持一个相对的位置关系。</p>
<p>​        如果 假设 f(n-1, m) = x  代表第n-1个数，从0开始，m个删除一次，最终剩下的数的位置 是 x；考虑 f(n, m) 的关系。n个数，在第一次删除，即去掉 第 m -1 个数后(起点是从0开始)，就剩下 n-1 个数了，此时就退化为 f(n-1, m) 了只不过，这里n-1的起点是 m%n （删除了第 m%n-1个数，就从第m%n个数开始）。根据上面的规律，f(n, m) = (x + m%n) % n。起点相对 f(n-1) 的 0  变为 m  终点也应该相对 x 向后 + m，由于是环，所以 % n </p>
<h4 id="求1-2-…-n"><a href="#求1-2-…-n" class="headerlink" title="求1+2+…+n"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qiu-12n-lcof/">求1+2+…+n</a></h4><p>​        判断，循环语句等不能用。使用递归求和  但是需要有判断 递归停止的条件，<strong>可以使用 &amp;&amp; 逻辑运算符</strong> 替代 判断。当递归的返回值 n 为 0 就开始 return </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        n &amp;&amp; (n += <span class="built_in">sumNums</span>(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">不用加减乘除做加法</a></h4><p>​        使用位运算 比较简单</p>
<ul>
<li><p>计算机中 申请一个 int 型的 变量，它在内存中直接存的 补码。因此此题只用将两个数 按照加法的逻辑计算即可，不需要再转补码了。  </p>
<p>  位运算  两个数相加  可以分为两部分 ： 无进位和 + 进位  满足以下规律：</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/03/28/yPMmYSpuXVrzJ6x.png" alt="image-20200924203153740"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;   <span class="comment">//当进位 为  0 时 就停止递归 计算结束</span></span><br><span class="line">        <span class="keyword">return</span> b ? <span class="built_in">add</span>(a^b, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a&amp;b)&lt;&lt;<span class="number">1</span>) : a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%88%B7%E9%A2%98/" rel="tag"><i class="fa fa-tag"></i> 刷题</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/b.%20%E5%89%91%E6%8C%87Offer/" rel="prev" title="剑指offer">
      <i class="fa fa-chevron-left"></i> 剑指offer
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/leecode_DFS_BFS/" rel="next" title="相关的编程题汇总-DFS/BFS">
      相关的编程题汇总-DFS/BFS <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 
      src="//music.163.com/outchain/player?type=0&id=885457449&auto=0&height=66">
    </iframe>

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97"><span class="nav-number">1.</span> <span class="nav-text">数组中的重复数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">2.</span> <span class="nav-text">二维数组中的查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="nav-number">3.</span> <span class="nav-text">替换空格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9-https-cyc2018-github-io-CS-Notes-notes-8-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-number">4.</span> <span class="nav-text">[二叉树的下一个结点](https:&#x2F;&#x2F;cyc2018.github.io&#x2F;CS-Notes&#x2F;#&#x2F;notes&#x2F;8. 二叉树的下一个结点)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%A9%E5%BD%A2%E5%A1%AB%E5%85%85"><span class="nav-number">5.</span> <span class="nav-text">矩形填充</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%8F%E7%BB%B3%E5%AD%90"><span class="nav-number">6.</span> <span class="nav-text">减绳子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9"><span class="nav-number">7.</span> <span class="nav-text">数值的整数次方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">8.</span> <span class="nav-text">正则表达式匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">9.</span> <span class="nav-text">删除链表倒数第K个节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC"><span class="nav-number">10.</span> <span class="nav-text">链表反转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">11.</span> <span class="nav-text">合并两个有序链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="nav-number">12.</span> <span class="nav-text">顺时针打印矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="nav-number">13.</span> <span class="nav-text">包含min函数的栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><span class="nav-number">14.</span> <span class="nav-text">栈的压入、弹出序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="nav-number">15.</span> <span class="nav-text">二叉搜索树的后序遍历序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-number">16.</span> <span class="nav-text">二叉树中和为某一值的路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-number">17.</span> <span class="nav-text">复杂链表的复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">18.</span> <span class="nav-text">二叉搜索树与双向链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">19.</span> <span class="nav-text">数组中出现次数超过一半的数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0-https-leetcode-cn-com-problems-zui-xiao-de-kge-shu-lcof"><span class="nav-number">20.</span> <span class="nav-text">最小的k个数](https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;zui-xiao-de-kge-shu-lcof&#x2F;)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number">21.</span> <span class="nav-text">数据流中的中位数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E5%AD%97-1-%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">22.</span> <span class="nav-text">数字 1 的个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="nav-number">23.</span> <span class="nav-text">把数组排成最小的数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">24.</span> <span class="nav-text">把数字翻译成字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="nav-number">25.</span> <span class="nav-text">礼物的最大价值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%91%E6%95%B0"><span class="nav-number">26.</span> <span class="nav-text">丑数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="nav-number">27.</span> <span class="nav-text">数组中的逆序对</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9"><span class="nav-number">28.</span> <span class="nav-text">两个链表的第一个公共节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-number">29.</span> <span class="nav-text">数组中数字出现的次数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">30.</span> <span class="nav-text">平衡二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">31.</span> <span class="nav-text">滑动窗口的最大值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0"><span class="nav-number">32.</span> <span class="nav-text">n个骰子的点数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%821-2-%E2%80%A6-n"><span class="nav-number">33.</span> <span class="nav-text">求1+2+…+n</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95"><span class="nav-number">34.</span> <span class="nav-text">不用加减乘除做加法</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">常若望</p>
  <div class="site-description" itemprop="description">可乐</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/changruowang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;changruowang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/changruowang@qq.com" title="E-Mail → changruowang@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>

  <div id="sidebar-dimmer"></div>



      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        


<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">常若望</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
