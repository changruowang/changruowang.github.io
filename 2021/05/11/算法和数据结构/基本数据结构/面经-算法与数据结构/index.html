<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="整理了面试中常问的数据结构相关的知识点">
<meta property="og:type" content="article">
<meta property="og:title" content="面经-数据结构相关">
<meta property="og:url" content="http://example.com/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E7%BB%8F-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Ruowang&#39;s blogs">
<meta property="og:description" content="整理了面试中常问的数据结构相关的知识点">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210413153208.png">
<meta property="article:published_time" content="2021-05-11T02:11:01.000Z">
<meta property="article:modified_time" content="2021-05-13T09:03:26.684Z">
<meta property="article:author" content="常若望">
<meta property="article:tag" content="面经">
<meta property="article:tag" content="算法和数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210413153208.png">

<link rel="canonical" href="http://example.com/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E7%BB%8F-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>面经-数据结构相关 | Ruowang's blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ruowang's blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">去更远的地方，见更亮的光</p>
      <a>
        <img class="custom-logo-image" src="/images/icon.png" alt="Ruowang's blogs">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%9D%A2%E7%BB%8F-%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="常若望">
      <meta itemprop="description" content="可乐">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ruowang's blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面经-数据结构相关
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-11 10:11:01" itemprop="dateCreated datePublished" datetime="2021-05-11T10:11:01+08:00">2021-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-13 17:03:26" itemprop="dateModified" datetime="2021-05-13T17:03:26+08:00">2021-05-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">算法和数据结构</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">基本数据结构</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>整理了面试中常问的数据结构相关的知识点</p>
<span id="more"></span>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="红黑树和AVL树的定义，特点，以及二者区别"><a href="#红黑树和AVL树的定义，特点，以及二者区别" class="headerlink" title="红黑树和AVL树的定义，特点，以及二者区别"></a>红黑树和AVL树的定义，特点，以及二者区别</h3><p>​        AVL树是平衡二叉搜索树，每个节点的左右子树的高度差不超过1，左右子树的高度做差称为平衡因子，平衡因子的取值只可能是 0 +-1 绝对值超过1的就不是平衡二叉树。<br>​        红黑树是以 一个数据位标记节点红黑颜色的树，也是二叉搜索树，每次插入和删除节点都要满足一定的着色规则，从而约束红黑树使得根节点到叶子节点的最长路径不超过最短路径的2倍。（每个节点非红即黑，根节点是黑色，每个叶节点是黑色，如果一个节点是红色，其子节点必须是黑，每条路径上黑色节点数目一致）</p>
<p>​        <strong>区别</strong>：红黑树是弱平衡二叉树，AVL 树由于平衡条件过于严格，导致每次插入或删除节点都容易使得平衡打破，需要频繁的旋转调整树，导致效率下降。所以在需要频繁插入或删除的应用场景，红黑树速度更快。<strong>红黑树插入节点最多旋转两次，删除节点最多旋转三次。</strong></p>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>​        哈夫曼编码是哈夫曼树的一种应用，用于数据的无损压缩。根据序列中字符出现频率，使用0/1来对字符重新编码。是一种不等长前缀编码，出现频率高的字符使用较多位空间编码。具体：</p>
<ol>
<li>哈夫曼树是一种自底向上构建表示的最优前缀二叉树T</li>
<li>算法以|C|个叶节点（每个叶节点表示一个字符）开始，经过C-1次合并运算产生最终要求的树。</li>
<li>构建步骤  … </li>
</ol>
<h3 id="map底层为什么用红黑树实现"><a href="#map底层为什么用红黑树实现" class="headerlink" title="map底层为什么用红黑树实现"></a>map底层为什么用红黑树实现</h3><p> 介绍AVL树定义特点,  介绍红黑树 定义特点</p>
<p>​        <strong>AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。所以红黑树在查找</strong>，<strong>插入删除的性能都是O(logn)，且性能稳定</strong>，所以STL里面很多结构包括map底层实现都是使用的红黑树。</p>
<h3 id="介绍一下B-树"><a href="#介绍一下B-树" class="headerlink" title="介绍一下B+树"></a>介绍一下B+树</h3><p>​        B+树是一种多路搜索树，主要为磁盘或其他直接存储设备而设计的一种平衡查找树，因为磁盘相对内存而言读写速度慢，使用B+树相对二叉搜索树  每次 减少磁盘读写次数。B+树每个节点可有多个孩子，每个节点中的键值有序排列。所有值都存在叶节点中。相对B树有以下特点：</p>
<ul>
<li>内部节点不存数据，只存键值</li>
<li>叶子节点存放数据，且和相邻叶子节点构成有序链表</li>
<li>每个节点的最大子树个数M 则键值M  而 B树M M-1</li>
<li>….</li>
</ul>
<h3 id="说一说map和unordered-map的底层实现"><a href="#说一说map和unordered-map的底层实现" class="headerlink" title="说一说map和unordered_map的底层实现"></a>说一说map和unordered_map的底层实现</h3><p>​        map 的底层是基于红黑树实现的 因此map内部元素是有序的，且查找速度log(N)  而unordered_map是无序的底层基于 哈希实现，查找更快 接近常数级别，极端情况会O(N)</p>
<h3 id="map和unordered-map优点和缺点"><a href="#map和unordered-map优点和缺点" class="headerlink" title="map和unordered_map优点和缺点"></a>map和unordered_map优点和缺点</h3><p>对于map，其底层是基于红黑树实现的，优点如下：</p>
<ol>
<li>有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作</li>
<li>map的查找、删除、增加等一系列操作时间复杂度稳定，都为logn</li>
</ol>
<p>unordered_map</p>
<ol>
<li>内部基于哈希表，以（key,value）对的形式存储，因此空间占用率高</li>
<li>无序</li>
<li>Unordered_map的查找、删除、添加的时间复杂度不稳定，平均为O(c)，取决于哈希函数。极端情况下可能为O(n)</li>
</ol>
<h3 id="回答一下epoll怎么实现的"><a href="#回答一下epoll怎么实现的" class="headerlink" title="回答一下epoll怎么实现的"></a>回答一下epoll怎么实现的</h3><p><strong>epoll应用场景</strong>： 对于高连接的应用场景。例如 有上百万个用户通过TCP连接至服务器，但是每一时刻只有几十个或几百个TCP活跃（接受TCP包 ，需要内核完成读写文件操作）。那么epoll就是为了在此种场景下高效处理数据连接。在linux内核2.4以前，使用select 或者 poll事件驱动的方式实现。</p>
<p><strong>select</strong>: select的工作流程：创建socket－&gt;绑定端口bind－&gt;监听listen－&gt;accept-&gt;write/read。当有客户端连接到来时,select会把该连接的文件描述符放到 fd_set（文件描述符(fd)的集合  相当于数组）,然后select会循环遍历它所监测的 fd_set 内的所有文件描述符，如果没有一个资源可用(即没有一个文件描述符可以进行read/write可以操作)，则select让该进程阻塞的等待，一直等到有资源可用为止。而fd_set是一个类似于数组的数据结构，由于它每次都要遍历整个数组，所以它的效率会随着文件描述符的数量增多而明显的变慢，除此之外在每次遍历这些描述符之前，系统还需要把这些描述符集合从内核copy到用户空间，然后再copy回去，如果此时没有一个描述符有事件发生（例如：read和write）这些copy操作和便利操作都是无用功，可见slect随着连接数量的增多，效率大大降低。可见如果在高并发的场景下select并不适用，况且select默认的最大描述符为1024。</p>
<p><strong>epoll</strong>: Linux epoll机制是通过红黑树和双向链表实现的。 首先通过epoll_create()系统调用在内核中创建一个eventpoll类型的句柄，其中包括红黑树根节点和双向链表头节点。然后通过epoll_ctl()系统调用，向epoll对象的红黑树结构中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。最后通过epoll_wait()系统调用判断双向链表是否为空，如果为空则阻塞。当文件描述符状态改变，fd上的回调函数被调用，该函数将fd加入到双向链表中，此时epoll_wait函数被唤醒，返回就绪好的事件。</p>
<p><strong>总结</strong>： epoll 的机制感觉就是  充分利用了回调函数。使用一个红黑树 存储当前的所有感兴趣事件 （百万级别 很多休眠），而使用一个双向链表来存储 活跃连接。TCP开始活跃时 系统 在中断中调用事先注册的回调函数向 链表中添加 活跃事件。用户只用通过 epoll_wait() 去链表访问活跃事件的数据和id即可。  </p>
<h3 id="请你说一说Top-K-问题"><a href="#请你说一说Top-K-问题" class="headerlink" title="请你说一说Top(K)问题"></a>请你说一说Top(K)问题</h3><ul>
<li>直接排序法：直接调用一般的排序算法，对所有元素进行排序，然后去topK，这种方法效率低，对内存需求大，因为进行了很多无意义的排序。</li>
<li>基于快速排序的变形：根据快排的思想，每次从待排列的数据中随机选取一个作为 参考数据，将比他大的放在它的右边，小的放左边，分组完成后，如果基准元素右侧的个数n=K，完毕；如果n&gt;K，则重新对左边数据进行一次相同的分组操作；如果基准元素右侧的元素个数n&lt; K，则重新对左边数据进行一次相同的分组操作，此时K=K-n；</li>
<li>基于堆排序的思路：首先构建一个含有 K 个元素的小顶堆，每次读入数据和堆顶数据比较，如果小于它直接pass，否则删除堆顶元素并将其入堆。遍历完成后，堆中数据即为TopK</li>
<li>分治法：</li>
<li>Hash 法：对于含有大量重复元素的数据，可以先通过hash法把重复的数去掉。这样可以减小很多的不必要计算</li>
</ul>
<h3 id="请你说一说C-两种map"><a href="#请你说一说C-两种map" class="headerlink" title="请你说一说C++两种map"></a>请你说一说C++两种map</h3><p>unordered_map  (Hash) 和  map (红黑树)</p>
<h3 id="请你说一说红黑树的性质还有左右旋转"><a href="#请你说一说红黑树的性质还有左右旋转" class="headerlink" title="请你说一说红黑树的性质还有左右旋转"></a>请你说一说红黑树的性质还有左右旋转</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43939593/article/details/104420724?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159021709219725211930470%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=159021709219725211930470&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v1~rank_blog_v1-1-104420724.pc_v1_rank_blog_v1&amp;utm_term=%E7%BA%A2%E9%BB%91%E6%A0%91">https://blog.csdn.net/weixin_43939593/article/details/104420724?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159021709219725211930470%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=159021709219725211930470&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v1~rank_blog_v1-1-104420724.pc_v1_rank_blog_v1&amp;utm_term=%E7%BA%A2%E9%BB%91%E6%A0%91</a></p>
<h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><h3 id="说一说你理解的stack-overflow"><a href="#说一说你理解的stack-overflow" class="headerlink" title="说一说你理解的stack overflow"></a>说一说你理解的stack overflow</h3><p>​        栈溢出概念：栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变。</p>
<p>​        栈溢出得原因：</p>
<ul>
<li>局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。局部变量是存储在栈中的，因此这个很好理解。解决这类问题的办法有两个，一是增大栈空间,二是改用动态分配，使用堆（heap）而不是栈（stack）。</li>
<li>递归调用的层数太多。递归函数在运行的时候会执行压栈操作。当压栈次数太多时，也会导致堆栈溢出。</li>
<li>数组指针越界</li>
</ul>
<h3 id="栈和堆的区别，以及为什么栈要快"><a href="#栈和堆的区别，以及为什么栈要快" class="headerlink" title="栈和堆的区别，以及为什么栈要快"></a>栈和堆的区别，以及为什么栈要快</h3><p>区别：</p>
<ol>
<li>地址生长方向，栈是由高地址向低地址，堆反之</li>
<li>分配方式：栈是系统自动分配内存，有硬件实现，存放局部变量参数等。而堆是人为实现的一种结构，需要手动申请和释放内存。</li>
<li>栈由于其先进后出的特性，不会产生内存碎片</li>
<li>栈高效</li>
</ol>
<p><strong>栈高效的原因</strong>：栈是操作系统提供的数据结构，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行；而堆是由C/C++函数库提供的，机制复杂，需要一些列分配内存、合并内存和释放内存的算法，因此效率较低。</p>
<h3 id="手写代码，两个栈实现一个队列"><a href="#手写代码，两个栈实现一个队列" class="headerlink" title="手写代码，两个栈实现一个队列"></a>手写代码，两个栈实现一个队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.<span class="built_in">push</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.<span class="built_in">size</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = stack2.<span class="built_in">top</span>();</span><br><span class="line">        stack2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(stack1.<span class="built_in">size</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = stack1.<span class="built_in">top</span>();</span><br><span class="line">        stack1.<span class="built_in">pop</span>();</span><br><span class="line">        stack2.<span class="built_in">push</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<h3 id="小根堆特点"><a href="#小根堆特点" class="headerlink" title="小根堆特点"></a>小根堆特点</h3><ol>
<li>堆是一个完全二叉树，除最后一层外，其他的都得是满的</li>
<li>小顶堆，父节点总是小于他的左右子节点的值，因此堆顶的元素最小。大顶堆相反。</li>
</ol>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h3><p>数组的特点：数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。数组的插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。但数组的随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。并且数组不利于扩展，数组定义的空间不够时要重新定义数组。</p>
<p>链表的特点：链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。比如：上一个元素有个指针指到下一个元素，以此类推，直到最后一个元素。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表数据结构了。不指定大小，扩展方便。链表大小不用定义，数据随意增删。</p>
<p>数组的优缺点：</p>
<ol>
<li>随机访问性强</li>
<li>查找速度快</li>
<li>插入和删除效率低</li>
<li>数组大小固定，不能动态拓展   可能浪费内存</li>
<li>内存空间要求高，必须有足够的连续内存空间。</li>
</ol>
<p>链表的优缺点：</p>
<ol>
<li> 插入删除速度快</li>
<li>内存利用率高，不会浪费内存</li>
<li>大小没有固定，拓展很灵活。</li>
<li>不能随机查找，必须从第一个开始遍历，查找效率低</li>
</ol>
<h3 id="判断有无重复数"><a href="#判断有无重复数" class="headerlink" title="判断有无重复数"></a>判断有无重复数</h3><p>​        一个长度为N的整形数组，数组中每个元素的取值范围是[0,n-1],判断该数组否有重复的数，请说一下你的思路并手写代码</p>
<p>思路： 把每个数放到自己对应序号的位置上，如果其他位置上有和自己对应序号相同的数，那么即为有重复的数值。时间复杂度为O(N),同时为了节省空间复杂度，可以在原数组上进行操作，空间复杂度为O(1)</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="手写快排的代码"><a href="#手写快排的代码" class="headerlink" title="手写快排的代码"></a>手写快排的代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="海量数据如何去取最大的k个"><a href="#海量数据如何去取最大的k个" class="headerlink" title="海量数据如何去取最大的k个"></a>海量数据如何去取最大的k个</h3><ul>
<li>基础的对所有元素进行排序，效率不高，因为只用求K大 并不需要对所有元素排序</li>
<li>快排的变形，选取基准数，左右分区，如果右边比基准数大的个数不等于K，根据与K的大小关系选择是对基准数左半部分or右半部分数递归求K-N or K 大。</li>
<li>最小堆法。首先建立一个含有K个元素的最小堆，每次取序列中的元素与堆顶元素比，如果比堆顶元素大，将堆顶元素弹出，改元素入堆，如果小，就说明他肯定不是K大中的一个，跳过。依次遍历到结束，最后堆中的元素就是topK</li>
<li>分治法：将所有元素分为N 分，如果每份的元素数量可以放入内存，就分别对每份找出前K大，否则继续分治处理。最后每份挑出了K个，一共有N*K个元素，可以使用快排的变形找出前K个。</li>
<li>Hash法：对于含有大量重复元素，使用Hash去重，如果剩下元素可以读入内存了，就直接排序，否则可以使用分支法读入内存在处理或者堆法。</li>
</ul>
<h3 id="快排的时间复杂度最差是多少？什么时候时间最差"><a href="#快排的时间复杂度最差是多少？什么时候时间最差" class="headerlink" title="快排的时间复杂度最差是多少？什么时候时间最差"></a>快排的时间复杂度最差是多少？什么时候时间最差</h3><p>元素倒序，O(n^2)</p>
<h3 id="什么是稳定性排序"><a href="#什么是稳定性排序" class="headerlink" title="什么是稳定性排序"></a>什么是稳定性排序</h3><p>对于相等的元素，排序前后相对顺序不变</p>
<h3 id="快排算法最差情况推导公式"><a href="#快排算法最差情况推导公式" class="headerlink" title="快排算法最差情况推导公式"></a>快排算法最差情况推导公式</h3><p>一般的快排中的基准元素选取的为 最左边或者最右边的元素。<br>当选取最左边元素作为基准，而序列原本又是正序的时候，每次左右分拨都要挨个交换位置，就和冒泡排序类似；所以O(n^2)<br>反之当选取最右边基准…倒序…..；<br>当元素都相同时</p>
<p>所以可以随机选择基准元素，降低出现最坏情况的概率    </p>
<h3 id="稳定排序哪几种"><a href="#稳定排序哪几种" class="headerlink" title="稳定排序哪几种"></a>稳定排序哪几种</h3><p>插入法，冒泡排序，归并排序，计数排序，基数排序，桶排序</p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="hash表的实现，包括STL中的哈希桶长度常数"><a href="#hash表的实现，包括STL中的哈希桶长度常数" class="headerlink" title="hash表的实现，包括STL中的哈希桶长度常数"></a>hash表的实现，包括STL中的哈希桶长度常数</h3><p>主要包含两部分，一是Hash函数构造由key的值使用Hash函数处理的得到地址。另一个是处理Hash冲突</p>
<p>前者构造Hash的方法主要有  直接地址法，平方取中法，除留余数法<br>后者的方法有：开放地址法，链地址法，再Hash法，建立公共溢出区等方法</p>
<p>使用链地址法不一定必须满足 桶的个数为质数….？</p>
<h3 id="解决hash冲突的方法"><a href="#解决hash冲突的方法" class="headerlink" title="解决hash冲突的方法"></a>解决hash冲突的方法</h3><p>​        当不同经过hash产生相同的地址时，即差生hash冲突。此时解决的方法有如下：</p>
<ul>
<li>开放地址：所谓开放地址，就是当hash过后 地址重复了之后，按照一定的规律从当前地址往其他地方搜索表中的空内存区 （Hi = H(key + di)）。根据寻址扩展的规律分为如下。产生新地址的方法能覆盖所有表区，免得内存浪费。再读取时，如果在Hash的地址找不到对应的元素，那么就按照指定的寻址方式往其他内存寻找元素对比key，找到表尾也没找到说明不存在。<ol>
<li>线性探查：di = c x i  就是地址线性往后递增 （注意对表长取余了 所以会循环 可以覆盖所有区域）</li>
<li>二次探查： di = + - i^2  就是平方规律分别向前和向后探测</li>
<li>伪随机探测：di 是一组伪随机数</li>
</ol>
</li>
<li>链地址：向指定地址插入Hash值时，如果该地址已有元素，桶内使用链表存储新增的数据。那么在读取的时候也是遍历链表找到对应的key的内容。</li>
<li>公共溢出区：建立一个公共溢出区域，把hash冲突的元素都放在该溢出区里。查找时，如果发现hash表中对应桶里存在其他元素，还需要在公共溢出区里再次进行查找。</li>
<li>再hash：再散列法其实很简单，就是再使用哈希函数去散列一个输入的时候，输出是同一个位置就再次散列，直至不发生冲突位置。每次冲突都要重新计算散列，计算时间增加。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/changruowang/cloudimg/img/20210413153208.png" alt="image-20201117201021698"></p>
<h3 id="哈希表的桶个数为什么是质数"><a href="#哈希表的桶个数为什么是质数" class="headerlink" title="哈希表的桶个数为什么是质数"></a>哈希表的桶个数为什么是质数</h3><p>​        哈希表的桶个数使用质数，可以最大程度减少冲突概率，使哈希后的数据分布的更加均匀。如果使用合数，可能会造成很多数据分布会集中在某些点上，从而影响哈希表效率。<br>​        例如常用的Hash函数是标准的求模函数，质数的因数只有1和它本身，合数不止。例如 6 和 7  ，当Hash数是2/3的时候，6%2 = 6%3=0  也就是经过取模Hash后  Key=2/3在同一个地址了。</p>
<h3 id="hash表如何rehash-怎么处理其中保存的资源"><a href="#hash表如何rehash-怎么处理其中保存的资源" class="headerlink" title="hash表如何rehash  怎么处理其中保存的资源"></a>hash表如何rehash  怎么处理其中保存的资源</h3><p>Hash表中有个负载因子，代表 存储数据长度 / 表的长度。负载因子越大，查找复杂度就越大。每次往表中装载数据要保证负载因子 &lt; 1否则就需要rehash，保证可以装载成功。rehash过程类似数组扩容，开辟一个新的原桶数组的两倍大的空间，并把原本的桶的数组中的元素全部重新Hash到新的Hash桶数组中。</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="手写代码：最长公共连续子序列"><a href="#手写代码：最长公共连续子序列" class="headerlink" title="手写代码：最长公共连续子序列"></a>手写代码：最长公共连续子序列</h3><h3 id="手写代码：求一个字符串最长回文子串"><a href="#手写代码：求一个字符串最长回文子串" class="headerlink" title="手写代码：求一个字符串最长回文子串"></a>手写代码：求一个字符串最长回文子串</h3><h3 id="手写代码：查找最长回文子串"><a href="#手写代码：查找最长回文子串" class="headerlink" title="手写代码：查找最长回文子串"></a>手写代码：查找最长回文子串</h3><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="手写代码，如何合并两个有序链表"><a href="#手写代码，如何合并两个有序链表" class="headerlink" title="手写代码，如何合并两个有序链表"></a>手写代码，如何合并两个有序链表</h3><h3 id="手写代码：反转链表"><a href="#手写代码：反转链表" class="headerlink" title="手写代码：反转链表"></a>手写代码：反转链表</h3><h3 id="手写代码：判断链表是否为回文"><a href="#手写代码：判断链表是否为回文" class="headerlink" title="手写代码：判断链表是否为回文"></a>手写代码：判断链表是否为回文</h3><h3 id="什么是单向链表"><a href="#什么是单向链表" class="headerlink" title="什么是单向链表"></a>什么是单向链表</h3><h3 id="判断两个单向链表是否相交"><a href="#判断两个单向链表是否相交" class="headerlink" title="判断两个单向链表是否相交"></a>判断两个单向链表是否相交</h3><h2 id="高级算法"><a href="#高级算法" class="headerlink" title="高级算法"></a>高级算法</h2><h3 id="加密方法有那些"><a href="#加密方法有那些" class="headerlink" title="加密方法有那些"></a>加密方法有那些</h3><h3 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h3><h3 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h3>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag"><i class="fa fa-tag"></i> 面经</a>
              <a href="/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"><i class="fa fa-tag"></i> 算法和数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%A1%A8/" rel="prev" title="数据结构-表">
      <i class="fa fa-chevron-left"></i> 数据结构-表
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/a.%20%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/" rel="next" title="算法思想汇总">
      算法思想汇总 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 
      src="//music.163.com/outchain/player?type=0&id=885457449&auto=0&height=66">
    </iframe>

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">1.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8CAVL%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E7%89%B9%E7%82%B9%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BA%8C%E8%80%85%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.</span> <span class="nav-text">红黑树和AVL树的定义，特点，以及二者区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-number">1.2.</span> <span class="nav-text">哈夫曼编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map%E5%BA%95%E5%B1%82%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.</span> <span class="nav-text">map底层为什么用红黑树实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BB-%E6%A0%91"><span class="nav-number">1.4.</span> <span class="nav-text">介绍一下B+树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4map%E5%92%8Cunordered-map%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.5.</span> <span class="nav-text">说一说map和unordered_map的底层实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map%E5%92%8Cunordered-map%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="nav-number">1.6.</span> <span class="nav-text">map和unordered_map优点和缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E7%AD%94%E4%B8%80%E4%B8%8Bepoll%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">1.7.</span> <span class="nav-text">回答一下epoll怎么实现的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E4%B8%80%E8%AF%B4Top-K-%E9%97%AE%E9%A2%98"><span class="nav-number">1.8.</span> <span class="nav-text">请你说一说Top(K)问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E4%B8%80%E8%AF%B4C-%E4%B8%A4%E7%A7%8Dmap"><span class="nav-number">1.9.</span> <span class="nav-text">请你说一说C++两种map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E4%B8%80%E8%AF%B4%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8%E8%BF%98%E6%9C%89%E5%B7%A6%E5%8F%B3%E6%97%8B%E8%BD%AC"><span class="nav-number">1.10.</span> <span class="nav-text">请你说一说红黑树的性质还有左右旋转</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88"><span class="nav-number">2.</span> <span class="nav-text">堆和栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84stack-overflow"><span class="nav-number">2.1.</span> <span class="nav-text">说一说你理解的stack overflow</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A0%88%E8%A6%81%E5%BF%AB"><span class="nav-number">2.2.</span> <span class="nav-text">栈和堆的区别，以及为什么栈要快</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97"><span class="nav-number">2.3.</span> <span class="nav-text">手写代码，两个栈实现一个队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E6%A0%B9%E5%A0%86%E7%89%B9%E7%82%B9"><span class="nav-number">2.4.</span> <span class="nav-text">小根堆特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">3.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.</span> <span class="nav-text">数组和链表的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%9C%89%E6%97%A0%E9%87%8D%E5%A4%8D%E6%95%B0"><span class="nav-number">3.2.</span> <span class="nav-text">判断有无重复数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">4.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E5%BF%AB%E6%8E%92%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">4.1.</span> <span class="nav-text">手写快排的代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E5%8E%BB%E5%8F%96%E6%9C%80%E5%A4%A7%E7%9A%84k%E4%B8%AA"><span class="nav-number">4.2.</span> <span class="nav-text">海量数据如何去取最大的k个</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E6%8E%92%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9C%80%E5%B7%AE%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%97%B6%E9%97%B4%E6%9C%80%E5%B7%AE"><span class="nav-number">4.3.</span> <span class="nav-text">快排的时间复杂度最差是多少？什么时候时间最差</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%B3%E5%AE%9A%E6%80%A7%E6%8E%92%E5%BA%8F"><span class="nav-number">4.4.</span> <span class="nav-text">什么是稳定性排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E6%8E%92%E7%AE%97%E6%B3%95%E6%9C%80%E5%B7%AE%E6%83%85%E5%86%B5%E6%8E%A8%E5%AF%BC%E5%85%AC%E5%BC%8F"><span class="nav-number">4.5.</span> <span class="nav-text">快排算法最差情况推导公式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="nav-number">4.6.</span> <span class="nav-text">稳定排序哪几种</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C"><span class="nav-number">5.</span> <span class="nav-text">哈希</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hash%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%8C%85%E6%8B%ACSTL%E4%B8%AD%E7%9A%84%E5%93%88%E5%B8%8C%E6%A1%B6%E9%95%BF%E5%BA%A6%E5%B8%B8%E6%95%B0"><span class="nav-number">5.1.</span> <span class="nav-text">hash表的实现，包括STL中的哈希桶长度常数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3hash%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">解决hash冲突的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%A1%B6%E4%B8%AA%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E8%B4%A8%E6%95%B0"><span class="nav-number">5.3.</span> <span class="nav-text">哈希表的桶个数为什么是质数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash%E8%A1%A8%E5%A6%82%E4%BD%95rehash-%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%85%B6%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E8%B5%84%E6%BA%90"><span class="nav-number">5.4.</span> <span class="nav-text">hash表如何rehash  怎么处理其中保存的资源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">6.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%EF%BC%9A%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">6.1.</span> <span class="nav-text">手写代码：最长公共连续子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%EF%BC%9A%E6%B1%82%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-number">6.2.</span> <span class="nav-text">手写代码：求一个字符串最长回文子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%EF%BC%9A%E6%9F%A5%E6%89%BE%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-number">6.3.</span> <span class="nav-text">手写代码：查找最长回文子串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">7.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">7.1.</span> <span class="nav-text">手写代码，如何合并两个有序链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">7.2.</span> <span class="nav-text">手写代码：反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%EF%BC%9A%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87"><span class="nav-number">7.3.</span> <span class="nav-text">手写代码：判断链表是否为回文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">7.4.</span> <span class="nav-text">什么是单向链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4"><span class="nav-number">7.5.</span> <span class="nav-text">判断两个单向链表是否相交</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95"><span class="nav-number">8.</span> <span class="nav-text">高级算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E6%96%B9%E6%B3%95%E6%9C%89%E9%82%A3%E4%BA%9B"><span class="nav-number">8.1.</span> <span class="nav-text">加密方法有那些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LRU%E7%BC%93%E5%AD%98"><span class="nav-number">8.2.</span> <span class="nav-text">LRU缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95"><span class="nav-number">8.3.</span> <span class="nav-text">洗牌算法</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">常若望</p>
  <div class="site-description" itemprop="description">可乐</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/changruowang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;changruowang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/changruowang@qq.com" title="E-Mail → changruowang@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>

  <div id="sidebar-dimmer"></div>



      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        


<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">常若望</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
